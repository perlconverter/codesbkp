<DOCUMENT_ID="ArcherCraftStore/ArcherVMPeridot/tree/master/RailsInstaller_D/DevKit/lib/perl5/5.8/unicore/lib/gc_sc/Ext.pl"> # ▁ ! ! ! ! ! ▁ DO ▁ NOT ▁ EDIT ▁ THIS ▁ FILE ▁ ! ! ! ! ! ▁ ENDCOM # ▁ This ▁ file ▁ is ▁ built ▁ by ▁ mktables ▁ from ▁ e . g . ▁ UnicodeData . txt . ENDCOM # ▁ Any ▁ changes ▁ made ▁ here ▁ will ▁ be ▁ lost ! ENDCOM # ▁ Binary ▁ property ▁ ' Extender ' ENDCOM return << ' END ' ; 00 B7 Extender 02 D0 02 D1 Extender 0640 Extender 0E46 Extender 0E C6 Extender 1843 Extender 3005 Extender 3031 3035 Extender 309D 309E Extender 30F C 30F E Extender A015 Extender FF70 Extender END </DOCUMENT>
<DOCUMENT_ID="timduru/platform-external-chromium_org/tree/master/tools/memory_watcher/scripts/finditem.pl"> # ! / usr / bin / perl ENDCOM # ▁ Copyright ▁ ( c ) ▁ 2012 ▁ The ▁ Chromium ▁ Authors . ▁ All ▁ rights ▁ reserved . ENDCOM # ▁ Use ▁ of ▁ this ▁ source ▁ code ▁ is ▁ governed ▁ by ▁ a ▁ BSD - style ▁ license ▁ that ▁ can ▁ be ENDCOM # ▁ found ▁ in ▁ the ▁ LICENSE ▁ file . ENDCOM sub process_raw ( $$ ) { my $file = shift ; my $search = shift ; my % leaks = ( ) ; my $save = 0 ; my $print = 0 ; my $bytes = 0 ; my $calls = 0 ; my $sum_bytes = 0 ; my $sum_calls = 0 ; open ( LOGFILE , " $ file " ) or die ( " could ▁ not ▁ open ▁ $ file " ) ; while ( < LOGFILE > ) { my $line = $_ ; if ( $line = ~ m / ( [ 0 - 9 ] * ) bytes , ( [ 0 - 9 ] * ) allocs / ) { $save = " " ; $print = 0 ; $bytes = $1 ; $calls = $2 ; } elsif ( $line = ~ m / $search / ) { $print = 1 ; } elsif ( $line = ~ m /= == == == == == == / ) { $save . = $line ; if ( $print ) { print " $ bytes ▁ bytes ▁ ( $ calls ▁ calls ) \n " ; print $save ; $sum_bytes += $bytes ; $sum_calls += $calls ; $save = " " ; $print = 0 ; $calls = 0 ; } } $save . = $line ; } print ( " TOTAL : ▁ $ sum _ bytes ▁ bytes ▁ ( $ sum _ calls ▁ calls ) \n " ) ; } # ▁ - - - - - ▁ Main ▁ - - - - - ENDCOM # ▁ Get ▁ the ▁ command ▁ line ▁ argument ENDCOM my $filename = shift ; my $search = shift ; # ▁ Process ▁ the ▁ file . ENDCOM process_raw ( $filename , $search ) ; </DOCUMENT>
<DOCUMENT_ID="esttorhe/WinObjC/tree/master/deps/3rdparty/icu/icu/source/test/perf/collperf/CollPerf_r.pl"> # ! / usr / bin / perl ENDCOM # ▁ * ▁ COPYRIGHT : ENDCOM # ▁ * ▁ Copyright ▁ ( c ) ▁ 2008-2013 , ▁ International ▁ Business ▁ Machines ▁ Corporation ▁ and ENDCOM # ▁ * ▁ others . ▁ All ▁ Rights ▁ Reserved . ENDCOM # use ▁ strict ; ENDCOM use lib ' . . / perldriver ' ; require " . . / perldriver / Common . pl " ; use PerfFramework ; my $options = { " title " = > " Collation ▁ performanceregression : ▁ ICU ▁ ( " . $ICUPreviousVersion . " ▁ and ▁ " . $ICULatestVersion . " ) " , " headers " = > " ICU " . $ICUPreviousVersion . " ▁ ICU " . $ICULatestVersion , " operationIs " = > " unicode ▁ String " , " passes " = > "1" , " time " = > "2" , # " outputType " = > " HTML " , ENDCOM " dataDir " = > $CollationDataPath , " outputDir " = > " . . / results " } ; # ▁ programs ENDCOM # ▁ tests ▁ will ▁ be ▁ done ▁ for ▁ all ▁ the ▁ programs . ▁ Results ▁ will ▁ be ▁ stored ▁ and ▁ connected ENDCOM my $p1 , $p2 ; if ( $OnWindows ) { $p1 = " cd ▁ " . $ICUPrevious . " / bin ▁ & & ▁ " . $ICUPathPrevious . " / collperf / $ WindowsPlatform / Release / collperf . exe " ; $p2 = " cd ▁ " . $ICULatest . " / bin ▁ & & ▁ " . $ICUPathLatest . " / collperf / $ WindowsPlatform / Release / collperf . exe " ; } else { $p1 = " LD _ LIBRARY _ PATH = " . $ICUPrevious . " / source / lib : " . $ICUPrevious . " / source / tools / ctestfw ▁ " . $ICUPathPrevious . " / collperf / collperf " ; $p2 = " LD _ LIBRARY _ PATH = " . $ICULatest . " / source / lib : " . $ICULatest . " / source / tools / ctestfw ▁ " . $ICUPathLatest . " / collperf / collperf " ; } my $tests = { " Key ▁ Gen ▁ ICU ▁ null " , [ " $ p1 , TestIcu _ KeyGen _ null " , " $ p2 , TestIcu _ KeyGen _ null " ] , " Key ▁ Gen ▁ ICU ▁ len " , [ " $ p1 , TestIcu _ KeyGen _ len " , " $ p2 , TestIcu _ KeyGen _ len " ] , " Iteration ▁ icu ▁ forward ▁ null " , [ " $ p1 , TestIcu _ ForwardIter _ null " , " $ p2 , TestIcu _ ForwardIter _ null " ] , " Iteration ▁ icu ▁ forward ▁ len " , [ " $ p1 , TestIcu _ ForwardIter _ len " , " $ p2 , TestIcu _ ForwardIter _ len " ] , " Iteration ▁ icu ▁ backward ▁ null " , [ " $ p1 , TestIcu _ BackwardIter _ null " , " $ p2 , TestIcu _ BackwardIter _ null " ] , " Iteration ▁ icu ▁ backward ▁ len " , [ " $ p1 , TestIcu _ BackwardIter _ len " , " $ p2 , TestIcu _ BackwardIter _ len " ] , " Iteration / all ▁ icu ▁ forward ▁ null " , [ " $ p1 , TestIcu _ ForwardIter _ all _ null " , " $ p2 , TestIcu _ ForwardIter _ all _ null " ] , " Iteration / all ▁ icu ▁ forward ▁ len " , [ " $ p1 , TestIcu _ ForwardIter _ all _ len " , " $ p2 , TestIcu _ ForwardIter _ all _ len " ] , " Iteration / all ▁ icu ▁ backward ▁ null " , [ " $ p1 , TestIcu _ BackwardIter _ all _ null " , " $ p2 , TestIcu _ BackwardIter _ all _ null " ] , " Iteration / all ▁ icu ▁ backward ▁ len " , [ " $ p1 , TestIcu _ BackwardIter _ all _ len " , " $ p2 , TestIcu _ BackwardIter _ all _ len " ] , " qsort ▁ icu ▁ strcoll ▁ null " , [ " $ p1 , TestIcu _ qsort _ strcoll _ null " , " $ p2 , TestIcu _ qsort _ strcoll _ null " ] , " qsort ▁ icu ▁ strcoll ▁ len " , [ " $ p1 , TestIcu _ qsort _ strcoll _ len " , " $ p2 , TestIcu _ qsort _ strcoll _ len " ] , " qsort ▁ icu ▁ use ▁ key " , [ " $ p1 , TestIcu _ qsort _ usekey " , " $ p2 , TestIcu _ qsort _ usekey " ] , " Binary ▁ Search ▁ icu ▁ strcoll ▁ null " , [ " $ p1 , TestIcu _ BinarySearch _ strcoll _ null " , " $ p2 , TestIcu _ BinarySearch _ strcoll _ null " ] , " Binary ▁ Search ▁ icu ▁ strcoll ▁ len " , [ " $ p1 , TestIcu _ BinarySearch _ strcoll _ len " , " $ p2 , TestIcu _ BinarySearch _ strcoll _ len " ] , " Binary ▁ Search ▁ icu ▁ use ▁ key " , [ " $ p1 , TestIcu _ BinarySearch _ usekey " , " $ p2 , TestIcu _ BinarySearch _ usekey " ] , " Binary ▁ Search ▁ icu ▁ u _ strcmp " , [ " $ p1 , TestIcu _ BinarySearch _ strcmp " , " $ p2 , TestIcu _ BinarySearch _ strcmp " ] , " Binary ▁ Search ▁ icu ▁ cmpCPO " , [ " $ p1 , TestIcu _ BinarySearch _ cmpCPO " , " $ p2 , TestIcu _ BinarySearch _ cmpCPO " ] , } ; my $dataFiles = { " " , [ " TestNames _ Asian . txt " , " TestNames _ Chinese . txt " , " TestNames _ Japanese . txt " , " TestNames _ Japanese _ h . txt " , " TestNames _ Japanese _ k . txt " , " TestNames _ Korean . txt " , " TestNames _ Latin . txt " , " TestNames _ Russian . txt " , " TestNames _ SerbianSH . txt " , " TestNames _ SerbianSR . txt " , " TestNames _ Simplified _ Chinese . txt " , " TestNames _ Thai . txt " ] } ; runTests ( $options , $tests , $dataFiles ) ; </DOCUMENT>
<DOCUMENT_ID="aferr/TimingCompartments/tree/master/benchmarks/spec2k6bin/specint/lib/unicore/lib/ccc/A.pl"> # ▁ ! ! ! ! ! ▁ DO ▁ NOT ▁ EDIT ▁ THIS ▁ FILE ▁ ! ! ! ! ! ▁ ENDCOM # ▁ This ▁ file ▁ is ▁ built ▁ by ▁ mktables ▁ from ▁ e . g . ▁ UnicodeData . txt . ENDCOM # ▁ Any ▁ changes ▁ made ▁ here ▁ will ▁ be ▁ lost ! ENDCOM # ▁ CombiningClass ▁ category ▁ ' Above ' ENDCOM return << ' END ' ; 00 E6 END </DOCUMENT>
<DOCUMENT_ID="liblime/LibLime-Koha/tree/master/cgi/authorities/detail-biblio-search.pl"> # ! / usr / bin / env ▁ perl ENDCOM # ▁ Copyright ▁ 2000-2002 ▁ Katipo ▁ Communications ENDCOM # ▁ This ▁ file ▁ is ▁ part ▁ of ▁ Koha . ENDCOM # ▁ Koha ▁ is ▁ free ▁ software ; ▁ you ▁ can ▁ redistribute ▁ it ▁ and / or ▁ modify ▁ it ▁ under ▁ the ENDCOM # ▁ terms ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ as ▁ published ▁ by ▁ the ▁ Free ▁ Software ENDCOM # ▁ Foundation ; ▁ either ▁ version ▁ 2 ▁ of ▁ the ▁ License , ▁ or ▁ ( at ▁ your ▁ option ) ▁ any ▁ later ENDCOM # ▁ version . ENDCOM # ▁ Koha ▁ is ▁ distributed ▁ in ▁ the ▁ hope ▁ that ▁ it ▁ will ▁ be ▁ useful , ▁ but ▁ WITHOUT ▁ ANY ENDCOM # ▁ WARRANTY ; ▁ without ▁ even ▁ the ▁ implied ▁ warranty ▁ of ▁ MERCHANTABILITY ▁ or ▁ FITNESS ▁ FOR ENDCOM # ▁ A ▁ PARTICULAR ▁ PURPOSE . ▁ See ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ for ▁ more ▁ details . ENDCOM # ▁ You ▁ should ▁ have ▁ received ▁ a ▁ copy ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ along ▁ with ENDCOM # ▁ Koha ; ▁ if ▁ not , ▁ write ▁ to ▁ the ▁ Free ▁ Software ▁ Foundation , ▁ Inc . , ▁ 59 ▁ Temple ▁ Place , ENDCOM # ▁ Suite ▁ 330 , ▁ Boston , ▁ MA ▁ 02111-1307 ▁ USA ENDCOM = head1 NAME etail . pl : script to show an authority in MARC format = head1 SYNOPSIS = head1 DESCRIPTION This script needs an authid It shows the authority in a ( nice ) MARC format depending on authority MARC parameters tables . = head1 FUNCTIONS = over 2 = cut use Koha ; use Koha :: Authority ; use Koha :: HeadingMap ; use C4 :: Auth ; use C4 :: Context ; use C4 :: Output ; use CGI ; use C4 :: Koha ; my $query = CGI -> new ; my $authid = $query -> param ( ' authid ' ) ; my $auth = Koha :: Authority -> new ( id = > $authid ) ; my $index = $query -> param ( ' index ' ) ; my $authtypecode = $auth -> typecode ; my $tagslib = $auth -> code_labels ( 1 ) ; my $record = $auth -> marc ; # ▁ open ▁ template ENDCOM my ( $template , $loggedinuser , $cookie ) = get_template_and_user ( { template_name = > " authorities / detail - biblio - search . tmpl " , query = > $query , type = > " intranet " , authnotrequired = > 0 , flagsrequired = > { catalogue = > 1 } , debug = > 1 , } ) ; # ▁ fill ▁ arrays ENDCOM my @ loop_data = ( ) ; my $tag ; # ▁ loop ▁ through ▁ each ▁ tab ▁ 0 ▁ through ▁ 9 ENDCOM # ▁ for ▁ ( my ▁ $ tabloop ▁ = ▁ 0 ; ▁ $ tabloop < = 10 ; $ tabloop + + ) ▁ { ENDCOM # ▁ loop ▁ through ▁ each ▁ tag ENDCOM my @ fields = $record -> fields ( ) ; foreach my $field ( @ fields ) { my @ subfields_data ; # ▁ if ▁ tag ▁ < 10 , ▁ there ' s ▁ no ▁ subfield , ▁ use ▁ the ▁ " @ " ▁ trick ENDCOM if ( $field -> tag ( ) < 10 ) { # ▁ TABSYMBOL TABSYMBOL TABSYMBOL next ▁ if ▁ ( $ tagslib - > { $ field - > tag ( ) } - > { ' @ ' } - > { tab } ▁ ne ▁ $ tabloop ) ; ENDCOM next if ( $tagslib -> { $field -> tag ( ) } -> { ' @ ' } -> { hidden } ) ; my % subfield_data ; $subfield_data { marc_lib } = $tagslib -> { $field -> tag ( ) } -> { ' @ ' } -> { lib } ; $subfield_data { marc_value } = $field -> data ( ) ; $subfield_data { marc_subfield } = ' @ ' ; $subfield_data { marc_tag } = $field -> tag ( ) ; push ( @ subfields_data , \ % subfield_data ) ; } else { my @ subf = $field -> subfields ; # ▁ loop ▁ through ▁ each ▁ subfield ENDCOM for my $i ( 0. . $ # subf ) ▁ { ENDCOM $subf [ $i ] [ 0 ] = " @ " unless $subf [ $i ] [ 0 ] ; # ▁ TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL next ▁ if ▁ ( $ tagslib - > { $ field - > tag ( ) } - > { $ subf [ $ i ] [0 ] } - > { tab } ▁ ne ▁ $ tabloop ) ; ENDCOM next if ( $tagslib -> { $field -> tag ( ) } -> { $subf [ $i ] [ 0 ] } -> { hidden } ) ; my % subfield_data ; $subfield_data { marc_lib } = $tagslib -> { $field -> tag ( ) } -> { $subf [ $i ] [ 0 ] } -> { lib } ; if ( $tagslib -> { $field -> tag ( ) } -> { $subf [ $i ] [ 0 ] } -> { isurl } ) { $subfield_data { marc_value } = " < a ▁ href = \ " $ subf [ $ i ] [1 ] \ " > $ subf [ $ i ] [1 ] < / a > " ; } else { $subfield_data { marc_value } = $subf [ $i ] [ 1 ] ; } $subfield_data { marc_subfield } = $subf [ $i ] [ 0 ] ; $subfield_data { marc_tag } = $field -> tag ( ) ; push ( @ subfields_data , \ % subfield_data ) ; } } if ( $ # subfields _ data > = 0 ) ▁ { ENDCOM my % tag_data ; $tag_data { tag } = $field -> tag ( ) . ' ▁ - ' . $tagslib -> { $field -> tag ( ) } -> { lib } ; $tag_data { subfield } = \ @ subfields_data ; push ( @ loop_data , \ % tag_data ) ; } } $template -> param ( "0XX " = > \ @ loop_data ) ; my $authtypes = Koha :: HeadingMap -> auth_types ; my @ authtypesloop ; foreach my $thisauthtype ( keys % $authtypes ) { my $selected = 1 if $thisauthtype eq $authtypecode ; my % row = ( value = > $thisauthtype , selected = > $selected , authtypetext = > $authtypes -> { $thisauthtype } { ' authtypetext ' } , ) ; push @ authtypesloop , \ % row ; } $template -> param ( authid = > $authid , authtypesloop = > \ @ authtypesloop , index = > $index , ) ; output_html_with_http_headers $query , $cookie , $template -> output ; </DOCUMENT>
<DOCUMENT_ID="pombredanne/paperpile/tree/master/catalyst/perl5/linux64/base/pwd.pl"> ; # ▁ pwd . pl ▁ - ▁ keeps ▁ track ▁ of ▁ current ▁ working ▁ directory ▁ in ▁ PWD ▁ environment ▁ var ENDCOM ; # ▁ This ▁ library ▁ is ▁ no ▁ longer ▁ being ▁ maintained , ▁ and ▁ is ▁ included ▁ for ▁ backward ENDCOM # ▁ compatibility ▁ with ▁ Perl ▁ 4 ▁ programs ▁ which ▁ may ▁ require ▁ it . ENDCOM # ▁ In ▁ particular , ▁ this ▁ should ▁ not ▁ be ▁ used ▁ as ▁ an ▁ example ▁ of ▁ modern ▁ Perl ENDCOM # ▁ programming ▁ techniques . ENDCOM # ▁ Suggested ▁ alternative : ▁ Cwd ENDCOM ; # ▁ $ RCSfile : ▁ pwd . pl , v ▁ $ $ Revision : ▁ 4.1 ▁ $ $ Date : ▁ 92/08/07 ▁ 18:24:11 ▁ $ ENDCOM ; ; # ▁ $ Log : TABSYMBOL pwd . pl , v ▁ $ ENDCOM ; ; # ▁ Usage : ENDCOM ; # TABSYMBOL require ▁ " pwd . pl " ; ENDCOM ; # TABSYMBOL & initpwd ; ENDCOM ; ; # TABSYMBOL & chdir ( $ newdir ) ; ENDCOM package pwd ; sub main ' initpwd ▁ { STRNEWLINE ▁ ▁ ▁ ▁ if ▁ ( $ ENV { ' PWD ' } ) ▁ { STRNEWLINE TABSYMBOL local ( $ dd , $ di ) ▁ = ▁ stat ( ' . ' ) ; STRNEWLINE TABSYMBOL local ( $ pd , $ pi ) ▁ = ▁ stat ( $ ENV { ' PWD ' } ) ; STRNEWLINE TABSYMBOL if ▁ ( ! defined ▁ $ dd ▁ or ▁ ! defined ▁ $ pd ▁ or ▁ $ di ▁ ! = ▁ $ pi ▁ or ▁ $ dd ▁ ! = ▁ $ pd ) ▁ { STRNEWLINE TABSYMBOL ▁ ▁ ▁ ▁ chop ( $ ENV { ' PWD ' } ▁ = ▁ ` pwd ` ) ; STRNEWLINE TABSYMBOL } STRNEWLINE ▁ ▁ ▁ ▁ } STRNEWLINE ▁ ▁ ▁ ▁ else ▁ { STRNEWLINE TABSYMBOL chop ( $ ENV { ' PWD ' } ▁ = ▁ ` pwd ` ) ; STRNEWLINE ▁ ▁ ▁ ▁ } STRNEWLINE ▁ ▁ ▁ ▁ if ▁ ( $ ENV { ' PWD ' } ▁ = ~ ▁ m | ( / [ ^ / ] + ( / [ ^ / ] + / [ ^ / ] + ) ) ( . * ) | ) ▁ { STRNEWLINE TABSYMBOL local ( $ pd , $ pi ) ▁ = ▁ stat ( $ 2 ) ; STRNEWLINE TABSYMBOL local ( $ dd , $ di ) ▁ = ▁ stat ( $ 1 ) ; STRNEWLINE TABSYMBOL if ▁ ( defined ▁ $ pd ▁ and ▁ defined ▁ $ dd ▁ and ▁ $ di ▁ = = ▁ $ pi ▁ and ▁ $ dd ▁ = = ▁ $ pd ) ▁ { STRNEWLINE TABSYMBOL ▁ ▁ ▁ ▁ $ ENV { ' PWD ' } = " $ 2 $ 3 " ; STRNEWLINE TABSYMBOL } STRNEWLINE ▁ ▁ ▁ ▁ } STRNEWLINE } STRNEWLINE STRNEWLINE sub ▁ main ' chdir { local ( $newdir ) = shift ; $newdir = ~ s | / { 2 , } | / | g ; if ( chdir $newdir ) { if ( $newdir = ~ m $ENV { ' PWD ' } = $newdir ; } else { local ( @ curdir ) = split ( m # / # , $ ENV { ' PWD ' } ) ; ENDCOM @ curdir = ' ' unless @ curdir ; foreach $component ( split ( m # / # , ▁ $ newdir ) ) ▁ { ENDCOM next if $component eq ' . ' ; pop ( @ curdir ) , next if $component eq ' . . ' ; push ( @ curdir , $component ) ; } $ENV { ' PWD ' } = join ( ' / ' , @ curdir ) || ' / ' ; } } else { 0 ; } } 1 ; </DOCUMENT>
<DOCUMENT_ID="SandPox/android_kernel_samsung_kyleproxx/tree/master/drivers/usb/serial/ezusb_convert.pl"> # ! ▁ / usr / bin / perl ▁ - w ENDCOM # ▁ convert ▁ an ▁ Intel ▁ HEX ▁ file ▁ into ▁ a ▁ set ▁ of ▁ C ▁ records ▁ usable ▁ by ▁ the ▁ firmware ENDCOM # ▁ loading ▁ code ▁ in ▁ usb - serial . c ▁ ( or ▁ others ) ENDCOM # ▁ accepts ▁ the ▁ . hex ▁ file ( s ) ▁ on ▁ stdin , ▁ a ▁ basename ▁ ( to ▁ name ▁ the ▁ initialized ENDCOM # ▁ array ) ▁ as ▁ an ▁ argument , ▁ and ▁ prints ▁ the ▁ . h ▁ file ▁ to ▁ stdout . ▁ Typical ▁ usage : ENDCOM # ▁ perl ▁ ezusb _ convert . pl ▁ foo ▁ < foo . hex ▁ > fw _ foo . h ENDCOM my $basename = $ARGV [ 0 ] ; die " no ▁ base ▁ name ▁ specified " unless $basename ; while ( < STDIN > ) { # ▁ ' : ' ▁ < len > ▁ < addr > ▁ < type > ▁ < len - data > ▁ < crc > ▁ ' ' ENDCOM # ▁ len , ▁ type , ▁ crc ▁ are ▁ 2 - char ▁ hex , ▁ addr ▁ is ▁ 4 - char ▁ hex . ▁ type ▁ is ▁ 00 ▁ for ENDCOM # ▁ normal ▁ records , ▁ 01 ▁ for ▁ EOF ENDCOM my ( $lenstring , $addrstring , $typestring , $reststring , $doscrap ) = / ^ : ( \ w \ w ) ( \ w \ w \ w \ w ) ( \ w \ w ) ( \ w + ) ( ? ) $ / ; die " malformed ▁ line : ▁ $ _ " unless $reststring ; last if $typestring eq '01' ; my ( $len ) = hex ( $lenstring ) ; my ( $addr ) = hex ( $addrstring ) ; my ( @ bytes ) = unpack ( " C * " , pack ( " H " . ( 2 * $len ) , $reststring ) ) ; # pop ( @ bytes ) ; ▁ # ▁ last ▁ byte ▁ is ▁ a ▁ CRC ENDCOM push ( @ records , [ $addr , \ @ bytes ] ) ; } @ sorted_records = sort { $a -> [ 0 ] <= > $b -> [ 0 ] } @ records ; print << " EOF " ; / * * $ { basename } _fw . h * * Generated from $ { basename } . s by ezusb_convert . pl * This file is presumed to be under the same copyright as the source file * from which it was derived . * / EOF print " static ▁ const ▁ struct ▁ ezusb _ hex _ record ▁ $ { basename } _ firmware [ ] ▁ = ▁ { \n " ; foreach $r ( @ sorted_records ) { printf ( " { ▁ 0x % 04x , \t % d , \t { " , $r -> [ 0 ] , scalar ( @ { $r -> [ 1 ] } ) ) ; print join ( " , ▁ " , map { sprintf ( '0x % 02x ' , $_ ) ; } @ { $r -> [ 1 ] } ) ; print " } ▁ } , \n " ; } print " { ▁ 0xffff , \t0 , \t { 0x00 } ▁ } \n " ; print " } ; \n " ; </DOCUMENT>
<DOCUMENT_ID="Coxxs/shadowsocks-android/tree/master/src/main/jni/openssl/crypto/perlasm/cbc.pl"> # ! / usr / local / bin / perl ENDCOM # ▁ void ▁ des _ ncbc _ encrypt ( input , ▁ output , ▁ length , ▁ schedule , ▁ ivec , ▁ enc ) ENDCOM # ▁ des _ cblock ▁ ( * input ) ; ENDCOM # ▁ des _ cblock ▁ ( * output ) ; ENDCOM # ▁ long ▁ length ; ENDCOM # ▁ des _ key _ schedule ▁ schedule ; ENDCOM # ▁ des _ cblock ▁ ( * ivec ) ; ENDCOM # ▁ int ▁ enc ; ENDCOM # ▁ calls ▁ ENDCOM # ▁ des _ encrypt ( ( DES _ LONG ▁ * ) tin , schedule , DES _ ENCRYPT ) ; ENDCOM # & cbc ( " des _ ncbc _ encrypt " , " des _ encrypt " ,0 ) ; ENDCOM # & cbc ( " BF _ cbc _ encrypt " , " BF _ encrypt " , " BF _ encrypt " , ENDCOM # TABSYMBOL 1,4,5,3,5 , - 1 ) ; ENDCOM # & cbc ( " des _ ncbc _ encrypt " , " des _ encrypt " , " des _ encrypt " , ENDCOM # TABSYMBOL 0,4,5,3,5 , - 1 ) ; ENDCOM # & cbc ( " des _ ede3 _ cbc _ encrypt " , " des _ encrypt3 " , " des _ decrypt3 " , ENDCOM # TABSYMBOL 0,6,7,3,4,5 ) ; ENDCOM # ▁ When ▁ doing ▁ a ▁ cipher ▁ that ▁ needs ▁ bigendian ▁ order , ENDCOM # ▁ for ▁ encrypt , ▁ the ▁ iv ▁ is ▁ kept ▁ in ▁ bigendian ▁ form , ENDCOM # ▁ while ▁ for ▁ decrypt , ▁ it ▁ is ▁ kept ▁ in ▁ little ▁ endian . ENDCOM sub cbc { local ( $name , $enc_func , $dec_func , $swap , $iv_off , $enc_off , $p1 , $p2 , $p3 ) = @ _ ; # ▁ name ▁ is ▁ the ▁ function ▁ name ENDCOM # ▁ enc _ func ▁ and ▁ dec _ func ▁ and ▁ the ▁ functions ▁ to ▁ call ▁ for ▁ encrypt / decrypt ENDCOM # ▁ swap ▁ is ▁ true ▁ if ▁ byte ▁ order ▁ needs ▁ to ▁ be ▁ reversed ENDCOM # ▁ iv _ off ▁ is ▁ parameter ▁ number ▁ for ▁ the ▁ iv ▁ ENDCOM # ▁ enc _ off ▁ is ▁ parameter ▁ number ▁ for ▁ the ▁ encrypt / decrypt ▁ flag ENDCOM # ▁ p1 , p2 , p3 ▁ are ▁ the ▁ offsets ▁ for ▁ parameters ▁ to ▁ be ▁ passed ▁ to ▁ the ENDCOM # ▁ underlying ▁ calls . ENDCOM & function_begin_B ( $name , " " ) ; & comment ( " " ) ; $in = " esi " ; $out = " edi " ; $count = " ebp " ; & push ( " ebp " ) ; & push ( " ebx " ) ; & push ( " esi " ) ; & push ( " edi " ) ; $data_off = 4 ; $data_off += 4 if ( $p1 > 0 ) ; $data_off += 4 if ( $p2 > 0 ) ; $data_off += 4 if ( $p3 > 0 ) ; & mov ( $count , & wparam ( 2 ) ) ; # ▁ length ENDCOM & comment ( " getting ▁ iv ▁ ptr ▁ from ▁ parameter ▁ $ iv _ off " ) ; & mov ( " ebx " , & wparam ( $iv_off ) ) ; # ▁ Get ▁ iv ▁ ptr ENDCOM & mov ( $in , & DWP ( 0 , " ebx " , " " , 0 ) ) ; # TABSYMBOL iv [ 0 ] ENDCOM & mov ( $out , & DWP ( 4 , " ebx " , " " , 0 ) ) ; # TABSYMBOL iv [ 1 ] ENDCOM & push ( $out ) ; & push ( $in ) ; & push ( $out ) ; # ▁ used ▁ in ▁ decrypt ▁ for ▁ iv [ 1 ] ENDCOM & push ( $in ) ; # ▁ used ▁ in ▁ decrypt ▁ for ▁ iv [ 0 ] ENDCOM & mov ( " ebx " , " esp " ) ; # ▁ This ▁ is ▁ the ▁ address ▁ of ▁ tin [ 2 ] ENDCOM & mov ( $in , & wparam ( 0 ) ) ; # ▁ in ENDCOM & mov ( $out , & wparam ( 1 ) ) ; # ▁ out ENDCOM # ▁ We ▁ have ▁ loaded ▁ them ▁ all , ▁ how ▁ lets ▁ push ▁ things ENDCOM & comment ( " getting ▁ encrypt ▁ flag ▁ from ▁ parameter ▁ $ enc _ off " ) ; & mov ( " ecx " , & wparam ( $enc_off ) ) ; # ▁ Get ▁ enc ▁ flag ENDCOM if ( $p3 > 0 ) { & comment ( " get ▁ and ▁ push ▁ parameter ▁ $ p3" ) ; if ( $enc_off != $p3 ) { & mov ( " eax " , & wparam ( $p3 ) ) ; & push ( " eax " ) ; } else { & push ( " ecx " ) ; } } if ( $p2 > 0 ) { & comment ( " get ▁ and ▁ push ▁ parameter ▁ $ p2" ) ; if ( $enc_off != $p2 ) { & mov ( " eax " , & wparam ( $p2 ) ) ; & push ( " eax " ) ; } else { & push ( " ecx " ) ; } } if ( $p1 > 0 ) { & comment ( " get ▁ and ▁ push ▁ parameter ▁ $ p1" ) ; if ( $enc_off != $p1 ) { & mov ( " eax " , & wparam ( $p1 ) ) ; & push ( " eax " ) ; } else { & push ( " ecx " ) ; } } & push ( " ebx " ) ; # ▁ push ▁ data / iv ENDCOM & cmp ( " ecx " , 0 ) ; & jz ( & label ( " decrypt " ) ) ; & and ( $count , 0xfffffff8 ) ; & mov ( " eax " , & DWP ( $data_off , " esp " , " " , 0 ) ) ; # ▁ load ▁ iv [ 0 ] ENDCOM & mov ( " ebx " , & DWP ( $data_off + 4 , " esp " , " " , 0 ) ) ; # ▁ load ▁ iv [ 1 ] ENDCOM & jz ( & label ( " encrypt _ finish " ) ) ; & set_label ( " encrypt _ loop " ) ; # ▁ encrypt ▁ start ▁ ENDCOM # ▁ " eax " ▁ and ▁ " ebx " ▁ hold ▁ iv ▁ ( or ▁ the ▁ last ▁ cipher ▁ text ) ENDCOM & mov ( " ecx " , & DWP ( 0 , $in , " " , 0 ) ) ; # ▁ load ▁ first ▁ 4 ▁ bytes ENDCOM & mov ( " edx " , & DWP ( 4 , $in , " " , 0 ) ) ; # ▁ second ▁ 4 ▁ bytes ENDCOM & xor ( " eax " , " ecx " ) ; & xor ( " ebx " , " edx " ) ; & bswap ( " eax " ) if $swap ; & bswap ( " ebx " ) if $swap ; & mov ( & DWP ( $data_off , " esp " , " " , 0 ) , " eax " ) ; # ▁ put ▁ in ▁ array ▁ for ▁ call ENDCOM & mov ( & DWP ( $data_off + 4 , " esp " , " " , 0 ) , " ebx " ) ; & call ( $enc_func ) ; & mov ( " eax " , & DWP ( $data_off , " esp " , " " , 0 ) ) ; & mov ( " ebx " , & DWP ( $data_off + 4 , " esp " , " " , 0 ) ) ; & bswap ( " eax " ) if $swap ; & bswap ( " ebx " ) if $swap ; & mov ( & DWP ( 0 , $out , " " , 0 ) , " eax " ) ; & mov ( & DWP ( 4 , $out , " " , 0 ) , " ebx " ) ; # ▁ eax ▁ and ▁ ebx ▁ are ▁ the ▁ next ▁ iv . ENDCOM & add ( $in , 8 ) ; & add ( $out , 8 ) ; & sub ( $count , 8 ) ; & jnz ( & label ( " encrypt _ loop " ) ) ; & set_label ( " encrypt _ finish " ) ; & mov ( $count , & wparam ( 2 ) ) ; # ▁ length ENDCOM & and ( $count , 7 ) ; & jz ( & label ( " finish " ) ) ; & call ( & label ( " PIC _ point " ) ) ; & set_label ( " PIC _ point " ) ; & blindpop ( " edx " ) ; & lea ( " ecx " , & DWP ( & label ( " cbc _ enc _ jmp _ table " ) . " - " . & label ( " PIC _ point " ) , " edx " ) ) ; & mov ( $count , & DWP ( 0 , " ecx " , $count , 4 ) ) & add ( $count , " edx " ) ; & xor ( " ecx " , " ecx " ) ; & xor ( " edx " , " edx " ) ; # & mov ( $ count , & DWP ( & label ( " cbc _ enc _ jmp _ table " ) , " " , $ count , 4 ) ) ; ENDCOM & jmp_ptr ( $count ) ; & set_label ( " ej7" ) ; & movb ( & HB ( " edx " ) , & BP ( 6 , $in , " " , 0 ) ) ; & shl ( " edx " , 8 ) ; & set_label ( " ej6" ) ; & movb ( & HB ( " edx " ) , & BP ( 5 , $in , " " , 0 ) ) ; & set_label ( " ej5" ) ; & movb ( & LB ( " edx " ) , & BP ( 4 , $in , " " , 0 ) ) ; & set_label ( " ej4" ) ; & mov ( " ecx " , & DWP ( 0 , $in , " " , 0 ) ) ; & jmp ( & label ( " ejend " ) ) ; & set_label ( " ej3" ) ; & movb ( & HB ( " ecx " ) , & BP ( 2 , $in , " " , 0 ) ) ; & shl ( " ecx " , 8 ) ; & set_label ( " ej2" ) ; & movb ( & HB ( " ecx " ) , & BP ( 1 , $in , " " , 0 ) ) ; & set_label ( " ej1" ) ; & movb ( & LB ( " ecx " ) , & BP ( 0 , $in , " " , 0 ) ) ; & set_label ( " ejend " ) ; & xor ( " eax " , " ecx " ) ; & xor ( " ebx " , " edx " ) ; & bswap ( " eax " ) if $swap ; & bswap ( " ebx " ) if $swap ; & mov ( & DWP ( $data_off , " esp " , " " , 0 ) , " eax " ) ; # ▁ put ▁ in ▁ array ▁ for ▁ call ENDCOM & mov ( & DWP ( $data_off + 4 , " esp " , " " , 0 ) , " ebx " ) ; & call ( $enc_func ) ; & mov ( " eax " , & DWP ( $data_off , " esp " , " " , 0 ) ) ; & mov ( " ebx " , & DWP ( $data_off + 4 , " esp " , " " , 0 ) ) ; & bswap ( " eax " ) if $swap ; & bswap ( " ebx " ) if $swap ; & mov ( & DWP ( 0 , $out , " " , 0 ) , " eax " ) ; & mov ( & DWP ( 4 , $out , " " , 0 ) , " ebx " ) ; & jmp ( & label ( " finish " ) ) ; & set_label ( " decrypt " , 1 ) ; # ▁ decrypt ▁ start ▁ ENDCOM & and ( $count , 0xfffffff8 ) ; # ▁ The ▁ next ▁ 2 ▁ instructions ▁ are ▁ only ▁ for ▁ if ▁ the ▁ jz ▁ is ▁ taken ENDCOM & mov ( " eax " , & DWP ( $data_off + 8 , " esp " , " " , 0 ) ) ; # ▁ get ▁ iv [ 0 ] ENDCOM & mov ( " ebx " , & DWP ( $data_off + 12 , " esp " , " " , 0 ) ) ; # ▁ get ▁ iv [ 1 ] ENDCOM & jz ( & label ( " decrypt _ finish " ) ) ; & set_label ( " decrypt _ loop " ) ; & mov ( " eax " , & DWP ( 0 , $in , " " , 0 ) ) ; # ▁ load ▁ first ▁ 4 ▁ bytes ENDCOM & mov ( " ebx " , & DWP ( 4 , $in , " " , 0 ) ) ; # ▁ second ▁ 4 ▁ bytes ENDCOM & bswap ( " eax " ) if $swap ; & bswap ( " ebx " ) if $swap ; & mov ( & DWP ( $data_off , " esp " , " " , 0 ) , " eax " ) ; # ▁ put ▁ back ENDCOM & mov ( & DWP ( $data_off + 4 , " esp " , " " , 0 ) , " ebx " ) ; & call ( $dec_func ) ; & mov ( " eax " , & DWP ( $data_off , " esp " , " " , 0 ) ) ; # ▁ get ▁ return ENDCOM & mov ( " ebx " , & DWP ( $data_off + 4 , " esp " , " " , 0 ) ) ; & bswap ( " eax " ) if $swap ; & bswap ( " ebx " ) if $swap ; & mov ( " ecx " , & DWP ( $data_off + 8 , " esp " , " " , 0 ) ) ; # ▁ get ▁ iv [ 0 ] ENDCOM & mov ( " edx " , & DWP ( $data_off + 12 , " esp " , " " , 0 ) ) ; # ▁ get ▁ iv [ 1 ] ENDCOM & xor ( " ecx " , " eax " ) ; & xor ( " edx " , " ebx " ) ; & mov ( " eax " , & DWP ( 0 , $in , " " , 0 ) ) ; # ▁ get ▁ old ▁ cipher ▁ text , ENDCOM & mov ( " ebx " , & DWP ( 4 , $in , " " , 0 ) ) ; # ▁ next ▁ iv ▁ actually ENDCOM & mov ( & DWP ( 0 , $out , " " , 0 ) , " ecx " ) ; & mov ( & DWP ( 4 , $out , " " , 0 ) , " edx " ) ; & mov ( & DWP ( $data_off + 8 , " esp " , " " , 0 ) , " eax " ) ; # ▁ save ▁ iv ENDCOM & mov ( & DWP ( $data_off + 12 , " esp " , " " , 0 ) , " ebx " ) ; & add ( $in , 8 ) ; & add ( $out , 8 ) ; & sub ( $count , 8 ) ; & jnz ( & label ( " decrypt _ loop " ) ) ; # # # # # ▁ ENDIT ▁ # # # # # 3 ENDCOM & set_label ( " decrypt _ finish " ) ; & mov ( $count , & wparam ( 2 ) ) ; # ▁ length ENDCOM & and ( $count , 7 ) ; & jz ( & label ( " finish " ) ) ; & mov ( " eax " , & DWP ( 0 , $in , " " , 0 ) ) ; # ▁ load ▁ first ▁ 4 ▁ bytes ENDCOM & mov ( " ebx " , & DWP ( 4 , $in , " " , 0 ) ) ; # ▁ second ▁ 4 ▁ bytes ENDCOM & bswap ( " eax " ) if $swap ; & bswap ( " ebx " ) if $swap ; & mov ( & DWP ( $data_off , " esp " , " " , 0 ) , " eax " ) ; # ▁ put ▁ back ENDCOM & mov ( & DWP ( $data_off + 4 , " esp " , " " , 0 ) , " ebx " ) ; & call ( $dec_func ) ; & mov ( " eax " , & DWP ( $data_off , " esp " , " " , 0 ) ) ; # ▁ get ▁ return ENDCOM & mov ( " ebx " , & DWP ( $data_off + 4 , " esp " , " " , 0 ) ) ; & bswap ( " eax " ) if $swap ; & bswap ( " ebx " ) if $swap ; & mov ( " ecx " , & DWP ( $data_off + 8 , " esp " , " " , 0 ) ) ; # ▁ get ▁ iv [ 0 ] ENDCOM & mov ( " edx " , & DWP ( $data_off + 12 , " esp " , " " , 0 ) ) ; # ▁ get ▁ iv [ 1 ] ENDCOM & xor ( " ecx " , " eax " ) ; & xor ( " edx " , " ebx " ) ; # ▁ this ▁ is ▁ for ▁ when ▁ we ▁ exit ENDCOM & mov ( " eax " , & DWP ( 0 , $in , " " , 0 ) ) ; # ▁ get ▁ old ▁ cipher ▁ text , ENDCOM & mov ( " ebx " , & DWP ( 4 , $in , " " , 0 ) ) ; # ▁ next ▁ iv ▁ actually ENDCOM & set_label ( " dj7" ) ; & rotr ( " edx " , 16 ) ; & movb ( & BP ( 6 , $out , " " , 0 ) , & LB ( " edx " ) ) ; & shr ( " edx " , 16 ) ; & set_label ( " dj6" ) ; & movb ( & BP ( 5 , $out , " " , 0 ) , & HB ( " edx " ) ) ; & set_label ( " dj5" ) ; & movb ( & BP ( 4 , $out , " " , 0 ) , & LB ( " edx " ) ) ; & set_label ( " dj4" ) ; & mov ( & DWP ( 0 , $out , " " , 0 ) , " ecx " ) ; & jmp ( & label ( " djend " ) ) ; & set_label ( " dj3" ) ; & rotr ( " ecx " , 16 ) ; & movb ( & BP ( 2 , $out , " " , 0 ) , & LB ( " ecx " ) ) ; & shl ( " ecx " , 16 ) ; & set_label ( " dj2" ) ; & movb ( & BP ( 1 , $in , " " , 0 ) , & HB ( " ecx " ) ) ; & set_label ( " dj1" ) ; & movb ( & BP ( 0 , $in , " " , 0 ) , & LB ( " ecx " ) ) ; & set_label ( " djend " ) ; # ▁ final ▁ iv ▁ is ▁ still ▁ in ▁ eax : ebx ENDCOM & jmp ( & label ( " finish " ) ) ; # # # # # ▁ FINISH ▁ # # # # # 3 ENDCOM & set_label ( " finish " , 1 ) ; & mov ( " ecx " , & wparam ( $iv_off ) ) ; # ▁ Get ▁ iv ▁ ptr ENDCOM $total = 16 + 4 ; $total += 4 if ( $p1 > 0 ) ; $total += 4 if ( $p2 > 0 ) ; $total += 4 if ( $p3 > 0 ) ; & add ( " esp " , $total ) ; & mov ( & DWP ( 0 , " ecx " , " " , 0 ) , " eax " ) ; # ▁ save ▁ iv ENDCOM & mov ( & DWP ( 4 , " ecx " , " " , 0 ) , " ebx " ) ; # ▁ save ▁ iv ENDCOM & function_end_A ( $name ) ; & align ( 64 ) ; & set_label ( " cbc _ enc _ jmp _ table " ) ; & data_word ( "0" ) ; & data_word ( & label ( " ej1" ) . " - " . & label ( " PIC _ point " ) ) ; & data_word ( & label ( " ej2" ) . " - " . & label ( " PIC _ point " ) ) ; & data_word ( & label ( " ej3" ) . " - " . & label ( " PIC _ point " ) ) ; & data_word ( & label ( " ej4" ) . " - " . & label ( " PIC _ point " ) ) ; & data_word ( & label ( " ej5" ) . " - " . & label ( " PIC _ point " ) ) ; & data_word ( & label ( " ej6" ) . " - " . & label ( " PIC _ point " ) ) ; & data_word ( & label ( " ej7" ) . " - " . & label ( " PIC _ point " ) ) ; # ▁ not ▁ used ENDCOM # & set _ label ( " cbc _ dec _ jmp _ table " ,1 ) ; ENDCOM # & data _ word ( "0 " ) ; ENDCOM # & data _ word ( & label ( " dj1 " ) . " - " . & label ( " PIC _ point " ) ) ; ENDCOM # & data _ word ( & label ( " dj2 " ) . " - " . & label ( " PIC _ point " ) ) ; ENDCOM # & data _ word ( & label ( " dj3 " ) . " - " . & label ( " PIC _ point " ) ) ; ENDCOM # & data _ word ( & label ( " dj4 " ) . " - " . & label ( " PIC _ point " ) ) ; ENDCOM # & data _ word ( & label ( " dj5 " ) . " - " . & label ( " PIC _ point " ) ) ; ENDCOM # & data _ word ( & label ( " dj6 " ) . " - " . & label ( " PIC _ point " ) ) ; ENDCOM # & data _ word ( & label ( " dj7 " ) . " - " . & label ( " PIC _ point " ) ) ; ENDCOM & align ( 64 ) ; & function_end_B ( $name ) ; } 1 ; </DOCUMENT>
<DOCUMENT_ID="ashang/google-mysql/tree/master/cmake/configure.pl"> # ! / usr / bin / perl ENDCOM # ▁ Copyright ▁ ( c ) ▁ 2009 , ▁ 2012 , ▁ Oracle ▁ and / or ▁ its ▁ affiliates . ▁ All ▁ rights ▁ reserved . ENDCOM # ▁ This ▁ program ▁ is ▁ free ▁ software ; ▁ you ▁ can ▁ redistribute ▁ it ▁ and / or ▁ modify ENDCOM # ▁ it ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ as ▁ published ▁ by ENDCOM # ▁ the ▁ Free ▁ Software ▁ Foundation ; ▁ version ▁ 2 ▁ of ▁ the ▁ License . ENDCOM # ▁ This ▁ program ▁ is ▁ distributed ▁ in ▁ the ▁ hope ▁ that ▁ it ▁ will ▁ be ▁ useful , ENDCOM # ▁ but ▁ WITHOUT ▁ ANY ▁ WARRANTY ; ▁ without ▁ even ▁ the ▁ implied ▁ warranty ▁ of ENDCOM # ▁ MERCHANTABILITY ▁ or ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE . ▁ See ▁ the ENDCOM # ▁ GNU ▁ General ▁ Public ▁ License ▁ for ▁ more ▁ details . ENDCOM # ▁ You ▁ should ▁ have ▁ received ▁ a ▁ copy ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ENDCOM # ▁ along ▁ with ▁ this ▁ program ; ▁ if ▁ not , ▁ write ▁ to ▁ the ▁ Free ▁ Software ENDCOM # ▁ Foundation , ▁ Inc . , ▁ 51 ▁ Franklin ▁ St , ▁ Fifth ▁ Floor , ▁ Boston , ▁ MA ▁ 02110-1301 ▁ USA ENDCOM use strict ; use Cwd ' abs _ path ' ; use File :: Basename ; my $cmakeargs = " " ; # ▁ Find ▁ source ▁ root ▁ directory ENDCOM # ▁ Assume ▁ this ▁ script ▁ is ▁ in ▁ < srcroot > / cmake ENDCOM my $srcdir = dirname ( dirname ( abs_path ( $0 ) ) ) ; my $cmake_install_prefix = " " ; my $just_print = 0 ; # ▁ Sets ▁ installation ▁ directory , ▁ bindir , ▁ libdir , ▁ libexecdir ▁ etc ENDCOM # ▁ the ▁ equivalent ▁ CMake ▁ variables ▁ are ▁ given ▁ without ▁ prefix ENDCOM # ▁ e . g ▁ if ▁ - - prefix ▁ is ▁ / usr ▁ and ▁ - - bindir ▁ is ▁ / usr / bin ENDCOM # ▁ then ▁ cmake ▁ variable ▁ ( INSTALL _ BINDIR ) ▁ must ▁ be ▁ just ▁ " bin " ENDCOM sub set_installdir { my ( $path , $varname ) = @ _ ; my $prefix_length = length ( $cmake_install_prefix ) ; if ( ( $prefix_length > 0 ) && ( index ( $path , $cmake_install_prefix ) == 0 ) ) { # ▁ path ▁ is ▁ under ▁ the ▁ prefix , ▁ so ▁ remove ▁ the ▁ prefix ▁ and ▁ maybe ▁ following ▁ " / " ENDCOM $path = substr ( $path , $prefix_length ) ; if ( length ( $path ) > 0 ) { my $char = substr ( $path , 0 , 1 ) ; if ( $char eq " / " ) { $path = substr ( $path , 1 ) ; } } if ( length ( $path ) > 0 ) { $cmakeargs = $cmakeargs . " ▁ - D " . $varname . " = " . $path ; } } } # ▁ CMake ▁ understands ▁ CC ▁ and ▁ CXX ▁ env . variables ▁ correctly , ▁ if ▁ they ▁ contain ▁ 1 ▁ or ▁ 2 ▁ tokens ENDCOM # ▁ e . g ▁ CXX = gcc ▁ and ▁ CXX = " ccache ▁ gcc " ▁ are ▁ ok . ▁ However ▁ it ▁ could ▁ have ▁ a ▁ problem ▁ if ▁ there ENDCOM # ▁ ( recognizing ▁ gcc ) ▁ with ▁ more ▁ tokens ▁ , e . g ▁ CXX = " ccache ▁ gcc ▁ - - pipe " . ENDCOM # ▁ The ▁ problem ▁ is ▁ simply ▁ fixed ▁ by ▁ splitting ▁ compiler ▁ and ▁ flags , ▁ e . g ENDCOM # ▁ CXX = " ccache ▁ gcc ▁ - - pipe " ▁ = > ▁ CXX = ccache ▁ gcc ▁ CXXFLAGS = - - pipe ENDCOM sub check_compiler { my ( $varname , $flagsvarname ) = @ _ ; my @ tokens = split ( / / , $ENV { $varname } ) ; if ( $ # tokens ▁ > = ▁ 2 ) ▁ ENDCOM { $ENV { $varname } = $tokens [ 0 ] . " ▁ " . $tokens [ 1 ] ; my $flags ; for ( my $i = 2 ; $i <= $ # tokens ; ▁ $ i + + ) ENDCOM { $flags = $flags . " ▁ " . $tokens [ $i ] ; } if ( defined $ENV { $flagsvarname } ) { $flags = $flags . " ▁ " . $ENV { $flagsvarname } ; } $ENV { $flagsvarname } = $flags ; print ( " $ varname = $ ENV { $ varname } \n " ) ; print ( " $ flagsvarname = $ ENV { $ flagsvarname } \n " ) ; } } check_compiler ( " CC " , " CFLAGS " ) ; check_compiler ( " CXX " , " CXXFLAGS " ) ; foreach my $option ( @ ARGV ) { if ( substr ( $option , 0 , 2 ) eq " - - " ) { $option = substr ( $option , 2 ) ; } else { # ▁ This ▁ must ▁ be ▁ environment ▁ variable ENDCOM my @ v = split ( ' = ' , $option ) ; my $name = shift ( @ v ) ; if ( @ v ) { $ENV { $name } = join ( ' = ' , @ v ) ; } next ; } if ( $option = ~ / srcdir / ) { $srcdir = substr ( $option , 7 ) ; next ; } if ( $option = ~ / help / ) { system ( " cmake ▁ $ { srcdir } ▁ - LH " ) ; exit ( 0 ) ; } if ( $option = ~ / print / ) { $just_print = 1 ; next ; } if ( $option = ~ / with - plugins = / ) { my @ plugins = split ( / , / , substr ( $option , 13 ) ) ; foreach my $p ( @ plugins ) { $p = ~ s / - / _ / g ; $cmakeargs = $cmakeargs . " ▁ - DWITH _ " . uc ( $p ) . " = 1" ; } next ; } if ( $option = ~ / with - extra - charsets = / ) { my $charsets = substr ( $option , 20 ) ; $cmakeargs = $cmakeargs . " ▁ - DWITH _ EXTRA _ CHARSETS = " . $charsets ; next ; } if ( $option = ~ / without - plugin = / ) { $cmakeargs = $cmakeargs . " ▁ - DWITHOUT _ " . uc ( substr ( $option , 15 ) ) . " = 1" ; next ; } if ( $option = ~ / with - zlib - dir = bundled / ) { $cmakeargs = $cmakeargs . " ▁ - DWITH _ ZLIB = bundled " ; next ; } if ( $option = ~ / with - zlib - dir = / ) { $cmakeargs = $cmakeargs . " ▁ - DWITH _ ZLIB = system " ; next ; } if ( $option = ~ / with - libevent = / ) { $cmakeargs = $cmakeargs . " ▁ - DWITH _ LIBEVENT = system " ; next ; } if ( $option = ~ / with - libevent / ) { $cmakeargs = $cmakeargs . " ▁ - DWITH _ LIBEVENT = bundled " ; next ; } if ( $option = ~ / with - ssl = / ) { $cmakeargs = $cmakeargs . " ▁ - DWITH _ SSL = yes " ; next ; } if ( $option = ~ / with - debug / ) { $cmakeargs = $cmakeargs . " ▁ - DCMAKE _ BUILD _ TYPE = Debug " ; next ; } if ( $option = ~ / with - ssl / ) { $cmakeargs = $cmakeargs . " ▁ - DWITH _ SSL = bundled " ; next ; } if ( $option = ~ / prefix = / ) { $cmake_install_prefix = substr ( $option , 7 ) ; $cmakeargs = $cmakeargs . " ▁ - DCMAKE _ INSTALL _ PREFIX = " . $cmake_install_prefix ; next ; } if ( $option = ~ / bindir = / ) { set_installdir ( substr ( $option , 7 ) , " INSTALL _ BINDIR " ) ; next ; } if ( $option = ~ / libdir = / ) { set_installdir ( substr ( $option , 7 ) , " INSTALL _ LIBDIR " ) ; next ; } if ( $option = ~ / libexecdir = / ) { set_installdir ( substr ( $option , 11 ) , " INSTALL _ SBINDIR " ) ; next ; } if ( $option = ~ / includedir = / ) { set_installdir ( substr ( $option , 11 ) , " INSTALL _ INCLUDEDIR " ) ; next ; } if ( $option = ~ / extra - charsets = all / ) { $cmakeargs = $cmakeargs . " ▁ - DWITH _ CHARSETS = all " ; next ; } if ( $option = ~ / extra - charsets = complex / ) { $cmakeargs = $cmakeargs . " ▁ - DWITH _ CHARSETS = complex " ; next ; } if ( $option = ~ / localstatedir = / ) { $cmakeargs = $cmakeargs . " ▁ - DMYSQL _ DATADIR = " . substr ( $option , 14 ) ; next ; } if ( $option = ~ / mysql - maintainer - mode / ) { $cmakeargs = $cmakeargs . " ▁ - DMYSQL _ MAINTAINER _ MODE = " . ( $option = ~ / enable / ? "1" : "0" ) ; next ; } if ( $option = ~ / with - comment = / ) { $cmakeargs = $cmakeargs . " ▁ \ " - DWITH _ COMMENT = " . substr ( $option , 13 ) . " \ " " ; next ; } if ( $option = ~ / with - gcov / ) { $cmakeargs = $cmakeargs . " ▁ - DENABLE _ GCOV = ON " ; next ; } if ( $option = ~ / verbose / ) { $cmakeargs = $cmakeargs . " ▁ - DCMAKE _ VERBOSE _ MAKEFILE = 1" ; next ; } if ( $option = ~ / with - client - ldflags / ) { print ( " configure . pl ▁ : ▁ ignoring ▁ $ option \n " ) ; next ; } if ( $option = ~ / with - mysqld - ldflags = / ) { print ( " configure . pl ▁ : ▁ ignoring ▁ $ option \n " ) ; next ; } if ( $option = ~ / with - client - ldflags / ) { print ( " configure . pl ▁ : ▁ ignoring ▁ $ option \n " ) ; next ; } if ( $option = ~ / with - mysqld - ldflags = / ) { print ( " configure . pl ▁ : ▁ ignoring ▁ $ option \n " ) ; next ; } $option = uc ( $option ) ; $option = ~ s / - / _ / g ; $cmakeargs = $cmakeargs . " ▁ - D " . $option . " = 1" ; } print ( " configure . pl ▁ : ▁ calling ▁ cmake ▁ $ srcdir ▁ $ cmakeargs \n " ) ; exit ( 0 ) if ( $just_print ) ; unlink ( " CMakeCache . txt " ) ; my $rc = system ( " cmake ▁ $ srcdir ▁ $ cmakeargs " ) ; exit ( $rc ) ; </DOCUMENT>
<DOCUMENT_ID="taschetto/artificialIntelligence/tree/master/prolog/demo.pl"> prof ( felipe ) . prof ( bordini ) . it ( ze ) . instructor ( carol ) . staff ( X ) : - prof ( X ) . staff ( X ) : - it ( X ) . staff ( X ) : - instructor ( X ) . first ( [ H | T ] , H ) . rest ( [ H | T ] , T ) . % find ( List , Element ) -- find ( [ a , b , c , d ] , b ) . find ( [ E | T ] , E ) . find ( [ _ | T ] , E ) : - find ( T , E ) . </DOCUMENT>
<DOCUMENT_ID="RAZAW/social-media-linkedin/tree/master/usr/share/perl5/core_perl/unicore/lib/SB/XX.pl"> # ▁ ! ! ! ! ! ▁ DO ▁ NOT ▁ EDIT ▁ THIS ▁ FILE ▁ ! ! ! ! ! ENDCOM # ▁ This ▁ file ▁ is ▁ machine - generated ▁ by ▁ lib / unicore / mktables ▁ from ▁ the ▁ Unicode ENDCOM # ▁ database , ▁ Version ▁ 7.0.0 . ▁ Any ▁ changes ▁ made ▁ here ▁ will ▁ be ▁ lost ! ENDCOM # ▁ ! ! ! ! ! ▁ INTERNAL ▁ PERL ▁ USE ▁ ONLY ▁ ! ! ! ! ! ENDCOM # ▁ This ▁ file ▁ is ▁ for ▁ internal ▁ use ▁ by ▁ core ▁ Perl ▁ only . ▁ The ▁ format ▁ and ▁ even ▁ the ENDCOM # ▁ name ▁ or ▁ existence ▁ of ▁ this ▁ file ▁ are ▁ subject ▁ to ▁ change ▁ without ▁ notice . ▁ Don ' t ENDCOM # ▁ use ▁ it ▁ directly . ▁ Use ▁ Unicode : : UCD ▁ to ▁ access ▁ the ▁ Unicode ▁ character ▁ data ENDCOM # ▁ base . ENDCOM return << ' END ' ; V1395 0 9 14 32 35 39 42 44 47 48 59 63 64 65 92 93 94 97 124 125 126 133 134 160 161 170 172 173 174 181 182 186 188 192 215 216 247 248 706 710 722 736 741 748 749 750 751 768 885 886 888 890 894 895 896 902 903 904 907 908 909 910 930 931 1014 1015 1154 1155 1328 1329 1367 1369 1370 1373 1374 1377 1416 1417 1418 1425 1470 1471 1472 1473 1475 1476 1478 1479 1480 1488 1515 1520 1524 1536 1542 1548 1550 1552 1563 1564 1565 1567 1642 1643 1645 1646 1758 1759 1769 1770 1789 1791 1795 1807 1867 1869 1970 1984 2038 2040 2043 2048 2094 2112 2140 2208 2227 2276 2416 2417 2436 2437 2445 2447 2449 2451 2473 2474 2481 2482 2483 2486 2490 2492 2501 2503 2505 2507 2511 2519 2520 2524 2526 2527 2532 2534 2546 2561 2564 2565 2571 2575 2577 2579 2601 2602 2609 2610 2612 2613 2615 2616 2618 2620 2621 2622 2627 2631 2633 2635 2638 2641 2642 2649 2653 2654 2655 2662 2678 2689 2692 2693 2702 2703 2706 2707 2729 2730 2737 2738 2740 2741 2746 2748 2758 2759 2762 2763 2766 2768 2769 2784 2788 2790 2800 2817 2820 2821 2829 2831 2833 2835 2857 2858 2865 2866 2868 2869 2874 2876 2885 2887 2889 2891 2894 2902 2904 2908 2910 2911 2916 2918 2928 2929 2930 2946 2948 2949 2955 2958 2961 2962 2966 2969 2971 2972 2973 2974 2976 2979 2981 2984 2987 2990 3002 3006 3011 3014 3017 3018 3022 3024 3025 3031 3032 3046 3056 3072 3076 3077 3085 3086 3089 3090 3113 3114 3130 3133 3141 3142 3145 3146 3150 3157 3159 3160 3162 3168 3172 3174 3184 3201 3204 3205 3213 3214 3217 3218 3241 3242 3252 3253 3258 3260 3269 3270 3273 3274 3278 3285 3287 3294 3295 3296 3300 3302 3312 3313 3315 3329 3332 3333 3341 3342 3345 3346 3387 3389 3397 3398 3401 3402 3407 3415 3416 3424 3428 3430 3440 3450 3456 3458 3460 3461 3479 3482 3506 3507 3516 3517 3518 3520 3527 3530 3531 3535 3541 3542 3543 3544 3552 3558 3568 3570 3572 3585 3643 3648 3663 3664 3674 3713 3715 3716 3717 3719 3721 3722 3723 3725 3726 3732 3736 3737 3744 3745 3748 3749 3750 3751 3752 3754 3756 3757 3770 3771 3774 3776 3781 3782 3783 3784 3790 3792 3802 3804 3808 3840 3841 3864 3866 3872 3882 3893 3894 3895 3896 3897 3912 3913 3949 3953 3973 3974 3992 3993 4029 4038 4039 4096 4172 4176 4254 4256 4294 4295 4296 4301 4302 4304 4347 4348 4681 4682 4686 4688 4695 4696 4697 4698 4702 4704 4745 4746 4750 4752 4785 4786 4790 4792 4799 4800 4801 4802 4806 4808 4823 4824 4881 4882 4886 4888 4955 4957 4960 4962 4963 4967 4969 4992 5008 5024 5109 5121 5741 5742 5789 5792 5867 5870 5881 5888 5901 5902 5909 5920 5943 5952 5972 5984 5997 5998 6001 6002 6004 6016 6100 6103 6104 6108 6110 6112 6122 6146 6148 6152 6154 6155 6159 6160 6170 6176 6264 6272 6315 6320 6390 6400 6431 6432 6444 6448 6460 6468 6510 6512 6517 6528 6572 6576 6602 6608 6618 6656 6684 6688 6751 6752 6781 6783 6794 6800 6810 6823 6828 6832 6847 6912 6988 6992 7004 7006 7008 7019 7028 7040 7156 7168 7224 7227 7229 7232 7242 7245 7296 7376 7379 7380 7415 7416 7418 7424 7670 7676 7958 7960 7966 7968 8006 8008 8014 8016 8024 8025 8026 8027 8028 8029 8030 8031 8062 8064 8117 8118 8125 8126 8127 8130 8133 8134 8141 8144 8148 8150 8156 8160 8173 8178 8181 8182 8189 8192 8208 8211 8213 8216 8224 8228 8229 8232 8240 8249 8251 8252 8254 8261 8266 8287 8293 8294 8304 8305 8306 8317 8320 8333 8335 8336 8349 8400 8433 8450 8451 8455 8456 8458 8468 8469 8470 8473 8478 8484 8485 8486 8487 8488 8489 8490 8494 8495 8506 8508 8512 8517 8522 8526 8527 8544 8585 8968 8972 9001 9003 9398 9450 10075 10081 10088 10102 10181 10183 10214 10224 10627 10649 10712 10716 10748 10750 11264 11311 11312 11359 11360 11493 11499 11508 11520 11558 11559 11560 11565 11566 11568 11624 11631 11632 11647 11671 11680 11687 11688 11695 11696 11703 11704 11711 11712 11719 11720 11727 11728 11735 11736 11743 11744 11790 11804 11806 11808 11818 11822 11824 11836 11837 11842 11843 12288 12291 12293 12306 12308 12316 12317 12320 12321 12336 12337 12342 12344 12349 12353 12439 12441 12443 12445 12448 12449 12539 12540 12544 12549 12590 12593 12687 12704 12731 12784 12800 13312 19894 19968 40909 40960 42125 42192 42238 42239 42509 42510 42540 42560 42611 42612 42622 42623 42654 42655 42738 42739 42740 42743 42744 42775 42784 42786 42889 42891 42895 42896 42926 42928 42930 42999 43048 43072 43124 43126 43128 43136 43205 43214 43226 43232 43256 43259 43260 43264 43310 43311 43348 43360 43389 43392 43457 43464 43466 43471 43482 43488 43519 43520 43575 43584 43598 43600 43610 43613 43639 43642 43715 43739 43742 43744 43767 43777 43783 43785 43791 43793 43799 43808 43815 43816 43823 43824 43867 43868 43872 43876 43878 43968 44014 44016 44026 44032 55204 55216 55239 55243 55292 63744 64110 64112 64218 64256 64263 64275 64280 64285 64297 64298 64311 64312 64317 64318 64319 64320 64322 64323 64325 64326 64434 64467 64832 64848 64912 64914 64968 65008 65020 65024 65042 65043 65044 65047 65049 65056 65070 65073 65075 65077 65093 65095 65097 65104 65107 65109 65119 65123 65124 65136 65141 65142 65277 65279 65280 65281 65282 65288 65290 65292 65295 65306 65307 65311 65312 65313 65340 65341 65342 65345 65372 65373 65374 65375 65381 65382 65471 65474 65480 65482 65488 65490 65496 65498 65501 65529 65532 65536 65548 65549 65575 65576 65595 65596 65598 65599 65614 65616 65630 65664 65787 65856 65909 66045 66046 66176 66205 66208 66257 66272 66273 66304 66336 66352 66379 66384 66427 66432 66462 66464 66500 66504 66512 66513 66518 66560 66718 66720 66730 66816 66856 66864 66916 67072 67383 67392 67414 67424 67432 67584 67590 67592 67593 67594 67638 67639 67641 67644 67645 67647 67670 67680 67703 67712 67743 67840 67862 67872 67898 67968 68024 68030 68032 68096 68100 68101 68103 68108 68116 68117 68120 68121 68148 68152 68155 68159 68160 68182 68184 68192 68221 68224 68253 68288 68296 68297 68327 68352 68406 68416 68438 68448 68467 68480 68498 68608 68681 69632 69705 69734 69744 69759 69819 69821 69826 69840 69865 69872 69882 69888 69941 69942 69952 69953 69956 69968 70004 70006 70007 70016 70087 70093 70094 70096 70107 70144 70162 70163 70202 70203 70205 70320 70379 70384 70394 70401 70404 70405 70413 70415 70417 70419 70441 70442 70449 70450 70452 70453 70458 70460 70469 70471 70473 70475 70478 70487 70488 70493 70500 70502 70509 70512 70517 70784 70854 70855 70856 70864 70874 71040 71094 71096 71105 71106 71108 71113 71114 71168 71235 71236 71237 71248 71258 71296 71352 71360 71370 71840 71914 71935 71936 72384 72441 73728 74649 74752 74863 77824 78895 92160 92729 92736 92767 92768 92778 92782 92784 92880 92910 92912 92918 92928 92985 92992 92997 93008 93018 93027 93048 93053 93072 93952 94021 94032 94079 94095 94112 110592 110594 113664 113771 113776 113789 113792 113801 113808 113818 113821 113828 119141 119146 119149 119171 119173 119180 119210 119214 119362 119365 119808 119893 119894 119965 119966 119968 119970 119971 119973 119975 119977 119981 119982 119994 119995 119996 119997 120004 120005 120070 120071 120075 120077 120085 120086 120093 120094 120122 120123 120127 120128 120133 120134 120135 120138 120145 120146 120486 120488 120513 120514 120539 120540 120571 120572 120597 120598 120629 120630 120655 120656 120687 120688 120713 120714 120745 120746 120771 120772 120780 120782 120832 124928 125125 125136 125143 126464 126468 126469 126496 126497 126499 126500 126501 126503 126504 126505 126515 126516 126520 126521 126522 126523 126524 126530 126531 126535 126536 126537 126538 126539 126540 126541 126544 126545 126547 126548 126549 126551 126552 126553 126554 126555 126556 126557 126558 126559 126560 126561 126563 126564 126565 126567 126571 126572 126579 126580 126584 126585 126589 126590 126591 126592 126602 126603 126620 126625 126628 126629 126634 126635 126652 127280 127306 127312 127338 127344 127370 128630 128633 131072 173783 173824 177973 177984 178206 194560 195102 917505 917506 917536 917632 917760 918000 END </DOCUMENT>
<DOCUMENT_ID="StephenWeatherford/terraform/tree/master/vendor/github.com/fsouza/go-dockerclient/external/golang.org/x/sys/unix/mksysnum_darwin.pl"> # ! / usr / bin / env ▁ perl ENDCOM # ▁ Copyright ▁ 2009 ▁ The ▁ Go ▁ Authors . ▁ All ▁ rights ▁ reserved . ENDCOM # ▁ Use ▁ of ▁ this ▁ source ▁ code ▁ is ▁ governed ▁ by ▁ a ▁ BSD - style ENDCOM # ▁ license ▁ that ▁ can ▁ be ▁ found ▁ in ▁ the ▁ LICENSE ▁ file . ENDCOM # ▁ Generate ▁ system ▁ call ▁ table ▁ for ▁ Darwin ▁ from ▁ sys / syscall . h ENDCOM use strict ; if ( $ENV { ' GOARCH ' } eq " " || $ENV { ' GOOS ' } eq " " ) { print STDERR " GOARCH ▁ or ▁ GOOS ▁ not ▁ defined ▁ in ▁ environment \n " ; exit 1 ; } my $command = " mksysnum _ darwin . pl ▁ " . join ( ' ▁ ' , @ ARGV ) ; print << EOF ; / / $command / / MACHINE GENERATED BY THE ABOVE COMMAND ; DO NOT EDIT / / + build $ENV { ' GOARCH ' } , $ENV { ' GOOS ' } package unix const ( EOF while ( < > ) { if ( / ^ # define\s + SYS _ ( \w + ) \s + ( [0-9 ] + ) / ) { ENDCOM my $name = $1 ; my $num = $2 ; $name = ~ y / a - z / A - Z / ; print " TABSYMBOL SYS _ $ name ▁ = ▁ $ num ; " } } print << EOF ; ) EOF </DOCUMENT>
<DOCUMENT_ID="caramucho/ns3-ndnsim/tree/master/src/lte/test/lte-test-run-time.pl"> # ! / usr / bin / perl ENDCOM use strict ; use IO :: CaptureOutput qw ( capture qxx qxy ) ; use Statistics :: Descriptive ; my $nIterations = 1 ; open ( FILE , ' > lteTimes . csv ' ) ; print FILE " # sTime\tnFloors\tnEnb\tnUe\trTime\trTDev \n " ; my @ nUe = ( 1 , 5 , 10 , 15 , 20 , 25 , 30 ) ; my @ nEnb = ( 1 , 2 , 4 , 6 , 8 , 12 , 14 , 18 , 22 ) ; my @ nFloors = ( 0 , 1 ) ; my @ simTime = ( 5 , 10 ) ; # ▁ Configure ▁ and ▁ complite ▁ first ▁ the ▁ program ▁ to ▁ avoid ▁ counting ▁ compilation ▁ time ▁ as ▁ running ▁ time ENDCOM my $launch = " CXXFLAGS = \ " - O3 ▁ - w\ " ▁ . / waf ▁ - d ▁ optimized ▁ configure ▁ - - enable - static ▁ - - enable - examples ▁ - - enable - modules = lte " ; my $out ; my $err ; capture { system ( $launch ) } \ $out , \ $err ; $launch = " . / waf ▁ - - run ▁ \ ' lena - profiling ▁ - - simTime = 0.1 ▁ - - nUe = 1 ▁ - - nEnb = 1 ▁ - - nFloors = 0\ ' " ; capture { system ( $launch ) } \ $out , \ $err ; foreach my $time ( @ simTime ) { foreach my $floor ( @ nFloors ) { foreach my $enb ( @ nEnb ) { foreach my $ue ( @ nUe ) { my $timeStats = Statistics :: Descriptive :: Full -> new ( ) ; for ( my $iteration = 0 ; $iteration < $nIterations ; $iteration ++ ) { $launch = " time ▁ . / waf ▁ - - run ▁ \ ' lena - profiling ▁ - - simTime = $ time ▁ - - nUe = $ ue ▁ - - nEnb = $ enb ▁ - - nFloors = $ floor\ ' " ; print " $ launch \n " ; capture { system ( $launch ) } \ $out , \ $err ; $err = ~ / real ( . + ) m ( . + ) s / ; my $minutes = $1 ; my $seconds = $minutes * 60 + $2 ; $timeStats -> add_data ( $seconds ) ; } print FILE " $ time\t $ floor\t $ enb\t $ ue\t " ; print FILE $timeStats -> mean ( ) . " \t " . $timeStats -> standard_deviation ( ) . " \n " ; } } } } </DOCUMENT>
<DOCUMENT_ID="amyvmiwei/kbengine/tree/master/kbe/src/lib/dependencies/openssl/crypto/sha/asm/sha512-sse2.pl"> # ! / usr / bin / perl ENDCOM # ▁ Written ▁ by ▁ Andy ▁ Polyakov ▁ < appro @ fy . chalmers . se > ▁ for ▁ the ▁ OpenSSL ENDCOM # ▁ project . ▁ Rights ▁ for ▁ redistribution ▁ and ▁ usage ▁ in ▁ source ▁ and ▁ binary ENDCOM # ▁ forms ▁ are ▁ granted ▁ according ▁ to ▁ the ▁ OpenSSL ▁ license . ENDCOM # ▁ SHA512 _ Transform _ SSE2 . ENDCOM # ▁ As ▁ the ▁ name ▁ suggests , ▁ this ▁ is ▁ an ▁ IA - 32 ▁ SSE2 ▁ implementation ▁ of ENDCOM # ▁ SHA512 _ Transform . ▁ Motivating ▁ factor ▁ for ▁ the ▁ undertaken ▁ effort ▁ was ▁ that ENDCOM # ▁ SHA512 ▁ was ▁ observed ▁ to ▁ * consistently * ▁ perform ▁ * significantly * ▁ poorer ENDCOM # ▁ than ▁ SHA256 ▁ [ 2x ▁ and ▁ slower ▁ is ▁ common ] ▁ on ▁ 32 - bit ▁ platforms . ▁ On ▁ 64 - bit ENDCOM # ▁ platforms ▁ on ▁ the ▁ other ▁ hand ▁ SHA512 ▁ tend ▁ to ▁ outperform ▁ SHA256 ▁ [ ~ 50 % ENDCOM # ▁ seem ▁ to ▁ be ▁ common ▁ improvement ▁ factor ] . ▁ All ▁ this ▁ is ▁ perfectly ▁ natural , ENDCOM # ▁ as ▁ SHA512 ▁ is ▁ a ▁ 64 - bit ▁ algorithm . ▁ But ▁ isn ' t ▁ IA - 32 ▁ SSE2 ▁ essentially ENDCOM # ▁ a ▁ 64 - bit ▁ instruction ▁ set ? ▁ Is ▁ it ▁ rich ▁ enough ▁ to ▁ implement ▁ SHA512 ? ENDCOM # ▁ If ▁ answer ▁ was ▁ " no , " ▁ then ▁ you ▁ wouldn ' t ▁ have ▁ been ▁ reading ▁ this . . . ENDCOM # ▁ Throughput ▁ performance ▁ in ▁ MBps ▁ ( larger ▁ is ▁ better ) : ENDCOM # TABSYMBOL TABSYMBOL 2.4GHz ▁ P4 TABSYMBOL 1.4GHz ▁ AMD32 TABSYMBOL 1.4GHz ▁ AMD64 ( * ) ENDCOM # ▁ SHA256 / gcc ( * ) TABSYMBOL 54 TABSYMBOL TABSYMBOL 43 TABSYMBOL TABSYMBOL 59 ENDCOM # ▁ SHA512 / gcc TABSYMBOL 17 TABSYMBOL TABSYMBOL 23 TABSYMBOL TABSYMBOL 92 ENDCOM # ▁ SHA512 / sse2 TABSYMBOL 61 ( * * ) TABSYMBOL TABSYMBOL 57 ( * * ) ENDCOM # ▁ SHA512 / icc TABSYMBOL 26 TABSYMBOL TABSYMBOL 28 ENDCOM # ▁ SHA256 / icc ( * ) TABSYMBOL 65 TABSYMBOL TABSYMBOL 54 ENDCOM # ▁ ( * ) TABSYMBOL AMD64 ▁ and ▁ SHA256 ▁ numbers ▁ are ▁ presented ▁ mostly ▁ for ▁ amusement ▁ or ENDCOM # TABSYMBOL reference ▁ purposes . ENDCOM # ▁ ( * * ) TABSYMBOL I . e . ▁ it ▁ gives ▁ ~ 2-3x ▁ speed - up ▁ if ▁ compared ▁ with ▁ compiler ▁ generated ENDCOM # TABSYMBOL code . ▁ One ▁ can ▁ argue ▁ that ▁ hand - coded ▁ * non * - SSE2 ▁ implementation ENDCOM # TABSYMBOL would ▁ perform ▁ better ▁ than ▁ compiler ▁ generated ▁ one ▁ as ▁ well , ▁ and ENDCOM # TABSYMBOL that ▁ comparison ▁ is ▁ therefore ▁ not ▁ exactly ▁ fair . ▁ Well , ▁ as ▁ SHA512 ENDCOM # TABSYMBOL puts ▁ enormous ▁ pressure ▁ on ▁ IA - 32 ▁ GP ▁ register ▁ bank , ▁ I ▁ reckon ▁ that ENDCOM # TABSYMBOL hand - coded ▁ version ▁ wouldn ' t ▁ perform ▁ significantly ▁ better ▁ than ENDCOM # TABSYMBOL one ▁ compiled ▁ with ▁ icc , ▁ ~ 20 % ▁ perhaps . . . ▁ So ▁ that ▁ this ▁ code ▁ would ENDCOM # TABSYMBOL still ▁ outperform ▁ it ▁ with ▁ distinguishing ▁ marginal . ▁ But ▁ feel ▁ free ENDCOM # TABSYMBOL to ▁ prove ▁ me ▁ wrong : - ) ENDCOM # TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL < appro @ fy . chalmers . se > ENDCOM push ( @ INC , " perlasm " , " . . / . . / perlasm " ) ; require " x86asm . pl " ; & asm_init ( $ARGV [ 0 ] , " sha512 - sse2 . pl " , $ARGV [ $ # ARGV ] ▁ eq ▁ " 386 " ) ; ENDCOM $K512 = " esi " ; # ▁ K512[80 ] ▁ table , ▁ found ▁ at ▁ the ▁ end . . . ENDCOM # $ W512 = " esp " ; TABSYMBOL # ▁ $ W512 ▁ is ▁ not ▁ just ▁ W512[16 ] : ▁ it ▁ comprises ▁ * two * ▁ copies ENDCOM # ▁ of ▁ W512[16 ] ▁ and ▁ a ▁ copy ▁ of ▁ A - H ▁ variables . . . ENDCOM $W512_SZ = 8 * ( 16 + 16 + 8 ) ; # ▁ see ▁ above . . . ENDCOM # $ Kidx = " ebx " ; TABSYMBOL # ▁ index ▁ in ▁ K512 ▁ table , ▁ advances ▁ from ▁ 0 ▁ to ▁ 80 . . . ENDCOM $Widx = " edx " ; # ▁ index ▁ in ▁ W512 , ▁ wraps ▁ around ▁ at ▁ 16 . . . ENDCOM $data = " edi " ; # ▁ 16 ▁ qwords ▁ of ▁ input ▁ data . . . ENDCOM $A = " mm0" ; # ▁ B - D ▁ and ENDCOM $E = " mm1" ; # ▁ F - H ▁ are ▁ allocated ▁ dynamically . . . ENDCOM $Aoff = 256 + 0 ; # ▁ A - H ▁ offsets ▁ relative ▁ to ▁ $ W512 . . . ENDCOM $Boff = 256 + 8 ; $Coff = 256 + 16 ; $Doff = 256 + 24 ; $Eoff = 256 + 32 ; $Foff = 256 + 40 ; $Goff = 256 + 48 ; $Hoff = 256 + 56 ; sub SHA2_ROUND ( ) { local ( $kidx , $widx ) = @ _ ; # ▁ One ▁ can ▁ argue ▁ that ▁ one ▁ could ▁ reorder ▁ instructions ▁ for ▁ better ENDCOM # ▁ performance . ▁ Well , ▁ I ▁ tried ▁ and ▁ it ▁ doesn ' t ▁ seem ▁ to ▁ make ▁ any ENDCOM # ▁ noticeable ▁ difference . ▁ Modern ▁ out - of - order ▁ execution ▁ cores ENDCOM # ▁ reorder ▁ instructions ▁ to ▁ their ▁ liking ▁ in ▁ either ▁ case ▁ and ▁ they ENDCOM # ▁ apparently ▁ do ▁ decent ▁ job . ▁ So ▁ we ▁ can ▁ keep ▁ the ▁ code ▁ more ENDCOM # ▁ readable / regular / comprehensible : - ) ENDCOM # ▁ I ▁ adhere ▁ to ▁ 64 - bit ▁ % mmX ▁ registers ▁ in ▁ order ▁ to ▁ avoid / not ▁ care ENDCOM # ▁ about ▁ # GP ▁ exceptions ▁ on ▁ misaligned ▁ 128 - bit ▁ access , ▁ most ENDCOM # ▁ notably ▁ in ▁ paddq ▁ with ▁ memory ▁ operand . ▁ Not ▁ to ▁ mention ▁ that ENDCOM # ▁ SSE2 ▁ intructions ▁ operating ▁ on ▁ % mmX ▁ can ▁ be ▁ scheduled ▁ every ENDCOM # ▁ cycle ▁ [ and ▁ not ▁ every ▁ second ▁ one ▁ if ▁ operating ▁ on ▁ % xmmN ] . ENDCOM & movq ( " mm4" , & QWP ( $Foff , $W512 ) ) ; # ▁ load ▁ f ENDCOM & movq ( " mm5" , & QWP ( $Goff , $W512 ) ) ; # ▁ load ▁ g ENDCOM & movq ( " mm6" , & QWP ( $Hoff , $W512 ) ) ; # ▁ load ▁ h ENDCOM & movq ( " mm2" , $E ) ; # ▁ % mm2 ▁ is ▁ sliding ▁ right ENDCOM & movq ( " mm3" , $E ) ; # ▁ % mm3 ▁ is ▁ sliding ▁ left ENDCOM & psrlq ( " mm2" , 14 ) ; & psllq ( " mm3" , 23 ) ; & movq ( " mm7" , " mm2" ) ; # ▁ % mm7 ▁ is ▁ T1 ENDCOM & pxor ( " mm7" , " mm3" ) ; & psrlq ( " mm2" , 4 ) ; & psllq ( " mm3" , 23 ) ; & pxor ( " mm7" , " mm2" ) ; & pxor ( " mm7" , " mm3" ) ; & psrlq ( " mm2" , 23 ) ; & psllq ( " mm3" , 4 ) ; & pxor ( " mm7" , " mm2" ) ; & pxor ( " mm7" , " mm3" ) ; # ▁ T1 = Sigma1_512 ( e ) ENDCOM & movq ( & QWP ( $Foff , $W512 ) , $E ) ; # ▁ f ▁ = ▁ e ENDCOM & movq ( & QWP ( $Goff , $W512 ) , " mm4" ) ; # ▁ g ▁ = ▁ f ENDCOM & movq ( & QWP ( $Hoff , $W512 ) , " mm5" ) ; # ▁ h ▁ = ▁ g ENDCOM & pxor ( " mm4" , " mm5" ) ; # ▁ f ^ = g ENDCOM & pand ( " mm4" , $E ) ; # ▁ f & = e ENDCOM & pxor ( " mm4" , " mm5" ) ; # ▁ f ^ = g ENDCOM & paddq ( " mm7" , " mm4" ) ; # ▁ T1 + = Ch ( e , f , g ) ENDCOM & movq ( " mm2" , & QWP ( $Boff , $W512 ) ) ; # ▁ load ▁ b ENDCOM & movq ( " mm3" , & QWP ( $Coff , $W512 ) ) ; # ▁ load ▁ c ENDCOM & movq ( $E , & QWP ( $Doff , $W512 ) ) ; # ▁ e ▁ = ▁ d ENDCOM & paddq ( " mm7" , " mm6" ) ; # ▁ T1 + = h ENDCOM & paddq ( " mm7" , & QWP ( 0 , $K512 , $kidx , 8 ) ) ; # ▁ T1 + = K512 [ i ] ENDCOM & paddq ( " mm7" , & QWP ( 0 , $W512 , $widx , 8 ) ) ; # ▁ T1 + = W512 [ i ] ENDCOM & paddq ( $E , " mm7" ) ; # ▁ e ▁ + = ▁ T1 ENDCOM & movq ( " mm4" , $A ) ; # ▁ % mm4 ▁ is ▁ sliding ▁ right ENDCOM & movq ( " mm5" , $A ) ; # ▁ % mm5 ▁ is ▁ sliding ▁ left ENDCOM & psrlq ( " mm4" , 28 ) ; & psllq ( " mm5" , 25 ) ; & movq ( " mm6" , " mm4" ) ; # ▁ % mm6 ▁ is ▁ T2 ENDCOM & pxor ( " mm6" , " mm5" ) ; & psrlq ( " mm4" , 6 ) ; & psllq ( " mm5" , 5 ) ; & pxor ( " mm6" , " mm4" ) ; & pxor ( " mm6" , " mm5" ) ; & psrlq ( " mm4" , 5 ) ; & psllq ( " mm5" , 6 ) ; & pxor ( " mm6" , " mm4" ) ; & pxor ( " mm6" , " mm5" ) ; # ▁ T2 = Sigma0_512 ( a ) ENDCOM & movq ( & QWP ( $Boff , $W512 ) , $A ) ; # ▁ b ▁ = ▁ a ENDCOM & movq ( & QWP ( $Coff , $W512 ) , " mm2" ) ; # ▁ c ▁ = ▁ b ENDCOM & movq ( & QWP ( $Doff , $W512 ) , " mm3" ) ; # ▁ d ▁ = ▁ c ENDCOM & movq ( " mm4" , $A ) ; # ▁ % mm4 = a ENDCOM & por ( $A , " mm3" ) ; # ▁ a = a | c ENDCOM & pand ( " mm4" , " mm3" ) ; # ▁ % mm4 = a & c ENDCOM & pand ( $A , " mm2" ) ; # ▁ a = ( a | c ) & b ENDCOM & por ( " mm4" , $A ) ; # ▁ % mm4 = ( a & c ) | ( ( a | c ) & b ) ENDCOM & paddq ( " mm6" , " mm4" ) ; # ▁ T2 + = Maj ( a , b , c ) ENDCOM & movq ( $A , " mm7" ) ; # ▁ a = T1 ENDCOM & paddq ( $A , " mm6" ) ; # ▁ a + = T2 ENDCOM } $func = " sha512 _ block _ sse2" ; & function_begin_B ( $func ) ; if ( 0 ) { # ▁ Caller ▁ is ▁ expected ▁ to ▁ check ▁ if ▁ it ' s ▁ appropriate ▁ to ENDCOM # ▁ call ▁ this ▁ routine . ▁ Below ▁ 3 ▁ lines ▁ are ▁ retained ▁ for ENDCOM # ▁ debugging ▁ purposes . . . ENDCOM & picmeup ( " eax " , " OPENSSL _ ia32cap " ) ; & bt ( & DWP ( 0 , " eax " ) , 26 ) ; & jnc ( " SHA512 _ Transform " ) ; } & push ( " ebp " ) ; & mov ( " ebp " , " esp " ) ; & push ( " ebx " ) ; & push ( " esi " ) ; & push ( " edi " ) ; & mov ( $Widx , & DWP ( 8 , " ebp " ) ) ; # ▁ A - H ▁ state , ▁ 1st ▁ arg ENDCOM & mov ( $data , & DWP ( 12 , " ebp " ) ) ; # ▁ input ▁ data , ▁ 2nd ▁ arg ENDCOM & call ( & label ( " pic _ point " ) ) ; # ▁ make ▁ it ▁ PIC ! ENDCOM & set_label ( " pic _ point " ) ; & blindpop ( $K512 ) ; & lea ( $K512 , & DWP ( & label ( " K512" ) . " - " . & label ( " pic _ point " ) , $K512 ) ) ; $W512 = " esp " ; # ▁ start ▁ using ▁ % esp ▁ as ▁ W512 ENDCOM & sub ( $W512 , $W512_SZ ) ; & and ( $W512 , - 16 ) ; # ▁ ensure ▁ 128 - bit ▁ alignment ENDCOM # ▁ make ▁ private ▁ copy ▁ of ▁ A - H ENDCOM # ▁ v ▁ assume ▁ the ▁ worst ▁ and ▁ stick ▁ to ▁ unaligned ▁ load ENDCOM & movdqu ( " xmm0" , & QWP ( 0 , $Widx ) ) ; & movdqu ( " xmm1" , & QWP ( 16 , $Widx ) ) ; & movdqu ( " xmm2" , & QWP ( 32 , $Widx ) ) ; & movdqu ( " xmm3" , & QWP ( 48 , $Widx ) ) ; & align ( 8 ) ; & set_label ( " _ chunk _ loop " ) ; & movdqa ( & QWP ( $Aoff , $W512 ) , " xmm0" ) ; # ▁ a , b ENDCOM & movdqa ( & QWP ( $Coff , $W512 ) , " xmm1" ) ; # ▁ c , d ENDCOM & movdqa ( & QWP ( $Eoff , $W512 ) , " xmm2" ) ; # ▁ e , f ENDCOM & movdqa ( & QWP ( $Goff , $W512 ) , " xmm3" ) ; # ▁ g , h ENDCOM & xor ( $Widx , $Widx ) ; & movdq2q ( $A , " xmm0" ) ; # ▁ load ▁ a ENDCOM & movdq2q ( $E , " xmm2" ) ; # ▁ load ▁ e ENDCOM # ▁ Why ▁ aren ' t ▁ loops ▁ unrolled ? ▁ It ▁ makes ▁ sense ▁ to ▁ unroll ▁ if ENDCOM # ▁ execution ▁ time ▁ for ▁ loop ▁ body ▁ is ▁ comparable ▁ with ▁ branch ENDCOM # ▁ penalties ▁ and / or ▁ if ▁ whole ▁ data - set ▁ resides ▁ in ▁ register ▁ bank . ENDCOM # ▁ Neither ▁ is ▁ case ▁ here . . . ▁ Well , ▁ it ▁ would ▁ be ▁ possible ▁ to ENDCOM # ▁ eliminate ▁ few ▁ store ▁ operations , ▁ but ▁ it ▁ would ▁ hardly ▁ affect ENDCOM # ▁ so ▁ to ▁ say ▁ stop - watch ▁ performance , ▁ as ▁ there ▁ is ▁ a ▁ lot ▁ of ENDCOM # ▁ available ▁ memory ▁ slots ▁ to ▁ fill . ▁ It ▁ will ▁ only ▁ relieve ▁ some ENDCOM # ▁ pressure ▁ off ▁ memory ▁ bus . . . ENDCOM # ▁ flip ▁ input ▁ stream ▁ byte ▁ order . . . ENDCOM & mov ( " eax " , & DWP ( 0 , $data , $Widx , 8 ) ) ; & mov ( " ebx " , & DWP ( 4 , $data , $Widx , 8 ) ) ; & bswap ( " eax " ) ; & bswap ( " ebx " ) ; & mov ( & DWP ( 0 , $W512 , $Widx , 8 ) , " ebx " ) ; # ▁ W512 [ i ] ENDCOM & mov ( & DWP ( 4 , $W512 , $Widx , 8 ) , " eax " ) ; & mov ( & DWP ( 128 + 0 , $W512 , $Widx , 8 ) , " ebx " ) ; # ▁ copy ▁ of ▁ W512 [ i ] ENDCOM & mov ( & DWP ( 128 + 4 , $W512 , $Widx , 8 ) , " eax " ) ; & align ( 8 ) ; & set_label ( " _ 1st _ loop " ) ; # ▁ 0-15 ENDCOM # ▁ flip ▁ input ▁ stream ▁ byte ▁ order . . . ENDCOM & mov ( " eax " , & DWP ( 0 + 8 , $data , $Widx , 8 ) ) ; & mov ( " ebx " , & DWP ( 4 + 8 , $data , $Widx , 8 ) ) ; & bswap ( " eax " ) ; & bswap ( " ebx " ) ; & mov ( & DWP ( 0 + 8 , $W512 , $Widx , 8 ) , " ebx " ) ; # ▁ W512 [ i ] ENDCOM & mov ( & DWP ( 4 + 8 , $W512 , $Widx , 8 ) , " eax " ) ; & mov ( & DWP ( 128 + 0 + 8 , $W512 , $Widx , 8 ) , " ebx " ) ; # ▁ copy ▁ of ▁ W512 [ i ] ENDCOM & mov ( & DWP ( 128 + 4 + 8 , $W512 , $Widx , 8 ) , " eax " ) ; & set_label ( " _ 1st _ looplet " ) ; & SHA2_ROUND ( $Widx , $Widx ) ; & inc ( $Widx ) ; & cmp ( $Widx , 15 ) & jl ( & label ( " _ 1st _ loop " ) ) ; & je ( & label ( " _ 1st _ looplet " ) ) ; # ▁ playing ▁ similar ▁ trick ▁ on ▁ 2nd ▁ loop ENDCOM # ▁ does ▁ not ▁ improve ▁ performance . . . ENDCOM $Kidx = " ebx " ; # ▁ start ▁ using ▁ % ebx ▁ as ▁ Kidx ENDCOM & mov ( $Kidx , $Widx ) ; & align ( 8 ) ; & set_label ( " _ 2nd _ loop " ) ; # ▁ 16-79 ENDCOM & and ( $Widx , 0xf ) ; # ▁ 128 - bit ▁ fragment ! ▁ I ▁ update ▁ W512 [ i ] ▁ and ▁ W512 [ i + 1 ] ▁ in ENDCOM # ▁ parallel : - ) ▁ Note ▁ that ▁ I ▁ refer ▁ to ▁ W512 [ ( i & 0xf ) + N ] ▁ and ▁ not ▁ to ENDCOM # ▁ W512 [ ( i + N ) &0xf ] ! ▁ This ▁ is ▁ exactly ▁ what ▁ I ▁ maintain ▁ the ▁ second ENDCOM # ▁ copy ▁ of ▁ W512[16 ] ▁ for . . . ENDCOM & movdqu ( " xmm0" , & QWP ( 8 * 1 , $W512 , $Widx , 8 ) ) ; # ▁ s0 = W512 [ i + 1 ] ENDCOM & movdqa ( " xmm2" , " xmm0" ) ; # ▁ % xmm2 ▁ is ▁ sliding ▁ right ENDCOM & movdqa ( " xmm3" , " xmm0" ) ; # ▁ % xmm3 ▁ is ▁ sliding ▁ left ENDCOM & psrlq ( " xmm2" , 1 ) ; & psllq ( " xmm3" , 56 ) ; & movdqa ( " xmm0" , " xmm2" ) ; & pxor ( " xmm0" , " xmm3" ) ; & psrlq ( " xmm2" , 6 ) ; & psllq ( " xmm3" , 7 ) ; & pxor ( " xmm0" , " xmm2" ) ; & pxor ( " xmm0" , " xmm3" ) ; & psrlq ( " xmm2" , 1 ) ; & pxor ( " xmm0" , " xmm2" ) ; # ▁ s0 ▁ = ▁ sigma0_512 ( s0 ) ; ENDCOM & movdqa ( " xmm1" , & QWP ( 8 * 14 , $W512 , $Widx , 8 ) ) ; # ▁ s1 = W512 [ i + 14 ] ENDCOM & movdqa ( " xmm4" , " xmm1" ) ; # ▁ % xmm4 ▁ is ▁ sliding ▁ right ENDCOM & movdqa ( " xmm5" , " xmm1" ) ; # ▁ % xmm5 ▁ is ▁ sliding ▁ left ENDCOM & psrlq ( " xmm4" , 6 ) ; & psllq ( " xmm5" , 3 ) ; & movdqa ( " xmm1" , " xmm4" ) ; & pxor ( " xmm1" , " xmm5" ) ; & psrlq ( " xmm4" , 13 ) ; & psllq ( " xmm5" , 42 ) ; & pxor ( " xmm1" , " xmm4" ) ; & pxor ( " xmm1" , " xmm5" ) ; & psrlq ( " xmm4" , 42 ) ; & pxor ( " xmm1" , " xmm4" ) ; # ▁ s1 ▁ = ▁ sigma1_512 ( s1 ) ; ENDCOM # ▁ + ▁ have ▁ to ▁ explictly ▁ load ▁ W512 [ i + 9 ] ▁ as ▁ it ' s ▁ not ▁ 128 - bit ENDCOM # ▁ v TABSYMBOL aligned ▁ and ▁ paddq ▁ would ▁ throw ▁ an ▁ exception . . . ENDCOM & movdqu ( " xmm6" , & QWP ( 8 * 9 , $W512 , $Widx , 8 ) ) ; & paddq ( " xmm0" , " xmm1" ) ; # ▁ s0 ▁ + = ▁ s1 ENDCOM & paddq ( " xmm0" , " xmm6" ) ; # ▁ s0 ▁ + = ▁ W512 [ i + 9 ] ENDCOM & paddq ( " xmm0" , & QWP ( 0 , $W512 , $Widx , 8 ) ) ; # ▁ s0 ▁ + = ▁ W512 [ i ] ENDCOM & movdqa ( & QWP ( 0 , $W512 , $Widx , 8 ) , " xmm0" ) ; # ▁ W512 [ i ] ▁ = ▁ s0 ENDCOM & movdqa ( & QWP ( 16 * 8 , $W512 , $Widx , 8 ) , " xmm0" ) ; # ▁ copy ▁ of ▁ W512 [ i ] ENDCOM # ▁ as ▁ the ▁ above ▁ fragment ▁ was ▁ 128 - bit , ▁ we ▁ " owe " ▁ 2 ▁ rounds . . . ENDCOM & SHA2_ROUND ( $Kidx , $Widx ) ; & inc ( $Kidx ) ; & inc ( $Widx ) ; & SHA2_ROUND ( $Kidx , $Widx ) ; & inc ( $Kidx ) ; & inc ( $Widx ) ; & cmp ( $Kidx , 80 ) ; & jl ( & label ( " _ 2nd _ loop " ) ) ; # ▁ update ▁ A - H ▁ state ENDCOM & mov ( $Widx , & DWP ( 8 , " ebp " ) ) ; # ▁ A - H ▁ state , ▁ 1st ▁ arg ENDCOM & movq ( & QWP ( $Aoff , $W512 ) , $A ) ; # ▁ write ▁ out ▁ a ENDCOM & movq ( & QWP ( $Eoff , $W512 ) , $E ) ; # ▁ write ▁ out ▁ e ENDCOM & movdqu ( " xmm0" , & QWP ( 0 , $Widx ) ) ; & movdqu ( " xmm1" , & QWP ( 16 , $Widx ) ) ; & movdqu ( " xmm2" , & QWP ( 32 , $Widx ) ) ; & movdqu ( " xmm3" , & QWP ( 48 , $Widx ) ) ; & paddq ( " xmm0" , & QWP ( $Aoff , $W512 ) ) ; # ▁ 128 - bit ▁ additions . . . ENDCOM & paddq ( " xmm1" , & QWP ( $Coff , $W512 ) ) ; & paddq ( " xmm2" , & QWP ( $Eoff , $W512 ) ) ; & paddq ( " xmm3" , & QWP ( $Goff , $W512 ) ) ; & movdqu ( & QWP ( 0 , $Widx ) , " xmm0" ) ; & movdqu ( & QWP ( 16 , $Widx ) , " xmm1" ) ; & movdqu ( & QWP ( 32 , $Widx ) , " xmm2" ) ; & movdqu ( & QWP ( 48 , $Widx ) , " xmm3" ) ; & add ( $data , 16 * 8 ) ; # ▁ advance ▁ input ▁ data ▁ pointer ENDCOM & dec ( & DWP ( 16 , " ebp " ) ) ; # ▁ decrement ▁ 3rd ▁ arg ENDCOM & jnz ( & label ( " _ chunk _ loop " ) ) ; # ▁ epilogue ENDCOM & emms ( ) ; # ▁ required ▁ for ▁ at ▁ least ▁ ELF ▁ and ▁ Win32 ▁ ABIs ENDCOM & mov ( " edi " , & DWP ( - 12 , " ebp " ) ) ; & mov ( " esi " , & DWP ( - 8 , " ebp " ) ) ; & mov ( " ebx " , & DWP ( - 4 , " ebp " ) ) ; & leave ( ) ; & ret ( ) ; & align ( 64 ) ; & set_label ( " K512" ) ; # ▁ Yes ! ▁ I ▁ keep ▁ it ▁ in ▁ the ▁ code ▁ segment ! ENDCOM & data_word ( 0xd728ae22 , 0x428a2f98 ) ; # ▁ u64 ENDCOM & data_word ( 0x23ef65cd , 0x71374491 ) ; # ▁ u64 ENDCOM & data_word ( 0xec4d3b2f , 0xb5c0fbcf ) ; # ▁ u64 ENDCOM & data_word ( 0x8189dbbc , 0xe9b5dba5 ) ; # ▁ u64 ENDCOM & data_word ( 0xf348b538 , 0x3956c25b ) ; # ▁ u64 ENDCOM & data_word ( 0xb605d019 , 0x59f111f1 ) ; # ▁ u64 ENDCOM & data_word ( 0xaf194f9b , 0x923f82a4 ) ; # ▁ u64 ENDCOM & data_word ( 0xda6d8118 , 0xab1c5ed5 ) ; # ▁ u64 ENDCOM & data_word ( 0xa3030242 , 0xd807aa98 ) ; # ▁ u64 ENDCOM & data_word ( 0x45706fbe , 0x12835b01 ) ; # ▁ u64 ENDCOM & data_word ( 0x4ee4b28c , 0x243185be ) ; # ▁ u64 ENDCOM & data_word ( 0xd5ffb4e2 , 0x550c7dc3 ) ; # ▁ u64 ENDCOM & data_word ( 0xf27b896f , 0x72be5d74 ) ; # ▁ u64 ENDCOM & data_word ( 0x3b1696b1 , 0x80deb1fe ) ; # ▁ u64 ENDCOM & data_word ( 0x25c71235 , 0x9bdc06a7 ) ; # ▁ u64 ENDCOM & data_word ( 0xcf692694 , 0xc19bf174 ) ; # ▁ u64 ENDCOM & data_word ( 0x9ef14ad2 , 0xe49b69c1 ) ; # ▁ u64 ENDCOM & data_word ( 0x384f25e3 , 0xefbe4786 ) ; # ▁ u64 ENDCOM & data_word ( 0x8b8cd5b5 , 0x0fc19dc6 ) ; # ▁ u64 ENDCOM & data_word ( 0x77ac9c65 , 0x240ca1cc ) ; # ▁ u64 ENDCOM & data_word ( 0x592b0275 , 0x2de92c6f ) ; # ▁ u64 ENDCOM & data_word ( 0x6ea6e483 , 0x4a7484aa ) ; # ▁ u64 ENDCOM & data_word ( 0xbd41fbd4 , 0x5cb0a9dc ) ; # ▁ u64 ENDCOM & data_word ( 0x831153b5 , 0x76f988da ) ; # ▁ u64 ENDCOM & data_word ( 0xee66dfab , 0x983e5152 ) ; # ▁ u64 ENDCOM & data_word ( 0x2db43210 , 0xa831c66d ) ; # ▁ u64 ENDCOM & data_word ( 0x98fb213f , 0xb00327c8 ) ; # ▁ u64 ENDCOM & data_word ( 0xbeef0ee4 , 0xbf597fc7 ) ; # ▁ u64 ENDCOM & data_word ( 0x3da88fc2 , 0xc6e00bf3 ) ; # ▁ u64 ENDCOM & data_word ( 0x930aa725 , 0xd5a79147 ) ; # ▁ u64 ENDCOM & data_word ( 0xe003826f , 0x06ca6351 ) ; # ▁ u64 ENDCOM & data_word ( 0x0a0e6e70 , 0x14292967 ) ; # ▁ u64 ENDCOM & data_word ( 0x46d22ffc , 0x27b70a85 ) ; # ▁ u64 ENDCOM & data_word ( 0x5c26c926 , 0x2e1b2138 ) ; # ▁ u64 ENDCOM & data_word ( 0x5ac42aed , 0x4d2c6dfc ) ; # ▁ u64 ENDCOM & data_word ( 0x9d95b3df , 0x53380d13 ) ; # ▁ u64 ENDCOM & data_word ( 0x8baf63de , 0x650a7354 ) ; # ▁ u64 ENDCOM & data_word ( 0x3c77b2a8 , 0x766a0abb ) ; # ▁ u64 ENDCOM & data_word ( 0x47edaee6 , 0x81c2c92e ) ; # ▁ u64 ENDCOM & data_word ( 0x1482353b , 0x92722c85 ) ; # ▁ u64 ENDCOM & data_word ( 0x4cf10364 , 0xa2bfe8a1 ) ; # ▁ u64 ENDCOM & data_word ( 0xbc423001 , 0xa81a664b ) ; # ▁ u64 ENDCOM & data_word ( 0xd0f89791 , 0xc24b8b70 ) ; # ▁ u64 ENDCOM & data_word ( 0x0654be30 , 0xc76c51a3 ) ; # ▁ u64 ENDCOM & data_word ( 0xd6ef5218 , 0xd192e819 ) ; # ▁ u64 ENDCOM & data_word ( 0x5565a910 , 0xd6990624 ) ; # ▁ u64 ENDCOM & data_word ( 0x5771202a , 0xf40e3585 ) ; # ▁ u64 ENDCOM & data_word ( 0x32bbd1b8 , 0x106aa070 ) ; # ▁ u64 ENDCOM & data_word ( 0xb8d2d0c8 , 0x19a4c116 ) ; # ▁ u64 ENDCOM & data_word ( 0x5141ab53 , 0x1e376c08 ) ; # ▁ u64 ENDCOM & data_word ( 0xdf8eeb99 , 0x2748774c ) ; # ▁ u64 ENDCOM & data_word ( 0xe19b48a8 , 0x34b0bcb5 ) ; # ▁ u64 ENDCOM & data_word ( 0xc5c95a63 , 0x391c0cb3 ) ; # ▁ u64 ENDCOM & data_word ( 0xe3418acb , 0x4ed8aa4a ) ; # ▁ u64 ENDCOM & data_word ( 0x7763e373 , 0x5b9cca4f ) ; # ▁ u64 ENDCOM & data_word ( 0xd6b2b8a3 , 0x682e6ff3 ) ; # ▁ u64 ENDCOM & data_word ( 0x5defb2fc , 0x748f82ee ) ; # ▁ u64 ENDCOM & data_word ( 0x43172f60 , 0x78a5636f ) ; # ▁ u64 ENDCOM & data_word ( 0xa1f0ab72 , 0x84c87814 ) ; # ▁ u64 ENDCOM & data_word ( 0x1a6439ec , 0x8cc70208 ) ; # ▁ u64 ENDCOM & data_word ( 0x23631e28 , 0x90befffa ) ; # ▁ u64 ENDCOM & data_word ( 0xde82bde9 , 0xa4506ceb ) ; # ▁ u64 ENDCOM & data_word ( 0xb2c67915 , 0xbef9a3f7 ) ; # ▁ u64 ENDCOM & data_word ( 0xe372532b , 0xc67178f2 ) ; # ▁ u64 ENDCOM & data_word ( 0xea26619c , 0xca273ece ) ; # ▁ u64 ENDCOM & data_word ( 0x21c0c207 , 0xd186b8c7 ) ; # ▁ u64 ENDCOM & data_word ( 0xcde0eb1e , 0xeada7dd6 ) ; # ▁ u64 ENDCOM & data_word ( 0xee6ed178 , 0xf57d4f7f ) ; # ▁ u64 ENDCOM & data_word ( 0x72176fba , 0x06f067aa ) ; # ▁ u64 ENDCOM & data_word ( 0xa2c898a6 , 0x0a637dc5 ) ; # ▁ u64 ENDCOM & data_word ( 0xbef90dae , 0x113f9804 ) ; # ▁ u64 ENDCOM & data_word ( 0x131c471b , 0x1b710b35 ) ; # ▁ u64 ENDCOM & data_word ( 0x23047d84 , 0x28db77f5 ) ; # ▁ u64 ENDCOM & data_word ( 0x40c72493 , 0x32caab7b ) ; # ▁ u64 ENDCOM & data_word ( 0x15c9bebc , 0x3c9ebe0a ) ; # ▁ u64 ENDCOM & data_word ( 0x9c100d4c , 0x431d67c4 ) ; # ▁ u64 ENDCOM & data_word ( 0xcb3e42b6 , 0x4cc5d4be ) ; # ▁ u64 ENDCOM & data_word ( 0xfc657e2a , 0x597f299c ) ; # ▁ u64 ENDCOM & data_word ( 0x3ad6faec , 0x5fcb6fab ) ; # ▁ u64 ENDCOM & data_word ( 0x4a475817 , 0x6c44198c ) ; # ▁ u64 ENDCOM & function_end_B ( $func ) ; & asm_finish ( ) ; </DOCUMENT>
<DOCUMENT_ID="Solitarily/LGF180-Optimus-G-_Android_KK_v30b_Kernel/tree/master/tools/perf/scripts/perl/failed-syscalls.pl"> # ▁ failed ▁ system ▁ call ▁ counts ENDCOM # ▁ ( c ) ▁ 2010 , ▁ Tom ▁ Zanussi ▁ < tzanussi @ gmail . com > ENDCOM # ▁ Licensed ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ GPL ▁ License ▁ version ▁ 2 ENDCOM # ▁ Displays ▁ system - wide ▁ failed ▁ system ▁ call ▁ totals ENDCOM # ▁ If ▁ a ▁ [ comm ] ▁ arg ▁ is ▁ specified , ▁ only ▁ syscalls ▁ called ▁ by ▁ [ comm ] ▁ are ▁ displayed . ENDCOM use lib " $ ENV { ' PERF _ EXEC _ PATH ' } / scripts / perl / Perf - Trace - Util / lib " ; use lib " . / Perf - Trace - Util / lib " ; use Perf :: Trace :: Core ; use Perf :: Trace :: Context ; use Perf :: Trace :: Util ; my $for_comm = shift ; my % failed_syscalls ; sub raw_syscalls :: sys_exit { my ( $event_name , $context , $common_cpu , $common_secs , $common_nsecs , $common_pid , $common_comm , $id , $ret ) = @ _ ; if ( $ret < 0 ) { $failed_syscalls { $common_comm } ++ ; } } sub trace_end { printf ( " \n failed ▁ syscalls ▁ by ▁ comm : \n \n " ) ; printf ( " % -20s ▁ ▁ % 10s \n " , " comm " , " # ▁ errors " ) ; printf ( " % -20s ▁ ▁ % 6s ▁ ▁ % 10s \n " , " - - - - - - - - - - - - - - - - - - - - " , " - - - - - - - - - - " ) ; foreach my $comm ( sort { $failed_syscalls { $b } <= > $failed_syscalls { $a } } keys % failed_syscalls ) { next if ( $for_comm && $comm ne $for_comm ) ; printf ( " % -20s ▁ ▁ % 10s \n " , $comm , $failed_syscalls { $comm } ) ; } } </DOCUMENT>
<DOCUMENT_ID="Solitarily/LGF180-Optimus-G-_Android_KK_v30b_Kernel/tree/master/tools/perf/scripts/perl/failed-syscalls.pl"> # ▁ failed ▁ system ▁ call ▁ counts ENDCOM # ▁ ( c ) ▁ 2010 , ▁ Tom ▁ Zanussi ▁ < tzanussi @ gmail . com > ENDCOM # ▁ Licensed ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ GPL ▁ License ▁ version ▁ 2 ENDCOM # ▁ Displays ▁ system - wide ▁ failed ▁ system ▁ call ▁ totals ENDCOM # ▁ If ▁ a ▁ [ comm ] ▁ arg ▁ is ▁ specified , ▁ only ▁ syscalls ▁ called ▁ by ▁ [ comm ] ▁ are ▁ displayed . ENDCOM use lib " $ ENV { ' PERF _ EXEC _ PATH ' } / scripts / perl / Perf - Trace - Util / lib " ; use lib " . / Perf - Trace - Util / lib " ; use Perf :: Trace :: Core ; use Perf :: Trace :: Context ; use Perf :: Trace :: Util ; my $for_comm = shift ; my % failed_syscalls ; sub raw_syscalls :: sys_exit { my ( $event_name , $context , $common_cpu , $common_secs , $common_nsecs , $common_pid , $common_comm , $id , $ret ) = @ _ ; if ( $ret < 0 ) { $failed_syscalls { $common_comm } ++ ; } } sub trace_end { printf ( " \n failed ▁ syscalls ▁ by ▁ comm : \n \n " ) ; printf ( " % -20s ▁ ▁ % 10s \n " , " comm " , " # ▁ errors " ) ; printf ( " % -20s ▁ ▁ % 6s ▁ ▁ % 10s \n " , " - - - - - - - - - - - - - - - - - - - - " , " - - - - - - - - - - " ) ; foreach my $comm ( sort { $failed_syscalls { $b } <= > $failed_syscalls { $a } } keys % failed_syscalls ) { next if ( $for_comm && $comm ne $for_comm ) ; printf ( " % -20s ▁ ▁ % 10s \n " , $comm , $failed_syscalls { $comm } ) ; } } </DOCUMENT>
<DOCUMENT_ID="yongjhih/android_tools/tree/master/ndk/prebuilt/linux-x86_64/lib/perl5/5.16.2/unicore/lib/CI/Y.pl"> # ▁ ! ! ! ! ! ▁ DO ▁ NOT ▁ EDIT ▁ THIS ▁ FILE ▁ ! ! ! ! ! ENDCOM # ▁ This ▁ file ▁ is ▁ machine - generated ▁ by ▁ lib / unicore / mktables ▁ from ▁ the ▁ Unicode ENDCOM # ▁ database , ▁ Version ▁ 6.1.0 . ▁ Any ▁ changes ▁ made ▁ here ▁ will ▁ be ▁ lost ! ENDCOM # ▁ ! ! ! ! ! ▁ INTERNAL ▁ PERL ▁ USE ▁ ONLY ▁ ! ! ! ! ! ENDCOM # ▁ This ▁ file ▁ is ▁ for ▁ internal ▁ use ▁ by ▁ core ▁ Perl ▁ only . ▁ The ▁ format ▁ and ▁ even ▁ the ENDCOM # ▁ name ▁ or ▁ existence ▁ of ▁ this ▁ file ▁ are ▁ subject ▁ to ▁ change ▁ without ▁ notice . ▁ Don ' t ENDCOM # ▁ use ▁ it ▁ directly . ENDCOM return << ' END ' ; 0027 002 E 003 A 005 E 0060 00 A8 00 AD 00 AF 00 B4 00 B7 00 B8 02 B0 036 F 0374 0375 037 A 03 84 03 85 03 87 04 83 04 89 055 9 05 91 05 BD 05 BF 05 C1 05 C2 05 C4 05 C5 05 C7 05 F4 0600 0604 0610 061 A 0640 064 B 065 F 0670 06 D6 06 DD 06 DF 06 E8 06 EA 06 ED 070 F 0711 0730 074 A 07 A6 07 B0 07 EB 07 F5 07 FA 0816 082D 0859 085 B 08E4 08F E 0900 0902 093 A 093 C 0941 0948 094D 0951 0957 0962 0963 0971 0981 09 BC 09 C1 09 C4 09 CD 09E2 09E3 0 A01 0 A02 0 A3C 0 A41 0 A42 0 A47 0 A48 0 A4B 0 A4D 0 A51 0 A70 0 A71 0 A75 0 A81 0 A82 0 ABC 0 AC1 0 AC5 0 AC7 0 AC8 0 ACD 0 AE2 0 AE3 0B01 0B 3 C 0B 3F 0B 41 0B 44 0B 4D 0B 56 0B 62 0B 63 0B 82 0B C0 0B CD 0 C3E 0 C40 0 C46 0 C48 0 C4A 0 C4D 0 C55 0 C56 0 C62 0 C63 0 CBC 0 CBF 0 CC6 0 CCC 0 CCD 0 CE2 0 CE3 0D 41 0D 44 0D 4D 0D 62 0D 63 0D CA 0D D2 0D D4 0D D6 0E31 0E34 0E3 A 0E46 0E4 E 0E B1 0E B4 0E B9 0E BB 0E BC 0E C6 0E C8 0E CD 0F 18 0F 19 0F 35 0F 37 0F 39 0F 71 0F 7E 0F 80 0F 84 0F 86 0F 87 0F 8D 0F 97 0F 99 0F BC 0F C6 102D 1030 1032 1037 1039 103 A 103D 103E 1058 1059 105E 1060 1071 1074 1082 1085 1086 108D 109D 10F C 135D 135F 1712 1714 1732 1734 1752 1753 1772 1773 17 B4 17 B5 17 B7 17 BD 17 C6 17 C9 17D 3 17D 7 17D D 180 B 180D 1843 18 A9 1920 1922 1927 1928 1932 1939 193 B 1 A17 1 A18 1 A56 1 A58 1 A5E 1 A60 1 A62 1 A65 1 A6C 1 A73 1 A7C 1 A7F 1 AA7 1 B00 1 B03 1 B34 1 B36 1 B3A 1 B3C 1 B42 1 B6B 1 B73 1 B80 1 B81 1 BA2 1 BA5 1 BA8 1 BA9 1 BAB 1 BE6 1 BE8 1 BE9 1 BED 1 BEF 1 BF1 1 C2C 1 C33 1 C36 1 C37 1 C78 1 C7D 1 CD0 1 CD2 1 CD4 1 CE0 1 CE2 1 CE8 1 CED 1 CF4 1D 2 C 1D 6 A 1D 78 1D 9 B 1D E6 1D FC 1D FF 1F BD 1F BF 1F C1 1F CD 1F CF 1F DD 1F DF 1F ED 1F EF 1F FD 1F FE 200 B 200F 2018 2019 2024 2027 202 A 202E 2060 2064 206 A 206F 2071 207F 2090 209 C 20D 0 20F 0 2 C7C 2 C7D 2 CEF 2 CF1 2D 6F 2D 7F 2D E0 2D FF 2E2F 3005 302 A 302D 3031 3035 303 B 3099 309E 30F C 30F E A015 A4F8 A4FD A60C A66F A672 A674 A67D A67F A69F A6F0 A6F1 A700 A721 A770 A788 A78A A7F8 A7F9 A802 A806 A80B A825 A826 A8C4 A8E0 A8F1 A926 A92D A947 A951 A980 A982 A9B3 A9B6 A9B9 A9BC A9CF AA29 AA2E AA31 AA32 AA35 AA36 AA43 AA4C AA70 AAB0 AAB2 AAB4 AAB7 AAB8 AABE AABF AAC1 AADD AAEC AAED AAF3 AAF4 AAF6 ABE5 ABE8 ABED FB1E FBB2 FBC1 FE00 FE0F FE13 FE20 FE26 FE52 FE55 FEFF FF07 FF0E FF1A FF3E FF40 FF70 FF9E FF9F FFE3 FFF9 FFFB 101F D 10 A01 10 A03 10 A05 10 A06 10 A0C 10 A0F 10 A38 10 A3A 10 A3F 11001 11038 11046 11080 11081 110 B3 110 B6 110 B9 110 BA 110 BD 11100 11102 11127 1112 B 1112D 11134 11180 11181 111 B6 111 BE 116 AB 116 AD 116 B0 116 B5 116 B7 16F 8F 16F 9F 1D 167 1D 169 1D 173 1D 182 1D 185 1D 18 B 1D 1 AA 1D 1 AD 1D 242 1D 244 E0001 E0020 E007F E0100 E01EF END </DOCUMENT>
<DOCUMENT_ID="rock12/ALPS.L1.MP6.V2.19_CENON6580_WE_1_L_KERNEL/tree/master/scripts/headerdep.pl"> # ! ▁ / usr / bin / perl ENDCOM # ▁ Detect ▁ cycles ▁ in ▁ the ▁ header ▁ file ▁ dependency ▁ graph ENDCOM # ▁ Vegard ▁ Nossum ▁ < vegardno @ ifi . uio . no > ENDCOM use strict ; use warnings ; use Getopt :: Long ; my $opt_all ; my @ opt_include ; my $opt_graph ; & Getopt :: Long :: Configure ( qw ( bundling pass_through ) ) ; & GetOptions ( help = > \ & help , version = > \ & version , all = > \ $opt_all , " I = s " = > \ @ opt_include , graph = > \ $opt_graph , ) ; push @ opt_include , ' include ' ; my % deps = ( ) ; my % linenos = ( ) ; my @ headers = grep { strip ( $_ ) } @ ARGV ; parse_all ( @ headers ) ; if ( $opt_graph ) { graph ( ) ; } else { detect_cycles ( @ headers ) ; } sub help { print " Usage : ▁ $ 0 ▁ [ options ] ▁ file . . . \n " ; print " \n " ; print " Options : \n " ; print " ▁ ▁ - - all \n " ; print " ▁ ▁ - - graph \n " ; print " \n " ; print " ▁ ▁ - I ▁ includedir \n " ; print " \n " ; print " To ▁ make ▁ nice ▁ graphs , ▁ try : \n " ; print " ▁ ▁ $ 0 ▁ - - graph ▁ include / linux / kernel . h ▁ | ▁ dot ▁ - Tpng ▁ - o ▁ graph . png \n " ; exit ; } sub version { print " headerdep ▁ version ▁ 2 \n " ; exit ; } # ▁ Get ▁ a ▁ file ▁ name ▁ that ▁ is ▁ relative ▁ to ▁ our ▁ include ▁ paths ENDCOM sub strip { my $filename = shift ; for my $i ( @ opt_include ) { my $stripped = $filename ; $stripped = ~ s / ^ $i \ / / / ; return $stripped if $stripped ne $filename ; } return $filename ; } # ▁ Search ▁ for ▁ the ▁ file ▁ name ▁ in ▁ the ▁ list ▁ of ▁ include ▁ paths ENDCOM sub search { my $filename = shift ; return $filename if - f $filename ; for my $i ( @ opt_include ) { my $path = " $ i / $ filename " ; return $path if - f $path ; } return ; } sub parse_all { # ▁ Parse ▁ all ▁ the ▁ headers . ENDCOM my @ queue = @ _ ; while ( @ queue ) { my $header = pop @ queue ; next if exists $deps { $header } ; $deps { $header } = [ ] unless exists $deps { $header } ; my $path = search ( $header ) ; next unless $path ; open ( my $file , ' < ' , $path ) or die ( $ ! ) ; chomp ( my @ lines = < $file > ) ; close ( $file ) ; for my $i ( 0 . . $ # lines ) ▁ { ENDCOM my $line = $lines [ $i ] ; if ( my ( $dep ) = ( $line = ~ m / ^ # \s * include\s * < ( . * ? ) > / ) ) ▁ { ENDCOM push @ queue , $dep ; push @ { $deps { $header } } , [ $i + 1 , $dep ] ; } } } } sub print_cycle { # ▁ $ cycle [ n ] ▁ includes ▁ $ cycle [ n ▁ + ▁ 1 ] ; ENDCOM # ▁ $ cycle [ -1 ] ▁ will ▁ be ▁ the ▁ culprit ENDCOM my $cycle = shift ; # ▁ Adjust ▁ the ▁ line ▁ numbers ENDCOM for my $i ( 0 . . $ # $ cycle ▁ - ▁ 1 ) ▁ { ENDCOM $cycle -> [ $i ] -> [ 0 ] = $cycle -> [ $i + 1 ] -> [ 0 ] ; } $cycle -> [ - 1 ] -> [ 0 ] = 0 ; my $first = shift @ $cycle ; my $last = pop @ $cycle ; my $msg = " In ▁ file ▁ included " ; printf " % s ▁ from ▁ % s , \n " , $msg , $last -> [ 1 ] if defined $last ; for my $header ( reverse @ $cycle ) { printf " % s ▁ from ▁ % s : % d % s \n " , " ▁ " x length $msg , $header -> [ 1 ] , $header -> [ 0 ] , $header -> [ 1 ] eq $last -> [ 1 ] ? ' ▁ < - - ▁ here ' : ' ' ; } printf " % s : % d : ▁ warning : ▁ recursive ▁ header ▁ inclusion \n " , $first -> [ 1 ] , $first -> [ 0 ] ; } # ▁ Find ▁ and ▁ print ▁ the ▁ smallest ▁ cycle ▁ starting ▁ in ▁ the ▁ specified ▁ node . ENDCOM sub detect_cycles { my @ queue = map { [ [ 0 , $_ ] ] } @ _ ; while ( @ queue ) { my $top = pop @ queue ; my $name = $top -> [ - 1 ] -> [ 1 ] ; for my $dep ( @ { $deps { $name } } ) { my $chain = [ @ $top , [ $dep -> [ 0 ] , $dep -> [ 1 ] ] ] ; # ▁ If ▁ the ▁ dep ▁ already ▁ exists ▁ in ▁ the ▁ chain , ▁ we ▁ have ▁ a ENDCOM # ▁ cycle . . . ENDCOM if ( grep { $_ -> [ 1 ] eq $dep -> [ 1 ] } @ $top ) { print_cycle ( $chain ) ; next if $opt_all ; return ; } push @ queue , $chain ; } } } sub mangle { $_ = shift ; s / \ / / __ / g ; s / \ . / _ / g ; s / - / _ / g ; $_ ; } # ▁ Output ▁ dependency ▁ graph ▁ in ▁ GraphViz ▁ language . ENDCOM sub graph { print " digraph ▁ { \n " ; print " \t / * ▁ vertices ▁ * / \n " ; for my $header ( keys % deps ) { printf " \t % s ▁ [ label = \ " % s\ " ] ; \n " , mangle ( $header ) , $header ; } print " \n " ; print " \t / * ▁ edges ▁ * / \n " ; for my $header ( keys % deps ) { for my $dep ( @ { $deps { $header } } ) { printf " \t % s ▁ - > ▁ % s ; \n " , mangle ( $header ) , mangle ( $dep -> [ 1 ] ) ; } } print " } \n " ; } </DOCUMENT>
<DOCUMENT_ID="yank555-lu/private_msm8660_ics/tree/master/scripts/bootgraph.pl"> # ! / usr / bin / perl ENDCOM # ▁ Copyright ▁ 2008 , ▁ Intel ▁ Corporation ENDCOM # ▁ This ▁ file ▁ is ▁ part ▁ of ▁ the ▁ Linux ▁ kernel ENDCOM # ▁ This ▁ program ▁ file ▁ is ▁ free ▁ software ; ▁ you ▁ can ▁ redistribute ▁ it ▁ and / or ▁ modify ▁ it ENDCOM # ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ as ▁ published ▁ by ▁ the ENDCOM # ▁ Free ▁ Software ▁ Foundation ; ▁ version ▁ 2 ▁ of ▁ the ▁ License . ENDCOM # ▁ This ▁ program ▁ is ▁ distributed ▁ in ▁ the ▁ hope ▁ that ▁ it ▁ will ▁ be ▁ useful , ▁ but ▁ WITHOUT ENDCOM # ▁ ANY ▁ WARRANTY ; ▁ without ▁ even ▁ the ▁ implied ▁ warranty ▁ of ▁ MERCHANTABILITY ▁ or ENDCOM # ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE . ▁ See ▁ the ▁ GNU ▁ General ▁ Public ▁ License ENDCOM # ▁ for ▁ more ▁ details . ENDCOM # ▁ You ▁ should ▁ have ▁ received ▁ a ▁ copy ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ENDCOM # ▁ along ▁ with ▁ this ▁ program ▁ in ▁ a ▁ file ▁ named ▁ COPYING ; ▁ if ▁ not , ▁ write ▁ to ▁ the ENDCOM # ▁ Free ▁ Software ▁ Foundation , ▁ Inc . , ENDCOM # ▁ 51 ▁ Franklin ▁ Street , ▁ Fifth ▁ Floor , ENDCOM # ▁ Boston , ▁ MA ▁ 02110-1301 ▁ USA ENDCOM # ▁ Authors : ENDCOM # ▁ TABSYMBOL Arjan ▁ van ▁ de ▁ Ven ▁ < arjan @ linux . intel . com > ENDCOM # ▁ This ▁ script ▁ turns ▁ a ▁ dmesg ▁ output ▁ into ▁ a ▁ SVG ▁ graphic ▁ that ▁ shows ▁ which ENDCOM # ▁ functions ▁ take ▁ how ▁ much ▁ time . ▁ You ▁ can ▁ view ▁ SVG ▁ graphics ▁ with ▁ various ENDCOM # ▁ programs , ▁ including ▁ Inkscape , ▁ The ▁ Gimp ▁ and ▁ Firefox . ENDCOM # ▁ For ▁ this ▁ script ▁ to ▁ work , ▁ the ▁ kernel ▁ needs ▁ to ▁ be ▁ compiled ▁ with ▁ the ENDCOM # ▁ CONFIG _ PRINTK _ TIME ▁ configuration ▁ option ▁ enabled , ▁ and ▁ with ENDCOM # ▁ " initcall _ debug " ▁ passed ▁ on ▁ the ▁ kernel ▁ command ▁ line . ENDCOM # ▁ usage : ENDCOM # ▁ TABSYMBOL dmesg ▁ | ▁ perl ▁ scripts / bootgraph . pl ▁ > ▁ output . svg ENDCOM use strict ; my % start ; my % end ; my % type ; my $done = 0 ; my $maxtime = 0 ; my $firsttime = 100 ; my $count = 0 ; my % pids ; my % pidctr ; while ( < > ) { my $line = $_ ; if ( $line = ~ / ( [ 0 - 9 \ . ] + ) \ ] calling ( [ a - zA - Z0 - 9 \ _ \ . ] + ) \ + / ) { my $func = $2 ; if ( $done == 0 ) { $start { $func } = $1 ; $type { $func } = 0 ; if ( $1 < $firsttime ) { $firsttime = $1 ; } } if ( $line = ~ / \ @ ( [ 0 - 9 ] + ) / ) { $pids { $func } = $1 ; } $count = $count + 1 ; } if ( $line = ~ / ( [ 0 - 9 \ . ] + ) \ ] async_waiting @ ( [ 0 - 9 ] + ) / ) { my $pid = $2 ; my $func ; if ( ! defined ( $pidctr { $pid } ) ) { $func = " wait _ " . $pid . " _ 1" ; $pidctr { $pid } = 1 ; } else { $pidctr { $pid } = $pidctr { $pid } + 1 ; $func = " wait _ " . $pid . " _ " . $pidctr { $pid } ; } if ( $done == 0 ) { $start { $func } = $1 ; $type { $func } = 1 ; if ( $1 < $firsttime ) { $firsttime = $1 ; } } $pids { $func } = $pid ; $count = $count + 1 ; } if ( $line = ~ / ( [ 0 - 9 \ . ] + ) \ ] initcall ( [ a - zA - Z0 - 9 \ _ \ . ] + ) \ + . * returned / ) { if ( $done == 0 ) { $end { $2 } = $1 ; $maxtime = $1 ; } } if ( $line = ~ / ( [ 0 - 9 \ . ] + ) \ ] async_continuing @ ( [ 0 - 9 ] + ) / ) { my $pid = $2 ; my $func = " wait _ " . $pid . " _ " . $pidctr { $pid } ; $end { $func } = $1 ; $maxtime = $1 ; } if ( $line = ~ / Write protecting the / ) { $done = 1 ; } if ( $line = ~ / Freeing unused kernel memory / ) { $done = 1 ; } } if ( $count == 0 ) { print STDERR << END ; No data found in the dmesg . Make sure that ' printk . time = 1' and ' initcall _ debug ' are passed on the kernel command line . Usage : dmesg | perl scripts / bootgraph . pl > output . svg END exit 1 ; } print " < ? xml ▁ version = \ " 1.0\ " ▁ standalone = \ " no\ " ? > ▁ \n " ; print " < svg ▁ width = \ " 2000\ " ▁ height = \ " 100 % \ " ▁ version = \ " 1.1\ " ▁ xmlns = \ " http : / / www . w3 . org / 2000 / svg\ " > \n " ; my @ styles ; $styles [ 0 ] = " fill : rgb ( 0,0,255 ) ; fill - opacity : 0.5 ; stroke - width : 1 ; stroke : rgb ( 0,0,0 ) " ; $styles [ 1 ] = " fill : rgb ( 0,255,0 ) ; fill - opacity : 0.5 ; stroke - width : 1 ; stroke : rgb ( 0,0,0 ) " ; $styles [ 2 ] = " fill : rgb ( 255,0,20 ) ; fill - opacity : 0.5 ; stroke - width : 1 ; stroke : rgb ( 0,0,0 ) " ; $styles [ 3 ] = " fill : rgb ( 255,255,20 ) ; fill - opacity : 0.5 ; stroke - width : 1 ; stroke : rgb ( 0,0,0 ) " ; $styles [ 4 ] = " fill : rgb ( 255,0,255 ) ; fill - opacity : 0.5 ; stroke - width : 1 ; stroke : rgb ( 0,0,0 ) " ; $styles [ 5 ] = " fill : rgb ( 0,255,255 ) ; fill - opacity : 0.5 ; stroke - width : 1 ; stroke : rgb ( 0,0,0 ) " ; $styles [ 6 ] = " fill : rgb ( 0,128,255 ) ; fill - opacity : 0.5 ; stroke - width : 1 ; stroke : rgb ( 0,0,0 ) " ; $styles [ 7 ] = " fill : rgb ( 0,255,128 ) ; fill - opacity : 0.5 ; stroke - width : 1 ; stroke : rgb ( 0,0,0 ) " ; $styles [ 8 ] = " fill : rgb ( 255,0,128 ) ; fill - opacity : 0.5 ; stroke - width : 1 ; stroke : rgb ( 0,0,0 ) " ; $styles [ 9 ] = " fill : rgb ( 255,255,128 ) ; fill - opacity : 0.5 ; stroke - width : 1 ; stroke : rgb ( 0,0,0 ) " ; $styles [ 10 ] = " fill : rgb ( 255,128,255 ) ; fill - opacity : 0.5 ; stroke - width : 1 ; stroke : rgb ( 0,0,0 ) " ; $styles [ 11 ] = " fill : rgb ( 128,255,255 ) ; fill - opacity : 0.5 ; stroke - width : 1 ; stroke : rgb ( 0,0,0 ) " ; my $style_wait = " fill : rgb ( 128,128,128 ) ; fill - opacity : 0.5 ; stroke - width : 0 ; stroke : rgb ( 0,0,0 ) " ; my $mult = 1950.0 / ( $maxtime - $firsttime ) ; my $threshold2 = ( $maxtime - $firsttime ) / 120.0 ; my $threshold = $threshold2 / 10 ; my $stylecounter = 0 ; my % rows ; my $rowscount = 1 ; my @ initcalls = sort { $start { $a } <= > $start { $b } } keys ( % start ) ; foreach my $key ( @ initcalls ) { my $duration = $end { $key } - $start { $key } ; if ( $duration >= $threshold ) { my ( $s , $s2 , $s3 , $e , $w , $y , $y2 , $style ) ; my $pid = $pids { $key } ; if ( ! defined ( $rows { $pid } ) ) { $rows { $pid } = $rowscount ; $rowscount = $rowscount + 1 ; } $s = ( $start { $key } - $firsttime ) * $mult ; $s2 = $s + 6 ; $s3 = $s + 1 ; $e = ( $end { $key } - $firsttime ) * $mult ; $w = $e - $s ; $y = $rows { $pid } * 150 ; $y2 = $y + 4 ; $style = $styles [ $stylecounter ] ; $stylecounter = $stylecounter + 1 ; if ( $stylecounter > 11 ) { $stylecounter = 0 ; } ; if ( $type { $key } == 1 ) { $y = $y + 15 ; print " < rect ▁ x = \ " $ s\ " ▁ width = \ " $ w\ " ▁ y = \ " $ y\ " ▁ height = \ " 115\ " ▁ style = \ " $ style _ wait\ " / > \n " ; } else { print " < rect ▁ x = \ " $ s\ " ▁ width = \ " $ w\ " ▁ y = \ " $ y\ " ▁ height = \ " 145\ " ▁ style = \ " $ style\ " / > \n " ; if ( $duration >= $threshold2 ) { print " < text ▁ transform = \ " translate ( $ s2 , $ y2 ) ▁ rotate ( 90 ) \ " > $ key < / text > \n " ; } else { print " < text ▁ transform = \ " translate ( $ s3 , $ y2 ) ▁ rotate ( 90 ) \ " ▁ font - size = \ " 3pt\ " > $ key < / text > \n " ; } } } } # ▁ print ▁ the ▁ time ▁ line ▁ on ▁ top ENDCOM my $time = $firsttime ; my $step = ( $maxtime - $firsttime ) / 15 ; while ( $time < $maxtime ) { my $s3 = ( $time - $firsttime ) * $mult ; my $tm = int ( $time * 100 ) / 100.0 ; print " < text ▁ transform = \ " translate ( $ s3,89 ) ▁ rotate ( 90 ) \ " > $ tm < / text > \n " ; $time = $time + $step ; } print " < / svg > \n " ; </DOCUMENT>
<DOCUMENT_ID="RAZAW/social-media-linkedin/tree/master/usr/share/perl5/core_perl/unicore/lib/SB/XX.pl"> # ▁ ! ! ! ! ! ▁ DO ▁ NOT ▁ EDIT ▁ THIS ▁ FILE ▁ ! ! ! ! ! ENDCOM # ▁ This ▁ file ▁ is ▁ machine - generated ▁ by ▁ lib / unicore / mktables ▁ from ▁ the ▁ Unicode ENDCOM # ▁ database , ▁ Version ▁ 7.0.0 . ▁ Any ▁ changes ▁ made ▁ here ▁ will ▁ be ▁ lost ! ENDCOM # ▁ ! ! ! ! ! ▁ INTERNAL ▁ PERL ▁ USE ▁ ONLY ▁ ! ! ! ! ! ENDCOM # ▁ This ▁ file ▁ is ▁ for ▁ internal ▁ use ▁ by ▁ core ▁ Perl ▁ only . ▁ The ▁ format ▁ and ▁ even ▁ the ENDCOM # ▁ name ▁ or ▁ existence ▁ of ▁ this ▁ file ▁ are ▁ subject ▁ to ▁ change ▁ without ▁ notice . ▁ Don ' t ENDCOM # ▁ use ▁ it ▁ directly . ▁ Use ▁ Unicode : : UCD ▁ to ▁ access ▁ the ▁ Unicode ▁ character ▁ data ENDCOM # ▁ base . ENDCOM return << ' END ' ; V1395 0 9 14 32 35 39 42 44 47 48 59 63 64 65 92 93 94 97 124 125 126 133 134 160 161 170 172 173 174 181 182 186 188 192 215 216 247 248 706 710 722 736 741 748 749 750 751 768 885 886 888 890 894 895 896 902 903 904 907 908 909 910 930 931 1014 1015 1154 1155 1328 1329 1367 1369 1370 1373 1374 1377 1416 1417 1418 1425 1470 1471 1472 1473 1475 1476 1478 1479 1480 1488 1515 1520 1524 1536 1542 1548 1550 1552 1563 1564 1565 1567 1642 1643 1645 1646 1758 1759 1769 1770 1789 1791 1795 1807 1867 1869 1970 1984 2038 2040 2043 2048 2094 2112 2140 2208 2227 2276 2416 2417 2436 2437 2445 2447 2449 2451 2473 2474 2481 2482 2483 2486 2490 2492 2501 2503 2505 2507 2511 2519 2520 2524 2526 2527 2532 2534 2546 2561 2564 2565 2571 2575 2577 2579 2601 2602 2609 2610 2612 2613 2615 2616 2618 2620 2621 2622 2627 2631 2633 2635 2638 2641 2642 2649 2653 2654 2655 2662 2678 2689 2692 2693 2702 2703 2706 2707 2729 2730 2737 2738 2740 2741 2746 2748 2758 2759 2762 2763 2766 2768 2769 2784 2788 2790 2800 2817 2820 2821 2829 2831 2833 2835 2857 2858 2865 2866 2868 2869 2874 2876 2885 2887 2889 2891 2894 2902 2904 2908 2910 2911 2916 2918 2928 2929 2930 2946 2948 2949 2955 2958 2961 2962 2966 2969 2971 2972 2973 2974 2976 2979 2981 2984 2987 2990 3002 3006 3011 3014 3017 3018 3022 3024 3025 3031 3032 3046 3056 3072 3076 3077 3085 3086 3089 3090 3113 3114 3130 3133 3141 3142 3145 3146 3150 3157 3159 3160 3162 3168 3172 3174 3184 3201 3204 3205 3213 3214 3217 3218 3241 3242 3252 3253 3258 3260 3269 3270 3273 3274 3278 3285 3287 3294 3295 3296 3300 3302 3312 3313 3315 3329 3332 3333 3341 3342 3345 3346 3387 3389 3397 3398 3401 3402 3407 3415 3416 3424 3428 3430 3440 3450 3456 3458 3460 3461 3479 3482 3506 3507 3516 3517 3518 3520 3527 3530 3531 3535 3541 3542 3543 3544 3552 3558 3568 3570 3572 3585 3643 3648 3663 3664 3674 3713 3715 3716 3717 3719 3721 3722 3723 3725 3726 3732 3736 3737 3744 3745 3748 3749 3750 3751 3752 3754 3756 3757 3770 3771 3774 3776 3781 3782 3783 3784 3790 3792 3802 3804 3808 3840 3841 3864 3866 3872 3882 3893 3894 3895 3896 3897 3912 3913 3949 3953 3973 3974 3992 3993 4029 4038 4039 4096 4172 4176 4254 4256 4294 4295 4296 4301 4302 4304 4347 4348 4681 4682 4686 4688 4695 4696 4697 4698 4702 4704 4745 4746 4750 4752 4785 4786 4790 4792 4799 4800 4801 4802 4806 4808 4823 4824 4881 4882 4886 4888 4955 4957 4960 4962 4963 4967 4969 4992 5008 5024 5109 5121 5741 5742 5789 5792 5867 5870 5881 5888 5901 5902 5909 5920 5943 5952 5972 5984 5997 5998 6001 6002 6004 6016 6100 6103 6104 6108 6110 6112 6122 6146 6148 6152 6154 6155 6159 6160 6170 6176 6264 6272 6315 6320 6390 6400 6431 6432 6444 6448 6460 6468 6510 6512 6517 6528 6572 6576 6602 6608 6618 6656 6684 6688 6751 6752 6781 6783 6794 6800 6810 6823 6828 6832 6847 6912 6988 6992 7004 7006 7008 7019 7028 7040 7156 7168 7224 7227 7229 7232 7242 7245 7296 7376 7379 7380 7415 7416 7418 7424 7670 7676 7958 7960 7966 7968 8006 8008 8014 8016 8024 8025 8026 8027 8028 8029 8030 8031 8062 8064 8117 8118 8125 8126 8127 8130 8133 8134 8141 8144 8148 8150 8156 8160 8173 8178 8181 8182 8189 8192 8208 8211 8213 8216 8224 8228 8229 8232 8240 8249 8251 8252 8254 8261 8266 8287 8293 8294 8304 8305 8306 8317 8320 8333 8335 8336 8349 8400 8433 8450 8451 8455 8456 8458 8468 8469 8470 8473 8478 8484 8485 8486 8487 8488 8489 8490 8494 8495 8506 8508 8512 8517 8522 8526 8527 8544 8585 8968 8972 9001 9003 9398 9450 10075 10081 10088 10102 10181 10183 10214 10224 10627 10649 10712 10716 10748 10750 11264 11311 11312 11359 11360 11493 11499 11508 11520 11558 11559 11560 11565 11566 11568 11624 11631 11632 11647 11671 11680 11687 11688 11695 11696 11703 11704 11711 11712 11719 11720 11727 11728 11735 11736 11743 11744 11790 11804 11806 11808 11818 11822 11824 11836 11837 11842 11843 12288 12291 12293 12306 12308 12316 12317 12320 12321 12336 12337 12342 12344 12349 12353 12439 12441 12443 12445 12448 12449 12539 12540 12544 12549 12590 12593 12687 12704 12731 12784 12800 13312 19894 19968 40909 40960 42125 42192 42238 42239 42509 42510 42540 42560 42611 42612 42622 42623 42654 42655 42738 42739 42740 42743 42744 42775 42784 42786 42889 42891 42895 42896 42926 42928 42930 42999 43048 43072 43124 43126 43128 43136 43205 43214 43226 43232 43256 43259 43260 43264 43310 43311 43348 43360 43389 43392 43457 43464 43466 43471 43482 43488 43519 43520 43575 43584 43598 43600 43610 43613 43639 43642 43715 43739 43742 43744 43767 43777 43783 43785 43791 43793 43799 43808 43815 43816 43823 43824 43867 43868 43872 43876 43878 43968 44014 44016 44026 44032 55204 55216 55239 55243 55292 63744 64110 64112 64218 64256 64263 64275 64280 64285 64297 64298 64311 64312 64317 64318 64319 64320 64322 64323 64325 64326 64434 64467 64832 64848 64912 64914 64968 65008 65020 65024 65042 65043 65044 65047 65049 65056 65070 65073 65075 65077 65093 65095 65097 65104 65107 65109 65119 65123 65124 65136 65141 65142 65277 65279 65280 65281 65282 65288 65290 65292 65295 65306 65307 65311 65312 65313 65340 65341 65342 65345 65372 65373 65374 65375 65381 65382 65471 65474 65480 65482 65488 65490 65496 65498 65501 65529 65532 65536 65548 65549 65575 65576 65595 65596 65598 65599 65614 65616 65630 65664 65787 65856 65909 66045 66046 66176 66205 66208 66257 66272 66273 66304 66336 66352 66379 66384 66427 66432 66462 66464 66500 66504 66512 66513 66518 66560 66718 66720 66730 66816 66856 66864 66916 67072 67383 67392 67414 67424 67432 67584 67590 67592 67593 67594 67638 67639 67641 67644 67645 67647 67670 67680 67703 67712 67743 67840 67862 67872 67898 67968 68024 68030 68032 68096 68100 68101 68103 68108 68116 68117 68120 68121 68148 68152 68155 68159 68160 68182 68184 68192 68221 68224 68253 68288 68296 68297 68327 68352 68406 68416 68438 68448 68467 68480 68498 68608 68681 69632 69705 69734 69744 69759 69819 69821 69826 69840 69865 69872 69882 69888 69941 69942 69952 69953 69956 69968 70004 70006 70007 70016 70087 70093 70094 70096 70107 70144 70162 70163 70202 70203 70205 70320 70379 70384 70394 70401 70404 70405 70413 70415 70417 70419 70441 70442 70449 70450 70452 70453 70458 70460 70469 70471 70473 70475 70478 70487 70488 70493 70500 70502 70509 70512 70517 70784 70854 70855 70856 70864 70874 71040 71094 71096 71105 71106 71108 71113 71114 71168 71235 71236 71237 71248 71258 71296 71352 71360 71370 71840 71914 71935 71936 72384 72441 73728 74649 74752 74863 77824 78895 92160 92729 92736 92767 92768 92778 92782 92784 92880 92910 92912 92918 92928 92985 92992 92997 93008 93018 93027 93048 93053 93072 93952 94021 94032 94079 94095 94112 110592 110594 113664 113771 113776 113789 113792 113801 113808 113818 113821 113828 119141 119146 119149 119171 119173 119180 119210 119214 119362 119365 119808 119893 119894 119965 119966 119968 119970 119971 119973 119975 119977 119981 119982 119994 119995 119996 119997 120004 120005 120070 120071 120075 120077 120085 120086 120093 120094 120122 120123 120127 120128 120133 120134 120135 120138 120145 120146 120486 120488 120513 120514 120539 120540 120571 120572 120597 120598 120629 120630 120655 120656 120687 120688 120713 120714 120745 120746 120771 120772 120780 120782 120832 124928 125125 125136 125143 126464 126468 126469 126496 126497 126499 126500 126501 126503 126504 126505 126515 126516 126520 126521 126522 126523 126524 126530 126531 126535 126536 126537 126538 126539 126540 126541 126544 126545 126547 126548 126549 126551 126552 126553 126554 126555 126556 126557 126558 126559 126560 126561 126563 126564 126565 126567 126571 126572 126579 126580 126584 126585 126589 126590 126591 126592 126602 126603 126620 126625 126628 126629 126634 126635 126652 127280 127306 127312 127338 127344 127370 128630 128633 131072 173783 173824 177973 177984 178206 194560 195102 917505 917506 917536 917632 917760 918000 END </DOCUMENT>
<DOCUMENT_ID="vlascoder/otrs/tree/master/scripts/tools/sync-ldap2db.pl"> # ! / usr / bin / perl ENDCOM # ▁ scripts / tools / sync - ldap2db . pl ▁ - ▁ sync ▁ a ▁ ldap ▁ directory ▁ to ▁ database ENDCOM # ▁ Copyright ▁ ( C ) ▁ 2001-2014 ▁ OTRS ▁ AG , ▁ http : / / otrs . com / ENDCOM # ▁ This ▁ program ▁ is ▁ free ▁ software ; ▁ you ▁ can ▁ redistribute ▁ it ▁ and / or ▁ modify ENDCOM # ▁ it ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ AFFERO ▁ General ▁ Public ▁ License ▁ as ▁ published ▁ by ENDCOM # ▁ the ▁ Free ▁ Software ▁ Foundation ; ▁ either ▁ version ▁ 3 ▁ of ▁ the ▁ License , ▁ or ENDCOM # ▁ any ▁ later ▁ version . ENDCOM # ▁ This ▁ program ▁ is ▁ distributed ▁ in ▁ the ▁ hope ▁ that ▁ it ▁ will ▁ be ▁ useful , ENDCOM # ▁ but ▁ WITHOUT ▁ ANY ▁ WARRANTY ; ▁ without ▁ even ▁ the ▁ implied ▁ warranty ▁ of ENDCOM # ▁ MERCHANTABILITY ▁ or ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE . ▁ See ▁ the ENDCOM # ▁ GNU ▁ General ▁ Public ▁ License ▁ for ▁ more ▁ details . ENDCOM # ▁ You ▁ should ▁ have ▁ received ▁ a ▁ copy ▁ of ▁ the ▁ GNU ▁ Affero ▁ General ▁ Public ▁ License ENDCOM # ▁ along ▁ with ▁ this ▁ program ; ▁ if ▁ not , ▁ write ▁ to ▁ the ▁ Free ▁ Software ENDCOM # ▁ Foundation , ▁ Inc . , ▁ 51 ▁ Franklin ▁ St , ▁ Fifth ▁ Floor , ▁ Boston , ▁ MA ▁ 02110-1301 ▁ USA ENDCOM # ▁ or ▁ see ▁ http : / / www . gnu . org / licenses / agpl . txt . ENDCOM use strict ; use warnings ; # ▁ use ▁ . . / ▁ as ▁ lib ▁ location ENDCOM use File :: Basename ; use FindBin qw ( $RealBin ) ; use lib dirname ( $RealBin ) . " / . . / " ; use lib dirname ( $RealBin ) . " / . . / Kernel / cpan - lib " ; use Net :: LDAP ; use Kernel :: Config ; use Kernel :: System :: Log ; use Kernel :: System :: Main ; use Kernel :: System :: DB ; use Kernel :: System :: Encode ; # ▁ create ▁ common ▁ objects ENDCOM my % CommonObject = ( ) ; $CommonObject { ConfigObject } = Kernel :: Config -> new ( ) ; $CommonObject { LogObject } = Kernel :: System :: Log -> new ( LogPrefix = > ' OTRS - sync - ldap2db ' , % CommonObject , ) ; $CommonObject { MainObject } = Kernel :: System :: Main -> new ( % CommonObject ) ; $CommonObject { EncodeObject } = Kernel :: System :: Encode -> new ( % CommonObject ) ; $CommonObject { DBObject } = Kernel :: System :: DB -> new ( % CommonObject ) ; my $UidLDAP = ' uid ' ; my $UidDB = ' login ' ; my % Map = ( # ▁ db ▁ = > ▁ ldap ENDCOM email = > ' mail ' , customer_id = > ' mail ' , first_name = > ' sn ' , last_name = > ' givenname ' , pw = > ' test ' , # ▁ comments ▁ = > ▁ ' description ' , ENDCOM comments = > ' postaladdress ' , ) ; my $LDAPHost = ' bay . csuhayward . edu ' ; my % LDAPParams = ( ) ; my $LDAPBaseDN = ' ou = seas , o = csuh ' ; my $LDAPBindDN = ' ' ; my $LDAPBindPW = ' ' ; my $LDAPScope = ' sub ' ; my $LDAPCharset = ' utf - 8' ; # my ▁ $ LDAPFilter ▁ = ▁ ' ' ; ENDCOM my $LDAPFilter = ' ( ObjectClass = * ) ' ; my $DBCharset = ' iso - 8859-1' ; my $DBTable = ' customer _ user ' ; # ▁ ldap ▁ connect ▁ and ▁ bind ▁ ( maybe ▁ with ▁ SearchUserDN ▁ and ▁ SearchUserPw ) ENDCOM my $LDAP = Net :: LDAP -> new ( $LDAPHost , % LDAPParams ) || die " $ @ " ; if ( ! $LDAP -> bind ( dn = > $LDAPBindDN , password = > $LDAPBindPW ) ) { $CommonObject { LogObject } -> Log ( Priority = > ' error ' , Message = > " Bind ▁ failed ! " , ) ; exit 1 ; } # ▁ split ▁ request ▁ of ▁ all ▁ accounts ENDCOM for ( qw ( 0 1 2 3 4 5 6 7 8 9 a b c d e f g h i j k l m n o p q r s t u v w x y z ) ) { my $Filter = " ( $ UidLDAP = $ _ * ) " ; if ( $LDAPFilter ) { $Filter = " ( & $ LDAPFilter $ Filter ) " ; } # ▁ perform ▁ user ▁ search ENDCOM my $Result = $LDAP -> search ( base = > $LDAPBaseDN , scope = > $LDAPScope , filter = > $Filter , ) ; # print ▁ " F : ▁ ( $ UidLDAP = $ _ * ) \n " ; ENDCOM for my $Entry ( $Result -> all_entries ( ) ) { my $UID = $Entry -> get_value ( $UidLDAP ) ; if ( $UID ) { # ▁ check ▁ if ▁ uid ▁ existsis ▁ in ▁ db ENDCOM my $Insert = 1 ; $CommonObject { DBObject } -> Prepare ( SQL = > " SELECT ▁ $ UidDB ▁ FROM ▁ $ DBTable ▁ WHERE ▁ $ UidDB ▁ = ▁ ' " . $CommonObject { DBObject } -> Quote ( $UID ) . " ' " , Limit = > 1 , ) ; while ( my @ Row = $CommonObject { DBObject } -> FetchrowArray ( ) ) { $Insert = 0 ; } my $SQLPre = ' ' ; my $SQLPost = ' ' ; my $Type = ' ' ; if ( $Insert ) { $Type = ' INSERT ' ; } else { $Type = ' UPDATE ' ; } for ( sort keys % Map ) { my $Value = $CommonObject { DBObject } -> Quote ( _ConvertTo ( $Entry -> get_value ( $Map { $_ } ) ) || ' ' ) ; if ( $Type eq ' UPDATE ' ) { if ( $SQLPre ) { $SQLPre . = " , ▁ " ; } $SQLPre . = " ▁ $ _ ▁ = ▁ ' $ Value ' " ; } else { if ( $SQLPre ) { $SQLPre . = " , ▁ " ; } $SQLPre . = " $ _ " ; if ( $SQLPost ) { $SQLPost . = " , ▁ " ; } $SQLPost . = " ' $ Value ' " ; } } my $SQL = ' ' ; if ( $Type eq ' UPDATE ' ) { print " UPDATE : ▁ $ UID \n " ; $SQL = " UPDATE ▁ $ DBTable ▁ SET ▁ $ SQLPre , ▁ valid _ id ▁ = ▁ 1 , ▁ change _ time ▁ = ▁ current _ timestamp , ▁ change _ by ▁ = ▁ 1 ▁ " ; $SQL . = " ▁ WHERE ▁ $ UidDB ▁ = ▁ ' " . $CommonObject { DBObject } -> Quote ( $UID ) . " ' " ; } else { print " INSERT : ▁ $ UID \n " ; $SQL = " INSERT ▁ INTO ▁ $ DBTable ▁ ( $ SQLPre , ▁ $ UidDB , ▁ valid _ id , ▁ create _ time , ▁ create _ by , ▁ change _ time , ▁ change _ by ) ▁ VALUES ▁ ( $ SQLPost , ▁ ' " . $CommonObject { DBObject } -> Quote ( $UID ) . " ' , ▁ 1 , ▁ current _ timestamp , ▁ 1 , ▁ current _ timestamp , ▁ 1 ) " ; } $CommonObject { DBObject } -> Do ( SQL = > $SQL ) ; } } } sub _ConvertTo { my $Text = shift ; return if ! defined $Text ; return $CommonObject { EncodeObject } -> Convert ( Text = > $Text , To = > $DBCharset , From = > $LDAPCharset , ) ; } </DOCUMENT>
<DOCUMENT_ID="diogos88/SensorsMQTT/tree/master/Externals/MySensors/libraries/UIPEthernet/tests/perl/udpclient.pl"> # ! / usr / bin / perl ENDCOM # udpclient . pl ENDCOM use IO :: Socket :: INET ; # ▁ flush ▁ after ▁ every ▁ write ENDCOM $ | = 1 ; my ( $socket , $data ) ; # ▁ We ▁ call ▁ IO : : Socket : : INET - > new ( ) ▁ to ▁ create ▁ the ▁ UDP ▁ Socket ENDCOM # ▁ and ▁ bind ▁ with ▁ the ▁ PeerAddr . ENDCOM $socket = new IO :: Socket :: INET ( PeerAddr = > '192.168.0.6:5000' , Proto = > ' udp ' ) or die " ERROR ▁ in ▁ Socket ▁ Creation ▁ : ▁ $ ! \n " ; # send ▁ operation ENDCOM $data = " data ▁ from ▁ client " ; $socket -> send ( $data ) ; # read ▁ operation ENDCOM $data = < $socket > ; print " Data ▁ received ▁ from ▁ socket ▁ : ▁ $ data \n ▁ " ; sleep ( 10 ) ; $socket -> close ( ) ; </DOCUMENT>
<DOCUMENT_ID="jocelynthode/TextSecure/tree/master/jni/openssl/apps/CA.pl"> # ! / usr / bin / perl ENDCOM # ▁ CA ▁ - ▁ wrapper ▁ around ▁ ca ▁ to ▁ make ▁ it ▁ easier ▁ to ▁ use ▁ . . . ▁ basically ▁ ca ▁ requires ENDCOM # ▁ some ▁ setup ▁ stuff ▁ to ▁ be ▁ done ▁ before ▁ you ▁ can ▁ use ▁ it ▁ and ▁ this ▁ makes ENDCOM # ▁ things ▁ easier ▁ between ▁ now ▁ and ▁ when ▁ Eric ▁ is ▁ convinced ▁ to ▁ fix ▁ it ▁ : - ) ENDCOM # ▁ CA ▁ - newca ▁ . . . ▁ will ▁ setup ▁ the ▁ right ▁ stuff ENDCOM # ▁ CA ▁ - newreq [ - nodes ] ▁ . . . ▁ will ▁ generate ▁ a ▁ certificate ▁ request ▁ ENDCOM # ▁ CA ▁ - sign ▁ . . . ▁ will ▁ sign ▁ the ▁ generated ▁ request ▁ and ▁ output ▁ ENDCOM # ▁ At ▁ the ▁ end ▁ of ▁ that ▁ grab ▁ newreq . pem ▁ and ▁ newcert . pem ▁ ( one ▁ has ▁ the ▁ key ▁ ENDCOM # ▁ and ▁ the ▁ other ▁ the ▁ certificate ) ▁ and ▁ cat ▁ them ▁ together ▁ and ▁ that ▁ is ▁ what ENDCOM # ▁ you ▁ want / need ▁ . . . ▁ I ' ll ▁ make ▁ even ▁ this ▁ a ▁ little ▁ cleaner ▁ later . ENDCOM # ▁ 12 - Jan - 96 ▁ tjh ▁ Added ▁ more ▁ things ▁ . . . ▁ including ▁ CA ▁ - signcert ▁ which ENDCOM # ▁ converts ▁ a ▁ certificate ▁ to ▁ a ▁ request ▁ and ▁ then ▁ signs ▁ it . ENDCOM # ▁ 10 - Jan - 96 ▁ eay ▁ Fixed ▁ a ▁ few ▁ more ▁ bugs ▁ and ▁ added ▁ the ▁ SSLEAY _ CONFIG ENDCOM # TABSYMBOL TABSYMBOL ▁ environment ▁ variable ▁ so ▁ this ▁ can ▁ be ▁ driven ▁ from ENDCOM # TABSYMBOL TABSYMBOL ▁ a ▁ script . ENDCOM # ▁ 25 - Jul - 96 ▁ eay ▁ Cleaned ▁ up ▁ filenames ▁ some ▁ more . ENDCOM # ▁ 11 - Jun - 96 ▁ eay ▁ Fixed ▁ a ▁ few ▁ filename ▁ missmatches . ENDCOM # ▁ 03 - May - 96 ▁ eay ▁ Modified ▁ to ▁ use ▁ ' ssleay ▁ cmd ' ▁ instead ▁ of ▁ ' cmd ' . ENDCOM # ▁ 18 - Apr - 96 ▁ tjh ▁ Original ▁ hacking ENDCOM # ▁ Tim ▁ Hudson ENDCOM # ▁ tjh @ cryptsoft . com ENDCOM # ▁ 27 - Apr - 98 ▁ snh ▁ Translation ▁ into ▁ perl , ▁ fix ▁ existing ▁ CA ▁ bug . ENDCOM # ▁ Steve ▁ Henson ENDCOM # ▁ shenson @ bigfoot . com ENDCOM # ▁ default ▁ openssl . cnf ▁ file ▁ has ▁ setup ▁ as ▁ per ▁ the ▁ following ENDCOM # ▁ demoCA ▁ . . . ▁ where ▁ everything ▁ is ▁ stored ENDCOM my $openssl ; if ( defined $ENV { OPENSSL } ) { $openssl = $ENV { OPENSSL } ; } else { $openssl = " openssl " ; $ENV { OPENSSL } = $openssl ; } $SSLEAY_CONFIG = $ENV { " SSLEAY _ CONFIG " } ; $DAYS = " - days ▁ 365" ; # ▁ 1 ▁ year ENDCOM $CADAYS = " - days ▁ 1095" ; # ▁ 3 ▁ years ENDCOM $REQ = " $ openssl ▁ req ▁ $ SSLEAY _ CONFIG " ; $CA = " $ openssl ▁ ca ▁ $ SSLEAY _ CONFIG " ; $VERIFY = " $ openssl ▁ verify " ; $X509 = " $ openssl ▁ x509" ; $PKCS12 = " $ openssl ▁ pkcs12" ; $CATOP = " . / demoCA " ; $CAKEY = " cakey . pem " ; $CAREQ = " careq . pem " ; $CACERT = " cacert . pem " ; $DIRMODE = 0777 ; $RET = 0 ; foreach ( @ ARGV ) { if ( / ^ ( - \ ? | - h | - help ) $ / ) { print STDERR " usage : ▁ CA ▁ - newcert | - newreq | - newreq - nodes | - newca | - sign | - verify \n " ; exit 0 ; } elsif ( / ^ - newcert$ / ) { # ▁ create ▁ a ▁ certificate ENDCOM system ( " $ REQ ▁ - new ▁ - x509 ▁ - keyout ▁ newkey . pem ▁ - out ▁ newcert . pem ▁ $ DAYS " ) ; $RET = $ ? ; print " Certificate ▁ is ▁ in ▁ newcert . pem , ▁ private ▁ key ▁ is ▁ in ▁ newkey . pem \n " } elsif ( / ^ - newreq$ / ) { # ▁ create ▁ a ▁ certificate ▁ request ENDCOM system ( " $ REQ ▁ - new ▁ - keyout ▁ newkey . pem ▁ - out ▁ newreq . pem ▁ $ DAYS " ) ; $RET = $ ? ; print " Request ▁ is ▁ in ▁ newreq . pem , ▁ private ▁ key ▁ is ▁ in ▁ newkey . pem \n " ; } elsif ( / ^ - newreq - nodes$ / ) { # ▁ create ▁ a ▁ certificate ▁ request ENDCOM system ( " $ REQ ▁ - new ▁ - nodes ▁ - keyout ▁ newkey . pem ▁ - out ▁ newreq . pem ▁ $ DAYS " ) ; $RET = $ ? ; print " Request ▁ is ▁ in ▁ newreq . pem , ▁ private ▁ key ▁ is ▁ in ▁ newkey . pem \n " ; } elsif ( / ^ - newca$ / ) { # ▁ if ▁ explicitly ▁ asked ▁ for ▁ or ▁ it ▁ doesn ' t ▁ exist ▁ then ▁ setup ▁ the ENDCOM # ▁ directory ▁ structure ▁ that ▁ Eric ▁ likes ▁ to ▁ manage ▁ things ▁ ENDCOM $NEW = "1" ; if ( " $ NEW " || ! - f " $ { CATOP } / serial " ) { # ▁ create ▁ the ▁ directory ▁ hierarchy ENDCOM mkdir $CATOP , $DIRMODE ; mkdir " $ { CATOP } / certs " , $DIRMODE ; mkdir " $ { CATOP } / crl " , $DIRMODE ; mkdir " $ { CATOP } / newcerts " , $DIRMODE ; mkdir " $ { CATOP } / private " , $DIRMODE ; open OUT , " > $ { CATOP } / index . txt " ; close OUT ; open OUT , " > $ { CATOP } / crlnumber " ; print OUT "01 \n " ; close OUT ; } if ( ! - f " $ { CATOP } / private / $ CAKEY " ) { print " CA ▁ certificate ▁ filename ▁ ( or ▁ enter ▁ to ▁ create ) \n " ; $FILE = < STDIN > ; chop $FILE ; # ▁ ask ▁ user ▁ for ▁ existing ▁ CA ▁ certificate ENDCOM if ( $FILE ) { cp_pem ( $FILE , " $ { CATOP } / private / $ CAKEY " , " PRIVATE " ) ; cp_pem ( $FILE , " $ { CATOP } / $ CACERT " , " CERTIFICATE " ) ; $RET = $ ? ; } else { print " Making ▁ CA ▁ certificate ▁ . . . \n " ; system ( " $ REQ ▁ - new ▁ - keyout ▁ " . " $ { CATOP } / private / $ CAKEY ▁ - out ▁ $ { CATOP } / $ CAREQ " ) ; system ( " $ CA ▁ - create _ serial ▁ " . " - out ▁ $ { CATOP } / $ CACERT ▁ $ CADAYS ▁ - batch ▁ " . " - keyfile ▁ $ { CATOP } / private / $ CAKEY ▁ - selfsign ▁ " . " - extensions ▁ v3 _ ca ▁ " . " - infiles ▁ $ { CATOP } / $ CAREQ ▁ " ) ; $RET = $ ? ; } } } elsif ( / ^ - pkcs12$ / ) { my $cname = $ARGV [ 1 ] ; $cname = " My ▁ Certificate " unless defined $cname ; system ( " $ PKCS12 ▁ - in ▁ newcert . pem ▁ - inkey ▁ newkey . pem ▁ " . " - certfile ▁ $ { CATOP } / $ CACERT ▁ - out ▁ newcert . p12 ▁ " . " - export ▁ - name ▁ \ " $ cname\ " " ) ; $RET = $ ? ; print " PKCS ▁ # 12 ▁ file ▁ is ▁ in ▁ newcert . p12 \n " ; exit $RET ; } elsif ( / ^ - xsign$ / ) { system ( " $ CA ▁ - policy ▁ policy _ anything ▁ - infiles ▁ newreq . pem " ) ; $RET = $ ? ; } elsif ( / ^ ( - sign | - signreq ) $ / ) { system ( " $ CA ▁ - policy ▁ policy _ anything ▁ - out ▁ newcert . pem ▁ " . " - infiles ▁ newreq . pem " ) ; $RET = $ ? ; print " Signed ▁ certificate ▁ is ▁ in ▁ newcert . pem \n " ; } elsif ( / ^ ( - signCA ) $ / ) { system ( " $ CA ▁ - policy ▁ policy _ anything ▁ - out ▁ newcert . pem ▁ " . " - extensions ▁ v3 _ ca ▁ - infiles ▁ newreq . pem " ) ; $RET = $ ? ; print " Signed ▁ CA ▁ certificate ▁ is ▁ in ▁ newcert . pem \n " ; } elsif ( / ^ - signcert$ / ) { system ( " $ X509 ▁ - x509toreq ▁ - in ▁ newreq . pem ▁ - signkey ▁ newreq . pem ▁ " . " - out ▁ tmp . pem " ) ; system ( " $ CA ▁ - policy ▁ policy _ anything ▁ - out ▁ newcert . pem ▁ " . " - infiles ▁ tmp . pem " ) ; $RET = $ ? ; print " Signed ▁ certificate ▁ is ▁ in ▁ newcert . pem \n " ; } elsif ( / ^ - verify$ / ) { if ( shift ) { foreach $j ( @ ARGV ) { system ( " $ VERIFY ▁ - CAfile ▁ $ CATOP / $ CACERT ▁ $ j " ) ; $RET = $ ? if ( $ ? != 0 ) ; } exit $RET ; } else { system ( " $ VERIFY ▁ - CAfile ▁ $ CATOP / $ CACERT ▁ newcert . pem " ) ; $RET = $ ? ; exit 0 ; } } else { print STDERR " Unknown ▁ arg ▁ $ _ \n " ; print STDERR " usage : ▁ CA ▁ - newcert | - newreq | - newreq - nodes | - newca | - sign | - verify \n " ; exit 1 ; } } exit $RET ; sub cp_pem { my ( $infile , $outfile , $bound ) = @ _ ; open IN , $infile ; open OUT , " > $ outfile " ; my $flag = 0 ; while ( < IN > ) { $flag = 1 if ( / ^ -- -- - BEGIN . * $bound / ) ; print OUT $_ if ( $flag ) ; if ( / ^ -- -- - END . * $bound / ) { close IN ; close OUT ; return ; } } } </DOCUMENT>
<DOCUMENT_ID="vincentchen/lede/tree/master/scripts/flashing/adam2flash.pl"> # ! / usr / bin / env ▁ perl ENDCOM # ▁ D - Link ▁ DSL - G6x4T ▁ flash ▁ utility ENDCOM # ▁ Copyright ▁ ( C ) ▁ 2005 ▁ Felix ▁ Fietkau ▁ < mailto @ nbd . name > ENDCOM # ▁ based ▁ on ▁ fbox ▁ recovery ▁ util ▁ by ▁ Enrik ▁ Berkhan ENDCOM # ▁ This ▁ program ▁ is ▁ free ▁ software ; ▁ you ▁ can ▁ redistribute ▁ it ▁ and / or ▁ modify ENDCOM # ▁ it ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ as ▁ published ▁ by ENDCOM # ▁ the ▁ Free ▁ Software ▁ Foundation ; ▁ either ▁ version ▁ 2 ▁ of ▁ the ▁ License , ▁ or ENDCOM # ▁ ( at ▁ your ▁ option ) ▁ any ▁ later ▁ version . ENDCOM # ▁ This ▁ program ▁ is ▁ distributed ▁ in ▁ the ▁ hope ▁ that ▁ it ▁ will ▁ be ▁ useful , ENDCOM # ▁ but ▁ WITHOUT ▁ ANY ▁ WARRANTY ; ▁ without ▁ even ▁ the ▁ implied ▁ warranty ▁ of ENDCOM # ▁ MERCHANTABILITY ▁ or ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE . ▁ See ▁ the ENDCOM # ▁ GNU ▁ General ▁ Public ▁ License ▁ for ▁ more ▁ details . ENDCOM # ▁ You ▁ should ▁ have ▁ received ▁ a ▁ copy ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ENDCOM # ▁ along ▁ with ▁ this ▁ program ; ▁ if ▁ not , ▁ write ▁ to ▁ the ▁ Free ▁ Software ENDCOM # ▁ Foundation , ▁ Inc . , ▁ 59 ▁ Temple ▁ Place , ▁ Suite ▁ 330 , ▁ Boston , ▁ MA ▁ 02111-1307 ▁ USA ENDCOM use IO :: Socket :: INET ; use Socket ; use strict ; use warnings ; sub usage ( ) { print STDERR " Usage : ▁ $ 0 ▁ < ip > ▁ [ firmware . bin ] \n \n " ; exit 0 ; } my $ip = shift @ ARGV ; $ip and $ip = ~ / \ d { 1 , 3 } \ . \ d { 1 , 3 } \ . \ d { 1 , 3 } \ . \ d { 1 , 3 } / or usage ( ) ; my $probe = IO :: Socket :: INET -> new ( Proto = > ' udp ' , Broadcast = > 1 , LocalPort = > 5035 ) or die " socket : ▁ $ ! " ; my $setip = unpack ( " N " , inet_aton ( $ip ) ) ; $setip > 0 or usage ( ) ; my @ packets ; foreach my $ver ( [ 18 , 1 ] , [ 22 , 2 ] ) { push @ packets , pack ( " vCCVNV " , 0 , @ $ver , 1 , $setip , 0 ) ; } print STDERR " Looking ▁ for ▁ device : ▁ " ; my $broadcast = sockaddr_in ( 5035 , INADDR_BROADCAST ) ; my $scanning ; my $box ; $SIG { " ALRM " } = sub { return if -- $scanning <= 0 ; foreach my $packet ( @ packets ) { $probe -> send ( $packet , 0 , $broadcast ) ; } print STDERR " . " ; } ; $scanning = 10 ; foreach my $packet ( @ packets ) { $probe -> send ( $packet , 0 , $broadcast ) ; } print STDERR " . " ; while ( $scanning ) { my $reply ; alarm ( 1 ) ; if ( my $peer = $probe -> recv ( $reply , 16 ) ) { next if ( length ( $reply ) < 16 ) ; my ( $port , $addr ) = sockaddr_in ( $peer ) ; my ( $major , $minor1 , $minor2 , $code , $addr2 ) = unpack ( " vCCVV " , $reply ) ; $addr2 = pack ( " N " , $addr2 ) ; if ( $code == 2 ) { $scanning = 0 ; printf STDERR " ▁ found ! \n ADAM2 ▁ version ▁ $ major . $ minor1 . $ minor2 ▁ at ▁ % s ▁ ( % s ) \n " , inet_ntoa ( $addr ) , inet_ntoa ( $addr2 ) ; $box = inet_ntoa ( $addr ) ; } } } $box or die " ▁ not ▁ found ! \n " ; { package ADAM2FTP ; use base qw ( Net :: FTP ) ; # ▁ ADAM2 ▁ requires ▁ upper ▁ case ▁ commands , ▁ some ▁ brain ▁ dead ▁ firewall ▁ doesn ' t ▁ ; - ) ENDCOM sub _USER { shift -> command ( " USER " , @ _ ) -> response ( ) } sub _GETENV { my $ftp = shift ; my ( $ok , $name , $value ) ; $ftp -> command ( " GETENV " , @ _ ) ; while ( length ( $ok = $ftp -> response ( ) ) < 1 ) { my $line = $ftp -> getline ( ) ; unless ( defined ( $value ) ) { chomp ( $line ) ; ( $name , $value ) = split ( / \ s + / , $line , 2 ) ; } } $ftp -> debug_print ( 0 , " getenv : ▁ $ value \n " ) if $ftp -> debug ( ) ; return $value ; } sub getenv { my $ftp = shift ; my $name = shift ; return $ftp -> _GETENV ( $name ) ; } sub _REBOOT { shift -> command ( " REBOOT " ) -> response ( ) == Net :: FTP :: CMD_OK } sub reboot { my $ftp = shift ; $ftp -> _REBOOT ; $ftp -> close ; } } my $file = shift @ ARGV ; $file || exit 0 ; open FILE , " < $ file " or die " can ' t ▁ open ▁ firmware ▁ file \n " ; my $ftp = ADAM2FTP -> new ( $box , Debug = > 0 , Timeout = > 600 ) or die " can ' t ▁ open ▁ control ▁ connection \n " ; $ftp -> login ( " adam2" , " adam2" ) or die " can ' t ▁ login \n " ; my $mtd0 = $ftp -> getenv ( " mtd0" ) ; my $mtd1 = $ftp -> getenv ( " mtd1" ) ; my ( $ksize , $fssize ) ; $mtd1 = ~ / ^ ( 0x \ w + ) , ( 0x \ w + ) $ / and $ksize = hex ( $2 ) - hex ( $1 ) ; $mtd0 = ~ / ^ ( 0x \ w + ) , ( 0x \ w + ) $ / and $fssize = hex ( $2 ) - hex ( $1 ) ; $ksize and $fssize or die ' cannot ▁ read ▁ partition ▁ offsets ' ; printf STDERR " Available ▁ flash ▁ space : ▁ 0x % 08x ▁ ( 0x % 08x ▁ + ▁ 0x % 08x ) \n " , $ksize + $fssize , $ksize , $fssize ; $ftp -> command ( " MEDIA ▁ FLSH " ) -> response ( ) ; $ftp -> binary ( ) ; print STDERR " Writing ▁ to ▁ mtd1 . . . \n " ; my $dc = $ftp -> stor ( " fs ▁ mtd1" ) ; $dc or die " can ' t ▁ open ▁ data ▁ connection \n " ; my $rbytes = 1 ; while ( ( $ksize > 0 ) and ( $rbytes > 0 ) ) { my $buffer ; my $len = ( $ksize > 1024 ? 1024 : $ksize ) ; $rbytes = read FILE , $buffer , $len ; $rbytes and $ksize -= $dc -> write ( $buffer , $rbytes , 600 ) ; } $dc -> close ( ) ; $rbytes or die " no ▁ more ▁ data ▁ left ▁ to ▁ write \n " ; print STDERR " Writing ▁ to ▁ mtd0 . . . \n " ; $dc = $ftp -> stor ( " fs ▁ mtd0" ) ; $dc or die " can ' t ▁ open ▁ data ▁ connection \n " ; while ( ( $fssize > 0 ) and ( $rbytes > 0 ) ) { my $buffer ; my $len = ( $fssize > 1024 ? 1024 : $fssize ) ; $rbytes = read FILE , $buffer , $len ; $rbytes and $fssize -= $dc -> write ( $buffer , $rbytes , 600 ) ; } $dc -> close ( ) ; $ftp -> reboot ( ) ; </DOCUMENT>
<DOCUMENT_ID="fb39ca4/mongoose/tree/master/test/all_build_flags.pl"> # ! / usr / bin / env ▁ perl ENDCOM @ flags = ( " NO _ POPEN " , " NO _ SSL " , " NDEBUG " , " DEBUG " , " NO _ CGI " ) ; my $num_flags = @ flags ; sub fail { print " FAILED : ▁ @ _ \n " ; exit 1 ; } my $platform = $ARGV [ 0 ] || " linux " ; for ( my $i = 0 ; $i < 2 * * $num_flags ; $i ++ ) { my $bitmask = sprintf ( " % * . * b " , $num_flags , $num_flags , $i ) ; my @ combination = ( ) ; for ( my $j = 0 ; $j < $num_flags ; $j ++ ) { push @ combination , $flags [ $j ] if substr ( $bitmask , $j , 1 ) ; } my $defines = join ( " ▁ " , map { " - D $ _ " } @ combination ) ; my $cmd = " CFLAGS = \ " $ defines\ " ▁ make ▁ clean ▁ $ platform ▁ > / dev / null " ; system ( $cmd ) == 0 or fail " build ▁ failed : ▁ $ _ " ; print " Build ▁ succeeded , ▁ flags : ▁ [ $ defines ] \n " ; system ( " perl ▁ test / test . pl ▁ basic _ tests ▁ > / dev / null " ) == 0 or fail " basic ▁ tests " ; print " Basic ▁ tests : ▁ OK \n " ; } print " PASS : ▁ All ▁ builds ▁ passed ! \n " ; </DOCUMENT>
<DOCUMENT_ID="kkdd/arangodb/tree/master/3rdParty/V8-4.3.61/third_party/cygwin/lib/perl5/5.10/unicore/lib/gc_sc/InAncien.pl"> # ▁ ! ! ! ! ! ▁ DO ▁ NOT ▁ EDIT ▁ THIS ▁ FILE ▁ ! ! ! ! ! ▁ ENDCOM # ▁ This ▁ file ▁ is ▁ built ▁ by ▁ mktables ▁ from ▁ e . g . ▁ UnicodeData . txt . ENDCOM # ▁ Any ▁ changes ▁ made ▁ here ▁ will ▁ be ▁ lost ! ENDCOM # ▁ This ▁ file ▁ supports : ENDCOM # ▁ TABSYMBOL \p { InAncientSymbols } ▁ ( and ▁ fuzzy ▁ permutations ) ENDCOM # ▁ Meaning : ▁ Block ▁ ' Ancient ▁ Symbols ' ENDCOM return << ' END ' ; 10190 101 CF Ancient Symbols END </DOCUMENT>
<DOCUMENT_ID="keishi/chromium/tree/master/third_party/talloc/script/mksigs.pl"> # ! / usr / bin / perl ENDCOM # ▁ mksigs . pl ▁ - ▁ extract ▁ signatures ▁ from ▁ C ▁ headers ENDCOM # ▁ Copyright ▁ ( C ) ▁ Michael ▁ Adam ▁ 2009 ENDCOM # ▁ This ▁ program ▁ is ▁ free ▁ software ; ▁ you ▁ can ▁ redistribute ▁ it ▁ and / or ▁ modify ▁ it ENDCOM # ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ as ▁ published ▁ by ▁ the ▁ Free ENDCOM # ▁ Software ▁ Foundation ; ▁ either ▁ version ▁ 3 ▁ of ▁ the ▁ License , ▁ or ▁ ( at ▁ your ▁ option ) ENDCOM # ▁ any ▁ later ▁ version . ENDCOM # ▁ This ▁ program ▁ is ▁ distributed ▁ in ▁ the ▁ hope ▁ that ▁ it ▁ will ▁ be ▁ useful , ▁ but ▁ WITHOUT ENDCOM # ▁ ANY ▁ WARRANTY ; ▁ without ▁ even ▁ the ▁ implied ▁ warranty ▁ of ▁ MERCHANTABILITY ▁ or ENDCOM # ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE . ▁ See ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ for ENDCOM # ▁ more ▁ details . ENDCOM # ▁ You ▁ should ▁ have ▁ received ▁ a ▁ copy ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ along ▁ with ENDCOM # ▁ this ▁ program ; ▁ if ▁ not , ▁ see ▁ < http : / / www . gnu . org / licenses / > . ENDCOM # ▁ USAGE : ▁ cat ▁ $ header _ files ▁ | ▁ mksigs . pl ▁ > ▁ $ signature _ file ENDCOM # ▁ The ▁ header ▁ files ▁ to ▁ parse ▁ are ▁ read ▁ from ▁ stdin . ENDCOM # ▁ The ▁ output ▁ is ▁ in ▁ a ▁ form ▁ as ▁ produced ▁ by ▁ gcc ▁ with ▁ the ▁ - aux - info ▁ switch ENDCOM # ▁ and ▁ printed ▁ to ▁ stdout . ENDCOM use strict ; use warnings ; my $in_comment = 0 ; my $extern_C_block = 0 ; while ( my $LINE = < > ) { # ▁ find ▁ end ▁ of ▁ started ▁ multi - line - comment ENDCOM if ( $in_comment ) { if ( $LINE = ~ / ^ . * ? \ * \ / ( . * ) $ / ) { $LINE = $1 ; $in_comment = 0 ; } else { # ▁ whole ▁ line ▁ within ▁ comment ENDCOM next ; } } # ▁ strip ▁ C + + - style ▁ comments ENDCOM $LINE = ~ s / ^ ( . * ? ) \ / \ / . * $ / $1 / ; # ▁ strip ▁ in - line - comments : ENDCOM while ( $LINE = ~ / \ / \ * . * ? \ * \ / / ) { $LINE = ~ s / \ / \ * . * ? \ * \ / / / ; } # ▁ find ▁ starts ▁ of ▁ multi - line - comments ENDCOM if ( $LINE = ~ / ^ ( . * ) \ / \ * / ) { $in_comment = 1 ; $LINE = $1 ; } # ▁ skip ▁ empty ▁ lines ENDCOM next if $LINE = ~ / ^ \ s * $ / ; # ▁ remove ▁ leading ▁ spaces ENDCOM $LINE = ~ s / ^ \ s * ( . * ) $ / $1 / ; # ▁ concatenate ▁ lines ▁ split ▁ with ▁ " \ " ▁ ( usually ▁ macro ▁ defines ) ENDCOM while ( $LINE = ~ / ^ ( . * ? ) \ s + \ \ $ / ) { my $LINE2 = < > ; $LINE = $1 ; $LINE2 = ~ s / ^ \ s * ( . * ) $ / $1 / ; $LINE . = " ▁ " . $LINE2 ; } # ▁ remove ▁ all ▁ preprocessor ▁ directives ENDCOM next if ( $LINE = ~ / ^ if ( $LINE = ~ / ^ extern \ s + " C " \ s + \ { / ) { $extern_C_block = 1 ; next ; } if ( ( $LINE = ~ / ^ [ ^ \ { ] * \ } / ) and $extern_C_block ) { $extern_C_block = 0 ; next ; } $LINE = ~ s / ^ extern \ s / / ; # ▁ concatenate ▁ braces ▁ stretched ▁ over ▁ multiple ▁ lines ENDCOM # ▁ ( from ▁ structs ▁ or ▁ enums ) ENDCOM my $REST = $LINE ; my $braces = 0 ; while ( ( $REST = ~ / [ \ { \ } ] / ) or ( $braces ) ) { while ( $REST = ~ / [ \ { \ } ] / ) { # ▁ collect ▁ opening ENDCOM while ( $REST = ~ / ^ [ ^ \ { \ } ] * \ { ( . * ) $ / ) { $braces ++ ; $REST = $1 ; } # ▁ collect ▁ closing ENDCOM while ( $REST = ~ / ^ [ ^ \ { \ } ] * \ } ( . * ) $ / ) { $braces -- ; $REST = $1 ; } } # ▁ concatenate ▁ if ▁ not ▁ balanced ENDCOM if ( $braces ) { if ( my $LINE2 = < > ) { $LINE2 = ~ s / ^ \ s * ( . * ) $ / $1 / ; chomp ( $LINE ) ; $LINE . = " ▁ " . $LINE2 ; chomp $REST ; $REST . = " ▁ " . $LINE2 ; } else { print " ERROR : ▁ unbalanced ▁ braces ▁ ( $ braces ) \n " ; last ; } } } # ▁ concetenate ▁ function ▁ prototypes ▁ that ▁ stretch ▁ over ▁ multiple ▁ lines ENDCOM $REST = $LINE ; my $parenthesis = 0 ; while ( ( $REST = ~ / [ \ ( \ ) ] / ) or ( $parenthesis ) ) { while ( $REST = ~ / [ \ ( \ ) ] / ) { # ▁ collect ▁ opening ENDCOM while ( $REST = ~ / ^ [ ^ \ ( \ ) ] * \ ( ( . * ) $ / ) { $parenthesis ++ ; $REST = $1 ; } # ▁ collect ▁ closing ENDCOM while ( $REST = ~ / ^ [ ^ \ ( \ ) ] * \ ) ( . * ) $ / ) { $parenthesis -- ; $REST = $1 ; } } # ▁ concatenate ▁ if ▁ not ▁ balanced ENDCOM if ( $parenthesis ) { if ( my $LINE2 = < > ) { $LINE2 = ~ s / ^ \ s * ( . * ) $ / $1 / ; chomp ( $LINE ) ; $LINE . = " ▁ " . $LINE2 ; chomp ( $REST ) ; $REST . = " ▁ " . $LINE2 ; } else { print " ERROR : ▁ unbalanced ▁ parantheses ▁ ( $ parenthesis ) \n " ; last ; } } } next if ( $LINE = ~ / ^ typedef \ s / ) ; next if ( $LINE = ~ / ^ enum \ s + [ ^ \ { \ ( ] + \ s + \ { / ) ; next if ( $LINE = ~ / ^ struct \ s + [ ^ \ { \ ( ] + \ s + \ { . * \ } \ s * ; / ) ; next if ( $LINE = ~ / ^ struct \ s + [ a - zA - Z0 - 9 _ ] + \ s * ; / ) ; # ▁ remove ▁ trailing ▁ spaces ENDCOM $LINE = ~ s / ( . * ? ) \ s * $ / $1 / ; $LINE = ~ s / ^ ( . * \ ) ) \ s + PRINTF_ATTRIBUTE \ ( [ ^ \ ) ] * \ ) ( \ s * [ ; , ] ) / $1$2 / ; $LINE = ~ s / ^ ( . * \ ) ) \ s * [ a - zA - Z0 - 9 _ ] + \ s * ; $ / $1 ; / ; # ▁ remove ▁ parameter ▁ names ▁ - ▁ slightly ▁ too ▁ coarse ▁ probably ENDCOM $LINE = ~ s / ( [ \ s \ ( ] \ * ? ) [ _0 - 9 a - zA - Z ] + \ s * ( [ , \ ) ] ) / $1$2 / g ; # ▁ remedy ▁ ( void ) ▁ from ▁ last ▁ line ENDCOM $LINE = ~ s / \ ( \ ) / ( void ) / g ; # ▁ normalize ▁ spaces ENDCOM $LINE = ~ s / \ s * \ ) \ s * / ) / g ; $LINE = ~ s / \ s * \ ( \ s * / ( / g ; $LINE = ~ s / \ s * , \ s * / , / g ; # ▁ normalize ▁ unsigned ENDCOM $LINE = ~ s / ( [ \ s , \ ( ] ) unsigned ( [ , \ ) ] ) / $1unsigned int$2 / g ; # ▁ normalize ▁ bool ENDCOM $LINE = ~ s / ( \ b ) bool ( \ b ) / _Bool / g ; print $LINE . " \n " ; } </DOCUMENT>
<DOCUMENT_ID="craigacgomez/android_kernel_samsung_manta/tree/master/tools/perf/scripts/perl/rw-by-file.pl"> # ! / usr / bin / perl ▁ - w ENDCOM # ▁ ( c ) ▁ 2009 , ▁ Tom ▁ Zanussi ▁ < tzanussi @ gmail . com > ENDCOM # ▁ Licensed ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ GPL ▁ License ▁ version ▁ 2 ENDCOM # ▁ Display ▁ r / w ▁ activity ▁ for ▁ files ▁ read / written ▁ to ▁ for ▁ a ▁ given ▁ program ENDCOM # ▁ The ▁ common _ * ▁ event ▁ handler ▁ fields ▁ are ▁ the ▁ most ▁ useful ▁ fields ▁ common ▁ to ENDCOM # ▁ all ▁ events . ▁ They ▁ don ' t ▁ necessarily ▁ correspond ▁ to ▁ the ▁ ' common _ * ' ▁ fields ENDCOM # ▁ in ▁ the ▁ status ▁ files . ▁ Those ▁ fields ▁ not ▁ available ▁ as ▁ handler ▁ params ▁ can ENDCOM # ▁ be ▁ retrieved ▁ via ▁ script ▁ functions ▁ of ▁ the ▁ form ▁ get _ common _ * ( ) . ENDCOM use 5.010000 ; use strict ; use warnings ; use lib " $ ENV { ' PERF _ EXEC _ PATH ' } / scripts / perl / Perf - Trace - Util / lib " ; use lib " . / Perf - Trace - Util / lib " ; use Perf :: Trace :: Core ; use Perf :: Trace :: Util ; my $usage = " perf ▁ script ▁ - s ▁ rw - by - file . pl ▁ < comm > \n " ; my $for_comm = shift or die $usage ; my % reads ; my % writes ; sub syscalls :: sys_enter_read { my ( $event_name , $context , $common_cpu , $common_secs , $common_nsecs , $common_pid , $common_comm , $nr , $fd , $buf , $count ) = @ _ ; if ( $common_comm eq $for_comm ) { $reads { $fd } { bytes_requested } += $count ; $reads { $fd } { total_reads } ++ ; } } sub syscalls :: sys_enter_write { my ( $event_name , $context , $common_cpu , $common_secs , $common_nsecs , $common_pid , $common_comm , $nr , $fd , $buf , $count ) = @ _ ; if ( $common_comm eq $for_comm ) { $writes { $fd } { bytes_written } += $count ; $writes { $fd } { total_writes } ++ ; } } sub trace_end { printf ( " file ▁ read ▁ counts ▁ for ▁ $ for _ comm : \n \n " ) ; printf ( " % 6s ▁ ▁ % 10s ▁ ▁ % 10s \n " , " fd " , " # ▁ reads " , " bytes _ requested " ) ; printf ( " % 6s ▁ ▁ % 10s ▁ ▁ % 10s \n " , " - - - - - - " , " - - - - - - - - - - " , " - - - - - - - - - - - " ) ; foreach my $fd ( sort { $reads { $b } { bytes_requested } <= > $reads { $a } { bytes_requested } } keys % reads ) { my $total_reads = $reads { $fd } { total_reads } ; my $bytes_requested = $reads { $fd } { bytes_requested } ; printf ( " % 6u ▁ ▁ % 10u ▁ ▁ % 10u \n " , $fd , $total_reads , $bytes_requested ) ; } printf ( " \n file ▁ write ▁ counts ▁ for ▁ $ for _ comm : \n \n " ) ; printf ( " % 6s ▁ ▁ % 10s ▁ ▁ % 10s \n " , " fd " , " # ▁ writes " , " bytes _ written " ) ; printf ( " % 6s ▁ ▁ % 10s ▁ ▁ % 10s \n " , " - - - - - - " , " - - - - - - - - - - " , " - - - - - - - - - - - " ) ; foreach my $fd ( sort { $writes { $b } { bytes_written } <= > $writes { $a } { bytes_written } } keys % writes ) { my $total_writes = $writes { $fd } { total_writes } ; my $bytes_written = $writes { $fd } { bytes_written } ; printf ( " % 6u ▁ ▁ % 10u ▁ ▁ % 10u \n " , $fd , $total_writes , $bytes_written ) ; } print_unhandled ( ) ; } my % unhandled ; sub print_unhandled { if ( ( scalar keys % unhandled ) == 0 ) { return ; } print " \n unhandled ▁ events : \n \n " ; printf ( " % -40s ▁ ▁ % 10s \n " , " event " , " count " ) ; printf ( " % -40s ▁ ▁ % 10s \n " , " - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - " , " - - - - - - - - - - - " ) ; foreach my $event_name ( keys % unhandled ) { printf ( " % -40s ▁ ▁ % 10d \n " , $event_name , $unhandled { $event_name } ) ; } } sub trace_unhandled { my ( $event_name , $context , $common_cpu , $common_secs , $common_nsecs , $common_pid , $common_comm ) = @ _ ; $unhandled { $event_name } ++ ; } </DOCUMENT>
<DOCUMENT_ID="nanocad-lab/vipzone-linux/tree/master/scripts/bootgraph.pl"> # ! / usr / bin / perl ENDCOM # ▁ Copyright ▁ 2008 , ▁ Intel ▁ Corporation ENDCOM # ▁ This ▁ file ▁ is ▁ part ▁ of ▁ the ▁ Linux ▁ kernel ENDCOM # ▁ This ▁ program ▁ file ▁ is ▁ free ▁ software ; ▁ you ▁ can ▁ redistribute ▁ it ▁ and / or ▁ modify ▁ it ENDCOM # ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ as ▁ published ▁ by ▁ the ENDCOM # ▁ Free ▁ Software ▁ Foundation ; ▁ version ▁ 2 ▁ of ▁ the ▁ License . ENDCOM # ▁ This ▁ program ▁ is ▁ distributed ▁ in ▁ the ▁ hope ▁ that ▁ it ▁ will ▁ be ▁ useful , ▁ but ▁ WITHOUT ENDCOM # ▁ ANY ▁ WARRANTY ; ▁ without ▁ even ▁ the ▁ implied ▁ warranty ▁ of ▁ MERCHANTABILITY ▁ or ENDCOM # ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE . ▁ See ▁ the ▁ GNU ▁ General ▁ Public ▁ License ENDCOM # ▁ for ▁ more ▁ details . ENDCOM # ▁ You ▁ should ▁ have ▁ received ▁ a ▁ copy ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ENDCOM # ▁ along ▁ with ▁ this ▁ program ▁ in ▁ a ▁ file ▁ named ▁ COPYING ; ▁ if ▁ not , ▁ write ▁ to ▁ the ENDCOM # ▁ Free ▁ Software ▁ Foundation , ▁ Inc . , ENDCOM # ▁ 51 ▁ Franklin ▁ Street , ▁ Fifth ▁ Floor , ENDCOM # ▁ Boston , ▁ MA ▁ 02110-1301 ▁ USA ENDCOM # ▁ Authors : ENDCOM # ▁ TABSYMBOL Arjan ▁ van ▁ de ▁ Ven ▁ < arjan @ linux . intel . com > ENDCOM # ▁ This ▁ script ▁ turns ▁ a ▁ dmesg ▁ output ▁ into ▁ a ▁ SVG ▁ graphic ▁ that ▁ shows ▁ which ENDCOM # ▁ functions ▁ take ▁ how ▁ much ▁ time . ▁ You ▁ can ▁ view ▁ SVG ▁ graphics ▁ with ▁ various ENDCOM # ▁ programs , ▁ including ▁ Inkscape , ▁ The ▁ Gimp ▁ and ▁ Firefox . ENDCOM # ▁ For ▁ this ▁ script ▁ to ▁ work , ▁ the ▁ kernel ▁ needs ▁ to ▁ be ▁ compiled ▁ with ▁ the ENDCOM # ▁ CONFIG _ PRINTK _ TIME ▁ configuration ▁ option ▁ enabled , ▁ and ▁ with ENDCOM # ▁ " initcall _ debug " ▁ passed ▁ on ▁ the ▁ kernel ▁ command ▁ line . ENDCOM # ▁ usage : ENDCOM # ▁ TABSYMBOL dmesg ▁ | ▁ perl ▁ scripts / bootgraph . pl ▁ > ▁ output . svg ENDCOM use strict ; my % start ; my % end ; my % type ; my $done = 0 ; my $maxtime = 0 ; my $firsttime = 99999 ; my $count = 0 ; my % pids ; my % pidctr ; while ( < > ) { my $line = $_ ; if ( $line = ~ / ( [ 0 - 9 \ . ] + ) \ ] calling ( [ a - zA - Z0 - 9 \ _ \ . ] + ) \ + / ) { my $func = $2 ; if ( $done == 0 ) { $start { $func } = $1 ; $type { $func } = 0 ; if ( $1 < $firsttime ) { $firsttime = $1 ; } } if ( $line = ~ / \ @ ( [ 0 - 9 ] + ) / ) { $pids { $func } = $1 ; } $count = $count + 1 ; } if ( $line = ~ / ( [ 0 - 9 \ . ] + ) \ ] async_waiting @ ( [ 0 - 9 ] + ) / ) { my $pid = $2 ; my $func ; if ( ! defined ( $pidctr { $pid } ) ) { $func = " wait _ " . $pid . " _ 1" ; $pidctr { $pid } = 1 ; } else { $pidctr { $pid } = $pidctr { $pid } + 1 ; $func = " wait _ " . $pid . " _ " . $pidctr { $pid } ; } if ( $done == 0 ) { $start { $func } = $1 ; $type { $func } = 1 ; if ( $1 < $firsttime ) { $firsttime = $1 ; } } $pids { $func } = $pid ; $count = $count + 1 ; } if ( $line = ~ / ( [ 0 - 9 \ . ] + ) \ ] initcall ( [ a - zA - Z0 - 9 \ _ \ . ] + ) \ + . * returned / ) { if ( $done == 0 ) { $end { $2 } = $1 ; $maxtime = $1 ; } } if ( $line = ~ / ( [ 0 - 9 \ . ] + ) \ ] async_continuing @ ( [ 0 - 9 ] + ) / ) { my $pid = $2 ; my $func = " wait _ " . $pid . " _ " . $pidctr { $pid } ; $end { $func } = $1 ; $maxtime = $1 ; } if ( $line = ~ / Write protecting the / ) { $done = 1 ; } if ( $line = ~ / Freeing unused kernel memory / ) { $done = 1 ; } } if ( $count == 0 ) { print STDERR << END ; No data found in the dmesg . Make sure that ' printk . time = 1' and ' initcall _ debug ' are passed on the kernel command line . Usage : dmesg | perl scripts / bootgraph . pl > output . svg END exit 1 ; } print " < ? xml ▁ version = \ " 1.0\ " ▁ standalone = \ " no\ " ? > ▁ \n " ; print " < svg ▁ width = \ " 2000\ " ▁ height = \ " 100 % \ " ▁ version = \ " 1.1\ " ▁ xmlns = \ " http : / / www . w3 . org / 2000 / svg\ " > \n " ; my @ styles ; $styles [ 0 ] = " fill : rgb ( 0,0,255 ) ; fill - opacity : 0.5 ; stroke - width : 1 ; stroke : rgb ( 0,0,0 ) " ; $styles [ 1 ] = " fill : rgb ( 0,255,0 ) ; fill - opacity : 0.5 ; stroke - width : 1 ; stroke : rgb ( 0,0,0 ) " ; $styles [ 2 ] = " fill : rgb ( 255,0,20 ) ; fill - opacity : 0.5 ; stroke - width : 1 ; stroke : rgb ( 0,0,0 ) " ; $styles [ 3 ] = " fill : rgb ( 255,255,20 ) ; fill - opacity : 0.5 ; stroke - width : 1 ; stroke : rgb ( 0,0,0 ) " ; $styles [ 4 ] = " fill : rgb ( 255,0,255 ) ; fill - opacity : 0.5 ; stroke - width : 1 ; stroke : rgb ( 0,0,0 ) " ; $styles [ 5 ] = " fill : rgb ( 0,255,255 ) ; fill - opacity : 0.5 ; stroke - width : 1 ; stroke : rgb ( 0,0,0 ) " ; $styles [ 6 ] = " fill : rgb ( 0,128,255 ) ; fill - opacity : 0.5 ; stroke - width : 1 ; stroke : rgb ( 0,0,0 ) " ; $styles [ 7 ] = " fill : rgb ( 0,255,128 ) ; fill - opacity : 0.5 ; stroke - width : 1 ; stroke : rgb ( 0,0,0 ) " ; $styles [ 8 ] = " fill : rgb ( 255,0,128 ) ; fill - opacity : 0.5 ; stroke - width : 1 ; stroke : rgb ( 0,0,0 ) " ; $styles [ 9 ] = " fill : rgb ( 255,255,128 ) ; fill - opacity : 0.5 ; stroke - width : 1 ; stroke : rgb ( 0,0,0 ) " ; $styles [ 10 ] = " fill : rgb ( 255,128,255 ) ; fill - opacity : 0.5 ; stroke - width : 1 ; stroke : rgb ( 0,0,0 ) " ; $styles [ 11 ] = " fill : rgb ( 128,255,255 ) ; fill - opacity : 0.5 ; stroke - width : 1 ; stroke : rgb ( 0,0,0 ) " ; my $style_wait = " fill : rgb ( 128,128,128 ) ; fill - opacity : 0.5 ; stroke - width : 0 ; stroke : rgb ( 0,0,0 ) " ; my $mult = 1950.0 / ( $maxtime - $firsttime ) ; my $threshold2 = ( $maxtime - $firsttime ) / 120.0 ; my $threshold = $threshold2 / 10 ; my $stylecounter = 0 ; my % rows ; my $rowscount = 1 ; my @ initcalls = sort { $start { $a } <= > $start { $b } } keys ( % start ) ; foreach my $key ( @ initcalls ) { my $duration = $end { $key } - $start { $key } ; if ( $duration >= $threshold ) { my ( $s , $s2 , $s3 , $e , $w , $y , $y2 , $style ) ; my $pid = $pids { $key } ; if ( ! defined ( $rows { $pid } ) ) { $rows { $pid } = $rowscount ; $rowscount = $rowscount + 1 ; } $s = ( $start { $key } - $firsttime ) * $mult ; $s2 = $s + 6 ; $s3 = $s + 1 ; $e = ( $end { $key } - $firsttime ) * $mult ; $w = $e - $s ; $y = $rows { $pid } * 150 ; $y2 = $y + 4 ; $style = $styles [ $stylecounter ] ; $stylecounter = $stylecounter + 1 ; if ( $stylecounter > 11 ) { $stylecounter = 0 ; } ; if ( $type { $key } == 1 ) { $y = $y + 15 ; print " < rect ▁ x = \ " $ s\ " ▁ width = \ " $ w\ " ▁ y = \ " $ y\ " ▁ height = \ " 115\ " ▁ style = \ " $ style _ wait\ " / > \n " ; } else { print " < rect ▁ x = \ " $ s\ " ▁ width = \ " $ w\ " ▁ y = \ " $ y\ " ▁ height = \ " 145\ " ▁ style = \ " $ style\ " / > \n " ; if ( $duration >= $threshold2 ) { print " < text ▁ transform = \ " translate ( $ s2 , $ y2 ) ▁ rotate ( 90 ) \ " > $ key < / text > \n " ; } else { print " < text ▁ transform = \ " translate ( $ s3 , $ y2 ) ▁ rotate ( 90 ) \ " ▁ font - size = \ " 3pt\ " > $ key < / text > \n " ; } } } } # ▁ print ▁ the ▁ time ▁ line ▁ on ▁ top ENDCOM my $time = $firsttime ; my $step = ( $maxtime - $firsttime ) / 15 ; while ( $time < $maxtime ) { my $s3 = ( $time - $firsttime ) * $mult ; my $tm = int ( $time * 100 ) / 100.0 ; print " < text ▁ transform = \ " translate ( $ s3,89 ) ▁ rotate ( 90 ) \ " > $ tm < / text > \n " ; $time = $time + $step ; } print " < / svg > \n " ; </DOCUMENT>
<DOCUMENT_ID="gabriel-fernandez/kernel/tree/master/tools/perf/scripts/perl/rw-by-pid.pl"> # ! / usr / bin / perl ▁ - w ENDCOM # ▁ ( c ) ▁ 2009 , ▁ Tom ▁ Zanussi ▁ < tzanussi @ gmail . com > ENDCOM # ▁ Licensed ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ GPL ▁ License ▁ version ▁ 2 ENDCOM # ▁ Display ▁ r / w ▁ activity ▁ for ▁ all ▁ processes ENDCOM # ▁ The ▁ common _ * ▁ event ▁ handler ▁ fields ▁ are ▁ the ▁ most ▁ useful ▁ fields ▁ common ▁ to ENDCOM # ▁ all ▁ events . ▁ They ▁ don ' t ▁ necessarily ▁ correspond ▁ to ▁ the ▁ ' common _ * ' ▁ fields ENDCOM # ▁ in ▁ the ▁ status ▁ files . ▁ Those ▁ fields ▁ not ▁ available ▁ as ▁ handler ▁ params ▁ can ENDCOM # ▁ be ▁ retrieved ▁ via ▁ script ▁ functions ▁ of ▁ the ▁ form ▁ get _ common _ * ( ) . ENDCOM use 5.010000 ; use strict ; use warnings ; use lib " $ ENV { ' PERF _ EXEC _ PATH ' } / scripts / perl / Perf - Trace - Util / lib " ; use lib " . / Perf - Trace - Util / lib " ; use Perf :: Trace :: Core ; use Perf :: Trace :: Util ; my % reads ; my % writes ; sub syscalls :: sys_exit_read { my ( $event_name , $context , $common_cpu , $common_secs , $common_nsecs , $common_pid , $common_comm , $nr , $ret ) = @ _ ; if ( $ret > 0 ) { $reads { $common_pid } { bytes_read } += $ret ; } else { if ( ! defined ( $reads { $common_pid } { bytes_read } ) ) { $reads { $common_pid } { bytes_read } = 0 ; } $reads { $common_pid } { errors } { $ret } ++ ; } } sub syscalls :: sys_enter_read { my ( $event_name , $context , $common_cpu , $common_secs , $common_nsecs , $common_pid , $common_comm , $nr , $fd , $buf , $count ) = @ _ ; $reads { $common_pid } { bytes_requested } += $count ; $reads { $common_pid } { total_reads } ++ ; $reads { $common_pid } { comm } = $common_comm ; } sub syscalls :: sys_exit_write { my ( $event_name , $context , $common_cpu , $common_secs , $common_nsecs , $common_pid , $common_comm , $nr , $ret ) = @ _ ; if ( $ret <= 0 ) { $writes { $common_pid } { errors } { $ret } ++ ; } } sub syscalls :: sys_enter_write { my ( $event_name , $context , $common_cpu , $common_secs , $common_nsecs , $common_pid , $common_comm , $nr , $fd , $buf , $count ) = @ _ ; $writes { $common_pid } { bytes_written } += $count ; $writes { $common_pid } { total_writes } ++ ; $writes { $common_pid } { comm } = $common_comm ; } sub trace_end { printf ( " read ▁ counts ▁ by ▁ pid : \n \n " ) ; printf ( " % 6s ▁ ▁ % 20s ▁ ▁ % 10s ▁ ▁ % 10s ▁ ▁ % 10s \n " , " pid " , " comm " , " # ▁ reads " , " bytes _ requested " , " bytes _ read " ) ; printf ( " % 6s ▁ ▁ % -20s ▁ ▁ % 10s ▁ ▁ % 10s ▁ ▁ % 10s \n " , " - - - - - - " , " - - - - - - - - - - - - - - - - - - - - " , " - - - - - - - - - - - " , " - - - - - - - - - - " , " - - - - - - - - - - " ) ; foreach my $pid ( sort { ( $reads { $b } { bytes_read } || 0 ) <= > ( $reads { $a } { bytes_read } || 0 ) } keys % reads ) { my $comm = $reads { $pid } { comm } || " " ; my $total_reads = $reads { $pid } { total_reads } || 0 ; my $bytes_requested = $reads { $pid } { bytes_requested } || 0 ; my $bytes_read = $reads { $pid } { bytes_read } || 0 ; printf ( " % 6s ▁ ▁ % -20s ▁ ▁ % 10s ▁ ▁ % 10s ▁ ▁ % 10s \n " , $pid , $comm , $total_reads , $bytes_requested , $bytes_read ) ; } printf ( " \n failed ▁ reads ▁ by ▁ pid : \n \n " ) ; printf ( " % 6s ▁ ▁ % 20s ▁ ▁ % 6s ▁ ▁ % 10s \n " , " pid " , " comm " , " error ▁ # " , " # ▁ errors " ) ; printf ( " % 6s ▁ ▁ % 20s ▁ ▁ % 6s ▁ ▁ % 10s \n " , " - - - - - - " , " - - - - - - - - - - - - - - - - - - - - " , " - - - - - - " , " - - - - - - - - - - " ) ; my @ errcounts = ( ) ; foreach my $pid ( keys % reads ) { foreach my $error ( keys % { $reads { $pid } { errors } } ) { my $comm = $reads { $pid } { comm } || " " ; my $errcount = $reads { $pid } { errors } { $error } || 0 ; push @ errcounts , [ $pid , $comm , $error , $errcount ] ; } } @ errcounts = sort { $b -> [ 3 ] <= > $a -> [ 3 ] } @ errcounts ; for my $i ( 0 . . $ # errcounts ) ▁ { ENDCOM printf ( " % 6d ▁ ▁ % -20s ▁ ▁ % 6d ▁ ▁ % 10s \n " , $errcounts [ $i ] [ 0 ] , $errcounts [ $i ] [ 1 ] , $errcounts [ $i ] [ 2 ] , $errcounts [ $i ] [ 3 ] ) ; } printf ( " \n write ▁ counts ▁ by ▁ pid : \n \n " ) ; printf ( " % 6s ▁ ▁ % 20s ▁ ▁ % 10s ▁ ▁ % 10s \n " , " pid " , " comm " , " # ▁ writes " , " bytes _ written " ) ; printf ( " % 6s ▁ ▁ % -20s ▁ ▁ % 10s ▁ ▁ % 10s \n " , " - - - - - - " , " - - - - - - - - - - - - - - - - - - - - " , " - - - - - - - - - - - " , " - - - - - - - - - - " ) ; foreach my $pid ( sort { ( $writes { $b } { bytes_written } || 0 ) <= > ( $writes { $a } { bytes_written } || 0 ) } keys % writes ) { my $comm = $writes { $pid } { comm } || " " ; my $total_writes = $writes { $pid } { total_writes } || 0 ; my $bytes_written = $writes { $pid } { bytes_written } || 0 ; printf ( " % 6s ▁ ▁ % -20s ▁ ▁ % 10s ▁ ▁ % 10s \n " , $pid , $comm , $total_writes , $bytes_written ) ; } printf ( " \n failed ▁ writes ▁ by ▁ pid : \n \n " ) ; printf ( " % 6s ▁ ▁ % 20s ▁ ▁ % 6s ▁ ▁ % 10s \n " , " pid " , " comm " , " error ▁ # " , " # ▁ errors " ) ; printf ( " % 6s ▁ ▁ % 20s ▁ ▁ % 6s ▁ ▁ % 10s \n " , " - - - - - - " , " - - - - - - - - - - - - - - - - - - - - " , " - - - - - - " , " - - - - - - - - - - " ) ; @ errcounts = ( ) ; foreach my $pid ( keys % writes ) { foreach my $error ( keys % { $writes { $pid } { errors } } ) { my $comm = $writes { $pid } { comm } || " " ; my $errcount = $writes { $pid } { errors } { $error } || 0 ; push @ errcounts , [ $pid , $comm , $error , $errcount ] ; } } @ errcounts = sort { $b -> [ 3 ] <= > $a -> [ 3 ] } @ errcounts ; for my $i ( 0 . . $ # errcounts ) ▁ { ENDCOM printf ( " % 6d ▁ ▁ % -20s ▁ ▁ % 6d ▁ ▁ % 10s \n " , $errcounts [ $i ] [ 0 ] , $errcounts [ $i ] [ 1 ] , $errcounts [ $i ] [ 2 ] , $errcounts [ $i ] [ 3 ] ) ; } print_unhandled ( ) ; } my % unhandled ; sub print_unhandled { if ( ( scalar keys % unhandled ) == 0 ) { return ; } print " \n unhandled ▁ events : \n \n " ; printf ( " % -40s ▁ ▁ % 10s \n " , " event " , " count " ) ; printf ( " % -40s ▁ ▁ % 10s \n " , " - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - " , " - - - - - - - - - - - " ) ; foreach my $event_name ( keys % unhandled ) { printf ( " % -40s ▁ ▁ % 10d \n " , $event_name , $unhandled { $event_name } ) ; } } sub trace_unhandled { my ( $event_name , $context , $common_cpu , $common_secs , $common_nsecs , $common_pid , $common_comm ) = @ _ ; $unhandled { $event_name } ++ ; } </DOCUMENT>
<DOCUMENT_ID="Kiritoalex/galileo-linux-stable/tree/master/tools/perf/scripts/perl/rwtop.pl"> # ! / usr / bin / perl ▁ - w ENDCOM # ▁ ( c ) ▁ 2010 , ▁ Tom ▁ Zanussi ▁ < tzanussi @ gmail . com > ENDCOM # ▁ Licensed ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ GPL ▁ License ▁ version ▁ 2 ENDCOM # ▁ read / write ▁ top ENDCOM # ▁ Periodically ▁ displays ▁ system - wide ▁ r / w ▁ call ▁ activity , ▁ broken ▁ down ▁ by ENDCOM # ▁ pid . ▁ If ▁ an ▁ [ interval ] ▁ arg ▁ is ▁ specified , ▁ the ▁ display ▁ will ▁ be ENDCOM # ▁ refreshed ▁ every ▁ [ interval ] ▁ seconds . ▁ The ▁ default ▁ interval ▁ is ▁ 3 ENDCOM # ▁ seconds . ENDCOM use 5.010000 ; use strict ; use warnings ; use lib " $ ENV { ' PERF _ EXEC _ PATH ' } / scripts / perl / Perf - Trace - Util / lib " ; use lib " . / Perf - Trace - Util / lib " ; use Perf :: Trace :: Core ; use Perf :: Trace :: Util ; use POSIX qw / SIGALRM SA_RESTART / ; my $default_interval = 3 ; my $nlines = 20 ; my $print_thread ; my $print_pending = 0 ; my % reads ; my % writes ; my $interval = shift ; if ( ! $interval ) { $interval = $default_interval ; } sub syscalls :: sys_exit_read { my ( $event_name , $context , $common_cpu , $common_secs , $common_nsecs , $common_pid , $common_comm , $nr , $ret ) = @ _ ; print_check ( ) ; if ( $ret > 0 ) { $reads { $common_pid } { bytes_read } += $ret ; } else { if ( ! defined ( $reads { $common_pid } { bytes_read } ) ) { $reads { $common_pid } { bytes_read } = 0 ; } $reads { $common_pid } { errors } { $ret } ++ ; } } sub syscalls :: sys_enter_read { my ( $event_name , $context , $common_cpu , $common_secs , $common_nsecs , $common_pid , $common_comm , $nr , $fd , $buf , $count ) = @ _ ; print_check ( ) ; $reads { $common_pid } { bytes_requested } += $count ; $reads { $common_pid } { total_reads } ++ ; $reads { $common_pid } { comm } = $common_comm ; } sub syscalls :: sys_exit_write { my ( $event_name , $context , $common_cpu , $common_secs , $common_nsecs , $common_pid , $common_comm , $nr , $ret ) = @ _ ; print_check ( ) ; if ( $ret <= 0 ) { $writes { $common_pid } { errors } { $ret } ++ ; } } sub syscalls :: sys_enter_write { my ( $event_name , $context , $common_cpu , $common_secs , $common_nsecs , $common_pid , $common_comm , $nr , $fd , $buf , $count ) = @ _ ; print_check ( ) ; $writes { $common_pid } { bytes_written } += $count ; $writes { $common_pid } { total_writes } ++ ; $writes { $common_pid } { comm } = $common_comm ; } sub trace_begin { my $sa = POSIX :: SigAction -> new ( \ & set_print_pending ) ; $sa -> flags ( SA_RESTART ) ; $sa -> safe ( 1 ) ; POSIX :: sigaction ( SIGALRM , $sa ) or die " Can ' t ▁ set ▁ SIGALRM ▁ handler : ▁ $ ! \n " ; alarm 1 ; } sub trace_end { print_unhandled ( ) ; print_totals ( ) ; } sub print_check ( ) { if ( $print_pending == 1 ) { $print_pending = 0 ; print_totals ( ) ; } } sub set_print_pending ( ) { $print_pending = 1 ; alarm $interval ; } sub print_totals { my $count ; $count = 0 ; clear_term ( ) ; printf ( " \n read ▁ counts ▁ by ▁ pid : \n \n " ) ; printf ( " % 6s ▁ ▁ % 20s ▁ ▁ % 10s ▁ ▁ % 10s ▁ ▁ % 10s \n " , " pid " , " comm " , " # ▁ reads " , " bytes _ req " , " bytes _ read " ) ; printf ( " % 6s ▁ ▁ % -20s ▁ ▁ % 10s ▁ ▁ % 10s ▁ ▁ % 10s \n " , " - - - - - - " , " - - - - - - - - - - - - - - - - - - - - " , " - - - - - - - - - - " , " - - - - - - - - - - " , " - - - - - - - - - - " ) ; foreach my $pid ( sort { ( $reads { $b } { bytes_read } || 0 ) <= > ( $reads { $a } { bytes_read } || 0 ) } keys % reads ) { my $comm = $reads { $pid } { comm } || " " ; my $total_reads = $reads { $pid } { total_reads } || 0 ; my $bytes_requested = $reads { $pid } { bytes_requested } || 0 ; my $bytes_read = $reads { $pid } { bytes_read } || 0 ; printf ( " % 6s ▁ ▁ % -20s ▁ ▁ % 10s ▁ ▁ % 10s ▁ ▁ % 10s \n " , $pid , $comm , $total_reads , $bytes_requested , $bytes_read ) ; if ( ++ $count == $nlines ) { last ; } } $count = 0 ; printf ( " \n write ▁ counts ▁ by ▁ pid : \n \n " ) ; printf ( " % 6s ▁ ▁ % 20s ▁ ▁ % 10s ▁ ▁ % 13s \n " , " pid " , " comm " , " # ▁ writes " , " bytes _ written " ) ; printf ( " % 6s ▁ ▁ % -20s ▁ ▁ % 10s ▁ ▁ % 13s \n " , " - - - - - - " , " - - - - - - - - - - - - - - - - - - - - " , " - - - - - - - - - - " , " - - - - - - - - - - - - - " ) ; foreach my $pid ( sort { ( $writes { $b } { bytes_written } || 0 ) <= > ( $writes { $a } { bytes_written } || 0 ) } keys % writes ) { my $comm = $writes { $pid } { comm } || " " ; my $total_writes = $writes { $pid } { total_writes } || 0 ; my $bytes_written = $writes { $pid } { bytes_written } || 0 ; printf ( " % 6s ▁ ▁ % -20s ▁ ▁ % 10s ▁ ▁ % 13s \n " , $pid , $comm , $total_writes , $bytes_written ) ; if ( ++ $count == $nlines ) { last ; } } % reads = ( ) ; % writes = ( ) ; } my % unhandled ; sub print_unhandled { if ( ( scalar keys % unhandled ) == 0 ) { return ; } print " \n unhandled ▁ events : \n \n " ; printf ( " % -40s ▁ ▁ % 10s \n " , " event " , " count " ) ; printf ( " % -40s ▁ ▁ % 10s \n " , " - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - " , " - - - - - - - - - - - " ) ; foreach my $event_name ( keys % unhandled ) { printf ( " % -40s ▁ ▁ % 10d \n " , $event_name , $unhandled { $event_name } ) ; } } sub trace_unhandled { my ( $event_name , $context , $common_cpu , $common_secs , $common_nsecs , $common_pid , $common_comm ) = @ _ ; $unhandled { $event_name } ++ ; } </DOCUMENT>
<DOCUMENT_ID="jocelynthode/TextSecure/tree/master/jni/openssl/apps/CA.pl"> # ! / usr / bin / perl ENDCOM # ▁ CA ▁ - ▁ wrapper ▁ around ▁ ca ▁ to ▁ make ▁ it ▁ easier ▁ to ▁ use ▁ . . . ▁ basically ▁ ca ▁ requires ENDCOM # ▁ some ▁ setup ▁ stuff ▁ to ▁ be ▁ done ▁ before ▁ you ▁ can ▁ use ▁ it ▁ and ▁ this ▁ makes ENDCOM # ▁ things ▁ easier ▁ between ▁ now ▁ and ▁ when ▁ Eric ▁ is ▁ convinced ▁ to ▁ fix ▁ it ▁ : - ) ENDCOM # ▁ CA ▁ - newca ▁ . . . ▁ will ▁ setup ▁ the ▁ right ▁ stuff ENDCOM # ▁ CA ▁ - newreq [ - nodes ] ▁ . . . ▁ will ▁ generate ▁ a ▁ certificate ▁ request ▁ ENDCOM # ▁ CA ▁ - sign ▁ . . . ▁ will ▁ sign ▁ the ▁ generated ▁ request ▁ and ▁ output ▁ ENDCOM # ▁ At ▁ the ▁ end ▁ of ▁ that ▁ grab ▁ newreq . pem ▁ and ▁ newcert . pem ▁ ( one ▁ has ▁ the ▁ key ▁ ENDCOM # ▁ and ▁ the ▁ other ▁ the ▁ certificate ) ▁ and ▁ cat ▁ them ▁ together ▁ and ▁ that ▁ is ▁ what ENDCOM # ▁ you ▁ want / need ▁ . . . ▁ I ' ll ▁ make ▁ even ▁ this ▁ a ▁ little ▁ cleaner ▁ later . ENDCOM # ▁ 12 - Jan - 96 ▁ tjh ▁ Added ▁ more ▁ things ▁ . . . ▁ including ▁ CA ▁ - signcert ▁ which ENDCOM # ▁ converts ▁ a ▁ certificate ▁ to ▁ a ▁ request ▁ and ▁ then ▁ signs ▁ it . ENDCOM # ▁ 10 - Jan - 96 ▁ eay ▁ Fixed ▁ a ▁ few ▁ more ▁ bugs ▁ and ▁ added ▁ the ▁ SSLEAY _ CONFIG ENDCOM # TABSYMBOL TABSYMBOL ▁ environment ▁ variable ▁ so ▁ this ▁ can ▁ be ▁ driven ▁ from ENDCOM # TABSYMBOL TABSYMBOL ▁ a ▁ script . ENDCOM # ▁ 25 - Jul - 96 ▁ eay ▁ Cleaned ▁ up ▁ filenames ▁ some ▁ more . ENDCOM # ▁ 11 - Jun - 96 ▁ eay ▁ Fixed ▁ a ▁ few ▁ filename ▁ missmatches . ENDCOM # ▁ 03 - May - 96 ▁ eay ▁ Modified ▁ to ▁ use ▁ ' ssleay ▁ cmd ' ▁ instead ▁ of ▁ ' cmd ' . ENDCOM # ▁ 18 - Apr - 96 ▁ tjh ▁ Original ▁ hacking ENDCOM # ▁ Tim ▁ Hudson ENDCOM # ▁ tjh @ cryptsoft . com ENDCOM # ▁ 27 - Apr - 98 ▁ snh ▁ Translation ▁ into ▁ perl , ▁ fix ▁ existing ▁ CA ▁ bug . ENDCOM # ▁ Steve ▁ Henson ENDCOM # ▁ shenson @ bigfoot . com ENDCOM # ▁ default ▁ openssl . cnf ▁ file ▁ has ▁ setup ▁ as ▁ per ▁ the ▁ following ENDCOM # ▁ demoCA ▁ . . . ▁ where ▁ everything ▁ is ▁ stored ENDCOM my $openssl ; if ( defined $ENV { OPENSSL } ) { $openssl = $ENV { OPENSSL } ; } else { $openssl = " openssl " ; $ENV { OPENSSL } = $openssl ; } $SSLEAY_CONFIG = $ENV { " SSLEAY _ CONFIG " } ; $DAYS = " - days ▁ 365" ; # ▁ 1 ▁ year ENDCOM $CADAYS = " - days ▁ 1095" ; # ▁ 3 ▁ years ENDCOM $REQ = " $ openssl ▁ req ▁ $ SSLEAY _ CONFIG " ; $CA = " $ openssl ▁ ca ▁ $ SSLEAY _ CONFIG " ; $VERIFY = " $ openssl ▁ verify " ; $X509 = " $ openssl ▁ x509" ; $PKCS12 = " $ openssl ▁ pkcs12" ; $CATOP = " . / demoCA " ; $CAKEY = " cakey . pem " ; $CAREQ = " careq . pem " ; $CACERT = " cacert . pem " ; $DIRMODE = 0777 ; $RET = 0 ; foreach ( @ ARGV ) { if ( / ^ ( - \ ? | - h | - help ) $ / ) { print STDERR " usage : ▁ CA ▁ - newcert | - newreq | - newreq - nodes | - newca | - sign | - verify \n " ; exit 0 ; } elsif ( / ^ - newcert$ / ) { # ▁ create ▁ a ▁ certificate ENDCOM system ( " $ REQ ▁ - new ▁ - x509 ▁ - keyout ▁ newkey . pem ▁ - out ▁ newcert . pem ▁ $ DAYS " ) ; $RET = $ ? ; print " Certificate ▁ is ▁ in ▁ newcert . pem , ▁ private ▁ key ▁ is ▁ in ▁ newkey . pem \n " } elsif ( / ^ - newreq$ / ) { # ▁ create ▁ a ▁ certificate ▁ request ENDCOM system ( " $ REQ ▁ - new ▁ - keyout ▁ newkey . pem ▁ - out ▁ newreq . pem ▁ $ DAYS " ) ; $RET = $ ? ; print " Request ▁ is ▁ in ▁ newreq . pem , ▁ private ▁ key ▁ is ▁ in ▁ newkey . pem \n " ; } elsif ( / ^ - newreq - nodes$ / ) { # ▁ create ▁ a ▁ certificate ▁ request ENDCOM system ( " $ REQ ▁ - new ▁ - nodes ▁ - keyout ▁ newkey . pem ▁ - out ▁ newreq . pem ▁ $ DAYS " ) ; $RET = $ ? ; print " Request ▁ is ▁ in ▁ newreq . pem , ▁ private ▁ key ▁ is ▁ in ▁ newkey . pem \n " ; } elsif ( / ^ - newca$ / ) { # ▁ if ▁ explicitly ▁ asked ▁ for ▁ or ▁ it ▁ doesn ' t ▁ exist ▁ then ▁ setup ▁ the ENDCOM # ▁ directory ▁ structure ▁ that ▁ Eric ▁ likes ▁ to ▁ manage ▁ things ▁ ENDCOM $NEW = "1" ; if ( " $ NEW " || ! - f " $ { CATOP } / serial " ) { # ▁ create ▁ the ▁ directory ▁ hierarchy ENDCOM mkdir $CATOP , $DIRMODE ; mkdir " $ { CATOP } / certs " , $DIRMODE ; mkdir " $ { CATOP } / crl " , $DIRMODE ; mkdir " $ { CATOP } / newcerts " , $DIRMODE ; mkdir " $ { CATOP } / private " , $DIRMODE ; open OUT , " > $ { CATOP } / index . txt " ; close OUT ; open OUT , " > $ { CATOP } / crlnumber " ; print OUT "01 \n " ; close OUT ; } if ( ! - f " $ { CATOP } / private / $ CAKEY " ) { print " CA ▁ certificate ▁ filename ▁ ( or ▁ enter ▁ to ▁ create ) \n " ; $FILE = < STDIN > ; chop $FILE ; # ▁ ask ▁ user ▁ for ▁ existing ▁ CA ▁ certificate ENDCOM if ( $FILE ) { cp_pem ( $FILE , " $ { CATOP } / private / $ CAKEY " , " PRIVATE " ) ; cp_pem ( $FILE , " $ { CATOP } / $ CACERT " , " CERTIFICATE " ) ; $RET = $ ? ; } else { print " Making ▁ CA ▁ certificate ▁ . . . \n " ; system ( " $ REQ ▁ - new ▁ - keyout ▁ " . " $ { CATOP } / private / $ CAKEY ▁ - out ▁ $ { CATOP } / $ CAREQ " ) ; system ( " $ CA ▁ - create _ serial ▁ " . " - out ▁ $ { CATOP } / $ CACERT ▁ $ CADAYS ▁ - batch ▁ " . " - keyfile ▁ $ { CATOP } / private / $ CAKEY ▁ - selfsign ▁ " . " - extensions ▁ v3 _ ca ▁ " . " - infiles ▁ $ { CATOP } / $ CAREQ ▁ " ) ; $RET = $ ? ; } } } elsif ( / ^ - pkcs12$ / ) { my $cname = $ARGV [ 1 ] ; $cname = " My ▁ Certificate " unless defined $cname ; system ( " $ PKCS12 ▁ - in ▁ newcert . pem ▁ - inkey ▁ newkey . pem ▁ " . " - certfile ▁ $ { CATOP } / $ CACERT ▁ - out ▁ newcert . p12 ▁ " . " - export ▁ - name ▁ \ " $ cname\ " " ) ; $RET = $ ? ; print " PKCS ▁ # 12 ▁ file ▁ is ▁ in ▁ newcert . p12 \n " ; exit $RET ; } elsif ( / ^ - xsign$ / ) { system ( " $ CA ▁ - policy ▁ policy _ anything ▁ - infiles ▁ newreq . pem " ) ; $RET = $ ? ; } elsif ( / ^ ( - sign | - signreq ) $ / ) { system ( " $ CA ▁ - policy ▁ policy _ anything ▁ - out ▁ newcert . pem ▁ " . " - infiles ▁ newreq . pem " ) ; $RET = $ ? ; print " Signed ▁ certificate ▁ is ▁ in ▁ newcert . pem \n " ; } elsif ( / ^ ( - signCA ) $ / ) { system ( " $ CA ▁ - policy ▁ policy _ anything ▁ - out ▁ newcert . pem ▁ " . " - extensions ▁ v3 _ ca ▁ - infiles ▁ newreq . pem " ) ; $RET = $ ? ; print " Signed ▁ CA ▁ certificate ▁ is ▁ in ▁ newcert . pem \n " ; } elsif ( / ^ - signcert$ / ) { system ( " $ X509 ▁ - x509toreq ▁ - in ▁ newreq . pem ▁ - signkey ▁ newreq . pem ▁ " . " - out ▁ tmp . pem " ) ; system ( " $ CA ▁ - policy ▁ policy _ anything ▁ - out ▁ newcert . pem ▁ " . " - infiles ▁ tmp . pem " ) ; $RET = $ ? ; print " Signed ▁ certificate ▁ is ▁ in ▁ newcert . pem \n " ; } elsif ( / ^ - verify$ / ) { if ( shift ) { foreach $j ( @ ARGV ) { system ( " $ VERIFY ▁ - CAfile ▁ $ CATOP / $ CACERT ▁ $ j " ) ; $RET = $ ? if ( $ ? != 0 ) ; } exit $RET ; } else { system ( " $ VERIFY ▁ - CAfile ▁ $ CATOP / $ CACERT ▁ newcert . pem " ) ; $RET = $ ? ; exit 0 ; } } else { print STDERR " Unknown ▁ arg ▁ $ _ \n " ; print STDERR " usage : ▁ CA ▁ - newcert | - newreq | - newreq - nodes | - newca | - sign | - verify \n " ; exit 1 ; } } exit $RET ; sub cp_pem { my ( $infile , $outfile , $bound ) = @ _ ; open IN , $infile ; open OUT , " > $ outfile " ; my $flag = 0 ; while ( < IN > ) { $flag = 1 if ( / ^ -- -- - BEGIN . * $bound / ) ; print OUT $_ if ( $flag ) ; if ( / ^ -- -- - END . * $bound / ) { close IN ; close OUT ; return ; } } } </DOCUMENT>
<DOCUMENT_ID="gitpan/Gtk2-Ex-Clock/tree/master/examples/simple.pl"> # ! / usr / bin / perl ▁ - w ENDCOM # ▁ Copyright ▁ 2007 , ▁ 2008 , ▁ 2010 ▁ Kevin ▁ Ryde ENDCOM # ▁ This ▁ file ▁ is ▁ part ▁ of ▁ Gtk2 - Ex - Clock . ENDCOM # ▁ Gtk2 - Ex - Clock ▁ is ▁ free ▁ software ; ▁ you ▁ can ▁ redistribute ▁ it ▁ and / or ▁ modify ▁ it ENDCOM # ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ as ▁ published ▁ by ▁ the ▁ Free ENDCOM # ▁ Software ▁ Foundation ; ▁ either ▁ version ▁ 3 , ▁ or ▁ ( at ▁ your ▁ option ) ▁ any ▁ later ENDCOM # ▁ version . ENDCOM # ▁ Gtk2 - Ex - Clock ▁ is ▁ distributed ▁ in ▁ the ▁ hope ▁ that ▁ it ▁ will ▁ be ▁ useful , ▁ but ENDCOM # ▁ WITHOUT ▁ ANY ▁ WARRANTY ; ▁ without ▁ even ▁ the ▁ implied ▁ warranty ▁ of ▁ MERCHANTABILITY ENDCOM # ▁ or ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE . ▁ See ▁ the ▁ GNU ▁ General ▁ Public ▁ License ENDCOM # ▁ for ▁ more ▁ details . ENDCOM # ▁ You ▁ should ▁ have ▁ received ▁ a ▁ copy ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ along ENDCOM # ▁ with ▁ Gtk2 - Ex - Clock . ▁ If ▁ not , ▁ see ▁ < http : / / www . gnu . org / licenses / > . ENDCOM # ▁ Simple ▁ clock ▁ display . ENDCOM use strict ; use warnings ; use Gtk2 ' - init ' ; use Gtk2 :: Ex :: Clock ; my $toplevel = Gtk2 :: Window -> new ( ' toplevel ' ) ; $toplevel -> signal_connect ( destroy = > sub { Gtk2 -> main_quit ; } ) ; my $clock = Gtk2 :: Ex :: Clock -> new ( format = > ' % a ▁ % I : % M % P ' ) ; $toplevel -> add ( $clock ) ; $toplevel -> show_all ; Gtk2 -> main ; exit 0 ; </DOCUMENT>
<DOCUMENT_ID="koxda/android_kernel_samsung_msm8660-common/tree/master/tools/perf/scripts/perl/workqueue-stats.pl"> # ! / usr / bin / perl ▁ - w ENDCOM # ▁ ( c ) ▁ 2009 , ▁ Tom ▁ Zanussi ▁ < tzanussi @ gmail . com > ENDCOM # ▁ Licensed ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ GPL ▁ License ▁ version ▁ 2 ENDCOM # ▁ Displays ▁ workqueue ▁ stats ENDCOM # ▁ Usage : ENDCOM # ▁ perf ▁ record ▁ - c ▁ 1 ▁ - f ▁ - a ▁ - R ▁ - e ▁ workqueue : workqueue _ creation ▁ - e ENDCOM # ▁ workqueue : workqueue _ destruction ▁ - e ▁ workqueue : workqueue _ execution ENDCOM # ▁ - e ▁ workqueue : workqueue _ insertion ENDCOM # ▁ perf ▁ script ▁ - p ▁ - s ▁ tools / perf / scripts / perl / workqueue - stats . pl ENDCOM use 5.010000 ; use strict ; use warnings ; use lib " $ ENV { ' PERF _ EXEC _ PATH ' } / scripts / perl / Perf - Trace - Util / lib " ; use lib " . / Perf - Trace - Util / lib " ; use Perf :: Trace :: Core ; use Perf :: Trace :: Util ; my @ cpus ; sub workqueue :: workqueue_destruction { my ( $event_name , $context , $common_cpu , $common_secs , $common_nsecs , $common_pid , $common_comm , $thread_comm , $thread_pid ) = @ _ ; $cpus [ $common_cpu ] { $thread_pid } { destroyed } ++ ; $cpus [ $common_cpu ] { $thread_pid } { comm } = $thread_comm ; } sub workqueue :: workqueue_creation { my ( $event_name , $context , $common_cpu , $common_secs , $common_nsecs , $common_pid , $common_comm , $thread_comm , $thread_pid , $cpu ) = @ _ ; $cpus [ $common_cpu ] { $thread_pid } { created } ++ ; $cpus [ $common_cpu ] { $thread_pid } { comm } = $thread_comm ; } sub workqueue :: workqueue_execution { my ( $event_name , $context , $common_cpu , $common_secs , $common_nsecs , $common_pid , $common_comm , $thread_comm , $thread_pid , $func ) = @ _ ; $cpus [ $common_cpu ] { $thread_pid } { executed } ++ ; $cpus [ $common_cpu ] { $thread_pid } { comm } = $thread_comm ; } sub workqueue :: workqueue_insertion { my ( $event_name , $context , $common_cpu , $common_secs , $common_nsecs , $common_pid , $common_comm , $thread_comm , $thread_pid , $func ) = @ _ ; $cpus [ $common_cpu ] { $thread_pid } { inserted } ++ ; $cpus [ $common_cpu ] { $thread_pid } { comm } = $thread_comm ; } sub trace_end { print " workqueue ▁ work ▁ stats : \n \n " ; my $cpu = 0 ; printf ( " % 3s ▁ % 6s ▁ % 6s\t % -20s \n " , " cpu " , " ins " , " exec " , " name " ) ; printf ( " % 3s ▁ % 6s ▁ % 6s\t % -20s \n " , " - - - " , " - - - " , " - - - - " , " - - - - " ) ; foreach my $pidhash ( @ cpus ) { while ( ( my $pid , my $wqhash ) = each % $pidhash ) { my $ins = $$wqhash { ' inserted ' } || 0 ; my $exe = $$wqhash { ' executed ' } || 0 ; my $comm = $$wqhash { ' comm ' } || " " ; if ( $ins || $exe ) { printf ( " % 3u ▁ % 6u ▁ % 6u\t % -20s \n " , $cpu , $ins , $exe , $comm ) ; } } $cpu ++ ; } $cpu = 0 ; print " \n workqueue ▁ lifecycle ▁ stats : \n \n " ; printf ( " % 3s ▁ % 6s ▁ % 6s\t % -20s \n " , " cpu " , " created " , " destroyed " , " name " ) ; printf ( " % 3s ▁ % 6s ▁ % 6s\t % -20s \n " , " - - - " , " - - - - - - - " , " - - - - - - - - - " , " - - - - " ) ; foreach my $pidhash ( @ cpus ) { while ( ( my $pid , my $wqhash ) = each % $pidhash ) { my $created = $$wqhash { ' created ' } || 0 ; my $destroyed = $$wqhash { ' destroyed ' } || 0 ; my $comm = $$wqhash { ' comm ' } || " " ; if ( $created || $destroyed ) { printf ( " % 3u ▁ % 6u ▁ % 6u\t % -20s \n " , $cpu , $created , $destroyed , $comm ) ; } } $cpu ++ ; } print_unhandled ( ) ; } my % unhandled ; sub print_unhandled { if ( ( scalar keys % unhandled ) == 0 ) { return ; } print " \n unhandled ▁ events : \n \n " ; printf ( " % -40s ▁ ▁ % 10s \n " , " event " , " count " ) ; printf ( " % -40s ▁ ▁ % 10s \n " , " - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - " , " - - - - - - - - - - - " ) ; foreach my $event_name ( keys % unhandled ) { printf ( " % -40s ▁ ▁ % 10d \n " , $event_name , $unhandled { $event_name } ) ; } } sub trace_unhandled { my ( $event_name , $context , $common_cpu , $common_secs , $common_nsecs , $common_pid , $common_comm ) = @ _ ; $unhandled { $event_name } ++ ; } </DOCUMENT>
<DOCUMENT_ID="Adrioid83/jflte_xxx/tree/master/tools/perf/scripts/perl/failed-syscalls.pl"> # ▁ failed ▁ system ▁ call ▁ counts ENDCOM # ▁ ( c ) ▁ 2010 , ▁ Tom ▁ Zanussi ▁ < tzanussi @ gmail . com > ENDCOM # ▁ Licensed ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ GPL ▁ License ▁ version ▁ 2 ENDCOM # ▁ Displays ▁ system - wide ▁ failed ▁ system ▁ call ▁ totals ENDCOM # ▁ If ▁ a ▁ [ comm ] ▁ arg ▁ is ▁ specified , ▁ only ▁ syscalls ▁ called ▁ by ▁ [ comm ] ▁ are ▁ displayed . ENDCOM use lib " $ ENV { ' PERF _ EXEC _ PATH ' } / scripts / perl / Perf - Trace - Util / lib " ; use lib " . / Perf - Trace - Util / lib " ; use Perf :: Trace :: Core ; use Perf :: Trace :: Context ; use Perf :: Trace :: Util ; my $for_comm = shift ; my % failed_syscalls ; sub raw_syscalls :: sys_exit { my ( $event_name , $context , $common_cpu , $common_secs , $common_nsecs , $common_pid , $common_comm , $id , $ret ) = @ _ ; if ( $ret < 0 ) { $failed_syscalls { $common_comm } ++ ; } } sub trace_end { printf ( " \n failed ▁ syscalls ▁ by ▁ comm : \n \n " ) ; printf ( " % -20s ▁ ▁ % 10s \n " , " comm " , " # ▁ errors " ) ; printf ( " % -20s ▁ ▁ % 6s ▁ ▁ % 10s \n " , " - - - - - - - - - - - - - - - - - - - - " , " - - - - - - - - - - " ) ; foreach my $comm ( sort { $failed_syscalls { $b } <= > $failed_syscalls { $a } } keys % failed_syscalls ) { next if ( $for_comm && $comm ne $for_comm ) ; printf ( " % -20s ▁ ▁ % 10s \n " , $comm , $failed_syscalls { $comm } ) ; } } </DOCUMENT>
<DOCUMENT_ID="jondo/paperpile/tree/master/plack/perl5/win32/lib/unicore/lib/In/3_1.pl"> # ▁ ! ! ! ! ! ▁ DO ▁ NOT ▁ EDIT ▁ THIS ▁ FILE ▁ ! ! ! ! ! ENDCOM # ▁ This ▁ file ▁ is ▁ machine - generated ▁ by ▁ mktables ▁ from ▁ the ▁ Unicode ENDCOM # ▁ database , ▁ Version ▁ 5.2.0 . ▁ Any ▁ changes ▁ made ▁ here ▁ will ▁ be ▁ lost ! ENDCOM # ▁ ! ! ! ! ! ▁ INTERNAL ▁ PERL ▁ USE ▁ ONLY ▁ ! ! ! ! ! ENDCOM # ▁ This ▁ file ▁ is ▁ for ▁ internal ▁ use ▁ by ▁ the ▁ Perl ▁ program ▁ only . ▁ The ▁ format ▁ and ▁ even ENDCOM # ▁ the ▁ name ▁ or ▁ existence ▁ of ▁ this ▁ file ▁ are ▁ subject ▁ to ▁ change ▁ without ▁ notice . ENDCOM # ▁ Don ' t ▁ use ▁ it ▁ directly . ENDCOM # ▁ This ▁ file ▁ returns ▁ the ▁ 233_787 ▁ code ▁ points ▁ in ▁ Unicode ▁ Version ▁ 5.2.0 ▁ that ENDCOM # ▁ match ▁ any ▁ of ▁ the ▁ following ▁ regular ▁ expression ▁ constructs : ENDCOM # ▁ \p { Present _ In = 3.1 } ENDCOM # ▁ \p { In = 3.1 } ENDCOM # ▁ Meaning : ▁ Code ▁ point ' s ▁ usage ▁ introduced ▁ in ▁ version ▁ 3.1 ▁ or ▁ earlier ENDCOM # ▁ perluniprops . pod ▁ should ▁ be ▁ consulted ▁ for ▁ the ▁ syntax ▁ rules ▁ for ▁ any ▁ of ▁ these , ENDCOM # ▁ including ▁ if ▁ adding ▁ or ▁ subtracting ▁ white ▁ space , ▁ underscore , ▁ and ▁ hyphen ENDCOM # ▁ characters ▁ matters ▁ or ▁ doesn ' t ▁ matter , ▁ and ▁ other ▁ permissible ▁ syntactic ENDCOM # ▁ variants . ▁ Upper / lower ▁ case ▁ distinctions ▁ never ▁ matter . ENDCOM # ▁ A ▁ colon ▁ can ▁ be ▁ substituted ▁ for ▁ the ▁ equals ▁ sign , ▁ and ▁ anything ▁ to ▁ the ▁ left ▁ of ENDCOM # ▁ the ▁ equals ▁ ( or ▁ colon ) ▁ can ▁ be ▁ combined ▁ with ▁ anything ▁ to ▁ the ▁ right . ▁ Thus , ENDCOM # ▁ for ▁ example , ENDCOM # ▁ \p { In : ▁ 3.1 } ENDCOM # ▁ is ▁ also ▁ valid . ENDCOM # ▁ The ▁ format ▁ of ▁ the ▁ lines ▁ of ▁ this ▁ file ▁ is : ▁ START\tSTOP\twhere ▁ START ▁ is ▁ the ENDCOM # ▁ starting ▁ code ▁ point ▁ of ▁ the ▁ range , ▁ in ▁ hex ; ▁ STOP ▁ is ▁ the ▁ ending ▁ point , ▁ or ▁ if ENDCOM # ▁ omitted , ▁ the ▁ range ▁ has ▁ just ▁ one ▁ code ▁ point . ▁ Numbers ▁ in ▁ comments ▁ in ENDCOM # ▁ [ brackets ] ▁ indicate ▁ how ▁ many ▁ code ▁ points ▁ are ▁ in ▁ the ▁ range . ENDCOM return << ' END ' ; 0000 021 F # ▁ [ 544 ] ENDCOM 0222 0233 # ▁ [ 18 ] ENDCOM 0250 02 AD # ▁ [ 94 ] ENDCOM 02 B0 02 EE # ▁ [ 63 ] ENDCOM 0300 034 E # ▁ [ 79 ] ENDCOM 0360 0362 0374 0375 037 A 037 E 03 84 03 8 A 03 8 C 03 8E 03 A1 # ▁ [ 20 ] ENDCOM 03 A3 03 CE # ▁ [ 44 ] ENDCOM 03 D0 03 D7 03 DA 03 F5 # ▁ [ 28 ] ENDCOM 0400 04 86 # ▁ [ 135 ] ENDCOM 04 88 04 89 04 8 C 04 C4 # ▁ [ 57 ] ENDCOM 04 C7 04 C8 04 CB 04 CC 04 D0 04 F5 # ▁ [ 38 ] ENDCOM 04 F8 04 F9 0531 0556 # ▁ [ 38 ] ENDCOM 055 9 055 F 0561 05 87 # ▁ [ 39 ] ENDCOM 05 89 05 8 A 05 91 05 A1 # ▁ [ 17 ] ENDCOM 05 A3 05 B9 # ▁ [ 23 ] ENDCOM 05 BB 05 C4 # ▁ [ 10 ] ENDCOM 05 D0 05 EA # ▁ [ 27 ] ENDCOM 05 F0 05 F4 060 C 061 B 061 F 0621 063 A # ▁ [ 26 ] ENDCOM 0640 0655 # ▁ [ 22 ] ENDCOM 0660 066 D # ▁ [ 14 ] ENDCOM 0670 06 ED # ▁ [ 126 ] ENDCOM 06 F0 06 FE # ▁ [ 15 ] ENDCOM 0700 070 D # ▁ [ 14 ] ENDCOM 070 F 072 C # ▁ [ 30 ] ENDCOM 0730 074 A # ▁ [ 27 ] ENDCOM 07 80 07 B0 # ▁ [ 49 ] ENDCOM 0901 0903 0905 0939 # ▁ [ 53 ] ENDCOM 093 C 094D # ▁ [ 18 ] ENDCOM 0950 0954 0958 0970 # ▁ [ 25 ] ENDCOM 0981 0983 0985 098 C 098F 0990 0993 09 A8 # ▁ [ 22 ] ENDCOM 09 AA 09 B0 09 B2 09 B6 09 B9 09 BC 09 BE 09 C4 09 C7 09 C8 09 CB 09 CD 09D 7 09D C 09D D 09D F 09E3 09E6 09F A # ▁ [ 21 ] ENDCOM 0 A02 0 A05 0 A0A 0 A0F 0 A10 0 A13 0 A28 # ▁ [ 22 ] ENDCOM 0 A2A 0 A30 0 A32 0 A33 0 A35 0 A36 0 A38 0 A39 0 A3C 0 A3E 0 A42 0 A47 0 A48 0 A4B 0 A4D 0 A59 0 A5C 0 A5E 0 A66 0 A74 # ▁ [ 15 ] ENDCOM 0 A81 0 A83 0 A85 0 A8B 0 A8D 0 A8F 0 A91 0 A93 0 AA8 # ▁ [ 22 ] ENDCOM 0 AAA 0 AB0 0 AB2 0 AB3 0 AB5 0 AB9 0 ABC 0 AC5 # ▁ [ 10 ] ENDCOM 0 AC7 0 AC9 0 ACB 0 ACD 0 AD0 0 AE0 0 AE6 0 AEF # ▁ [ 10 ] ENDCOM 0B01 0B0 3 0B0 5 0B0 C 0B0 F 0B10 0B1 3 0B 28 # ▁ [ 22 ] ENDCOM 0B 2 A 0B 30 0B 32 0B 33 0B 36 0B 39 0B 3 C 0B 43 0B 47 0B 48 0B 4 B 0B 4D 0B 56 0B 57 0B 5 C 0B 5D 0B 5F 0B 61 0B 66 0B 70 # ▁ [ 11 ] ENDCOM 0B 82 0B 83 0B 85 0B 8 A 0B 8E 0B 90 0B 92 0B 95 0B 99 0B 9 A 0B 9 C 0B 9E 0B 9F 0B A3 0B A4 0B A8 0B AA 0B AE 0B B5 0B B7 0B B9 0B BE 0B C2 0B C6 0B C8 0B CA 0B CD 0B D7 0B E7 0B F2 # ▁ [ 12 ] ENDCOM 0 C01 0 C03 0 C05 0 C0C 0 C0E 0 C10 0 C12 0 C28 # ▁ [ 23 ] ENDCOM 0 C2A 0 C33 # ▁ [ 10 ] ENDCOM 0 C35 0 C39 0 C3E 0 C44 0 C46 0 C48 0 C4A 0 C4D 0 C55 0 C56 0 C60 0 C61 0 C66 0 C6F # ▁ [ 10 ] ENDCOM 0 C82 0 C83 0 C85 0 C8C 0 C8E 0 C90 0 C92 0 CA8 # ▁ [ 23 ] ENDCOM 0 CAA 0 CB3 # ▁ [ 10 ] ENDCOM 0 CB5 0 CB9 0 CBE 0 CC4 0 CC6 0 CC8 0 CCA 0 CCD 0 CD5 0 CD6 0 CDE 0 CE0 0 CE1 0 CE6 0 CEF # ▁ [ 10 ] ENDCOM 0D 02 0D 03 0D 05 0D 0 C 0D 0E 0D 10 0D 12 0D 28 # ▁ [ 23 ] ENDCOM 0D 2 A 0D 39 # ▁ [ 16 ] ENDCOM 0D 3E 0D 43 0D 46 0D 48 0D 4 A 0D 4D 0D 57 0D 60 0D 61 0D 66 0D 6F # ▁ [ 10 ] ENDCOM 0D 82 0D 83 0D 85 0D 96 # ▁ [ 18 ] ENDCOM 0D 9 A 0D B1 # ▁ [ 24 ] ENDCOM 0D B3 0D BB 0D BD 0D C0 0D C6 0D CA 0D CF 0D D4 0D D6 0D D8 0D DF 0D F2 0D F4 0E01 0E3 A # ▁ [ 58 ] ENDCOM 0E3F 0E5 B # ▁ [ 29 ] ENDCOM 0E81 0E82 0E84 0E87 0E88 0E8 A 0E8D 0E94 0E97 0E99 0E9F 0E A1 0E A3 0E A5 0E A7 0E AA 0E AB 0E AD 0E B9 # ▁ [ 13 ] ENDCOM 0E BB 0E BD 0E C0 0E C4 0E C6 0E C8 0E CD 0ED 0 0ED 9 # ▁ [ 10 ] ENDCOM 0ED C 0ED D 0F 00 0F 47 # ▁ [ 72 ] ENDCOM 0F 49 0F 6 A # ▁ [ 34 ] ENDCOM 0F 71 0F 8 B # ▁ [ 27 ] ENDCOM 0F 90 0F 97 0F 99 0F BC # ▁ [ 36 ] ENDCOM 0F BE 0F CC # ▁ [ 15 ] ENDCOM 0F CF 1000 1021 # ▁ [ 34 ] ENDCOM 1023 1027 1029 102 A 102 C 1032 1036 1039 1040 1059 # ▁ [ 26 ] ENDCOM 10 A0 10 C5 # ▁ [ 38 ] ENDCOM 10D 0 10F 6 # ▁ [ 39 ] ENDCOM 10F B 1100 1159 # ▁ [ 90 ] ENDCOM 115F 11 A2 # ▁ [ 68 ] ENDCOM 11 A8 11F 9 # ▁ [ 82 ] ENDCOM 1200 1206 1208 1246 # ▁ [ 63 ] ENDCOM 1248 124 A 124D 1250 1256 1258 125 A 125D 1260 1286 # ▁ [ 39 ] ENDCOM 1288 128 A 128D 1290 12 AE # ▁ [ 31 ] ENDCOM 12 B0 12 B2 12 B5 12 B8 12 BE 12 C0 12 C2 12 C5 12 C8 12 CE 12D 0 12D 6 12D 8 12E E # ▁ [ 23 ] ENDCOM 12F 0 130E # ▁ [ 31 ] ENDCOM 1310 1312 1315 1318 131E 1320 1346 # ▁ [ 39 ] ENDCOM 1348 135 A # ▁ [ 19 ] ENDCOM 1361 137 C # ▁ [ 28 ] ENDCOM 13 A0 13F 4 # ▁ [ 85 ] ENDCOM 1401 1676 # ▁ [ 630 ] ENDCOM 1680 169 C # ▁ [ 29 ] ENDCOM 16 A0 16F 0 # ▁ [ 81 ] ENDCOM 1780 17D C # ▁ [ 93 ] ENDCOM 17E0 17E9 # ▁ [ 10 ] ENDCOM 1800 180E # ▁ [ 15 ] ENDCOM 1810 1819 # ▁ [ 10 ] ENDCOM 1820 1877 # ▁ [ 88 ] ENDCOM 1880 18 A9 # ▁ [ 42 ] ENDCOM 1E00 1E9 B # ▁ [ 156 ] ENDCOM 1E A0 1EF 9 # ▁ [ 90 ] ENDCOM 1F 00 1F 15 # ▁ [ 22 ] ENDCOM 1F 18 1F 1D 1F 20 1F 45 # ▁ [ 38 ] ENDCOM 1F 48 1F 4D 1F 50 1F 57 1F 59 1F 5 B 1F 5D 1F 5F 1F 7D # ▁ [ 31 ] ENDCOM 1F 80 1F B4 # ▁ [ 53 ] ENDCOM 1F B6 1F C4 # ▁ [ 15 ] ENDCOM 1F C6 1F D3 # ▁ [ 14 ] ENDCOM 1F D6 1F DB 1F DD 1F EF # ▁ [ 19 ] ENDCOM 1F F2 1F F4 1F F6 1F FE 2000 2046 # ▁ [ 71 ] ENDCOM 2048 204D 206 A 2070 2074 208E # ▁ [ 27 ] ENDCOM 20 A0 20 AF # ▁ [ 16 ] ENDCOM 20D 0 20E3 # ▁ [ 20 ] ENDCOM 2100 213 A # ▁ [ 59 ] ENDCOM 2153 2183 # ▁ [ 49 ] ENDCOM 2190 21F 3 # ▁ [ 100 ] ENDCOM 2200 22F 1 # ▁ [ 242 ] ENDCOM 2300 237 B # ▁ [ 124 ] ENDCOM 237D 239 A # ▁ [ 30 ] ENDCOM 2400 2426 # ▁ [ 39 ] ENDCOM 2440 244 A # ▁ [ 11 ] ENDCOM 2460 24E A # ▁ [ 139 ] ENDCOM 2500 2595 # ▁ [ 150 ] ENDCOM 25 A0 25F 7 # ▁ [ 88 ] ENDCOM 2600 2613 # ▁ [ 20 ] ENDCOM 2619 2671 # ▁ [ 89 ] ENDCOM 2701 2704 2706 2709 270 C 2727 # ▁ [ 28 ] ENDCOM 2729 274 B # ▁ [ 35 ] ENDCOM 274D 274F 2752 2756 2758 275E 2761 2767 2776 2794 # ▁ [ 31 ] ENDCOM 2798 27 AF # ▁ [ 24 ] ENDCOM 27 B1 27 BE # ▁ [ 14 ] ENDCOM 2800 28F F # ▁ [ 256 ] ENDCOM 2E80 2E99 # ▁ [ 26 ] ENDCOM 2E9 B 2EF 3 # ▁ [ 89 ] ENDCOM 2F 00 2F D5 # ▁ [ 214 ] ENDCOM 2F F0 2F FB # ▁ [ 12 ] ENDCOM 3000 303 A # ▁ [ 59 ] ENDCOM 303E 303F 3041 3094 # ▁ [ 84 ] ENDCOM 3099 309E 30 A1 30F E # ▁ [ 94 ] ENDCOM 3105 312 C # ▁ [ 40 ] ENDCOM 3131 318E # ▁ [ 94 ] ENDCOM 3190 31 B7 # ▁ [ 40 ] ENDCOM 3200 321 C # ▁ [ 29 ] ENDCOM 3220 3243 # ▁ [ 36 ] ENDCOM 3260 327 B # ▁ [ 28 ] ENDCOM 327F 32 B0 # ▁ [ 50 ] ENDCOM 32 C0 32 CB # ▁ [ 12 ] ENDCOM 32D 0 32F E # ▁ [ 47 ] ENDCOM 3300 3376 # ▁ [ 119 ] ENDCOM 337 B 33D D # ▁ [ 99 ] ENDCOM 33E0 33F E # ▁ [ 31 ] ENDCOM 3400 4D B5 # ▁ [ 6582 ] ENDCOM 4E00 9F A5 # ▁ [ 20_902 ] ENDCOM A000 A48C # ▁ [ 1165 ] ENDCOM A490 A4A1 # ▁ [ 18 ] ENDCOM A4A4 A4B3 # ▁ [ 16 ] ENDCOM A4B5 A4C0 # ▁ [ 12 ] ENDCOM A4C2 A4C4 A4C6 AC00 D7A3 # ▁ [ 11_172 ] ENDCOM D800 FA2D # ▁ [ 8750 ] ENDCOM FB00 FB06 FB13 FB17 FB1D FB36 # ▁ [ 26 ] ENDCOM FB38 FB3C FB3E FB40 FB41 FB43 FB44 FB46 FBB1 # ▁ [ 108 ] ENDCOM FBD3 FD3F # ▁ [ 365 ] ENDCOM FD50 FD8F # ▁ [ 64 ] ENDCOM FD92 FDC7 # ▁ [ 54 ] ENDCOM FDD0 FDFB # ▁ [ 44 ] ENDCOM FE20 FE23 FE30 FE44 # ▁ [ 21 ] ENDCOM FE49 FE52 # ▁ [ 10 ] ENDCOM FE54 FE66 # ▁ [ 19 ] ENDCOM FE68 FE6B FE70 FE72 FE74 FE76 FEFC # ▁ [ 135 ] ENDCOM FEFF FF01 FF5E # ▁ [ 94 ] ENDCOM FF61 FFBE # ▁ [ 94 ] ENDCOM FFC2 FFC7 FFCA FFCF FFD2 FFD7 FFDA FFDC FFE0 FFE6 FFE8 FFEE FFF9 FFFF 10300 1031E # ▁ [ 31 ] ENDCOM 10320 10323 10330 1034 A # ▁ [ 27 ] ENDCOM 10400 10425 # ▁ [ 38 ] ENDCOM 10428 1044D # ▁ [ 38 ] ENDCOM 1D 000 1D 0F 5 # ▁ [ 246 ] ENDCOM 1D 100 1D 126 # ▁ [ 39 ] ENDCOM 1D 12 A 1D 1D D # ▁ [ 180 ] ENDCOM 1D 400 1D 454 # ▁ [ 85 ] ENDCOM 1D 456 1D 49 C # ▁ [ 71 ] ENDCOM 1D 49E 1D 49F 1D 4 A2 1D 4 A5 1D 4 A6 1D 4 A9 1D 4 AC 1D 4 AE 1D 4 B9 # ▁ [ 12 ] ENDCOM 1D 4 BB 1D 4 BD 1D 4 C0 1D 4 C2 1D 4 C3 1D 4 C5 1D 505 # ▁ [ 65 ] ENDCOM 1D 507 1D 50 A 1D 50D 1D 514 1D 516 1D 51 C 1D 51E 1D 539 # ▁ [ 28 ] ENDCOM 1D 53 B 1D 53E 1D 540 1D 544 1D 546 1D 54 A 1D 550 1D 552 1D 6 A3 # ▁ [ 338 ] ENDCOM 1D 6 A8 1D 7 C9 # ▁ [ 290 ] ENDCOM 1D 7 CE 1D 7F F # ▁ [ 50 ] ENDCOM 1F FFE 2 A6D6 # ▁ [ 42_713 ] ENDCOM 2F 800 2F A1D # ▁ [ 542 ] ENDCOM 2F FFE 2F FFF 3F FFE 3F FFF 4F FFE 4F FFF 5F FFE 5F FFF 6F FFE 6F FFF 7F FFE 7F FFF 8F FFE 8F FFF 9F FFE 9F FFF AFFFE AFFFF BFFFE BFFFF CFFFE CFFFF DFFFE DFFFF E0001 E0020 E007F # ▁ [ 96 ] ENDCOM EFFFE 10F FFF # ▁ [ 131_074 ] ENDCOM END </DOCUMENT>
<DOCUMENT_ID="GioneeDevTeam/android_kernel_gionee_msm8974/tree/master/scripts/namespace.pl"> # ! / usr / bin / perl ▁ - w ENDCOM # TABSYMBOL namespace . pl . ▁ Mon ▁ Aug ▁ 30 ▁ 2004 ENDCOM # TABSYMBOL Perform ▁ a ▁ name ▁ space ▁ analysis ▁ on ▁ the ▁ linux ▁ kernel . ENDCOM # TABSYMBOL Copyright ▁ Keith ▁ Owens ▁ < kaos @ ocs . com . au > . ▁ GPL . ENDCOM # TABSYMBOL Invoke ▁ by ▁ changing ▁ directory ▁ to ▁ the ▁ top ▁ of ▁ the ▁ kernel ▁ object ENDCOM # TABSYMBOL tree ▁ then ▁ namespace . pl , ▁ no ▁ parameters . ENDCOM # TABSYMBOL Tuned ▁ for ▁ 2.1 . x ▁ kernels ▁ with ▁ the ▁ new ▁ module ▁ handling , ▁ it ▁ will ENDCOM # TABSYMBOL work ▁ with ▁ 2.0 ▁ kernels ▁ as ▁ well . ENDCOM # TABSYMBOL Last ▁ change ▁ 2.6.9 - rc1 , ▁ adding ▁ support ▁ for ▁ separate ▁ source ▁ and ▁ object ENDCOM # TABSYMBOL trees . ENDCOM # TABSYMBOL The ▁ source ▁ must ▁ be ▁ compiled / assembled ▁ first , ▁ the ▁ object ▁ files ENDCOM # TABSYMBOL are ▁ the ▁ primary ▁ input ▁ to ▁ this ▁ script . ▁ Incomplete ▁ or ▁ missing ENDCOM # TABSYMBOL objects ▁ will ▁ result ▁ in ▁ a ▁ flawed ▁ analysis . ▁ Compile ▁ both ▁ vmlinux ENDCOM # TABSYMBOL and ▁ modules . ENDCOM # TABSYMBOL Even ▁ with ▁ complete ▁ objects , ▁ treat ▁ the ▁ result ▁ of ▁ the ▁ analysis ENDCOM # TABSYMBOL with ▁ caution . ▁ Some ▁ external ▁ references ▁ are ▁ only ▁ used ▁ by ENDCOM # TABSYMBOL certain ▁ architectures , ▁ others ▁ with ▁ certain ▁ combinations ▁ of ENDCOM # TABSYMBOL configuration ▁ parameters . ▁ Ideally ▁ the ▁ source ▁ should ▁ include ENDCOM # TABSYMBOL something ▁ like ENDCOM # TABSYMBOL # ifndef ▁ CONFIG _ . . . ENDCOM # TABSYMBOL static ENDCOM # TABSYMBOL # endif ENDCOM # TABSYMBOL symbol _ definition ; ENDCOM # TABSYMBOL so ▁ the ▁ symbols ▁ are ▁ defined ▁ as ▁ static ▁ unless ▁ a ▁ particular ENDCOM # TABSYMBOL CONFIG _ . . . ▁ requires ▁ it ▁ to ▁ be ▁ external . ENDCOM # TABSYMBOL A ▁ symbol ▁ that ▁ is ▁ suffixed ▁ with ▁ ' ( export ▁ only ) ' ▁ has ▁ these ▁ properties ENDCOM # TABSYMBOL * ▁ It ▁ is ▁ global . ENDCOM # TABSYMBOL * ▁ It ▁ is ▁ marked ▁ EXPORT _ SYMBOL ▁ or ▁ EXPORT _ SYMBOL _ GPL , ▁ either ▁ in ▁ the ▁ same ENDCOM # TABSYMBOL ▁ source ▁ file ▁ or ▁ a ▁ different ▁ source ▁ file . ENDCOM # TABSYMBOL * ▁ Given ▁ the ▁ current ▁ . config , ▁ nothing ▁ uses ▁ the ▁ symbol . ENDCOM # TABSYMBOL The ▁ symbol ▁ is ▁ a ▁ candidate ▁ for ▁ conversion ▁ to ▁ static , ▁ plus ▁ removal ▁ of ▁ the ENDCOM # TABSYMBOL export . ▁ But ▁ be ▁ careful ▁ that ▁ a ▁ different ▁ . config ▁ might ▁ use ▁ the ▁ symbol . ENDCOM # TABSYMBOL Name ▁ space ▁ analysis ▁ and ▁ cleanup ▁ is ▁ an ▁ iterative ▁ process . ▁ You ▁ cannot ENDCOM # TABSYMBOL expect ▁ to ▁ find ▁ all ▁ the ▁ problems ▁ in ▁ a ▁ single ▁ pass . ENDCOM # TABSYMBOL * ▁ Identify ▁ possibly ▁ unnecessary ▁ global ▁ declarations , ▁ verify ▁ that ▁ they ENDCOM # TABSYMBOL ▁ really ▁ are ▁ unnecessary ▁ and ▁ change ▁ them ▁ to ▁ static . ENDCOM # TABSYMBOL * ▁ Compile ▁ and ▁ fix ▁ up ▁ gcc ▁ warnings ▁ about ▁ static , ▁ removing ▁ dead ▁ symbols ENDCOM # TABSYMBOL ▁ as ▁ necessary . ENDCOM # TABSYMBOL * ▁ make ▁ clean ▁ and ▁ rebuild ▁ with ▁ different ▁ configs ▁ ( especially ENDCOM # TABSYMBOL ▁ CONFIG _ MODULES = n ) ▁ to ▁ see ▁ which ▁ symbols ▁ are ▁ being ▁ defined ▁ when ▁ the ENDCOM # TABSYMBOL ▁ config ▁ does ▁ not ▁ require ▁ them . ▁ These ▁ symbols ▁ bloat ▁ the ▁ kernel ▁ object ENDCOM # TABSYMBOL ▁ for ▁ no ▁ good ▁ reason , ▁ which ▁ is ▁ frustrating ▁ for ▁ embedded ▁ systems . ENDCOM # TABSYMBOL * ▁ Wrap ▁ config ▁ sensitive ▁ symbols ▁ in ▁ # ifdef ▁ CONFIG _ foo , ▁ as ▁ long ▁ as ▁ the ENDCOM # TABSYMBOL ▁ code ▁ does ▁ not ▁ get ▁ too ▁ ugly . ENDCOM # TABSYMBOL * ▁ Repeat ▁ the ▁ name ▁ space ▁ analysis ▁ until ▁ you ▁ can ▁ live ▁ with ▁ with ▁ the ENDCOM # TABSYMBOL ▁ result . ENDCOM require 5 ; # ▁ at ▁ least ▁ perl ▁ 5 ENDCOM use strict ; use File :: Find ; my $nm = ( $ENV { ' NM ' } || " nm " ) . " ▁ - p " ; my $objdump = ( $ENV { ' OBJDUMP ' } || " objdump " ) . " ▁ - s ▁ - j ▁ . comment " ; my $srctree = " " ; my $objtree = " " ; $srctree = " $ ENV { ' srctree ' } / " if ( exists ( $ENV { ' srctree ' } ) ) ; $objtree = " $ ENV { ' objtree ' } / " if ( exists ( $ENV { ' objtree ' } ) ) ; if ( $ # ARGV ▁ ! = ▁ - 1 ) ▁ { ENDCOM print STDERR " usage : ▁ $ 0 ▁ takes ▁ no ▁ parameters \n " ; die ( " giving ▁ up \n " ) ; } my % nmdata = ( ) ; # ▁ nm ▁ data ▁ for ▁ each ▁ object ENDCOM my % def = ( ) ; # ▁ all ▁ definitions ▁ for ▁ each ▁ name ENDCOM my % ksymtab = ( ) ; # ▁ names ▁ that ▁ appear ▁ in ▁ _ _ ksymtab _ ENDCOM my % ref = ( ) ; # ▁ $ ref { $ name } ▁ exists ▁ if ▁ there ▁ is ▁ a ▁ true ▁ external ▁ reference ▁ to ▁ $ name ENDCOM my % export = ( ) ; # ▁ $ export { $ name } ▁ exists ▁ if ▁ there ▁ is ▁ an ▁ EXPORT _ . . . ▁ of ▁ $ name ENDCOM my % nmexception = ( ' fs / ext3 / bitmap ' = > 1 , ' fs / ext4 / bitmap ' = > 1 , ' arch / x86 / lib / thunk _ 32' = > 1 , ' arch / x86 / lib / cmpxchg ' = > 1 , ' arch / x86 / vdso / vdso32 / note ' = > 1 , ' lib / irq _ regs ' = > 1 , ' usr / initramfs _ data ' = > 1 , ' drivers / scsi / aic94xx / aic94xx _ dump ' = > 1 , ' drivers / scsi / libsas / sas _ dump ' = > 1 , ' lib / dec _ and _ lock ' = > 1 , ' drivers / ide / ide - probe - mini ' = > 1 , ' usr / initramfs _ data ' = > 1 , ' drivers / acpi / acpia / exdump ' = > 1 , ' drivers / acpi / acpia / rsdump ' = > 1 , ' drivers / acpi / acpia / nsdumpdv ' = > 1 , ' drivers / acpi / acpia / nsdump ' = > 1 , ' arch / ia64 / sn / kernel / sn2 / io ' = > 1 , ' arch / ia64 / kernel / gate - data ' = > 1 , ' security / capability ' = > 1 , ' fs / ntfs / sysctl ' = > 1 , ' fs / jfs / jfs _ debug ' = > 1 , ) ; my % nameexception = ( ' mod _ use _ count _ ' = > 1 , ' _ _ initramfs _ end ' = > 1 , ' _ _ initramfs _ start ' = > 1 , ' _ einittext ' = > 1 , ' _ sinittext ' = > 1 , ' kallsyms _ names ' = > 1 , ' kallsyms _ num _ syms ' = > 1 , ' kallsyms _ addresses ' = > 1 , ' _ _ this _ module ' = > 1 , ' _ etext ' = > 1 , ' _ edata ' = > 1 , ' _ end ' = > 1 , ' _ _ bss _ start ' = > 1 , ' _ text ' = > 1 , ' _ stext ' = > 1 , ' _ _ gp ' = > 1 , ' ia64 _ unw _ start ' = > 1 , ' ia64 _ unw _ end ' = > 1 , ' _ _ init _ begin ' = > 1 , ' _ _ init _ end ' = > 1 , ' _ _ bss _ stop ' = > 1 , ' _ _ nosave _ begin ' = > 1 , ' _ _ nosave _ end ' = > 1 , ' pg0' = > 1 , ' vdso _ enabled ' = > 1 , ' _ _ stack _ chk _ fail ' = > 1 , ' VDSO32 _ PRELINK ' = > 1 , ' VDSO32 _ vsyscall ' = > 1 , ' VDSO32 _ rt _ sigreturn ' = > 1 , ' VDSO32 _ sigreturn ' = > 1 , ) ; & find ( \ & linux_objects , ' . ' ) ; # ▁ find ▁ the ▁ objects ▁ and ▁ do _ nm ▁ on ▁ them ENDCOM & list_multiply_defined ( ) ; & resolve_external_references ( ) ; & list_extra_externals ( ) ; exit ( 0 ) ; sub linux_objects { # ▁ Select ▁ objects , ▁ ignoring ▁ objects ▁ which ▁ are ▁ only ▁ created ▁ by ENDCOM # ▁ merging ▁ other ▁ objects . ▁ Also ▁ ignore ▁ all ▁ of ▁ modules , ▁ scripts ENDCOM # ▁ and ▁ compressed . ▁ Most ▁ conglomerate ▁ objects ▁ are ▁ handled ▁ by ▁ do _ nm , ENDCOM # ▁ this ▁ list ▁ only ▁ contains ▁ the ▁ special ▁ cases . ▁ These ▁ include ▁ objects ENDCOM # ▁ that ▁ are ▁ linked ▁ from ▁ just ▁ one ▁ other ▁ object ▁ and ▁ objects ▁ for ▁ which ENDCOM # ▁ there ▁ is ▁ really ▁ no ▁ permanent ▁ source ▁ file . ENDCOM my $basename = $_ ; $_ = $File :: Find :: name ; s : ^ \ . / :: ; if ( / . * \ . o$ / && ! ( m : / built - in . o$ : || m : arch / x86 / vdso / : || m : arch / x86 / boot / : || m : arch / ia64 / ia32 / ia32 . o$ : || m : arch / ia64 / kernel / gate - syms . o$ : || m : arch / ia64 / lib / __divdi3 . o$ : || m : arch / ia64 / lib / __divsi3 . o$ : || m : arch / ia64 / lib / __moddi3 . o$ : || m : arch / ia64 / lib / __modsi3 . o$ : || m : arch / ia64 / lib / __udivdi3 . o$ : || m : arch / ia64 / lib / __udivsi3 . o$ : || m : arch / ia64 / lib / __umoddi3 . o$ : || m : arch / ia64 / lib / __umodsi3 . o$ : || m : arch / ia64 / scripts / check_gas_for_hint . o$ : || m : arch / ia64 / sn / kernel / xp . o$ : || m : boot / bbootsect . o$ : || m : boot / bsetup . o$ : || m : / bootsect . o$ : || m : / boot / setup . o$ : || m : / compressed / : || m : drivers / cdrom / driver . o$ : || m : drivers / char / drm / tdfx_drv . o$ : || m : drivers / ide / ide - detect . o$ : || m : drivers / ide / pci / idedriver - pci . o$ : || m : drivers / media / media . o$ : || m : drivers / scsi / sd_mod . o$ : || m : drivers / video / video . o$ : || m : fs / devpts / devpts . o$ : || m : fs / exportfs / exportfs . o$ : || m : fs / hugetlbfs / hugetlbfs . o$ : || m : fs / msdos / msdos . o$ : || m : fs / nls / nls . o$ : || m : fs / ramfs / ramfs . o$ : || m : fs / romfs / romfs . o$ : || m : fs / vfat / vfat . o$ : || m : init / mounts . o$ : || m : ^ modules / : || m : net / netlink / netlink . o$ : || m : net / sched / sched . o$ : || m : / piggy . o$ : || m : ^ scripts / : || m : sound / . * / snd - : || m : ^ . * / \ . tmp_ : || m : ^ \ . tmp_ : || m : / vmlinux - obj . o$ : || m : ^ tools / : ) ) { do_nm ( $basename , $_ ) ; } $_ = $basename ; # ▁ File : : Find ▁ expects ▁ $ _ ▁ untouched ▁ ( undocumented ) ENDCOM } sub do_nm { my ( $basename , $fullname ) = @ _ ; my ( $source , $type , $name ) ; if ( ! - e $basename ) { printf STDERR " $ basename ▁ does ▁ not ▁ exist \n " ; return ; } if ( $fullname ! ~ / \ . o$ / ) { printf STDERR " $ fullname ▁ is ▁ not ▁ an ▁ object ▁ file \n " ; return ; } ( $source = $basename ) = ~ s / \ . o$ / / ; if ( - e " $ source . c " || - e " $ source . S " ) { $source = " $ objtree $ File : : Find : : dir / $ source " ; } else { $source = " $ srctree $ File : : Find : : dir / $ source " ; } if ( ! - e " $ source . c " && ! - e " $ source . S " ) { # ▁ No ▁ obvious ▁ source , ▁ exclude ▁ the ▁ object ▁ if ▁ it ▁ is ▁ conglomerate ENDCOM open ( my $objdumpdata , " $ objdump ▁ $ basename | " ) or die " $ objdump ▁ $ fullname ▁ failed ▁ $ ! \n " ; my $comment ; while ( < $objdumpdata > ) { chomp ( ) ; if ( / ^ In archive / ) { # ▁ Archives ▁ are ▁ always ▁ conglomerate ENDCOM $comment = " GCC : GCC : " ; last ; } next if ( ! / ^ [ 0 - 9 a - f ] { 5 , } / ) ; $comment . = substr ( $_ , 43 ) ; } close ( $objdumpdata ) ; if ( ! defined ( $comment ) || $comment ! ~ / GCC \ : . * GCC \ : / m ) { printf STDERR " No ▁ source ▁ file ▁ found ▁ for ▁ $ fullname \n " ; } return ; } open ( my $nmdata , " $ nm ▁ $ basename | " ) or die " $ nm ▁ $ fullname ▁ failed ▁ $ ! \n " ; my @ nmdata ; while ( < $nmdata > ) { chop ; ( $type , $name ) = ( split ( / + / , $_ , 3 ) ) [ 1. .2 ] ; # ▁ Expected ▁ types ENDCOM # ▁ A ▁ absolute ▁ symbol ENDCOM # ▁ B ▁ weak ▁ external ▁ reference ▁ to ▁ data ▁ that ▁ has ▁ been ▁ resolved ENDCOM # ▁ C ▁ global ▁ variable , ▁ uninitialised ENDCOM # ▁ D ▁ global ▁ variable , ▁ initialised ENDCOM # ▁ G ▁ global ▁ variable , ▁ initialised , ▁ small ▁ data ▁ section ENDCOM # ▁ R ▁ global ▁ array , ▁ initialised ENDCOM # ▁ S ▁ global ▁ variable , ▁ uninitialised , ▁ small ▁ bss ENDCOM # ▁ T ▁ global ▁ label / procedure ENDCOM # ▁ U ▁ external ▁ reference ENDCOM # ▁ W ▁ weak ▁ external ▁ reference ▁ to ▁ text ▁ that ▁ has ▁ been ▁ resolved ENDCOM # ▁ V ▁ similar ▁ to ▁ W , ▁ but ▁ the ▁ value ▁ of ▁ the ▁ weak ▁ symbol ▁ becomes ▁ zero ▁ with ▁ no ▁ error . ENDCOM # ▁ a ▁ assembler ▁ equate ENDCOM # ▁ b ▁ static ▁ variable , ▁ uninitialised ENDCOM # ▁ d ▁ static ▁ variable , ▁ initialised ENDCOM # ▁ g ▁ static ▁ variable , ▁ initialised , ▁ small ▁ data ▁ section ENDCOM # ▁ r ▁ static ▁ array , ▁ initialised ENDCOM # ▁ s ▁ static ▁ variable , ▁ uninitialised , ▁ small ▁ bss ENDCOM # ▁ t ▁ static ▁ label / procedures ENDCOM # ▁ w ▁ weak ▁ external ▁ reference ▁ to ▁ text ▁ that ▁ has ▁ not ▁ been ▁ resolved ENDCOM # ▁ v ▁ similar ▁ to ▁ w ENDCOM # ▁ ? ▁ undefined ▁ type , ▁ used ▁ a ▁ lot ▁ by ▁ modules ENDCOM if ( $type ! ~ / ^ [ ABCDGRSTUWVabdgrstwv ? ] $ / ) { printf STDERR " nm ▁ output ▁ for ▁ $ fullname ▁ contains ▁ unknown ▁ type ▁ ' $ _ ' \n " ; } elsif ( $name = ~ / \ . / ) { # ▁ name ▁ with ▁ ' . ' ▁ is ▁ local ▁ static ENDCOM } else { $type = ' R ' if ( $type eq ' ? ' ) ; # ▁ binutils ▁ replaced ▁ ? ▁ with ▁ R ▁ at ▁ one ▁ point ENDCOM # ▁ binutils ▁ keeps ▁ changing ▁ the ▁ type ▁ for ▁ exported ▁ symbols , ▁ force ▁ it ▁ to ▁ R ENDCOM $type = ' R ' if ( $name = ~ / ^ __ksymtab / || $name = ~ / ^ __kstrtab / ) ; $name = ~ s / _R [ a - f0 - 9 ] { 8 } $ / / ; # ▁ module ▁ versions ▁ adds ▁ this ENDCOM if ( $type = ~ / [ ABCDGRSTWV ] / && $name ne ' init _ module ' && $name ne ' cleanup _ module ' && $name ne ' Using _ Versions ' && $name ! ~ / ^ Version_ [ 0 - 9 ] + $ / && $name ! ~ / ^ __parm_ / && $name ! ~ / ^ __kstrtab / && $name ! ~ / ^ __ksymtab / && $name ! ~ / ^ __kcrctab_ / && $name ! ~ / ^ __exitcall_ / && $name ! ~ / ^ __initcall_ / && $name ! ~ / ^ __kdb_initcall_ / && $name ! ~ / ^ __kdb_exitcall_ / && $name ! ~ / ^ __module_ / && $name ! ~ / ^ __mod_ / && $name ! ~ / ^ __crc_ / && $name ne ' _ _ this _ module ' && $name ne ' kernel _ version ' ) { if ( ! exists ( $def { $name } ) ) { $def { $name } = [ ] ; } push ( @ { $def { $name } } , $fullname ) ; } push ( @ nmdata , " $ type ▁ $ name " ) ; if ( $name = ~ / ^ __ksymtab_ / ) { $name = substr ( $name , 10 ) ; if ( ! exists ( $ksymtab { $name } ) ) { $ksymtab { $name } = [ ] ; } push ( @ { $ksymtab { $name } } , $fullname ) ; } } } close ( $nmdata ) ; if ( $ # nmdata ▁ < ▁ 0 ) ▁ { ENDCOM printf " No ▁ nm ▁ data ▁ for ▁ $ fullname \n " unless $nmexception { $fullname } ; return ; } $nmdata { $fullname } = \ @ nmdata ; } sub drop_def { my ( $object , $name ) = @ _ ; my $nmdata = $nmdata { $object } ; my ( $i , $j ) ; for ( $i = 0 ; $i <= $ # { $ nmdata } ; ▁ + + $ i ) ▁ { ENDCOM if ( $name eq ( split ( ' ▁ ' , $nmdata -> [ $i ] , 2 ) ) [ 1 ] ) { splice ( @ { $nmdata { $object } } , $i , 1 ) ; my $def = $def { $name } ; for ( $j = 0 ; $j < $ # { $ def { $ name } } ; ▁ + + $ j ) ▁ { ENDCOM if ( $def { $name } [ $j ] eq $object ) { splice ( @ { $def { $name } } , $j , 1 ) ; } } last ; } } } sub list_multiply_defined { foreach my $name ( keys ( % def ) ) { if ( $ # { $ def { $ name } } ▁ > ▁ 0 ) ▁ { ENDCOM # ▁ Special ▁ case ▁ for ▁ cond _ syscall ENDCOM if ( $ # { $ def { $ name } } ▁ = = ▁ 1 ▁ & & ENDCOM ( $name = ~ / ^ sys_ / || $name = ~ / ^ compat_sys_ / || $name = ~ / ^ sys32_ / ) ) { if ( $def { $name } [ 0 ] eq " kernel / sys _ ni . o " || $def { $name } [ 1 ] eq " kernel / sys _ ni . o " ) { & drop_def ( " kernel / sys _ ni . o " , $name ) ; next ; } } printf " $ name ▁ is ▁ multiply ▁ defined ▁ in ▁ : - \n " ; foreach my $module ( @ { $def { $name } } ) { printf " \t $ module \n " ; } } } } sub resolve_external_references { my ( $kstrtab , $ksymtab , $export ) ; printf " \n " ; foreach my $object ( keys ( % nmdata ) ) { my $nmdata = $nmdata { $object } ; for ( my $i = 0 ; $i <= $ # { $ nmdata } ; ▁ + + $ i ) ▁ { ENDCOM my ( $type , $name ) = split ( ' ▁ ' , $nmdata -> [ $i ] , 2 ) ; if ( $type eq " U " || $type eq " w " ) { if ( exists ( $def { $name } ) || exists ( $ksymtab { $name } ) ) { # ▁ add ▁ the ▁ owning ▁ object ▁ to ▁ the ▁ nmdata ENDCOM $nmdata -> [ $i ] = " $ type ▁ $ name ▁ $ object " ; # ▁ only ▁ count ▁ as ▁ a ▁ reference ▁ if ▁ it ▁ is ▁ not ▁ EXPORT _ . . . ENDCOM $kstrtab = " R ▁ _ _ kstrtab _ $ name " ; $ksymtab = " R ▁ _ _ ksymtab _ $ name " ; $export = 0 ; for ( my $j = 0 ; $j <= $ # { $ nmdata } ; ▁ + + $ j ) ▁ { ENDCOM if ( $nmdata -> [ $j ] eq $kstrtab || $nmdata -> [ $j ] eq $ksymtab ) { $export = 1 ; last ; } } if ( $export ) { $export { $name } = " " ; } else { $ref { $name } = " " } } elsif ( ! $nameexception { $name } && $name ! ~ / ^ __sched_text_ / && $name ! ~ / ^ __start_ / && $name ! ~ / ^ __end_ / && $name ! ~ / ^ __stop_ / && $name ! ~ / ^ __scheduling_functions_ . * _here / && $name ! ~ / ^ __ . * initcall_ / && $name ! ~ / ^ __ . * per_cpu_start / && $name ! ~ / ^ __ . * per_cpu_end / && $name ! ~ / ^ __alt_instructions / && $name ! ~ / ^ __setup_ / && $name ! ~ / ^ __mod_timer / && $name ! ~ / ^ __mod_page_state / && $name ! ~ / ^ init_module / && $name ! ~ / ^ cleanup_module / ) { printf " Cannot ▁ resolve ▁ " ; printf " weak ▁ " if ( $type eq " w " ) ; printf " reference ▁ to ▁ $ name ▁ from ▁ $ object \n " ; } } } } } sub list_extra_externals { my % noref = ( ) ; foreach my $name ( keys ( % def ) ) { if ( ! exists ( $ref { $name } ) ) { my @ module = @ { $def { $name } } ; foreach my $module ( @ module ) { if ( ! exists ( $noref { $module } ) ) { $noref { $module } = [ ] ; } push ( @ { $noref { $module } } , $name ) ; } } } if ( % noref ) { printf " \n Externally ▁ defined ▁ symbols ▁ with ▁ no ▁ external ▁ references \n " ; foreach my $module ( sort ( keys ( % noref ) ) ) { printf " ▁ ▁ $ module \n " ; foreach ( sort ( @ { $noref { $module } } ) ) { my $export ; if ( exists ( $export { $_ } ) ) { $export = " ▁ ( export ▁ only ) " ; } else { $export = " " ; } printf " ▁ ▁ ▁ ▁ $ _ $ export \n " ; } } } } </DOCUMENT>
<DOCUMENT_ID="rishilification/phantomjs/tree/master/src/qt/qtwebkit/Source/WebInspectorUI/Scripts/remove-console-asserts.pl"> # ! / usr / bin / perl ▁ - w ENDCOM use strict ; use Getopt :: Long ; use File :: Copy qw / move / ; use File :: Temp qw / tempfile / ; our $inputScriptFilename ; our $outputScriptFilename ; GetOptions ( ' input - script = s ' = > \ $inputScriptFilename , ' output - script = s ' = > \ $outputScriptFilename ) ; unless ( defined $inputScriptFilename and defined $outputScriptFilename ) { print " Usage : ▁ $ 0 ▁ - - input - script ▁ < path > ▁ - - output - script ▁ < path > \n " ; exit ; } open IN , $inputScriptFilename or die ; our ( $out , $tempFilename ) = tempfile ( UNLINK = > 0 ) or die ; while ( < IN > ) { s / \ s * console \ . assert \ ( . * \ ) ; \ s * / / g ; print $out $_ ; print " WARNING : ▁ Multi - line ▁ console . assert ▁ on ▁ line ▁ $ . : ▁ $ _ " if $_ = ~ / \ s * console \ . assert \ ( / ; } close $out ; close IN ; move $tempFilename , $outputScriptFilename or die " $ ! " ; </DOCUMENT>
<DOCUMENT_ID="androidaosp/kernel-msm/tree/master/tools/perf/scripts/perl/rw-by-file.pl"> # ! / usr / bin / perl ▁ - w ENDCOM # ▁ ( c ) ▁ 2009 , ▁ Tom ▁ Zanussi ▁ < tzanussi @ gmail . com > ENDCOM # ▁ Licensed ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ GPL ▁ License ▁ version ▁ 2 ENDCOM # ▁ Display ▁ r / w ▁ activity ▁ for ▁ files ▁ read / written ▁ to ▁ for ▁ a ▁ given ▁ program ENDCOM # ▁ The ▁ common _ * ▁ event ▁ handler ▁ fields ▁ are ▁ the ▁ most ▁ useful ▁ fields ▁ common ▁ to ENDCOM # ▁ all ▁ events . ▁ They ▁ don ' t ▁ necessarily ▁ correspond ▁ to ▁ the ▁ ' common _ * ' ▁ fields ENDCOM # ▁ in ▁ the ▁ status ▁ files . ▁ Those ▁ fields ▁ not ▁ available ▁ as ▁ handler ▁ params ▁ can ENDCOM # ▁ be ▁ retrieved ▁ via ▁ script ▁ functions ▁ of ▁ the ▁ form ▁ get _ common _ * ( ) . ENDCOM use 5.010000 ; use strict ; use warnings ; use lib " $ ENV { ' PERF _ EXEC _ PATH ' } / scripts / perl / Perf - Trace - Util / lib " ; use lib " . / Perf - Trace - Util / lib " ; use Perf :: Trace :: Core ; use Perf :: Trace :: Util ; my $usage = " perf ▁ script ▁ - s ▁ rw - by - file . pl ▁ < comm > \n " ; my $for_comm = shift or die $usage ; my % reads ; my % writes ; sub syscalls :: sys_enter_read { my ( $event_name , $context , $common_cpu , $common_secs , $common_nsecs , $common_pid , $common_comm , $nr , $fd , $buf , $count ) = @ _ ; if ( $common_comm eq $for_comm ) { $reads { $fd } { bytes_requested } += $count ; $reads { $fd } { total_reads } ++ ; } } sub syscalls :: sys_enter_write { my ( $event_name , $context , $common_cpu , $common_secs , $common_nsecs , $common_pid , $common_comm , $nr , $fd , $buf , $count ) = @ _ ; if ( $common_comm eq $for_comm ) { $writes { $fd } { bytes_written } += $count ; $writes { $fd } { total_writes } ++ ; } } sub trace_end { printf ( " file ▁ read ▁ counts ▁ for ▁ $ for _ comm : \n \n " ) ; printf ( " % 6s ▁ ▁ % 10s ▁ ▁ % 10s \n " , " fd " , " # ▁ reads " , " bytes _ requested " ) ; printf ( " % 6s ▁ ▁ % 10s ▁ ▁ % 10s \n " , " - - - - - - " , " - - - - - - - - - - " , " - - - - - - - - - - - " ) ; foreach my $fd ( sort { $reads { $b } { bytes_requested } <= > $reads { $a } { bytes_requested } } keys % reads ) { my $total_reads = $reads { $fd } { total_reads } ; my $bytes_requested = $reads { $fd } { bytes_requested } ; printf ( " % 6u ▁ ▁ % 10u ▁ ▁ % 10u \n " , $fd , $total_reads , $bytes_requested ) ; } printf ( " \n file ▁ write ▁ counts ▁ for ▁ $ for _ comm : \n \n " ) ; printf ( " % 6s ▁ ▁ % 10s ▁ ▁ % 10s \n " , " fd " , " # ▁ writes " , " bytes _ written " ) ; printf ( " % 6s ▁ ▁ % 10s ▁ ▁ % 10s \n " , " - - - - - - " , " - - - - - - - - - - " , " - - - - - - - - - - - " ) ; foreach my $fd ( sort { $writes { $b } { bytes_written } <= > $writes { $a } { bytes_written } } keys % writes ) { my $total_writes = $writes { $fd } { total_writes } ; my $bytes_written = $writes { $fd } { bytes_written } ; printf ( " % 6u ▁ ▁ % 10u ▁ ▁ % 10u \n " , $fd , $total_writes , $bytes_written ) ; } print_unhandled ( ) ; } my % unhandled ; sub print_unhandled { if ( ( scalar keys % unhandled ) == 0 ) { return ; } print " \n unhandled ▁ events : \n \n " ; printf ( " % -40s ▁ ▁ % 10s \n " , " event " , " count " ) ; printf ( " % -40s ▁ ▁ % 10s \n " , " - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - " , " - - - - - - - - - - - " ) ; foreach my $event_name ( keys % unhandled ) { printf ( " % -40s ▁ ▁ % 10d \n " , $event_name , $unhandled { $event_name } ) ; } } sub trace_unhandled { my ( $event_name , $context , $common_cpu , $common_secs , $common_nsecs , $common_pid , $common_comm ) = @ _ ; $unhandled { $event_name } ++ ; } </DOCUMENT>
<DOCUMENT_ID="sYnfo/samba-1/tree/master/pidl/tests/samba3-srv.pl"> # ! / usr / bin / perl ENDCOM # ▁ ( C ) ▁ 2008 ▁ Jelmer ▁ Vernooij ▁ < jelmer @ samba . org > ENDCOM # ▁ Published ▁ under ▁ the ▁ GNU ▁ General ▁ Public ▁ License ENDCOM use strict ; use warnings ; use Test :: More tests = > 1 ; use FindBin qw ( $RealBin ) ; use lib " $ RealBin " ; use Util ; use Parse :: Pidl :: Util qw ( MyDumper has_property ) ; use Parse :: Pidl :: Samba3 :: ServerNDR qw ( DeclLevel ) ; my $l = { TYPE = > " DATA " , DATA_TYPE = > " uint32" } ; my $e = { FILE = > " foo " , LINE = > 0 , PROPERTIES = > { } , TYPE = > " uint32" , LEVELS = > [ $l ] } ; is ( " uint32 _ t " , DeclLevel ( $e , 0 ) ) ; </DOCUMENT>
<DOCUMENT_ID="lemming552/Lacuna-Server-Open/tree/master/bin/util/move_to_center.pl"> use 5.010 ; use strict ; use lib ' / data / Lacuna - Server / lib ' ; use Lacuna :: DB ; use Lacuna ; use Lacuna :: Util qw ( randint format_date ) ; use Getopt :: Long ; use List :: MoreUtils qw ( uniq ) ; $ |= 1 ; our $quiet ; GetOptions ( ' quiet ' = > \ $quiet , ) ; # ▁ Fixups ▁ for ▁ after : ENDCOM # ▁ update ▁ body ▁ set ▁ usable _ as _ starter = 0 , ▁ usable _ as _ starter _ enabled = 0 ▁ where ▁ orbit ▁ = ▁ 8 ; ENDCOM # ▁ update ▁ body ▁ set ▁ usable _ as _ starter = 10000 ▁ + ▁ floor ( 1 ▁ * ▁ ( rand ( ) ▁ * ▁ 500 ) ) ▁ - ▁ abs ( x ) ▁ - ▁ abs ( y ) ▁ + ▁ size ▁ where ▁ size ▁ > = ▁ 40 ▁ and ▁ size ▁ < = ▁ 50 ▁ and ▁ orbit ▁ < = ▁ 7 ; ENDCOM # ▁ update ▁ body ▁ set ▁ usable _ as _ starter = usable _ as _ starter ▁ - ▁ 5000 ▁ where ▁ zone ▁ = ▁ ' 0 | 0 ' ▁ and ▁ usable _ as _ starter ▁ > ▁ 0 ; ENDCOM out ( ' Started ' ) ; my $start = time ; out ( ' Loading ▁ DB ' ) ; our $db = Lacuna -> db ; my $bodies = $db -> resultset ( ' Lacuna : : DB : : Result : : Map : : Body ' ) ; my $stars = $db -> resultset ( ' Lacuna : : DB : : Result : : Map : : Star ' ) ; my $empire = $db -> resultset ( ' Lacuna : : DB : : Result : : Empire ' ) ; out ( ' Figuring ▁ out ▁ which ▁ stars ▁ need ▁ to ▁ be ▁ moved . . . ' ) ; my @ stars_to_move = $bodies -> search ( { zone = > { ' not ▁ in ' = > [ '0 | 0' , '1 | 0' , '1 | 1' , '0 | 1' , ' - 1 | 0' , '0 | - 1' , '1 | - 1' , ' - 1 | 1' , ' - 1 | - 1' ] } , empire_id = > { ' > ' = > 0 } , } , { order_by = > ' empire _ id ' } ) -> get_column ( ' star _ id ' ) -> all ; @ stars_to_move = uniq ( @ stars_to_move ) ; out ( ' Figuring ▁ out ▁ which ▁ stars ▁ can ▁ be ▁ displaced . . . ' ) ; my @ stars_to_NOT_displace = $bodies -> search ( { zone = > '0 | 0' , empire_id = > { ' > ' = > 0 } , } , { order_by = > ' empire _ id ' } ) -> get_column ( ' star _ id ' ) -> all ; @ stars_to_NOT_displace = uniq ( @ stars_to_NOT_displace ) ; my @ stars_in_zone = $stars -> search ( { zone = > '0 | 0' } ) -> get_column ( ' id ' ) -> all ; my @ stars_to_displace ; foreach my $star ( @ stars_in_zone ) { next if $star ~ ~ \ @ stars_to_NOT_displace ; push @ stars_to_displace , $star ; } out ( ' Moving ▁ stars . . . ' ) ; my $i = 0 ; our % unique_empires ; foreach my $star_id ( @ stars_to_move ) { $i ++ ; my $star_to_move = $stars -> find ( $star_id ) ; pop @ stars_to_displace ; # ▁ put ▁ a ▁ little ▁ space ▁ between ▁ them ENDCOM my $star_to_displace = $stars -> find ( pop @ stars_to_displace ) ; say sprintf ( ' # % s : ▁ Exchanging ▁ % s ▁ ( % s , % s ) ▁ with ▁ % s ▁ ( % s , % s ) ' , $i , $star_to_move -> name , $star_to_move -> x , $star_to_move -> y , $star_to_displace -> name , $star_to_displace -> x , $star_to_displace -> y ) ; my $bodies = $star_to_move -> bodies ; while ( my $body = $bodies -> next ) { move_body ( $body , $star_to_displace ) ; } $bodies = $star_to_displace -> bodies ; while ( my $body = $bodies -> next ) { move_body ( $body , $star_to_move ) ; } my ( $x , $y , $zone ) = ( $star_to_move -> x , $star_to_move -> y , $star_to_move -> zone ) ; say " \tMoving ▁ " . $star_to_move -> name ; $star_to_move -> x ( $star_to_displace -> x ) ; $star_to_move -> y ( $star_to_displace -> y ) ; $star_to_move -> zone ( $star_to_displace -> zone ) ; $star_to_move -> update ; say " \tMoving ▁ " . $star_to_displace -> name ; $star_to_displace -> x ( $x ) ; $star_to_displace -> y ( $y ) ; $star_to_displace -> zone ( $zone ) ; $star_to_displace -> update ; say " \tUnique ▁ Empires : ▁ " . scalar ( keys % unique_empires ) ; } my $finish = time ; out ( ' Finished ' ) ; out ( ( ( $finish - $start ) / 60 ) . " ▁ minutes ▁ have ▁ elapsed " ) ; # # ▁ SUBROUTINES ENDCOM sub move_body { my ( $body , $star ) = @ _ ; say " \tMoving ▁ body ▁ " . $body -> name ; $unique_empires { $body -> empire_id } = 1 if ( $body -> empire_id ) ; if ( $body -> orbit == 1 ) { $body -> x ( $star -> x + 1 ) ; $body -> y ( $star -> y + 2 ) ; } elsif ( $body -> orbit == 2 ) { $body -> x ( $star -> x + 2 ) ; $body -> y ( $star -> y + 1 ) ; } elsif ( $body -> orbit == 3 ) { $body -> x ( $star -> x + 2 ) ; $body -> y ( $star -> y - 1 ) ; } elsif ( $body -> orbit == 4 ) { $body -> x ( $star -> x + 1 ) ; $body -> y ( $star -> y - 2 ) ; } elsif ( $body -> orbit == 5 ) { $body -> x ( $star -> x - 1 ) ; $body -> y ( $star -> y - 2 ) ; } elsif ( $body -> orbit == 6 ) { $body -> x ( $star -> x - 2 ) ; $body -> y ( $star -> y - 1 ) ; } elsif ( $body -> orbit == 7 ) { $body -> x ( $star -> x - 2 ) ; $body -> y ( $star -> y + 1 ) ; } elsif ( $body -> orbit == 8 ) { $body -> x ( $star -> x - 1 ) ; $body -> y ( $star -> y + 2 ) ; } $body -> zone ( $star -> zone ) ; $body -> update ; } sub out { my $message = shift ; unless ( $quiet ) { say format_date ( DateTime -> now ) , " ▁ " , $message ; } } </DOCUMENT>
<DOCUMENT_ID="ArcherCraftStore/ArcherVMPeridot/tree/master/RailsInstaller_D/Git/lib/perl5/5.8.8/unicore/lib/nt/Di.pl"> # ▁ ! ! ! ! ! ▁ DO ▁ NOT ▁ EDIT ▁ THIS ▁ FILE ▁ ! ! ! ! ! ▁ ENDCOM # ▁ This ▁ file ▁ is ▁ built ▁ by ▁ mktables ▁ from ▁ e . g . ▁ UnicodeData . txt . ENDCOM # ▁ Any ▁ changes ▁ made ▁ here ▁ will ▁ be ▁ lost ! ENDCOM # ▁ NumericType ▁ category ▁ ' Digit ' ENDCOM return << ' END ' ; 00 B2 00 B3 00 B9 1369 1371 2070 2074 2079 2080 2089 2460 2468 2474 247 C 2488 2490 24E A 24F 5 24F D 24F F 2776 277E 2780 2788 278 A 2792 10 A40 10 A43 END </DOCUMENT>
<DOCUMENT_ID="cpascal/godot/tree/master/drivers/builtin_openssl2/crypto/rc5/asm/rc5-586.pl"> # ! / usr / local / bin / perl ENDCOM $0 = ~ m / ( . * [ \ / \ \ ] ) [ ^ \ / \ \ ] + $ / ; $dir = $1 ; push ( @ INC , " $ { dir } " , " $ { dir } . . / . . / perlasm " ) ; require " x86asm . pl " ; require " cbc . pl " ; & asm_init ( $ARGV [ 0 ] , " rc5-586 . pl " ) ; $RC5_MAX_ROUNDS = 16 ; $RC5_32_OFF = ( $RC5_MAX_ROUNDS + 2 ) * 4 ; $A = " edi " ; $B = " esi " ; $S = " ebp " ; $tmp1 = " eax " ; $r = " ebx " ; $tmpc = " ecx " ; $tmp4 = " edx " ; & RC5_32_encrypt ( " RC5_32 _ encrypt " , 1 ) ; & RC5_32_encrypt ( " RC5_32 _ decrypt " , 0 ) ; & cbc ( " RC5_32 _ cbc _ encrypt " , " RC5_32 _ encrypt " , " RC5_32 _ decrypt " , 0 , 4 , 5 , 3 , - 1 , - 1 ) ; & asm_finish ( ) ; sub RC5_32_encrypt { local ( $name , $enc ) = @ _ ; & function_begin_B ( $name , " " ) ; & comment ( " " ) ; & push ( " ebp " ) ; & push ( " esi " ) ; & push ( " edi " ) ; & mov ( $tmp4 , & wparam ( 0 ) ) ; & mov ( $S , & wparam ( 1 ) ) ; & comment ( " Load ▁ the ▁ 2 ▁ words " ) ; & mov ( $A , & DWP ( 0 , $tmp4 , " " , 0 ) ) ; & mov ( $B , & DWP ( 4 , $tmp4 , " " , 0 ) ) ; & push ( $r ) ; & mov ( $r , & DWP ( 0 , $S , " " , 0 ) ) ; # ▁ encrypting ▁ part ENDCOM if ( $enc ) { & add ( $A , & DWP ( 4 + 0 , $S , " " , 0 ) ) ; & add ( $B , & DWP ( 4 + 4 , $S , " " , 0 ) ) ; for ( $i = 0 ; $i < $RC5_MAX_ROUNDS ; $i ++ ) { & xor ( $A , $B ) ; & mov ( $tmp1 , & DWP ( 12 + $i * 8 , $S , " " , 0 ) ) ; & mov ( $tmpc , $B ) ; & rotl ( $A , & LB ( " ecx " ) ) ; & add ( $A , $tmp1 ) ; & xor ( $B , $A ) ; & mov ( $tmp1 , & DWP ( 16 + $i * 8 , $S , " " , 0 ) ) ; & mov ( $tmpc , $A ) ; & rotl ( $B , & LB ( " ecx " ) ) ; & add ( $B , $tmp1 ) ; if ( ( $i == 7 ) || ( $i == 11 ) ) { & cmp ( $r , $i + 1 ) ; & je ( & label ( " rc5 _ exit " ) ) ; } } } else { & cmp ( $r , 12 ) ; & je ( & label ( " rc5 _ dec _ 12" ) ) ; & cmp ( $r , 8 ) ; & je ( & label ( " rc5 _ dec _ 8" ) ) ; for ( $i = $RC5_MAX_ROUNDS ; $i > 0 ; $i -- ) { & set_label ( " rc5 _ dec _ $ i " ) if ( $i == 12 ) || ( $i == 8 ) ; & mov ( $tmp1 , & DWP ( $i * 8 + 8 , $S , " " , 0 ) ) ; & sub ( $B , $tmp1 ) ; & mov ( $tmpc , $A ) ; & rotr ( $B , & LB ( " ecx " ) ) ; & xor ( $B , $A ) ; & mov ( $tmp1 , & DWP ( $i * 8 + 4 , $S , " " , 0 ) ) ; & sub ( $A , $tmp1 ) ; & mov ( $tmpc , $B ) ; & rotr ( $A , & LB ( " ecx " ) ) ; & xor ( $A , $B ) ; } & sub ( $B , & DWP ( 4 + 4 , $S , " " , 0 ) ) ; & sub ( $A , & DWP ( 4 + 0 , $S , " " , 0 ) ) ; } & set_label ( " rc5 _ exit " ) ; & mov ( & DWP ( 0 , $tmp4 , " " , 0 ) , $A ) ; & mov ( & DWP ( 4 , $tmp4 , " " , 0 ) , $B ) ; & pop ( " ebx " ) ; & pop ( " edi " ) ; & pop ( " esi " ) ; & pop ( " ebp " ) ; & ret ( ) ; & function_end_B ( $name ) ; } </DOCUMENT>
