void getFunctionEntrypoint ( VM & vm , CodeSpecializationKind kind , JITCode & jitCode , MacroAssemblerCodePtr & arityCheck ) { if ( ! vm . canUseJIT ( ) ) { if ( kind == CodeForCall ) { jitCode = JITCode ( MacroAssemblerCodeRef :: createLLIntCodeRef ( llint_function_for_call_prologue ) , JITCode :: InterpreterThunk ) ; arityCheck = MacroAssemblerCodePtr :: createLLIntCodePtr ( llint_function_for_call_arity_check ) ; return ; } ASSERT ( kind == CodeForConstruct ) ; jitCode = JITCode ( MacroAssemblerCodeRef :: createLLIntCodeRef ( llint_function_for_construct_prologue ) , JITCode :: InterpreterThunk ) ; arityCheck = MacroAssemblerCodePtr :: createLLIntCodePtr ( llint_function_for_construct_arity_check ) ; return ; } ( JIT ) if ( kind == CodeForCall ) { jitCode = JITCode ( vm . getCTIStub ( functionForCallEntryThunkGenerator ) , JITCode :: InterpreterThunk ) ; arityCheck = vm . getCTIStub ( functionForCallArityCheckThunkGenerator ) . code ( ) ; return ; } ASSERT ( kind == CodeForConstruct ) ; jitCode = JITCode ( vm . getCTIStub ( functionForConstructEntryThunkGenerator ) , JITCode :: InterpreterThunk ) ; arityCheck = vm . getCTIStub ( functionForConstructArityCheckThunkGenerator ) . code ( ) ; // ▁ ENABLE ( JIT ) ENDCOM }
void getEvalEntrypoint ( VM & vm , JITCode & jitCode ) { if ( ! vm . canUseJIT ( ) ) { jitCode = JITCode ( MacroAssemblerCodeRef :: createLLIntCodeRef ( llint_eval_prologue ) , JITCode :: InterpreterThunk ) ; return ; } ( JIT ) jitCode = JITCode ( vm . getCTIStub ( evalEntryThunkGenerator ) , JITCode :: InterpreterThunk ) ; }
void getProgramEntrypoint ( VM & vm , JITCode & jitCode ) { if ( ! vm . canUseJIT ( ) ) { jitCode = JITCode ( MacroAssemblerCodeRef :: createLLIntCodeRef ( llint_program_prologue ) , JITCode :: InterpreterThunk ) ; return ; } ( JIT ) jitCode = JITCode ( vm . getCTIStub ( programEntryThunkGenerator ) , JITCode :: InterpreterThunk ) ; }
double compute_distance ( double r1 , double c1 , double h , double r2 , double c2 , double r , double c ) { if ( r1 < 0 || r1 >= r || r2 < 0 || r2 >= r ) return 1e12 ; double dr = abs ( r1 - r2 ) ; double dc = min ( abs ( c1 - c2 ) , c - abs ( c1 - c2 ) ) ; return sqrt ( dr * dr + dc * dc ) + 20. * ( h - 1. ) / ( sqrt ( dr * dr + dc * dc ) + 1 ) ; }
int check_cell_value ( Input & input , int r , int c ) { c = ( c + input . c ) % input . c ; if ( r >= 0 && r < input . r ) return input . cell_field [ r ] [ c ] ; else return 0 ; }
void check_cell ( Input & input , Coord cur , vector < Coord > & path , vector < int > & prev , set < Coord > & visited , vector < double > & dist , int idx , double r , double c , double alpha ) { int dr = input . movement_r [ cur . r ] [ cur . c ] [ cur . h ] ; int dc = input . movement_c [ cur . r ] [ cur . c ] [ cur . h ] ; cur . r += dr ; cur . c += dc ; cur . c = ( cur . c + input . c ) % input . c ; // double ▁ dinit ▁ = ▁ compute _ distance ( path [ 0 ] . r , path [ 0 ] . c , r , c , input . r , input . c ) ; ENDCOM // double ▁ dcur ▁ = ▁ compute _ distance ( ▁ cur . r , ▁ cur . c , r , c , input . r , input . c ) ; ENDCOM if ( visited . find ( cur ) != visited . end ( ) ) // ▁ | | ▁ ( dinit + 20 . ▁ < ▁ dcur ▁ & & ▁ path . size ( ) ▁ > ▁ 1 ) ) ENDCOM return ; int cnt_cells = 0 ; for ( int i = - 2 ; i <= 2 ; i ++ ) for ( int j = - 2 ; j <= 2 ; j ++ ) cnt_cells += check_cell_value ( input , cur . r + i , cur . c + j ) ; if ( cnt_cells > 12 ) dist . push_back ( dist [ idx ] + alpha ) ; else dist . push_back ( dist [ idx ] + 1.0 ) ; path . push_back ( cur ) ; prev . push_back ( idx ) ; visited . insert ( cur ) ; }
void bfs ( Input & input , vector < Coord > & path , vector < int > & prev , double r , double c , int bfsdepth , double alpha ) { set < Coord > visited ; vector < double > dist ; int idx = 0 ; dist . push_back ( 0 ) ; visited . insert ( path [ idx ] ) ; while ( idx < path . size ( ) ) { Coord cur = path [ idx ] ; // cerr ▁ < < ▁ " current ▁ balloon : ▁ " ▁ < < ▁ cur . r ▁ < < ▁ ' ▁ ' ▁ < < ▁ cur . c ▁ < < ▁ ' ▁ ' ▁ < < ▁ cur . h ▁ < < ▁ endl ; ENDCOM if ( dist [ idx ] > ( double ) bfsdepth ) break ; // if ▁ ( path . size ( ) ▁ > ▁ 10000 ) ENDCOM // TABSYMBOL break ; ENDCOM // ▁ out ▁ of ▁ bounds ▁ - > ▁ stay ▁ there ENDCOM if ( cur . r >= input . r || cur . r < 0 ) { path . push_back ( cur ) ; prev . push_back ( idx ) ; dist . push_back ( dist [ idx ] + 1 ) ; } // ▁ fly ▁ on ▁ neighboring ▁ altitudes ENDCOM else { check_cell ( input , cur , path , prev , visited , dist , idx , r , c , alpha ) ; if ( cur . h > 1 ) { cur . h -- ; check_cell ( input , cur , path , prev , visited , dist , idx , r , c , alpha ) ; cur . h ++ ; } if ( cur . h < input . a ) { cur . h ++ ; check_cell ( input , cur , path , prev , visited , dist , idx , r , c , alpha ) ; cur . h -- ; } } idx ++ ; } }
void append_path ( Input & input , int balloon , vector < Coord > & path , vector < int > & prev , int idx_min ) { vector < Coord > reversed_path ; for ( int i = idx_min ; i != 0 ; i = prev [ i ] ) reversed_path . push_back ( path [ i ] ) ; for ( int i = reversed_path . size ( ) - 1 ; i >= 0 ; i -- ) { input . balloons [ balloon ] . h . push_back ( reversed_path [ i ] . h ) ; input . balloons [ balloon ] . r . push_back ( reversed_path [ i ] . r ) ; input . balloons [ balloon ] . c . push_back ( reversed_path [ i ] . c ) ; if ( input . balloons [ balloon ] . h . size ( ) > input . t ) break ; } }
int choose_closest_point ( Input & input , vector < Coord > & path , double r , double c ) { double mind = 1e10 , curd ; int idx_min = 0 ; for ( int i = 1 ; i < path . size ( ) ; i ++ ) { curd = compute_distance ( path [ i ] . r , path [ i ] . c , path [ i ] . h , r , c , input . r , input . c ) ; if ( curd < mind || idx_min == 0 ) { idx_min = i ; mind = curd ; } } return idx_min ; }
bool check_horizontal_distance ( double c1 , double c2 , double delta_c , double c ) { if ( delta_c > c ) return true ; c2 += delta_c ; if ( c2 > c ) c2 -= c ; if ( abs ( c2 - c1 ) < c - abs ( c2 - c1 ) ) return c1 < c2 ; else return c1 > c2 ; }
void pathfinding ( Input & input , int balloon , double r , double c , double delta , int bfsdepth , double delta_c , double alpha = 0.5 ) { bool step_done = false ; while ( step_done == false || ( input . balloons [ balloon ] . h . size ( ) <= input . t && compute_distance ( input . balloons [ balloon ] . r . back ( ) , input . balloons [ balloon ] . c . back ( ) , input . balloons [ balloon ] . h . back ( ) , r , c , input . r , input . c ) > delta && check_horizontal_distance ( input . balloons [ balloon ] . c . back ( ) , c , delta_c , input . c ) ) ) { vector < Coord > path ; vector < int > prev ; // ▁ add ▁ starting ▁ cell ENDCOM Coord start ; start . r = input . balloons [ balloon ] . r . back ( ) ; start . c = input . balloons [ balloon ] . c . back ( ) ; start . h = input . balloons [ balloon ] . h . back ( ) ; path . push_back ( start ) ; prev . push_back ( - 1 ) ; bfs ( input , path , prev , r , c , bfsdepth , alpha ) ; int idx_min = choose_closest_point ( input , path , r , c ) ; append_path ( input , balloon , path , prev , idx_min ) ; step_done = true ; } // ▁ end ▁ of ▁ while ENDCOM // ▁ DEBUG ▁ OUTPUT TABSYMBOL ENDCOM /* bool ▁ inside ▁ = ▁ true , ▁ arrived ▁ = ▁ false ; STRNEWLINE TABSYMBOL for ▁ ( int ▁ i ▁ = ▁ 0 ; ▁ i ▁ < ▁ input . balloons [ balloon ] . r . size ( ) ; ▁ i + + ) STRNEWLINE TABSYMBOL { STRNEWLINE TABSYMBOL TABSYMBOL int ▁ rc ▁ = ▁ input . balloons [ balloon ] . r [ i ] ; STRNEWLINE TABSYMBOL TABSYMBOL int ▁ cc ▁ = ▁ input . balloons [ balloon ] . c [ i ] ; STRNEWLINE TABSYMBOL TABSYMBOL if ▁ ( ! arrived ▁ & & ▁ compute _ distance ( rc , cc , r , c , input . r , input . c ) ▁ < ▁ input . v ) STRNEWLINE TABSYMBOL TABSYMBOL { STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL cerr ▁ < < ▁ " Ballon ▁ " ▁ < < ▁ balloon ▁ < < ▁ " ▁ has ▁ reached ▁ the ▁ center ▁ of ▁ its ▁ cluster . \n " ; STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL arrived ▁ = ▁ true ; STRNEWLINE TABSYMBOL TABSYMBOL } STRNEWLINE TABSYMBOL TABSYMBOL STRNEWLINE TABSYMBOL TABSYMBOL if ▁ ( input . balloons [ balloon ] . h [ i ] ▁ > ▁ input . a ▁ | | ▁ ( input . balloons [ balloon ] . h [ i ] ▁ < ▁ 1 ▁ & & ▁ i ▁ > ▁ 0 ) ) STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL cerr ▁ < < ▁ " ERROR : ▁ balloon ▁ " ▁ < < ▁ balloon ▁ < < ▁ " ▁ violates ▁ the ▁ height ▁ constraints . \n " ; STRNEWLINE TABSYMBOL TABSYMBOL STRNEWLINE TABSYMBOL TABSYMBOL if ▁ ( cc ▁ < ▁ 0 ▁ | | ▁ cc ▁ > = ▁ input . c ) STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL cerr ▁ < < ▁ " ERROR : ▁ coordiantes ▁ of ▁ balloon ▁ " ▁ < < ▁ balloon ▁ < < ▁ " ▁ do ▁ not ▁ satisfy ▁ column ▁ constraints . \n " ; STRNEWLINE TABSYMBOL TABSYMBOL STRNEWLINE TABSYMBOL TABSYMBOL if ▁ ( inside ▁ & & ▁ ( rc ▁ < ▁ 0 ▁ | | ▁ rc ▁ > = ▁ input . r ) ) STRNEWLINE TABSYMBOL TABSYMBOL { STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL cerr ▁ < < ▁ " Ballon ▁ " ▁ < < ▁ balloon ▁ < < ▁ " ▁ was ▁ lost ▁ at ▁ turn ▁ " ▁ < < ▁ i ▁ < < ▁ " . \n " ; ▁ STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL inside ▁ = ▁ false ; STRNEWLINE TABSYMBOL TABSYMBOL } STRNEWLINE TABSYMBOL } // */ ENDCOM // ▁ VISULAIZATION ▁ OF ▁ THE ▁ PATH ENDCOM /* STRNEWLINE TABSYMBOL for ▁ ( int ▁ i ▁ = ▁ 0 ; ▁ i ▁ < ▁ input . balloons [ balloon ] . r . size ( ) - 1 ; ▁ i + + ) STRNEWLINE TABSYMBOL { STRNEWLINE TABSYMBOL TABSYMBOL int ▁ rc ▁ = ▁ input . balloons [ balloon ] . r [ i ] ; STRNEWLINE TABSYMBOL TABSYMBOL int ▁ rn ▁ = ▁ input . balloons [ balloon ] . r [ i + 1 ] ; STRNEWLINE STRNEWLINE TABSYMBOL TABSYMBOL int ▁ cc ▁ = ▁ input . balloons [ balloon ] . c [ i ] ; STRNEWLINE TABSYMBOL TABSYMBOL int ▁ cn ▁ = ▁ input . balloons [ balloon ] . c [ i + 1 ] ; STRNEWLINE STRNEWLINE TABSYMBOL TABSYMBOL if ▁ ( abs ( cc - cn ) ▁ > ▁ input . c ▁ - ▁ abs ( cc - cn ) ) STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL cerr ▁ < < ▁ cc ▁ < < ▁ ' ▁ ' ▁ < < ▁ rc ▁ < < ▁ ' ▁ ' ▁ < < ▁ 0 ▁ < < ▁ ' ▁ ' ▁ < < ▁ 0 ▁ < < ▁ ' ▁ ' ▁ < < ▁ input . balloons [ balloon ] . cluster _ id ▁ / ▁ ( ( double ) input . clusters . size ( ) ) ▁ < < ▁ endl ; STRNEWLINE TABSYMBOL TABSYMBOL else STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL cerr ▁ < < ▁ cc ▁ < < ▁ ' ▁ ' ▁ < < ▁ rc ▁ < < ▁ ' ▁ ' ▁ < < ▁ cn - cc ▁ < < ▁ ' ▁ ' ▁ < < ▁ rn - rc ▁ < < ▁ ' ▁ ' ▁ < < ▁ input . balloons [ balloon ] . cluster _ id ▁ / ▁ ( ( double ) input . clusters . size ( ) ) ▁ < < ▁ endl ; STRNEWLINE TABSYMBOL } */ ENDCOM }
TEST ( ModelInstantiatorTest , BrpProb ) { carl :: VariablePool :: getInstance ( ) . clear ( ) ; std :: string programFile = STORM_TEST_RESOURCES_DIR " / pdtmc / brp16_2 . pm " ; std :: string formulaAsString = " P = ? ▁ [ F ▁ s = 5 ▁ ] " ; // ▁ Program ▁ and ▁ formula ENDCOM storm :: prism :: Program program = storm :: api :: parseProgram ( programFile ) ; program . checkValidity ( ) ; std :: vector < std :: shared_ptr < storm :: logic :: Formula const >> formulas = storm :: api :: extractFormulasFromProperties ( storm :: api :: parsePropertiesForPrismProgram ( formulaAsString , program ) ) ; ASSERT_TRUE ( formulas . size ( ) == 1 ) ; // ▁ Parametric ▁ model ENDCOM storm :: generator :: NextStateGeneratorOptions options ( * formulas . front ( ) ) ; std :: shared_ptr < storm :: models :: sparse :: Dtmc < storm :: RationalFunction >> dtmc = storm :: builder :: ExplicitModelBuilder < storm :: RationalFunction > ( program , options ) . build ( ) -> as < storm :: models :: sparse :: Dtmc < storm :: RationalFunction >> ( ) ; storm :: utility :: ModelInstantiator < storm :: models :: sparse :: Dtmc < storm :: RationalFunction > , storm :: models :: sparse :: Dtmc < double >> modelInstantiator ( * dtmc ) ; EXPECT_FALSE ( dtmc -> hasRewardModel ( ) ) ; { std :: map < storm :: RationalFunctionVariable , storm :: RationalFunctionCoefficient > valuation ; storm :: RationalFunctionVariable const & pL = carl :: VariablePool :: getInstance ( ) . findVariableWithName ( " pL " ) ; ASSERT_NE ( pL , carl :: Variable :: NO_VARIABLE ) ; storm :: RationalFunctionVariable const & pK = carl :: VariablePool :: getInstance ( ) . findVariableWithName ( " pK " ) ; ASSERT_NE ( pK , carl :: Variable :: NO_VARIABLE ) ; valuation . insert ( std :: make_pair ( pL , storm :: utility :: convertNumber < storm :: RationalFunctionCoefficient > ( 0.8 ) ) ) ; valuation . insert ( std :: make_pair ( pK , storm :: utility :: convertNumber < storm :: RationalFunctionCoefficient > ( 0.9 ) ) ) ; storm :: models :: sparse :: Dtmc < double > const & instantiated ( modelInstantiator . instantiate ( valuation ) ) ; ASSERT_EQ ( dtmc -> getTransitionMatrix ( ) . getRowGroupIndices ( ) , instantiated . getTransitionMatrix ( ) . getRowGroupIndices ( ) ) ; for ( std :: size_t rowGroup = 0 ; rowGroup < dtmc -> getTransitionMatrix ( ) . getRowGroupCount ( ) ; ++ rowGroup ) { for ( std :: size_t row = dtmc -> getTransitionMatrix ( ) . getRowGroupIndices ( ) [ rowGroup ] ; row < dtmc -> getTransitionMatrix ( ) . getRowGroupIndices ( ) [ rowGroup + 1 ] ; ++ row ) { auto instantiatedEntry = instantiated . getTransitionMatrix ( ) . getRow ( row ) . begin ( ) ; for ( auto const & paramEntry : dtmc -> getTransitionMatrix ( ) . getRow ( row ) ) { EXPECT_EQ ( paramEntry . getColumn ( ) , instantiatedEntry -> getColumn ( ) ) ; double evaluatedValue = carl :: toDouble ( paramEntry . getValue ( ) . evaluate ( valuation ) ) ; EXPECT_EQ ( evaluatedValue , instantiatedEntry -> getValue ( ) ) ; ++ instantiatedEntry ; } EXPECT_EQ ( instantiated . getTransitionMatrix ( ) . getRow ( row ) . end ( ) , instantiatedEntry ) ; } } EXPECT_EQ ( dtmc -> getStateLabeling ( ) , instantiated . getStateLabeling ( ) ) ; EXPECT_EQ ( dtmc -> getOptionalChoiceLabeling ( ) , instantiated . getOptionalChoiceLabeling ( ) ) ; storm :: modelchecker :: SparseDtmcPrctlModelChecker < storm :: models :: sparse :: Dtmc < double >> modelchecker ( instantiated ) ; std :: unique_ptr < storm :: modelchecker :: CheckResult > chkResult = modelchecker . check ( * formulas [ 0 ] ) ; storm :: modelchecker :: ExplicitQuantitativeCheckResult < double > & quantitativeChkResult = chkResult -> asExplicitQuantitativeCheckResult < double > ( ) ; EXPECT_NEAR ( 0.2989278941 , quantitativeChkResult [ * instantiated . getInitialStates ( ) . begin ( ) ] , storm :: settings :: getModule < storm :: settings :: modules :: GeneralSettings > ( ) . getPrecision ( ) ) ; } { std :: map < storm :: RationalFunctionVariable , storm :: RationalFunctionCoefficient > valuation ; storm :: RationalFunctionVariable const & pL = carl :: VariablePool :: getInstance ( ) . findVariableWithName ( " pL " ) ; ASSERT_NE ( pL , carl :: Variable :: NO_VARIABLE ) ; storm :: RationalFunctionVariable const & pK = carl :: VariablePool :: getInstance ( ) . findVariableWithName ( " pK " ) ; ASSERT_NE ( pK , carl :: Variable :: NO_VARIABLE ) ; valuation . insert ( std :: make_pair ( pL , storm :: utility :: one < storm :: RationalFunctionCoefficient > ( ) ) ) ; valuation . insert ( std :: make_pair ( pK , storm :: utility :: one < storm :: RationalFunctionCoefficient > ( ) ) ) ; storm :: models :: sparse :: Dtmc < double > const & instantiated ( modelInstantiator . instantiate ( valuation ) ) ; ASSERT_EQ ( dtmc -> getTransitionMatrix ( ) . getRowGroupIndices ( ) , instantiated . getTransitionMatrix ( ) . getRowGroupIndices ( ) ) ; for ( std :: size_t rowGroup = 0 ; rowGroup < dtmc -> getTransitionMatrix ( ) . getRowGroupCount ( ) ; ++ rowGroup ) { for ( std :: size_t row = dtmc -> getTransitionMatrix ( ) . getRowGroupIndices ( ) [ rowGroup ] ; row < dtmc -> getTransitionMatrix ( ) . getRowGroupIndices ( ) [ rowGroup + 1 ] ; ++ row ) { auto instantiatedEntry = instantiated . getTransitionMatrix ( ) . getRow ( row ) . begin ( ) ; for ( auto const & paramEntry : dtmc -> getTransitionMatrix ( ) . getRow ( row ) ) { EXPECT_EQ ( paramEntry . getColumn ( ) , instantiatedEntry -> getColumn ( ) ) ; double evaluatedValue = carl :: toDouble ( paramEntry . getValue ( ) . evaluate ( valuation ) ) ; EXPECT_EQ ( evaluatedValue , instantiatedEntry -> getValue ( ) ) ; ++ instantiatedEntry ; } EXPECT_EQ ( instantiated . getTransitionMatrix ( ) . getRow ( row ) . end ( ) , instantiatedEntry ) ; } } EXPECT_EQ ( dtmc -> getStateLabeling ( ) , instantiated . getStateLabeling ( ) ) ; EXPECT_EQ ( dtmc -> getOptionalChoiceLabeling ( ) , instantiated . getOptionalChoiceLabeling ( ) ) ; storm :: modelchecker :: SparseDtmcPrctlModelChecker < storm :: models :: sparse :: Dtmc < double >> modelchecker ( instantiated ) ; std :: unique_ptr < storm :: modelchecker :: CheckResult > chkResult = modelchecker . check ( * formulas [ 0 ] ) ; storm :: modelchecker :: ExplicitQuantitativeCheckResult < double > & quantitativeChkResult = chkResult -> asExplicitQuantitativeCheckResult < double > ( ) ; EXPECT_EQ ( 0.0 , quantitativeChkResult [ * instantiated . getInitialStates ( ) . begin ( ) ] ) ; } { std :: map < storm :: RationalFunctionVariable , storm :: RationalFunctionCoefficient > valuation ; storm :: RationalFunctionVariable const & pL = carl :: VariablePool :: getInstance ( ) . findVariableWithName ( " pL " ) ; ASSERT_NE ( pL , carl :: Variable :: NO_VARIABLE ) ; storm :: RationalFunctionVariable const & pK = carl :: VariablePool :: getInstance ( ) . findVariableWithName ( " pK " ) ; ASSERT_NE ( pK , carl :: Variable :: NO_VARIABLE ) ; valuation . insert ( std :: make_pair ( pL , storm :: utility :: one < storm :: RationalFunctionCoefficient > ( ) ) ) ; valuation . insert ( std :: make_pair ( pK , storm :: utility :: convertNumber < storm :: RationalFunctionCoefficient > ( 0.9 ) ) ) ; storm :: models :: sparse :: Dtmc < double > const & instantiated ( modelInstantiator . instantiate ( valuation ) ) ; ASSERT_EQ ( dtmc -> getTransitionMatrix ( ) . getRowGroupIndices ( ) , instantiated . getTransitionMatrix ( ) . getRowGroupIndices ( ) ) ; for ( std :: size_t rowGroup = 0 ; rowGroup < dtmc -> getTransitionMatrix ( ) . getRowGroupCount ( ) ; ++ rowGroup ) { for ( std :: size_t row = dtmc -> getTransitionMatrix ( ) . getRowGroupIndices ( ) [ rowGroup ] ; row < dtmc -> getTransitionMatrix ( ) . getRowGroupIndices ( ) [ rowGroup + 1 ] ; ++ row ) { auto instantiatedEntry = instantiated . getTransitionMatrix ( ) . getRow ( row ) . begin ( ) ; for ( auto const & paramEntry : dtmc -> getTransitionMatrix ( ) . getRow ( row ) ) { EXPECT_EQ ( paramEntry . getColumn ( ) , instantiatedEntry -> getColumn ( ) ) ; double evaluatedValue = carl :: toDouble ( paramEntry . getValue ( ) . evaluate ( valuation ) ) ; EXPECT_EQ ( evaluatedValue , instantiatedEntry -> getValue ( ) ) ; ++ instantiatedEntry ; } EXPECT_EQ ( instantiated . getTransitionMatrix ( ) . getRow ( row ) . end ( ) , instantiatedEntry ) ; } } EXPECT_EQ ( dtmc -> getStateLabeling ( ) , instantiated . getStateLabeling ( ) ) ; EXPECT_EQ ( dtmc -> getOptionalChoiceLabeling ( ) , instantiated . getOptionalChoiceLabeling ( ) ) ; storm :: modelchecker :: SparseDtmcPrctlModelChecker < storm :: models :: sparse :: Dtmc < double >> modelchecker ( instantiated ) ; std :: unique_ptr < storm :: modelchecker :: CheckResult > chkResult = modelchecker . check ( * formulas [ 0 ] ) ; storm :: modelchecker :: ExplicitQuantitativeCheckResult < double > & quantitativeChkResult = chkResult -> asExplicitQuantitativeCheckResult < double > ( ) ; EXPECT_NEAR ( 0.01588055832 , quantitativeChkResult [ * instantiated . getInitialStates ( ) . begin ( ) ] , storm :: settings :: getModule < storm :: settings :: modules :: GeneralSettings > ( ) . getPrecision ( ) ) ; } }
TEST ( ModelInstantiatorTest , Brp_Rew ) { carl :: VariablePool :: getInstance ( ) . clear ( ) ; std :: string programFile = STORM_TEST_RESOURCES_DIR " / pdtmc / brp16_2 . pm " ; std :: string formulaAsString = " R = ? ▁ [ F ▁ ( ( s = 5 ) ▁ | ▁ ( s = 0 & srep = 3 ) ) ▁ ] " ; // ▁ Program ▁ and ▁ formula ENDCOM storm :: prism :: Program program = storm :: api :: parseProgram ( programFile ) ; program . checkValidity ( ) ; std :: vector < std :: shared_ptr < storm :: logic :: Formula const >> formulas = storm :: api :: extractFormulasFromProperties ( storm :: api :: parsePropertiesForPrismProgram ( formulaAsString , program ) ) ; ASSERT_TRUE ( formulas . size ( ) == 1 ) ; // ▁ Parametric ▁ model ENDCOM storm :: generator :: NextStateGeneratorOptions options ( * formulas . front ( ) ) ; std :: shared_ptr < storm :: models :: sparse :: Dtmc < storm :: RationalFunction >> dtmc = storm :: builder :: ExplicitModelBuilder < storm :: RationalFunction > ( program , options ) . build ( ) -> as < storm :: models :: sparse :: Dtmc < storm :: RationalFunction >> ( ) ; storm :: utility :: ModelInstantiator < storm :: models :: sparse :: Dtmc < storm :: RationalFunction > , storm :: models :: sparse :: Dtmc < double >> modelInstantiator ( * dtmc ) ; { std :: map < storm :: RationalFunctionVariable , storm :: RationalFunctionCoefficient > valuation ; storm :: RationalFunctionVariable const & pL = carl :: VariablePool :: getInstance ( ) . findVariableWithName ( " pL " ) ; ASSERT_NE ( pL , carl :: Variable :: NO_VARIABLE ) ; storm :: RationalFunctionVariable const & pK = carl :: VariablePool :: getInstance ( ) . findVariableWithName ( " pK " ) ; ASSERT_NE ( pK , carl :: Variable :: NO_VARIABLE ) ; storm :: RationalFunctionVariable const & TOMsg = carl :: VariablePool :: getInstance ( ) . findVariableWithName ( " TOMsg " ) ; ASSERT_NE ( pK , carl :: Variable :: NO_VARIABLE ) ; storm :: RationalFunctionVariable const & TOAck = carl :: VariablePool :: getInstance ( ) . findVariableWithName ( " TOAck " ) ; ASSERT_NE ( pK , carl :: Variable :: NO_VARIABLE ) ; valuation . insert ( std :: make_pair ( pL , storm :: utility :: convertNumber < storm :: RationalFunctionCoefficient > ( 0.9 ) ) ) ; valuation . insert ( std :: make_pair ( pK , storm :: utility :: convertNumber < storm :: RationalFunctionCoefficient > ( 0.3 ) ) ) ; valuation . insert ( std :: make_pair ( TOMsg , storm :: utility :: convertNumber < storm :: RationalFunctionCoefficient > ( 0.3 ) ) ) ; valuation . insert ( std :: make_pair ( TOAck , storm :: utility :: convertNumber < storm :: RationalFunctionCoefficient > ( 0.5 ) ) ) ; storm :: models :: sparse :: Dtmc < double > const & instantiated ( modelInstantiator . instantiate ( valuation ) ) ; ASSERT_EQ ( dtmc -> getTransitionMatrix ( ) . getRowGroupIndices ( ) , instantiated . getTransitionMatrix ( ) . getRowGroupIndices ( ) ) ; for ( std :: size_t rowGroup = 0 ; rowGroup < dtmc -> getTransitionMatrix ( ) . getRowGroupCount ( ) ; ++ rowGroup ) { for ( std :: size_t row = dtmc -> getTransitionMatrix ( ) . getRowGroupIndices ( ) [ rowGroup ] ; row < dtmc -> getTransitionMatrix ( ) . getRowGroupIndices ( ) [ rowGroup + 1 ] ; ++ row ) { auto instantiatedEntry = instantiated . getTransitionMatrix ( ) . getRow ( row ) . begin ( ) ; for ( auto const & paramEntry : dtmc -> getTransitionMatrix ( ) . getRow ( row ) ) { EXPECT_EQ ( paramEntry . getColumn ( ) , instantiatedEntry -> getColumn ( ) ) ; double evaluatedValue = carl :: toDouble ( paramEntry . getValue ( ) . evaluate ( valuation ) ) ; EXPECT_EQ ( evaluatedValue , instantiatedEntry -> getValue ( ) ) ; ++ instantiatedEntry ; } EXPECT_EQ ( instantiated . getTransitionMatrix ( ) . getRow ( row ) . end ( ) , instantiatedEntry ) ; } } ASSERT_TRUE ( instantiated . hasUniqueRewardModel ( ) ) ; EXPECT_FALSE ( instantiated . getUniqueRewardModel ( ) . hasStateRewards ( ) ) ; EXPECT_FALSE ( instantiated . getUniqueRewardModel ( ) . hasTransitionRewards ( ) ) ; EXPECT_TRUE ( instantiated . getUniqueRewardModel ( ) . hasStateActionRewards ( ) ) ; ASSERT_TRUE ( dtmc -> getUniqueRewardModel ( ) . hasStateActionRewards ( ) ) ; std :: size_t stateActionEntries = dtmc -> getUniqueRewardModel ( ) . getStateActionRewardVector ( ) . size ( ) ; ASSERT_EQ ( stateActionEntries , instantiated . getUniqueRewardModel ( ) . getStateActionRewardVector ( ) . size ( ) ) ; for ( std :: size_t i = 0 ; i < stateActionEntries ; ++ i ) { double evaluatedValue = carl :: toDouble ( dtmc -> getUniqueRewardModel ( ) . getStateActionRewardVector ( ) [ i ] . evaluate ( valuation ) ) ; EXPECT_EQ ( evaluatedValue , instantiated . getUniqueRewardModel ( ) . getStateActionRewardVector ( ) [ i ] ) ; } EXPECT_EQ ( dtmc -> getStateLabeling ( ) , instantiated . getStateLabeling ( ) ) ; EXPECT_EQ ( dtmc -> getOptionalChoiceLabeling ( ) , instantiated . getOptionalChoiceLabeling ( ) ) ; storm :: modelchecker :: SparseDtmcPrctlModelChecker < storm :: models :: sparse :: Dtmc < double >> modelchecker ( instantiated ) ; std :: unique_ptr < storm :: modelchecker :: CheckResult > chkResult = modelchecker . check ( * formulas [ 0 ] ) ; storm :: modelchecker :: ExplicitQuantitativeCheckResult < double > & quantitativeChkResult = chkResult -> asExplicitQuantitativeCheckResult < double > ( ) ; EXPECT_NEAR ( 1.308324495 , quantitativeChkResult [ * instantiated . getInitialStates ( ) . begin ( ) ] , storm :: settings :: getModule < storm :: settings :: modules :: GeneralSettings > ( ) . getPrecision ( ) ) ; } }
TEST ( ModelInstantiatorTest , Consensus ) { carl :: VariablePool :: getInstance ( ) . clear ( ) ; std :: string programFile = STORM_TEST_RESOURCES_DIR " / pmdp / coin2_2 . nm " ; std :: string formulaAsString = " Pmin = ? ▁ [ F ▁ \ " finished \ " & \ " all _ coins _ equal _ 1 \ " ▁ ] " ; // ▁ Program ▁ and ▁ formula ENDCOM storm :: prism :: Program program = storm :: api :: parseProgram ( programFile ) ; program . checkValidity ( ) ; std :: vector < std :: shared_ptr < storm :: logic :: Formula const >> formulas = storm :: api :: extractFormulasFromProperties ( storm :: api :: parsePropertiesForPrismProgram ( formulaAsString , program ) ) ; ASSERT_TRUE ( formulas . size ( ) == 1 ) ; // ▁ Parametric ▁ model ENDCOM storm :: generator :: NextStateGeneratorOptions options ( * formulas . front ( ) ) ; std :: shared_ptr < storm :: models :: sparse :: Mdp < storm :: RationalFunction >> mdp = storm :: builder :: ExplicitModelBuilder < storm :: RationalFunction > ( program , options ) . build ( ) -> as < storm :: models :: sparse :: Mdp < storm :: RationalFunction >> ( ) ; storm :: utility :: ModelInstantiator < storm :: models :: sparse :: Mdp < storm :: RationalFunction > , storm :: models :: sparse :: Mdp < double >> modelInstantiator ( * mdp ) ; std :: map < storm :: RationalFunctionVariable , storm :: RationalFunctionCoefficient > valuation ; storm :: RationalFunctionVariable const & p1 = carl :: VariablePool :: getInstance ( ) . findVariableWithName ( " p1" ) ; ASSERT_NE ( p1 , carl :: Variable :: NO_VARIABLE ) ; storm :: RationalFunctionVariable const & p2 = carl :: VariablePool :: getInstance ( ) . findVariableWithName ( " p2" ) ; ASSERT_NE ( p2 , carl :: Variable :: NO_VARIABLE ) ; valuation . insert ( std :: make_pair ( p1 , storm :: utility :: convertNumber < storm :: RationalFunctionCoefficient > ( 0.51 ) ) ) ; valuation . insert ( std :: make_pair ( p2 , storm :: utility :: convertNumber < storm :: RationalFunctionCoefficient > ( 0.49 ) ) ) ; storm :: models :: sparse :: Mdp < double > const & instantiated ( modelInstantiator . instantiate ( valuation ) ) ; ASSERT_EQ ( mdp -> getTransitionMatrix ( ) . getRowGroupIndices ( ) , instantiated . getTransitionMatrix ( ) . getRowGroupIndices ( ) ) ; for ( std :: size_t rowGroup = 0 ; rowGroup < mdp -> getTransitionMatrix ( ) . getRowGroupCount ( ) ; ++ rowGroup ) { for ( std :: size_t row = mdp -> getTransitionMatrix ( ) . getRowGroupIndices ( ) [ rowGroup ] ; row < mdp -> getTransitionMatrix ( ) . getRowGroupIndices ( ) [ rowGroup + 1 ] ; ++ row ) { auto instantiatedEntry = instantiated . getTransitionMatrix ( ) . getRow ( row ) . begin ( ) ; for ( auto const & paramEntry : mdp -> getTransitionMatrix ( ) . getRow ( row ) ) { EXPECT_EQ ( paramEntry . getColumn ( ) , instantiatedEntry -> getColumn ( ) ) ; double evaluatedValue = carl :: toDouble ( paramEntry . getValue ( ) . evaluate ( valuation ) ) ; EXPECT_EQ ( evaluatedValue , instantiatedEntry -> getValue ( ) ) ; ++ instantiatedEntry ; } EXPECT_EQ ( instantiated . getTransitionMatrix ( ) . getRow ( row ) . end ( ) , instantiatedEntry ) ; } } EXPECT_EQ ( mdp -> getStateLabeling ( ) , instantiated . getStateLabeling ( ) ) ; EXPECT_EQ ( mdp -> getOptionalChoiceLabeling ( ) , instantiated . getOptionalChoiceLabeling ( ) ) ; storm :: modelchecker :: SparseMdpPrctlModelChecker < storm :: models :: sparse :: Mdp < double >> modelchecker ( instantiated ) ; std :: unique_ptr < storm :: modelchecker :: CheckResult > chkResult = modelchecker . check ( * formulas [ 0 ] ) ; storm :: modelchecker :: ExplicitQuantitativeCheckResult < double > & quantitativeChkResult = chkResult -> asExplicitQuantitativeCheckResult < double > ( ) ; EXPECT_NEAR ( 0.3526577219 , quantitativeChkResult [ * instantiated . getInitialStates ( ) . begin ( ) ] , storm :: settings :: getModule < storm :: settings :: modules :: GeneralSettings > ( ) . getPrecision ( ) ) ; }
void printError ( const char * msg ) { QFile file ; file . open ( stderr , QIODevice :: WriteOnly ) ; file . write ( msg , qstrlen ( msg ) ) ; // ▁ write ▁ to ▁ stderr ENDCOM file . close ( ) ; }
int main ( ) { constexpr Person john { 30 } ; // ▁ Can ' t ▁ dereference ▁ a ▁ non - pointer . ENDCOM BOOST_HANA_CONSTANT_CHECK ( f ( john ) == hana :: nothing ) ; // ▁ ` int ` ▁ has ▁ no ▁ member ▁ named ▁ ` age ` . ENDCOM BOOST_HANA_CONSTANT_CHECK ( f ( 1 ) == hana :: nothing ) ; // ▁ All ▁ is ▁ good . ENDCOM BOOST_HANA_CONSTEXPR_CHECK ( f ( & john ) == hana :: just ( 30u ) ) ; }
/* STRNEWLINE ▁ * ▁ Copyright ▁ ( c ) ▁ 2011 ▁ Damien ▁ Grauser STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ This ▁ program ▁ is ▁ free ▁ software ; ▁ you ▁ can ▁ redistribute ▁ it ▁ and / or ▁ modify ▁ it STRNEWLINE ▁ * ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ as ▁ published ▁ by ▁ the ▁ Free STRNEWLINE ▁ * ▁ Software ▁ Foundation ; ▁ either ▁ version ▁ 2 ▁ of ▁ the ▁ License , ▁ or ▁ ( at ▁ your ▁ option ) STRNEWLINE ▁ * ▁ any ▁ later ▁ version . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ This ▁ program ▁ is ▁ distributed ▁ in ▁ the ▁ hope ▁ that ▁ it ▁ will ▁ be ▁ useful , ▁ but ▁ WITHOUT STRNEWLINE ▁ * ▁ ANY ▁ WARRANTY ; ▁ without ▁ even ▁ the ▁ implied ▁ warranty ▁ of ▁ MERCHANTABILITY ▁ or STRNEWLINE ▁ * ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE . ▁ See ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ for STRNEWLINE ▁ * ▁ more ▁ details . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ You ▁ should ▁ have ▁ received ▁ a ▁ copy ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ along STRNEWLINE ▁ * ▁ with ▁ this ▁ program ; ▁ if ▁ not , ▁ write ▁ to ▁ the ▁ Free ▁ Software ▁ Foundation , ▁ Inc . , ▁ 51 STRNEWLINE ▁ * ▁ Franklin ▁ Street , ▁ Fifth ▁ Floor , ▁ Boston , ▁ MA ▁ 02110-1301 ▁ USA STRNEWLINE ▁ */ ENDCOM static inline double max ( double a , double b ) { if ( a > b ) return a ; else return b ; }
public : HrPwPlotBackground ( HrPwPlot * _parent ) { setZ ( 0.0 ) ; parent = _parent ; }
// ▁ blue ENDCOM inline void swap ( short & a , short & b ) { short temp = a ; a = b ; b = temp ; }
void gbafilter_pal ( u16 * buf , int count ) { short temp [ 3 * 3 ] , s ; unsigned pix ; u8 red , green , blue ; while ( count -- ) { pix = * buf ; s = curve [ ( pix >> systemGreenShift ) & 0x1f ] ; temp [ 3 ] = s * influence [ 3 ] ; temp [ 4 ] = s * influence [ 4 ] ; temp [ 5 ] = s * influence [ 5 ] ; s = curve [ ( pix >> systemRedShift ) & 0x1f ] ; temp [ 0 ] = s * influence [ 0 ] ; temp [ 1 ] = s * influence [ 1 ] ; temp [ 2 ] = s * influence [ 2 ] ; s = curve [ ( pix >> systemBlueShift ) & 0x1f ] ; temp [ 6 ] = s * influence [ 6 ] ; temp [ 7 ] = s * influence [ 7 ] ; temp [ 8 ] = s * influence [ 8 ] ; if ( temp [ 0 ] < temp [ 3 ] ) swap ( temp [ 0 ] , temp [ 3 ] ) ; if ( temp [ 0 ] < temp [ 6 ] ) swap ( temp [ 0 ] , temp [ 6 ] ) ; if ( temp [ 3 ] < temp [ 6 ] ) swap ( temp [ 3 ] , temp [ 6 ] ) ; temp [ 3 ] <<= 1 ; temp [ 0 ] <<= 2 ; temp [ 0 ] += temp [ 3 ] + temp [ 6 ] ; red = ( ( int ( temp [ 0 ] ) * 160 ) >> 17 ) + 4 ; if ( red > 31 ) red = 31 ; if ( temp [ 2 ] < temp [ 5 ] ) swap ( temp [ 2 ] , temp [ 5 ] ) ; if ( temp [ 2 ] < temp [ 8 ] ) swap ( temp [ 2 ] , temp [ 8 ] ) ; if ( temp [ 5 ] < temp [ 8 ] ) swap ( temp [ 5 ] , temp [ 8 ] ) ; temp [ 5 ] <<= 1 ; temp [ 2 ] <<= 2 ; temp [ 2 ] += temp [ 5 ] + temp [ 8 ] ; blue = ( ( int ( temp [ 2 ] ) * 160 ) >> 17 ) + 4 ; if ( blue > 31 ) blue = 31 ; if ( temp [ 1 ] < temp [ 4 ] ) swap ( temp [ 1 ] , temp [ 4 ] ) ; if ( temp [ 1 ] < temp [ 7 ] ) swap ( temp [ 1 ] , temp [ 7 ] ) ; if ( temp [ 4 ] < temp [ 7 ] ) swap ( temp [ 4 ] , temp [ 7 ] ) ; temp [ 4 ] <<= 1 ; temp [ 1 ] <<= 2 ; temp [ 1 ] += temp [ 4 ] + temp [ 7 ] ; green = ( ( int ( temp [ 1 ] ) * 160 ) >> 17 ) + 4 ; if ( green > 31 ) green = 31 ; pix = red << systemRedShift ; pix += green << systemGreenShift ; pix += blue << systemBlueShift ; * buf ++ = pix ; } }
void gbafilter_pal32 ( u32 * buf , int count ) { short temp [ 3 * 3 ] , s ; unsigned pix ; u8 red , green , blue ; while ( count -- ) { pix = * buf ; s = curve [ ( pix >> systemGreenShift ) & 0x1f ] ; temp [ 3 ] = s * influence [ 3 ] ; temp [ 4 ] = s * influence [ 4 ] ; temp [ 5 ] = s * influence [ 5 ] ; s = curve [ ( pix >> systemRedShift ) & 0x1f ] ; temp [ 0 ] = s * influence [ 0 ] ; temp [ 1 ] = s * influence [ 1 ] ; temp [ 2 ] = s * influence [ 2 ] ; s = curve [ ( pix >> systemBlueShift ) & 0x1f ] ; temp [ 6 ] = s * influence [ 6 ] ; temp [ 7 ] = s * influence [ 7 ] ; temp [ 8 ] = s * influence [ 8 ] ; if ( temp [ 0 ] < temp [ 3 ] ) swap ( temp [ 0 ] , temp [ 3 ] ) ; if ( temp [ 0 ] < temp [ 6 ] ) swap ( temp [ 0 ] , temp [ 6 ] ) ; if ( temp [ 3 ] < temp [ 6 ] ) swap ( temp [ 3 ] , temp [ 6 ] ) ; temp [ 3 ] <<= 1 ; temp [ 0 ] <<= 2 ; temp [ 0 ] += temp [ 3 ] + temp [ 6 ] ; // red ▁ = ▁ ( ( int ( temp [ 0 ] ) ▁ * ▁ 160 ) ▁ > > ▁ 17 ) ▁ + ▁ 4 ; ENDCOM red = ( ( int ( temp [ 0 ] ) * 160 ) >> 14 ) + 32 ; if ( temp [ 2 ] < temp [ 5 ] ) swap ( temp [ 2 ] , temp [ 5 ] ) ; if ( temp [ 2 ] < temp [ 8 ] ) swap ( temp [ 2 ] , temp [ 8 ] ) ; if ( temp [ 5 ] < temp [ 8 ] ) swap ( temp [ 5 ] , temp [ 8 ] ) ; temp [ 5 ] <<= 1 ; temp [ 2 ] <<= 2 ; temp [ 2 ] += temp [ 5 ] + temp [ 8 ] ; // blue ▁ = ▁ ( ( int ( temp [ 2 ] ) ▁ * ▁ 160 ) ▁ > > ▁ 17 ) ▁ + ▁ 4 ; ENDCOM blue = ( ( int ( temp [ 2 ] ) * 160 ) >> 14 ) + 32 ; if ( temp [ 1 ] < temp [ 4 ] ) swap ( temp [ 1 ] , temp [ 4 ] ) ; if ( temp [ 1 ] < temp [ 7 ] ) swap ( temp [ 1 ] , temp [ 7 ] ) ; if ( temp [ 4 ] < temp [ 7 ] ) swap ( temp [ 4 ] , temp [ 7 ] ) ; temp [ 4 ] <<= 1 ; temp [ 1 ] <<= 2 ; temp [ 1 ] += temp [ 4 ] + temp [ 7 ] ; // green ▁ = ▁ ( ( int ( temp [ 1 ] ) ▁ * ▁ 160 ) ▁ > > ▁ 17 ) ▁ + ▁ 4 ; ENDCOM green = ( ( int ( temp [ 1 ] ) * 160 ) >> 14 ) + 32 ; // pix ▁ = ▁ red ▁ < < ▁ redshift ; ENDCOM // pix ▁ + = ▁ green ▁ < < ▁ greenshift ; ENDCOM // pix ▁ + = ▁ blue ▁ < < ▁ blueshift ; ENDCOM pix = red << ( systemRedShift - 3 ) ; pix += green << ( systemGreenShift - 3 ) ; pix += blue << ( systemBlueShift - 3 ) ; * buf ++ = pix ; } }
// ▁ for ▁ palette ▁ mode ▁ to ▁ work ▁ with ▁ the ▁ three ▁ spoony ▁ filters ▁ in ▁ 32bpp ▁ depth ENDCOM void gbafilter_pad ( u8 * buf , int count ) { union { struct { u8 r ; u8 g ; u8 b ; u8 a ; } part ; unsigned whole ; } mask ; mask . whole = 0x1f << systemRedShift ; mask . whole += 0x1f << systemGreenShift ; mask . whole += 0x1f << systemBlueShift ; switch ( systemColorDepth ) { case 24 : while ( count -- ) { * buf ++ &= mask . part . r ; * buf ++ &= mask . part . g ; * buf ++ &= mask . part . b ; } break ; case 32 : while ( count -- ) { * ( ( u32 * ) buf ) &= mask . whole ; buf += 4 ; } } }
public : void testInsert ( ) { Map < String , int > m ; m . insert ( " foo " , 3 ) ; CPPUNIT_ASSERT_EQUAL ( 3 , m [ " foo " ] ) ; m . insert ( " foo " , 7 ) ; CPPUNIT_ASSERT_EQUAL ( 7 , m [ " foo " ] ) ; }
// ▁ world . c ▁ - - ▁ world ▁ query ▁ functions ENDCOM /*  STRNEWLINE = = = = =  STRNEWLINE SV _ ClipHandleForEntity STRNEWLINE  STRNEWLINE Returns ▁ a ▁ headnode ▁ that ▁ can ▁ be ▁ used ▁ for ▁ testing ▁ or ▁ clipping ▁ to ▁ a STRNEWLINE given ▁ entity . ▁ If ▁ the ▁ entity ▁ is ▁ a ▁ bsp ▁ model , ▁ the ▁ headnode ▁ will STRNEWLINE be ▁ returned , ▁ otherwise ▁ a ▁ custom ▁ box ▁ tree ▁ will ▁ be ▁ constructed .  STRNEWLINE = = = = =  STRNEWLINE */ ENDCOM clipHandle_t SV_ClipHandleForEntity ( const sharedEntity_t * ent ) { if ( ent -> r . bmodel ) { // ▁ explicit ▁ hulls ▁ in ▁ the ▁ BSP ▁ model ENDCOM return CM_InlineModel ( ent -> s . modelindex ) ; } if ( ent -> r . svFlags & SVF_CAPSULE ) { // ▁ create ▁ a ▁ temp ▁ capsule ▁ from ▁ bounding ▁ box ▁ sizes ENDCOM return CM_TempBoxModel ( ent -> r . mins , ent -> r . maxs , qtrue ) ; } // ▁ create ▁ a ▁ temp ▁ tree ▁ from ▁ bounding ▁ box ▁ sizes ENDCOM return CM_TempBoxModel ( ent -> r . mins , ent -> r . maxs , qfalse ) ; }
/*  STRNEWLINE = = = = =  STRNEWLINE SV _ SectorList _ f STRNEWLINE = = = = =  STRNEWLINE */ ENDCOM void SV_SectorList_f ( void ) { int i , c ; worldSector_t * sec ; svEntity_t * ent ; for ( i = 0 ; i < AREA_NODES ; i ++ ) { sec = & sv_worldSectors [ i ] ; c = 0 ; for ( ent = sec -> entities ; ent ; ent = ent -> nextEntityInWorldSector ) { c ++ ; } Com_Printf ( " sector ▁ % i : ▁ % i ▁ entities \n " , i , c ) ; } }
/*  STRNEWLINE = = = = =  STRNEWLINE SV _ CreateworldSector STRNEWLINE  STRNEWLINE Builds ▁ a ▁ uniformly ▁ subdivided ▁ tree ▁ for ▁ the ▁ given ▁ world ▁ size STRNEWLINE = = = = =  STRNEWLINE */ ENDCOM worldSector_t * SV_CreateworldSector ( int depth , vec3_t mins , vec3_t maxs ) { worldSector_t * anode ; vec3_t size ; vec3_t mins1 , maxs1 , mins2 , maxs2 ; anode = & sv_worldSectors [ sv_numworldSectors ] ; sv_numworldSectors ++ ; if ( depth == AREA_DEPTH ) { anode -> axis = - 1 ; anode -> children [ 0 ] = anode -> children [ 1 ] = NULL ; return anode ; } VectorSubtract ( maxs , mins , size ) ; if ( size [ 0 ] > size [ 1 ] ) { anode -> axis = 0 ; } else { anode -> axis = 1 ; } anode -> dist = 0.5 * ( maxs [ anode -> axis ] + mins [ anode -> axis ] ) ; VectorCopy ( mins , mins1 ) ; VectorCopy ( mins , mins2 ) ; VectorCopy ( maxs , maxs1 ) ; VectorCopy ( maxs , maxs2 ) ; maxs1 [ anode -> axis ] = mins2 [ anode -> axis ] = anode -> dist ; anode -> children [ 0 ] = SV_CreateworldSector ( depth + 1 , mins2 , maxs2 ) ; anode -> children [ 1 ] = SV_CreateworldSector ( depth + 1 , mins1 , maxs1 ) ; return anode ; }
/*  STRNEWLINE = = = = =  STRNEWLINE SV _ ClearWorld STRNEWLINE  STRNEWLINE = = = = =  STRNEWLINE */ ENDCOM void SV_ClearWorld ( void ) { clipHandle_t h ; vec3_t mins , maxs ; Com_Memset ( sv_worldSectors , 0 , sizeof ( sv_worldSectors ) ) ; sv_numworldSectors = 0 ; // ▁ get ▁ world ▁ map ▁ bounds ENDCOM h = CM_InlineModel ( 0 ) ; CM_ModelBounds ( h , mins , maxs ) ; SV_CreateworldSector ( 0 , mins , maxs ) ; }
/*  STRNEWLINE = = = = =  STRNEWLINE SV _ UnlinkEntity STRNEWLINE  STRNEWLINE = = = = =  STRNEWLINE */ ENDCOM void SV_UnlinkEntity ( sharedEntity_t * gEnt ) { svEntity_t * ent ; svEntity_t * scan ; worldSector_t * ws ; ent = SV_SvEntityForGentity ( gEnt ) ; gEnt -> r . linked = qfalse ; ws = ent -> worldSector ; if ( ! ws ) { return ; // ▁ not ▁ linked ▁ in ▁ anywhere ENDCOM } ent -> worldSector = NULL ; if ( ws -> entities == ent ) { ws -> entities = ent -> nextEntityInWorldSector ; return ; } for ( scan = ws -> entities ; scan ; scan = scan -> nextEntityInWorldSector ) { if ( scan -> nextEntityInWorldSector == ent ) { scan -> nextEntityInWorldSector = ent -> nextEntityInWorldSector ; return ; } } Com_Printf ( " WARNING : ▁ SV _ UnlinkEntity : ▁ not ▁ found ▁ in ▁ worldSector \n " ) ; }
/*  STRNEWLINE = = = = =  STRNEWLINE SV _ LinkEntity STRNEWLINE  STRNEWLINE = = = = =  STRNEWLINE */ ENDCOM void SV_LinkEntity ( sharedEntity_t * gEnt ) { worldSector_t * node ; int leafs [ MAX_TOTAL_ENT_LEAFS ] ; int cluster ; int num_leafs ; int i , j , k ; int area ; int lastLeaf ; float * origin , * angles ; svEntity_t * ent ; ent = SV_SvEntityForGentity ( gEnt ) ; if ( ent -> worldSector ) { SV_UnlinkEntity ( gEnt ) ; // ▁ unlink ▁ from ▁ old ▁ position ENDCOM } // ▁ encode ▁ the ▁ size ▁ into ▁ the ▁ entityState _ t ▁ for ▁ client ▁ prediction ENDCOM if ( gEnt -> r . bmodel ) { gEnt -> s . solid = SOLID_BMODEL ; // ▁ a ▁ solid _ box ▁ will ▁ never ▁ create ▁ this ▁ value ENDCOM } else if ( gEnt -> r . contents & ( CONTENTS_SOLID | CONTENTS_BODY ) ) { // ▁ assume ▁ that ▁ x / y ▁ are ▁ equal ▁ and ▁ symetric ENDCOM i = gEnt -> r . maxs [ 0 ] ; if ( i < 1 ) i = 1 ; if ( i > 255 ) i = 255 ; // ▁ z ▁ is ▁ not ▁ symetric ENDCOM j = ( - gEnt -> r . mins [ 2 ] ) ; if ( j < 1 ) j = 1 ; if ( j > 255 ) j = 255 ; // ▁ and ▁ z ▁ maxs ▁ can ▁ be ▁ negative . . . ENDCOM k = ( gEnt -> r . maxs [ 2 ] + 32 ) ; if ( k < 1 ) k = 1 ; if ( k > 255 ) k = 255 ; gEnt -> s . solid = ( k << 16 ) | ( j << 8 ) | i ; } else { gEnt -> s . solid = 0 ; } // ▁ get ▁ the ▁ position ENDCOM origin = gEnt -> r . currentOrigin ; angles = gEnt -> r . currentAngles ; // ▁ set ▁ the ▁ abs ▁ box ENDCOM if ( gEnt -> r . bmodel && ( angles [ 0 ] || angles [ 1 ] || angles [ 2 ] ) ) { // ▁ expand ▁ for ▁ rotation ENDCOM float max ; int i ; max = RadiusFromBounds ( gEnt -> r . mins , gEnt -> r . maxs ) ; for ( i = 0 ; i < 3 ; i ++ ) { gEnt -> r . absmin [ i ] = origin [ i ] - max ; gEnt -> r . absmax [ i ] = origin [ i ] + max ; } } else { // ▁ normal ENDCOM VectorAdd ( origin , gEnt -> r . mins , gEnt -> r . absmin ) ; VectorAdd ( origin , gEnt -> r . maxs , gEnt -> r . absmax ) ; } // ▁ because ▁ movement ▁ is ▁ clipped ▁ an ▁ epsilon ▁ away ▁ from ▁ an ▁ actual ▁ edge , ENDCOM // ▁ we ▁ must ▁ fully ▁ check ▁ even ▁ when ▁ bounding ▁ boxes ▁ don ' t ▁ quite ▁ touch ENDCOM gEnt -> r . absmin [ 0 ] -= 1 ; gEnt -> r . absmin [ 1 ] -= 1 ; gEnt -> r . absmin [ 2 ] -= 1 ; gEnt -> r . absmax [ 0 ] += 1 ; gEnt -> r . absmax [ 1 ] += 1 ; gEnt -> r . absmax [ 2 ] += 1 ; // ▁ link ▁ to ▁ PVS ▁ leafs ENDCOM ent -> numClusters = 0 ; ent -> lastCluster = 0 ; ent -> areanum = - 1 ; ent -> areanum2 = - 1 ; // get ▁ all ▁ leafs , ▁ including ▁ solids ENDCOM num_leafs = CM_BoxLeafnums ( gEnt -> r . absmin , gEnt -> r . absmax , leafs , MAX_TOTAL_ENT_LEAFS , & lastLeaf ) ; // ▁ if ▁ none ▁ of ▁ the ▁ leafs ▁ were ▁ inside ▁ the ▁ map , ▁ the ENDCOM // ▁ entity ▁ is ▁ outside ▁ the ▁ world ▁ and ▁ can ▁ be ▁ considered ▁ unlinked ENDCOM if ( ! num_leafs ) { return ; } // ▁ set ▁ areas , ▁ even ▁ from ▁ clusters ▁ that ▁ don ' t ▁ fit ▁ in ▁ the ▁ entity ▁ array ENDCOM for ( i = 0 ; i < num_leafs ; i ++ ) { area = CM_LeafArea ( leafs [ i ] ) ; if ( area != - 1 ) { // ▁ doors ▁ may ▁ legally ▁ straggle ▁ two ▁ areas , ENDCOM // ▁ but ▁ nothing ▁ should ▁ evern ▁ need ▁ more ▁ than ▁ that ENDCOM if ( ent -> areanum != - 1 && ent -> areanum != area ) { if ( ent -> areanum2 != - 1 && ent -> areanum2 != area && sv . state == SS_LOADING ) { Com_DPrintf ( " Object ▁ % i ▁ touching ▁ 3 ▁ areas ▁ at ▁ % f ▁ % f ▁ % f \n " , gEnt -> s . number , gEnt -> r . absmin [ 0 ] , gEnt -> r . absmin [ 1 ] , gEnt -> r . absmin [ 2 ] ) ; } ent -> areanum2 = area ; } else { ent -> areanum = area ; } } } // ▁ store ▁ as ▁ many ▁ explicit ▁ clusters ▁ as ▁ we ▁ can ENDCOM ent -> numClusters = 0 ; for ( i = 0 ; i < num_leafs ; i ++ ) { cluster = CM_LeafCluster ( leafs [ i ] ) ; if ( cluster != - 1 ) { ent -> clusternums [ ent -> numClusters ++ ] = cluster ; if ( ent -> numClusters == MAX_ENT_CLUSTERS ) { break ; } } } // ▁ store ▁ off ▁ a ▁ last ▁ cluster ▁ if ▁ we ▁ need ▁ to ENDCOM if ( i != num_leafs ) { ent -> lastCluster = CM_LeafCluster ( lastLeaf ) ; } gEnt -> r . linkcount ++ ; // ▁ find ▁ the ▁ first ▁ world ▁ sector ▁ node ▁ that ▁ the ▁ ent ' s ▁ box ▁ crosses ENDCOM node = sv_worldSectors ; while ( 1 ) { if ( node -> axis == - 1 ) break ; if ( gEnt -> r . absmin [ node -> axis ] > node -> dist ) node = node -> children [ 0 ] ; else if ( gEnt -> r . absmax [ node -> axis ] < node -> dist ) node = node -> children [ 1 ] ; else break ; // ▁ crosses ▁ the ▁ node ENDCOM } // ▁ link ▁ it ▁ in ENDCOM ent -> worldSector = node ; ent -> nextEntityInWorldSector = node -> entities ; node -> entities = ent ; gEnt -> r . linked = qtrue ; }
/*  STRNEWLINE = = = = =  STRNEWLINE SV _ AreaEntities _ r STRNEWLINE  STRNEWLINE = = = = =  STRNEWLINE */ ENDCOM void SV_AreaEntities_r ( worldSector_t * node , areaParms_t * ap ) { svEntity_t * check , * next ; sharedEntity_t * gcheck ; int count ; count = 0 ; for ( check = node -> entities ; check ; check = next ) { next = check -> nextEntityInWorldSector ; gcheck = SV_GEntityForSvEntity ( check ) ; if ( gcheck -> r . absmin [ 0 ] > ap -> maxs [ 0 ] || gcheck -> r . absmin [ 1 ] > ap -> maxs [ 1 ] || gcheck -> r . absmin [ 2 ] > ap -> maxs [ 2 ] || gcheck -> r . absmax [ 0 ] < ap -> mins [ 0 ] || gcheck -> r . absmax [ 1 ] < ap -> mins [ 1 ] || gcheck -> r . absmax [ 2 ] < ap -> mins [ 2 ] ) { continue ; } if ( ap -> count == ap -> maxcount ) { Com_Printf ( " SV _ AreaEntities : ▁ MAXCOUNT \n " ) ; return ; } ap -> list [ ap -> count ] = check - sv . svEntities ; ap -> count ++ ; } if ( node -> axis == - 1 ) { return ; // ▁ terminal ▁ node ENDCOM } // ▁ recurse ▁ down ▁ both ▁ sides ENDCOM if ( ap -> maxs [ node -> axis ] > node -> dist ) { SV_AreaEntities_r ( node -> children [ 0 ] , ap ) ; } if ( ap -> mins [ node -> axis ] < node -> dist ) { SV_AreaEntities_r ( node -> children [ 1 ] , ap ) ; } }
/*  STRNEWLINE = = = = =  STRNEWLINE SV _ AreaEntities STRNEWLINE = = = = =  STRNEWLINE */ ENDCOM int SV_AreaEntities ( const vec3_t mins , const vec3_t maxs , int * entityList , int maxcount ) { areaParms_t ap ; ap . mins = mins ; ap . maxs = maxs ; ap . list = entityList ; ap . count = 0 ; ap . maxcount = maxcount ; SV_AreaEntities_r ( sv_worldSectors , & ap ) ; return ap . count ; }
/*  STRNEWLINE = = = = =  STRNEWLINE SV _ ClipToEntity STRNEWLINE  STRNEWLINE = = = = =  STRNEWLINE */ ENDCOM void SV_ClipToEntity ( trace_t * trace , const vec3_t start , const vec3_t mins , const vec3_t maxs , const vec3_t end , int entityNum , int contentmask , int capsule ) { sharedEntity_t * touch ; clipHandle_t clipHandle ; float * origin , * angles ; touch = SV_GentityNum ( entityNum ) ; Com_Memset ( trace , 0 , sizeof ( trace_t ) ) ; // ▁ if ▁ it ▁ doesn ' t ▁ have ▁ any ▁ brushes ▁ of ▁ a ▁ type ▁ we ENDCOM // ▁ are ▁ looking ▁ for , ▁ ignore ▁ it ENDCOM if ( ! ( contentmask & touch -> r . contents ) ) { trace -> fraction = 1.0 ; return ; } // ▁ might ▁ intersect , ▁ so ▁ do ▁ an ▁ exact ▁ clip ENDCOM clipHandle = SV_ClipHandleForEntity ( touch ) ; origin = touch -> r . currentOrigin ; angles = touch -> r . currentAngles ; if ( ! touch -> r . bmodel ) { angles = vec3_origin ; // ▁ boxes ▁ don ' t ▁ rotate ENDCOM } CM_TransformedBoxTrace ( trace , ( float * ) start , ( float * ) end , ( float * ) mins , ( float * ) maxs , clipHandle , contentmask , origin , angles , capsule ) ; if ( trace -> fraction < 1 ) { trace -> entityNum = touch -> s . number ; } }
/*  STRNEWLINE = = = = =  STRNEWLINE SV _ ClipMoveToEntities STRNEWLINE  STRNEWLINE = = = = =  STRNEWLINE */ ENDCOM void SV_ClipMoveToEntities ( moveclip_t * clip ) { int i , num ; int touchlist [ MAX_GENTITIES ] ; sharedEntity_t * touch ; int passOwnerNum ; trace_t trace , oldTrace ; clipHandle_t clipHandle ; float * origin , * angles ; int thisOwnerShared = 1 ; num = SV_AreaEntities ( clip -> boxmins , clip -> boxmaxs , touchlist , MAX_GENTITIES ) ; if ( clip -> passEntityNum != ENTITYNUM_NONE ) { passOwnerNum = ( SV_GentityNum ( clip -> passEntityNum ) ) -> r . ownerNum ; if ( passOwnerNum == ENTITYNUM_NONE ) { passOwnerNum = - 1 ; } } else { passOwnerNum = - 1 ; } if ( SV_GentityNum ( clip -> passEntityNum ) -> r . svFlags & SVF_OWNERNOTSHARED ) { thisOwnerShared = 0 ; } for ( i = 0 ; i < num ; i ++ ) { if ( clip -> trace . allsolid ) { return ; } touch = SV_GentityNum ( touchlist [ i ] ) ; // ▁ see ▁ if ▁ we ▁ should ▁ ignore ▁ this ▁ entity ENDCOM if ( clip -> passEntityNum != ENTITYNUM_NONE ) { if ( touchlist [ i ] == clip -> passEntityNum ) { continue ; // ▁ don ' t ▁ clip ▁ against ▁ the ▁ pass ▁ entity ENDCOM } if ( touch -> r . ownerNum == clip -> passEntityNum ) { if ( touch -> r . svFlags & SVF_OWNERNOTSHARED ) { if ( clip -> contentmask != ( MASK_SHOT | CONTENTS_LIGHTSABER ) && clip -> contentmask != ( MASK_SHOT ) ) { // it ' s ▁ not ▁ a ▁ laser ▁ hitting ▁ the ▁ other ▁ " missile " , ▁ don ' t ▁ care ▁ then ENDCOM continue ; } } else { continue ; // ▁ don ' t ▁ clip ▁ against ▁ own ▁ missiles ENDCOM } } if ( touch -> r . ownerNum == passOwnerNum && ! ( touch -> r . svFlags & SVF_OWNERNOTSHARED ) && ! thisOwnerShared ) { continue ; // ▁ don ' t ▁ clip ▁ against ▁ other ▁ missiles ▁ from ▁ our ▁ owner ENDCOM } } // ▁ if ▁ it ▁ doesn ' t ▁ have ▁ any ▁ brushes ▁ of ▁ a ▁ type ▁ we ENDCOM // ▁ are ▁ looking ▁ for , ▁ ignore ▁ it ENDCOM if ( ! ( clip -> contentmask & touch -> r . contents ) ) { continue ; } if ( ( clip -> contentmask == ( MASK_SHOT | CONTENTS_LIGHTSABER ) || clip -> contentmask == MASK_SHOT ) && ( touch -> r . contents > 0 && ( touch -> r . contents & CONTENTS_NOSHOT ) ) ) { continue ; } // ▁ might ▁ intersect , ▁ so ▁ do ▁ an ▁ exact ▁ clip ENDCOM clipHandle = SV_ClipHandleForEntity ( touch ) ; origin = touch -> r . currentOrigin ; angles = touch -> r . currentAngles ; if ( ! touch -> r . bmodel ) { angles = vec3_origin ; // ▁ boxes ▁ don ' t ▁ rotate ENDCOM } CM_TransformedBoxTrace ( & trace , ( float * ) clip -> start , ( float * ) clip -> end , ( float * ) clip -> mins , ( float * ) clip -> maxs , clipHandle , clip -> contentmask , origin , angles , clip -> capsule ) ; /*  STRNEWLINE Ghoul2 ▁ Insert ▁ Start STRNEWLINE */ ENDCOM // ▁ keep ▁ these ▁ older ▁ variables ▁ around ▁ for ▁ a ▁ bit , ▁ incase ▁ we ▁ need ▁ to ▁ replace ▁ them ▁ in ▁ the ▁ Ghoul2 ▁ Collision ▁ check ENDCOM oldTrace = clip -> trace ; /*  STRNEWLINE Ghoul2 ▁ Insert ▁ End STRNEWLINE */ ENDCOM if ( trace . allsolid ) { clip -> trace . allsolid = qtrue ; trace . entityNum = touch -> s . number ; } else if ( trace . startsolid ) { clip -> trace . startsolid = qtrue ; trace . entityNum = touch -> s . number ; } if ( trace . fraction < clip -> trace . fraction ) { qboolean oldStart ; // ▁ make ▁ sure ▁ we ▁ keep ▁ a ▁ startsolid ▁ from ▁ a ▁ previous ▁ trace ENDCOM oldStart = clip -> trace . startsolid ; trace . entityNum = touch -> s . number ; clip -> trace = trace ; clip -> trace . startsolid = ( qboolean ) ( ( unsigned ) clip -> trace . startsolid | ( unsigned ) oldStart ) ; } /*  STRNEWLINE Ghoul2 ▁ Insert ▁ Start STRNEWLINE */ ENDCOM // ▁ decide ▁ if ▁ we ▁ should ▁ do ▁ the ▁ ghoul2 ▁ collision ▁ detection ▁ right ▁ here ENDCOM if ( ( trace . entityNum == touch -> s . number ) && ( clip -> traceFlags ) ) { // ▁ do ▁ we ▁ actually ▁ have ▁ a ▁ ghoul2 ▁ model ▁ here ? ENDCOM if ( touch -> s . ghoul2 ) { int oldTraceRecSize = 0 ; int newTraceRecSize = 0 ; int z ; // ▁ we ▁ have ▁ to ▁ do ▁ this ▁ because ▁ sometimes ▁ you ▁ may ▁ hit ▁ a ▁ model ' s ▁ bounding ▁ box , ▁ but ▁ not ▁ actually ▁ penetrate ▁ the ▁ Ghoul2 ▁ Models ▁ polygons ENDCOM // ▁ this ▁ is , ▁ needless ▁ to ▁ say , ▁ not ▁ good . ▁ So ▁ we ▁ must ▁ check ▁ to ▁ see ▁ if ▁ we ▁ did ▁ actually ▁ hit ▁ the ▁ model , ▁ and ▁ if ▁ not , ▁ reset ▁ the ▁ trace ▁ stuff ENDCOM // ▁ to ▁ what ▁ it ▁ was ▁ to ▁ begin ▁ with ENDCOM // ▁ set ▁ our ▁ trace ▁ record ▁ size ENDCOM for ( z = 0 ; z < MAX_G2_COLLISIONS ; z ++ ) { if ( clip -> trace . G2CollisionMap [ z ] . mEntityNum != - 1 ) { oldTraceRecSize ++ ; } } G2API_CollisionDetect ( & clip -> trace . G2CollisionMap [ 0 ] , * ( ( CGhoul2Info_v * ) touch -> s . ghoul2 ) , touch -> s . angles , touch -> s . origin , svs . time , touch -> s . number , clip -> start , clip -> end , touch -> s . modelScale , G2VertSpaceServer , clip -> traceFlags , clip -> useLod ) ; // ▁ set ▁ our ▁ new ▁ trace ▁ record ▁ size ENDCOM for ( z = 0 ; z < MAX_G2_COLLISIONS ; z ++ ) { if ( clip -> trace . G2CollisionMap [ z ] . mEntityNum != - 1 ) { newTraceRecSize ++ ; } } // ▁ did ▁ we ▁ actually ▁ touch ▁ this ▁ model ? ▁ If ▁ not , ▁ lets ▁ reset ▁ this ▁ ent ▁ as ▁ being ▁ hit . . ENDCOM if ( newTraceRecSize == oldTraceRecSize ) { clip -> trace = oldTrace ; } } } /*  STRNEWLINE Ghoul2 ▁ Insert ▁ End STRNEWLINE */ ENDCOM } }
/*  STRNEWLINE = = = = =  STRNEWLINE SV _ Trace STRNEWLINE  STRNEWLINE Moves ▁ the ▁ given ▁ mins / maxs ▁ volume ▁ through ▁ the ▁ world ▁ from ▁ start ▁ to ▁ end .  STRNEWLINE passEntityNum ▁ and ▁ entities ▁ owned ▁ by ▁ passEntityNum ▁ are ▁ explicitly ▁ not ▁ checked .  STRNEWLINE = = = = =  STRNEWLINE */ ENDCOM /*  STRNEWLINE Ghoul2 ▁ Insert ▁ Start STRNEWLINE */ ENDCOM void SV_Trace ( trace_t * results , const vec3_t start , const vec3_t mins , const vec3_t maxs , const vec3_t end , int passEntityNum , int contentmask , int capsule , int traceFlags , int useLod ) { /*  STRNEWLINE Ghoul2 ▁ Insert ▁ End STRNEWLINE */ ENDCOM moveclip_t clip ; int i ; if ( ! mins ) { mins = vec3_origin ; } if ( ! maxs ) { maxs = vec3_origin ; } Com_Memset ( & clip , 0 , sizeof ( moveclip_t ) ) ; // ▁ clip ▁ to ▁ world ENDCOM CM_BoxTrace ( & clip . trace , start , end , mins , maxs , 0 , contentmask , capsule ) ; clip . trace . entityNum = clip . trace . fraction != 1.0 ? ENTITYNUM_WORLD : ENTITYNUM_NONE ; if ( clip . trace . fraction == 0 ) { * results = clip . trace ; return ; // ▁ blocked ▁ immediately ▁ by ▁ the ▁ world ENDCOM } clip . contentmask = contentmask ; /*  STRNEWLINE Ghoul2 ▁ Insert ▁ Start STRNEWLINE */ ENDCOM VectorCopy ( start , clip . start ) ; clip . traceFlags = traceFlags ; clip . useLod = useLod ; /*  STRNEWLINE Ghoul2 ▁ Insert ▁ End STRNEWLINE */ ENDCOM // TABSYMBOL VectorCopy ( ▁ clip . trace . endpos , ▁ clip . end ▁ ) ; ENDCOM VectorCopy ( end , clip . end ) ; clip . mins = mins ; clip . maxs = maxs ; clip . passEntityNum = passEntityNum ; clip . capsule = capsule ; // ▁ create ▁ the ▁ bounding ▁ box ▁ of ▁ the ▁ entire ▁ move ENDCOM // ▁ we ▁ can ▁ limit ▁ it ▁ to ▁ the ▁ part ▁ of ▁ the ▁ move ▁ not ENDCOM // ▁ already ▁ clipped ▁ off ▁ by ▁ the ▁ world , ▁ which ▁ can ▁ be ENDCOM // ▁ a ▁ significant ▁ savings ▁ for ▁ line ▁ of ▁ sight ▁ and ▁ shot ▁ traces ENDCOM for ( i = 0 ; i < 3 ; i ++ ) { if ( end [ i ] > start [ i ] ) { clip . boxmins [ i ] = clip . start [ i ] + clip . mins [ i ] - 1 ; clip . boxmaxs [ i ] = clip . end [ i ] + clip . maxs [ i ] + 1 ; } else { clip . boxmins [ i ] = clip . end [ i ] + clip . mins [ i ] - 1 ; clip . boxmaxs [ i ] = clip . start [ i ] + clip . maxs [ i ] + 1 ; } } // ▁ clip ▁ to ▁ other ▁ solid ▁ entities ENDCOM SV_ClipMoveToEntities ( & clip ) ; * results = clip . trace ; }
/*  STRNEWLINE = = = = =  STRNEWLINE SV _ PointContents STRNEWLINE = = = = =  STRNEWLINE */ ENDCOM int SV_PointContents ( const vec3_t p , int passEntityNum ) { int touch [ MAX_GENTITIES ] ; sharedEntity_t * hit ; int i , num ; int contents , c2 ; clipHandle_t clipHandle ; float * angles ; // ▁ get ▁ base ▁ contents ▁ from ▁ world ENDCOM contents = CM_PointContents ( p , 0 ) ; // ▁ or ▁ in ▁ contents ▁ from ▁ all ▁ the ▁ other ▁ entities ENDCOM num = SV_AreaEntities ( p , p , touch , MAX_GENTITIES ) ; for ( i = 0 ; i < num ; i ++ ) { if ( touch [ i ] == passEntityNum ) { continue ; } hit = SV_GentityNum ( touch [ i ] ) ; // ▁ might ▁ intersect , ▁ so ▁ do ▁ an ▁ exact ▁ clip ENDCOM clipHandle = SV_ClipHandleForEntity ( hit ) ; angles = hit -> s . angles ; if ( ! hit -> r . bmodel ) { angles = vec3_origin ; // ▁ boxes ▁ don ' t ▁ rotate ENDCOM } c2 = CM_TransformedPointContents ( p , clipHandle , hit -> s . origin , hit -> s . angles ) ; contents |= c2 ; } return contents ; }
BOOST_AUTO_TEST_SUITE ( multisig_tests ) CScript sign_multisig ( CScript scriptPubKey , vector < CKey > keys , CTransaction transaction , int whichIn ) { uint256 hash = SignatureHash ( scriptPubKey , transaction , whichIn , SIGHASH_ALL ) ; CScript result ; result << OP_0 ; // ▁ CHECKMULTISIG ▁ bug ▁ workaround ENDCOM BOOST_FOREACH ( const CKey & key , keys ) { vector < unsigned char > vchSig ; BOOST_CHECK ( key . Sign ( hash , vchSig ) ) ; vchSig . push_back ( ( unsigned char ) SIGHASH_ALL ) ; result << vchSig ; } return result ; }
BOOST_AUTO_TEST_CASE ( multisig_verify ) { unsigned int flags = SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_STRICTENC ; CKey key [ 4 ] ; for ( int i = 0 ; i < 4 ; i ++ ) key [ i ] . MakeNewKey ( true ) ; CScript a_and_b ; a_and_b << OP_2 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << OP_2 << OP_CHECKMULTISIG ; CScript a_or_b ; a_or_b << OP_1 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << OP_2 << OP_CHECKMULTISIG ; CScript escrow ; escrow << OP_2 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << key [ 2 ] . GetPubKey ( ) << OP_3 << OP_CHECKMULTISIG ; CTransaction txFrom ; // ▁ Funding ▁ transaction ENDCOM txFrom . vout . resize ( 3 ) ; txFrom . vout [ 0 ] . scriptPubKey = a_and_b ; txFrom . vout [ 1 ] . scriptPubKey = a_or_b ; txFrom . vout [ 2 ] . scriptPubKey = escrow ; CTransaction txTo [ 3 ] ; // ▁ Spending ▁ transaction ENDCOM for ( int i = 0 ; i < 3 ; i ++ ) { txTo [ i ] . vin . resize ( 1 ) ; txTo [ i ] . vout . resize ( 1 ) ; txTo [ i ] . vin [ 0 ] . prevout . n = i ; txTo [ i ] . vin [ 0 ] . prevout . hash = txFrom . GetHash ( ) ; txTo [ i ] . vout [ 0 ] . nValue = 1 ; } vector < CKey > keys ; CScript s ; // ▁ Test ▁ a ▁ AND ▁ b : ENDCOM keys . clear ( ) ; keys += key [ 0 ] , key [ 1 ] ; // ▁ magic ▁ operator + = ▁ from ▁ boost . assign ENDCOM s = sign_multisig ( a_and_b , keys , txTo [ 0 ] , 0 ) ; BOOST_CHECK ( VerifyScript ( s , a_and_b , txTo [ 0 ] , 0 , flags , 0 ) ) ; for ( int i = 0 ; i < 4 ; i ++ ) { keys . clear ( ) ; keys += key [ i ] ; s = sign_multisig ( a_and_b , keys , txTo [ 0 ] , 0 ) ; BOOST_CHECK_MESSAGE ( ! VerifyScript ( s , a_and_b , txTo [ 0 ] , 0 , flags , 0 ) , strprintf ( " a & b ▁ 1 : ▁ % d " , i ) ) ; keys . clear ( ) ; keys += key [ 1 ] , key [ i ] ; s = sign_multisig ( a_and_b , keys , txTo [ 0 ] , 0 ) ; BOOST_CHECK_MESSAGE ( ! VerifyScript ( s , a_and_b , txTo [ 0 ] , 0 , flags , 0 ) , strprintf ( " a & b ▁ 2 : ▁ % d " , i ) ) ; } // ▁ Test ▁ a ▁ OR ▁ b : ENDCOM for ( int i = 0 ; i < 4 ; i ++ ) { keys . clear ( ) ; keys += key [ i ] ; s = sign_multisig ( a_or_b , keys , txTo [ 1 ] , 0 ) ; if ( i == 0 || i == 1 ) BOOST_CHECK_MESSAGE ( VerifyScript ( s , a_or_b , txTo [ 1 ] , 0 , flags , 0 ) , strprintf ( " a | b : ▁ % d " , i ) ) ; else BOOST_CHECK_MESSAGE ( ! VerifyScript ( s , a_or_b , txTo [ 1 ] , 0 , flags , 0 ) , strprintf ( " a | b : ▁ % d " , i ) ) ; } s . clear ( ) ; s << OP_0 << OP_0 ; BOOST_CHECK ( ! VerifyScript ( s , a_or_b , txTo [ 1 ] , 0 , flags , 0 ) ) ; s . clear ( ) ; s << OP_0 << OP_1 ; BOOST_CHECK ( ! VerifyScript ( s , a_or_b , txTo [ 1 ] , 0 , flags , 0 ) ) ; for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) { keys . clear ( ) ; keys += key [ i ] , key [ j ] ; s = sign_multisig ( escrow , keys , txTo [ 2 ] , 0 ) ; if ( i < j && i < 3 && j < 3 ) BOOST_CHECK_MESSAGE ( VerifyScript ( s , escrow , txTo [ 2 ] , 0 , flags , 0 ) , strprintf ( " escrow ▁ 1 : ▁ % d ▁ % d " , i , j ) ) ; else BOOST_CHECK_MESSAGE ( ! VerifyScript ( s , escrow , txTo [ 2 ] , 0 , flags , 0 ) , strprintf ( " escrow ▁ 2 : ▁ % d ▁ % d " , i , j ) ) ; } }
BOOST_AUTO_TEST_CASE ( multisig_IsStandard ) { CKey key [ 4 ] ; for ( int i = 0 ; i < 4 ; i ++ ) key [ i ] . MakeNewKey ( true ) ; CScript a_and_b ; a_and_b << OP_2 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << OP_2 << OP_CHECKMULTISIG ; BOOST_CHECK ( :: IsStandard ( a_and_b ) ) ; CScript a_or_b ; a_or_b << OP_1 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << OP_2 << OP_CHECKMULTISIG ; BOOST_CHECK ( :: IsStandard ( a_or_b ) ) ; CScript escrow ; escrow << OP_2 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << key [ 2 ] . GetPubKey ( ) << OP_3 << OP_CHECKMULTISIG ; BOOST_CHECK ( :: IsStandard ( escrow ) ) ; CScript one_of_four ; one_of_four << OP_1 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << key [ 2 ] . GetPubKey ( ) << key [ 3 ] . GetPubKey ( ) << OP_4 << OP_CHECKMULTISIG ; BOOST_CHECK ( ! :: IsStandard ( one_of_four ) ) ; CScript malformed [ 6 ] ; malformed [ 0 ] << OP_3 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << OP_2 << OP_CHECKMULTISIG ; malformed [ 1 ] << OP_2 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << OP_3 << OP_CHECKMULTISIG ; malformed [ 2 ] << OP_0 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << OP_2 << OP_CHECKMULTISIG ; malformed [ 3 ] << OP_1 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << OP_0 << OP_CHECKMULTISIG ; malformed [ 4 ] << OP_1 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << OP_CHECKMULTISIG ; malformed [ 5 ] << OP_1 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) ; for ( int i = 0 ; i < 6 ; i ++ ) BOOST_CHECK ( ! :: IsStandard ( malformed [ i ] ) ) ; }
BOOST_AUTO_TEST_CASE ( multisig_Solver1 ) { // ▁ Tests ▁ Solver ( ) ▁ that ▁ returns ▁ lists ▁ of ▁ keys ▁ that ▁ are ENDCOM // ▁ required ▁ to ▁ satisfy ▁ a ▁ ScriptPubKey ENDCOM // ▁ Also ▁ tests ▁ IsMine ( ) ▁ and ▁ ExtractAddress ( ) ENDCOM // ▁ Note : ▁ ExtractAddress ▁ for ▁ the ▁ multisignature ▁ transactions ENDCOM // ▁ always ▁ returns ▁ false ▁ for ▁ this ▁ release , ▁ even ▁ if ▁ you ▁ have ENDCOM // ▁ one ▁ key ▁ that ▁ would ▁ satisfy ▁ an ▁ ( a | b ) ▁ or ▁ 2 - of - 3 ▁ keys ▁ needed ENDCOM // ▁ to ▁ spend ▁ an ▁ escrow ▁ transaction . ENDCOM CBasicKeyStore keystore , emptykeystore , partialkeystore ; CKey key [ 3 ] ; CTxDestination keyaddr [ 3 ] ; for ( int i = 0 ; i < 3 ; i ++ ) { key [ i ] . MakeNewKey ( true ) ; keystore . AddKey ( key [ i ] ) ; keyaddr [ i ] = key [ i ] . GetPubKey ( ) . GetID ( ) ; } partialkeystore . AddKey ( key [ 0 ] ) ; { vector < valtype > solutions ; txnouttype whichType ; CScript s ; s << key [ 0 ] . GetPubKey ( ) << OP_CHECKSIG ; BOOST_CHECK ( Solver ( s , whichType , solutions ) ) ; BOOST_CHECK ( solutions . size ( ) == 1 ) ; CTxDestination addr ; BOOST_CHECK ( ExtractDestination ( s , addr ) ) ; BOOST_CHECK ( addr == keyaddr [ 0 ] ) ; BOOST_CHECK ( IsMine ( keystore , s ) ) ; BOOST_CHECK ( ! IsMine ( emptykeystore , s ) ) ; } { vector < valtype > solutions ; txnouttype whichType ; CScript s ; s << OP_DUP << OP_HASH160 << key [ 0 ] . GetPubKey ( ) . GetID ( ) << OP_EQUALVERIFY << OP_CHECKSIG ; BOOST_CHECK ( Solver ( s , whichType , solutions ) ) ; BOOST_CHECK ( solutions . size ( ) == 1 ) ; CTxDestination addr ; BOOST_CHECK ( ExtractDestination ( s , addr ) ) ; BOOST_CHECK ( addr == keyaddr [ 0 ] ) ; BOOST_CHECK ( IsMine ( keystore , s ) ) ; BOOST_CHECK ( ! IsMine ( emptykeystore , s ) ) ; } { vector < valtype > solutions ; txnouttype whichType ; CScript s ; s << OP_2 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << OP_2 << OP_CHECKMULTISIG ; BOOST_CHECK ( Solver ( s , whichType , solutions ) ) ; BOOST_CHECK_EQUAL ( solutions . size ( ) , 4U ) ; CTxDestination addr ; BOOST_CHECK ( ! ExtractDestination ( s , addr ) ) ; BOOST_CHECK ( IsMine ( keystore , s ) ) ; BOOST_CHECK ( ! IsMine ( emptykeystore , s ) ) ; BOOST_CHECK ( ! IsMine ( partialkeystore , s ) ) ; } { vector < valtype > solutions ; txnouttype whichType ; CScript s ; s << OP_1 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << OP_2 << OP_CHECKMULTISIG ; BOOST_CHECK ( Solver ( s , whichType , solutions ) ) ; BOOST_CHECK_EQUAL ( solutions . size ( ) , 4U ) ; vector < CTxDestination > addrs ; int nRequired ; BOOST_CHECK ( ExtractDestinations ( s , whichType , addrs , nRequired ) ) ; BOOST_CHECK ( addrs [ 0 ] == keyaddr [ 0 ] ) ; BOOST_CHECK ( addrs [ 1 ] == keyaddr [ 1 ] ) ; BOOST_CHECK ( nRequired == 1 ) ; BOOST_CHECK ( IsMine ( keystore , s ) ) ; BOOST_CHECK ( ! IsMine ( emptykeystore , s ) ) ; BOOST_CHECK ( ! IsMine ( partialkeystore , s ) ) ; } { vector < valtype > solutions ; txnouttype whichType ; CScript s ; s << OP_2 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << key [ 2 ] . GetPubKey ( ) << OP_3 << OP_CHECKMULTISIG ; BOOST_CHECK ( Solver ( s , whichType , solutions ) ) ; BOOST_CHECK ( solutions . size ( ) == 5 ) ; } }
BOOST_AUTO_TEST_CASE ( multisig_Sign ) { // ▁ Test ▁ SignSignature ( ) ▁ ( and ▁ therefore ▁ the ▁ version ▁ of ▁ Solver ( ) ▁ that ▁ signs ▁ transactions ) ENDCOM CBasicKeyStore keystore ; CKey key [ 4 ] ; for ( int i = 0 ; i < 4 ; i ++ ) { key [ i ] . MakeNewKey ( true ) ; keystore . AddKey ( key [ i ] ) ; } CScript a_and_b ; a_and_b << OP_2 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << OP_2 << OP_CHECKMULTISIG ; CScript a_or_b ; a_or_b << OP_1 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << OP_2 << OP_CHECKMULTISIG ; CScript escrow ; escrow << OP_2 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << key [ 2 ] . GetPubKey ( ) << OP_3 << OP_CHECKMULTISIG ; CTransaction txFrom ; // ▁ Funding ▁ transaction ENDCOM txFrom . vout . resize ( 3 ) ; txFrom . vout [ 0 ] . scriptPubKey = a_and_b ; txFrom . vout [ 1 ] . scriptPubKey = a_or_b ; txFrom . vout [ 2 ] . scriptPubKey = escrow ; CTransaction txTo [ 3 ] ; // ▁ Spending ▁ transaction ENDCOM for ( int i = 0 ; i < 3 ; i ++ ) { txTo [ i ] . vin . resize ( 1 ) ; txTo [ i ] . vout . resize ( 1 ) ; txTo [ i ] . vin [ 0 ] . prevout . n = i ; txTo [ i ] . vin [ 0 ] . prevout . hash = txFrom . GetHash ( ) ; txTo [ i ] . vout [ 0 ] . nValue = 1 ; } for ( int i = 0 ; i < 3 ; i ++ ) { BOOST_CHECK_MESSAGE ( SignSignature ( keystore , txFrom , txTo [ i ] , 0 ) , strprintf ( " SignSignature ▁ % d " , i ) ) ; } }
// ▁ license : BSD - 3 - Clause ENDCOM // ▁ copyright - holders : Curt ▁ Coder ENDCOM / ▁ i8275 ▁ crtc ▁ display ▁ pixels I8275_DRAW_CHARACTER_MEMBER ( mm1_state :: crtc_display_pixels ) { UINT8 romdata = m_char_rom -> base ( ) [ ( charcode << 4 ) | linecount ] ; int gpa0 = BIT ( gpa , 0 ) ; // ▁ general ▁ purpose ▁ attribute ▁ 0 ENDCOM int llen = m_llen ; // ▁ light ▁ enable ENDCOM int compl_in = rvv ; // ▁ reverse ▁ video ENDCOM int hlt_in = hlgt ; // ▁ highlight ; ENDCOM int color ; // ▁ 0 ▁ = ▁ black , ▁ 1 ▁ = ▁ dk ▁ green , ▁ 2 ▁ = ▁ lt ▁ green ; ▁ on ▁ MikroMikko ▁ 1 , ▁ " highlight " ▁ is ▁ actually ▁ the ▁ darker ▁ shade ▁ of ▁ green ENDCOM int i , qh , video_in ; int d7 = BIT ( romdata , 7 ) ; // ▁ save ▁ MSB ▁ ( 1 ▁ indicates ▁ that ▁ this ▁ is ▁ a ▁ Visual ▁ Attribute ▁ or ▁ Special ▁ Code ▁ instead ▁ of ▁ a ▁ normal ▁ display ▁ character ) ENDCOM int d6 = BIT ( romdata , 6 ) ; // ▁ save ▁ also ▁ first ▁ and ▁ last ▁ char ▁ bitmap ▁ bits ▁ before ▁ shifting ▁ out ▁ the ▁ MSB ENDCOM int d0 = BIT ( romdata , 0 ) ; UINT8 data = ( romdata << 1 ) | ( d7 & d0 ) ; // ▁ get ▁ rid ▁ of ▁ MSB , ▁ duplicate ▁ LSB ▁ for ▁ special ▁ characters ENDCOM if ( y < 360 || x >= HORIZONTAL_CHARACTER_PIXELS || compl_in == 0 ) // ▁ leftmost ▁ char ▁ on ▁ the ▁ 25th ▁ row ▁ is ▁ never ▁ displayed ▁ on ▁ actual ▁ MikroMikko ▁ 1 ▁ HW ▁ if ▁ it ' s ▁ inversed ENDCOM { if ( HORIZONTAL_CHARACTER_PIXELS == 10 ) { // ▁ Hack ▁ to ▁ stretch ▁ 8 ▁ pixels ▁ wide ▁ character ▁ bitmap ▁ to ▁ 10 ▁ pixels ▁ on ▁ screen . ENDCOM // ▁ This ▁ was ▁ needed ▁ because ▁ high ▁ res ▁ graphics ▁ use ▁ 800 ▁ pixels ▁ wide ▁ bitmap ▁ but ENDCOM // ▁ 80 ▁ chars ▁ * ▁ 8 ▁ pixels ▁ is ▁ only ▁ 640 ▁ - > ▁ characters ▁ would ▁ cover ▁ only ▁ 80 % ▁ of ▁ the ▁ screen ▁ width . ENDCOM // ▁ Step ▁ 1 : ▁ Instead ▁ of ▁ 8 , ▁ set ▁ MCFG _ I8275 _ CHARACTER _ WIDTH ( 10 ) ▁ at ▁ the ▁ end ▁ of ▁ this ▁ file ENDCOM // ▁ Step ▁ 2 : ▁ Make ▁ sure ▁ i8275 _ device : : recompute _ parameters ( ) ▁ is ▁ called ▁ in ▁ i8275 _ device : : device _ start ( ) ENDCOM // ▁ Step ▁ 3 : ▁ Fill ▁ in ▁ missing ▁ 2 ▁ pixels ▁ in ▁ the ▁ screen ▁ bitmap ▁ by ▁ repeating ▁ last ▁ column ▁ of ▁ the ▁ char ▁ bitmap ENDCOM // ▁ ( works ▁ better ▁ with ▁ MikroMikko ▁ 1 ▁ font ▁ than ▁ duplicating ▁ the ▁ first ▁ and ▁ the ▁ last ▁ column ) ENDCOM qh = d7 & d6 ; // ▁ extend ▁ pixels ▁ on ▁ the ▁ right ▁ side ▁ only ▁ if ▁ there ▁ were ▁ two ▁ adjacent ▁ ones ▁ before ▁ shifting ▁ out ▁ the ▁ MSB ENDCOM video_in = ( ( ( ( d7 & llen ) | ( vsp ? 0 : 1 ) ) & ( gpa0 ? 0 : 1 ) ) & qh ) | lten ; color = ( hlt_in ? 1 : 2 ) * ( video_in ^ compl_in ) ; bitmap . pix32 ( y , x + 8 ) = m_palette -> pen ( color ) ; bitmap . pix32 ( y , x + 9 ) = m_palette -> pen ( color ) ; } for ( i = 0 ; i < 8 ; ++ i ) // ▁ . . . and ▁ now ▁ the ▁ actual ▁ character ▁ bitmap ▁ bits ▁ for ▁ this ▁ scanline ENDCOM { qh = BIT ( data , i ) ; video_in = ( ( ( ( d7 & llen ) | ( vsp ? 0 : 1 ) ) & ( gpa0 ? 0 : 1 ) ) & qh ) | lten ; color = ( hlt_in ? 1 : 2 ) * ( video_in ^ compl_in ) ; bitmap . pix32 ( y , x + i ) = m_palette -> pen ( color ) ; } } }
// ▁ ADDRESS _ MAP ( ▁ mm1 _ upd7220 _ map ▁ ) ENDCOM static ADDRESS_MAP_START ( mm1_upd7220_map , AS_0 , 16 , mm1_state ) ADDRESS_MAP_GLOBAL_MASK ( 0x7fff ) AM_RANGE ( 0x0000 , 0x7fff ) AM_RAM AM_SHARE ( " video _ ram " ) ADDRESS_MAP_END // ▁ UPD7220 _ INTERFACE ( ▁ hgdc _ intf ▁ ) ENDCOM UPD7220_DISPLAY_PIXELS_MEMBER ( mm1_state :: hgdc_display_pixels ) { UINT16 data = m_video_ram [ address >> 1 ] ; for ( int i = 0 ; i < 16 ; i ++ ) { if ( BIT ( data , i ) ) bitmap . pix32 ( y , x + i ) = m_palette -> pen ( 2 ) ; } }
// ▁ GFXDECODE ( ▁ mm1 ▁ ) ENDCOM static GFXDECODE_START ( mm1 ) GFXDECODE_ENTRY ( " chargen " , 0 , charlayout , 0 , 1 ) GFXDECODE_END PALETTE_INIT_MEMBER ( mm1_state , mm1 ) { palette . set_pen_color ( 0 , rgb_t ( 0x00 , 0x00 , 0x00 ) ) ; palette . set_pen_color ( 1 , rgb_t ( 0x00 , 0x7F , 0x0A ) ) ; // ▁ dark ▁ green ▁ ( " highlight " ▁ mode ▁ color ) ENDCOM palette . set_pen_color ( 2 , rgb_t ( 0x08 , 0xD0 , 0x1A ) ) ; // ▁ bright ▁ green ▁ ( normal ▁ color ) ENDCOM }
// ▁ Motivated ▁ by ▁ https : // bugs . webkit . org / show _ bug . cgi ? id = 38956 . ▁ libsoup ENDCOM // ▁ does ▁ not ▁ add ▁ the ▁ password ▁ to ▁ the ▁ URL ▁ when ▁ calling ENDCOM // ▁ soup _ uri _ to _ string , ▁ and ▁ thus ▁ the ▁ requests ▁ are ▁ not ▁ properly ENDCOM // ▁ built . ▁ Fixing ▁ soup _ uri _ to _ string ▁ is ▁ a ▁ no - no ▁ as ▁ the ▁ maintainer ▁ does ENDCOM // ▁ not ▁ want ▁ to ▁ break ▁ compatibility ▁ with ▁ previous ▁ implementations ENDCOM KURL soupURIToKURL ( SoupURI * soupURI ) { GOwnPtr < gchar > urlString ( soup_uri_to_string ( soupURI , FALSE ) ) ; KURL url ( KURL ( ) , String :: fromUTF8 ( urlString . get ( ) ) ) ; if ( ! soupURI -> password ) return url ; url . setPass ( String :: fromUTF8 ( soupURI -> password ) ) ; return url ; }
void EnsureWalletIsUnlocked ( ) { if ( pwalletMain -> IsLocked ( ) ) throw JSONRPCError ( RPC_WALLET_UNLOCK_NEEDED , " Error : ▁ Please ▁ enter ▁ the ▁ wallet ▁ passphrase ▁ with ▁ walletpassphrase ▁ first . " ) ; if ( fWalletUnlockStakingOnly ) throw JSONRPCError ( RPC_WALLET_ALREADY_UNLOCKED_STAKING_ONLY , " Error : ▁ Wallet ▁ is ▁ unlocked ▁ for ▁ staking ▁ only . " ) ; }
void WalletTxToJSON ( const CWalletTx & wtx , Object & entry ) { int confirms = wtx . GetDepthInMainChain ( ) ; entry . push_back ( Pair ( " confirmations " , confirms ) ) ; if ( wtx . IsCoinBase ( ) || wtx . IsCoinStake ( ) ) entry . push_back ( Pair ( " generated " , true ) ) ; if ( confirms > 0 ) { entry . push_back ( Pair ( " blockhash " , wtx . hashBlock . GetHex ( ) ) ) ; entry . push_back ( Pair ( " blockindex " , wtx . nIndex ) ) ; entry . push_back ( Pair ( " blocktime " , ( boost :: int64_t ) ( mapBlockIndex [ wtx . hashBlock ] -> nTime ) ) ) ; } entry . push_back ( Pair ( " txid " , wtx . GetHash ( ) . GetHex ( ) ) ) ; entry . push_back ( Pair ( " normtxid " , wtx . GetNormalizedHash ( ) . GetHex ( ) ) ) ; entry . push_back ( Pair ( " time " , ( boost :: int64_t ) wtx . GetTxTime ( ) ) ) ; entry . push_back ( Pair ( " timereceived " , ( boost :: int64_t ) wtx . nTimeReceived ) ) ; BOOST_FOREACH ( const PAIRTYPE ( string , string ) & item , wtx . mapValue ) entry . push_back ( Pair ( item . first , item . second ) ) ; }
string AccountFromValue ( const Value & value ) { string strAccount = value . get_str ( ) ; if ( strAccount == " * " ) throw JSONRPCError ( RPC_WALLET_INVALID_ACCOUNT_NAME , " Invalid ▁ account ▁ name " ) ; return strAccount ; }
Value getinfo ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) != 0 ) throw runtime_error ( " getinfo \n " " Returns ▁ an ▁ object ▁ containing ▁ various ▁ state ▁ info . " ) ; proxyType proxy ; GetProxy ( NET_IPV4 , proxy ) ; Object obj ; obj . push_back ( Pair ( " version " , ( int ) CLIENT_VERSION ) ) ; obj . push_back ( Pair ( " protocolversion " , ( int ) PROTOCOL_VERSION ) ) ; if ( pwalletMain ) { obj . push_back ( Pair ( " walletversion " , pwalletMain -> GetVersion ( ) ) ) ; obj . push_back ( Pair ( " balance " , ValueFromAmount ( pwalletMain -> GetBalance ( ) ) ) ) ; obj . push_back ( Pair ( " unconfirmedbalance " , ValueFromAmount ( pwalletMain -> GetUnconfirmedBalance ( ) ) ) ) ; obj . push_back ( Pair ( " stake " , ValueFromAmount ( pwalletMain -> GetStake ( ) ) ) ) ; obj . push_back ( Pair ( " locked " , pwalletMain -> IsLocked ( ) ) ) ; obj . push_back ( Pair ( " encrypted " , pwalletMain -> IsCrypted ( ) ) ) ; } obj . push_back ( Pair ( " blocks " , ( int ) nBestHeight ) ) ; obj . push_back ( Pair ( " timeoffset " , ( boost :: int64_t ) GetTimeOffset ( ) ) ) ; obj . push_back ( Pair ( " moneysupply " , ValueFromAmount ( pindexBest -> nMoneySupply ) ) ) ; obj . push_back ( Pair ( " connections " , ( int ) vNodes . size ( ) ) ) ; obj . push_back ( Pair ( " proxy " , ( proxy . first . IsValid ( ) ? proxy . first . ToStringIPPort ( ) : string ( ) ) ) ) ; obj . push_back ( Pair ( " difficulty " , ( double ) GetDifficulty ( ) ) ) ; obj . push_back ( Pair ( " testnet " , fTestNet ) ) ; if ( pwalletMain ) { obj . push_back ( Pair ( " keypoololdest " , ( boost :: int64_t ) pwalletMain -> GetOldestKeyPoolTime ( ) ) ) ; obj . push_back ( Pair ( " keypoolsize " , ( int ) pwalletMain -> GetKeyPoolSize ( ) ) ) ; } obj . push_back ( Pair ( " paytxfee " , ValueFromAmount ( nTransactionFee ) ) ) ; obj . push_back ( Pair ( " mininput " , ValueFromAmount ( nMinimumInputValue ) ) ) ; if ( pwalletMain && pwalletMain -> IsCrypted ( ) ) obj . push_back ( Pair ( " unlocked _ until " , ( boost :: int64_t ) nWalletUnlockTime ) ) ; obj . push_back ( Pair ( " errors " , GetWarnings ( " statusbar " ) ) ) ; return obj ; }
Value getnewaddress ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) > 1 ) throw runtime_error ( " getnewaddress ▁ [ account ] \n " " Returns ▁ a ▁ new ▁ ILoveYouCoins ▁ address ▁ for ▁ receiving ▁ payments . ▁ ▁ " " If ▁ [ account ] ▁ is ▁ specified ▁ ( recommended ) , ▁ it ▁ is ▁ added ▁ to ▁ the ▁ address ▁ book ▁ " " so ▁ payments ▁ received ▁ with ▁ the ▁ address ▁ will ▁ be ▁ credited ▁ to ▁ [ account ] . " ) ; // ▁ Parse ▁ the ▁ account ▁ first ▁ so ▁ we ▁ don ' t ▁ generate ▁ a ▁ key ▁ if ▁ there ' s ▁ an ▁ error ENDCOM string strAccount ; if ( params . size ( ) > 0 ) strAccount = AccountFromValue ( params [ 0 ] ) ; if ( ! pwalletMain -> IsLocked ( ) ) pwalletMain -> TopUpKeyPool ( ) ; // ▁ Generate ▁ a ▁ new ▁ key ▁ that ▁ is ▁ added ▁ to ▁ wallet ENDCOM CPubKey newKey ; if ( ! pwalletMain -> GetKeyFromPool ( newKey , false ) ) throw JSONRPCError ( RPC_WALLET_KEYPOOL_RAN_OUT , " Error : ▁ Keypool ▁ ran ▁ out , ▁ please ▁ call ▁ keypoolrefill ▁ first " ) ; CKeyID keyID = newKey . GetID ( ) ; pwalletMain -> SetAddressBookName ( keyID , strAccount ) ; return CBitcoinAddress ( keyID ) . ToString ( ) ; }
CBitcoinAddress GetAccountAddress ( string strAccount , bool bForceNew = false ) { CWalletDB walletdb ( pwalletMain -> strWalletFile ) ; CAccount account ; walletdb . ReadAccount ( strAccount , account ) ; bool bKeyUsed = false ; // ▁ Check ▁ if ▁ the ▁ current ▁ key ▁ has ▁ been ▁ used ENDCOM if ( account . vchPubKey . IsValid ( ) ) { CScript scriptPubKey ; scriptPubKey . SetDestination ( account . vchPubKey . GetID ( ) ) ; for ( map < uint256 , CWalletTx > :: iterator it = pwalletMain -> mapWallet . begin ( ) ; it != pwalletMain -> mapWallet . end ( ) && account . vchPubKey . IsValid ( ) ; ++ it ) { const CWalletTx & wtx = ( * it ) . second ; BOOST_FOREACH ( const CTxOut & txout , wtx . vout ) if ( txout . scriptPubKey == scriptPubKey ) bKeyUsed = true ; } } // ▁ Generate ▁ a ▁ new ▁ key ENDCOM if ( ! account . vchPubKey . IsValid ( ) || bForceNew || bKeyUsed ) { if ( ! pwalletMain -> GetKeyFromPool ( account . vchPubKey , false ) ) throw JSONRPCError ( RPC_WALLET_KEYPOOL_RAN_OUT , " Error : ▁ Keypool ▁ ran ▁ out , ▁ please ▁ call ▁ keypoolrefill ▁ first " ) ; pwalletMain -> SetAddressBookName ( account . vchPubKey . GetID ( ) , strAccount ) ; walletdb . WriteAccount ( strAccount , account ) ; } return CBitcoinAddress ( account . vchPubKey . GetID ( ) ) ; }
Value getaccountaddress ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) != 1 ) throw runtime_error ( " getaccountaddress ▁ < account > \n " " Returns ▁ the ▁ current ▁ ILoveYouCoins ▁ address ▁ for ▁ receiving ▁ payments ▁ to ▁ this ▁ account . " ) ; // ▁ Parse ▁ the ▁ account ▁ first ▁ so ▁ we ▁ don ' t ▁ generate ▁ a ▁ key ▁ if ▁ there ' s ▁ an ▁ error ENDCOM string strAccount = AccountFromValue ( params [ 0 ] ) ; Value ret ; ret = GetAccountAddress ( strAccount ) . ToString ( ) ; return ret ; }
Value setaccount ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) < 1 || params . size ( ) > 2 ) throw runtime_error ( " setaccount ▁ < iloveyoucoinsaddress > ▁ < account > \n " " Sets ▁ the ▁ account ▁ associated ▁ with ▁ the ▁ given ▁ address . " ) ; CBitcoinAddress address ( params [ 0 ] . get_str ( ) ) ; if ( ! address . IsValid ( ) ) throw JSONRPCError ( RPC_INVALID_ADDRESS_OR_KEY , " Invalid ▁ ILoveYouCoins ▁ address " ) ; string strAccount ; if ( params . size ( ) > 1 ) strAccount = AccountFromValue ( params [ 1 ] ) ; // ▁ Detect ▁ when ▁ changing ▁ the ▁ account ▁ of ▁ an ▁ address ▁ that ▁ is ▁ the ▁ ' unused ▁ current ▁ key ' ▁ of ▁ another ▁ account : ENDCOM if ( pwalletMain -> mapAddressBook . count ( address . Get ( ) ) ) { string strOldAccount = pwalletMain -> mapAddressBook [ address . Get ( ) ] ; if ( address == GetAccountAddress ( strOldAccount ) ) GetAccountAddress ( strOldAccount , true ) ; } pwalletMain -> SetAddressBookName ( address . Get ( ) , strAccount ) ; return Value :: null ; }
Value getaccount ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) != 1 ) throw runtime_error ( " getaccount ▁ < iloveyoucoinsaddress > \n " " Returns ▁ the ▁ account ▁ associated ▁ with ▁ the ▁ given ▁ address . " ) ; CBitcoinAddress address ( params [ 0 ] . get_str ( ) ) ; if ( ! address . IsValid ( ) ) throw JSONRPCError ( RPC_INVALID_ADDRESS_OR_KEY , " Invalid ▁ ILoveYouCoins ▁ address " ) ; string strAccount ; map < CTxDestination , string > :: iterator mi = pwalletMain -> mapAddressBook . find ( address . Get ( ) ) ; if ( mi != pwalletMain -> mapAddressBook . end ( ) && ! ( * mi ) . second . empty ( ) ) strAccount = ( * mi ) . second ; return strAccount ; }
Value getaddressesbyaccount ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) != 1 ) throw runtime_error ( " getaddressesbyaccount ▁ < account > \n " " Returns ▁ the ▁ list ▁ of ▁ addresses ▁ for ▁ the ▁ given ▁ account . " ) ; string strAccount = AccountFromValue ( params [ 0 ] ) ; // ▁ Find ▁ all ▁ addresses ▁ that ▁ have ▁ the ▁ given ▁ account ENDCOM Array ret ; BOOST_FOREACH ( const PAIRTYPE ( CBitcoinAddress , string ) & item , pwalletMain -> mapAddressBook ) { const CBitcoinAddress & address = item . first ; const string & strName = item . second ; if ( strName == strAccount ) ret . push_back ( address . ToString ( ) ) ; } return ret ; }
Value setmininput ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) < 1 || params . size ( ) > 1 ) throw runtime_error ( " setmininput ▁ < amount > \n " " < amount > ▁ is ▁ a ▁ real ▁ and ▁ is ▁ rounded ▁ to ▁ the ▁ nearest ▁ 0.00000001" ) ; // ▁ Amount ENDCOM int64 nAmount = 0 ; if ( params [ 0 ] . get_real ( ) != 0.0 ) nAmount = AmountFromValue ( params [ 0 ] ) ; // ▁ rejects ▁ 0.0 ▁ amounts ENDCOM nMinimumInputValue = nAmount ; return true ; }
Value sendtoaddress ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) < 2 || params . size ( ) > 4 ) throw runtime_error ( " sendtoaddress ▁ < iloveyoucoinsaddress > ▁ < amount > ▁ [ comment ] ▁ [ comment - to ] \n " " < amount > ▁ is ▁ a ▁ real ▁ and ▁ is ▁ rounded ▁ to ▁ the ▁ nearest ▁ 0.00000001" + HelpRequiringPassphrase ( ) ) ; CBitcoinAddress address ( params [ 0 ] . get_str ( ) ) ; if ( ! address . IsValid ( ) ) throw JSONRPCError ( RPC_INVALID_ADDRESS_OR_KEY , " Invalid ▁ ILoveYouCoins ▁ address " ) ; // ▁ Amount ENDCOM int64 nAmount = AmountFromValue ( params [ 1 ] ) ; // ▁ Wallet ▁ comments ENDCOM CWalletTx wtx ; if ( params . size ( ) > 2 && params [ 2 ] . type ( ) != null_type && ! params [ 2 ] . get_str ( ) . empty ( ) ) wtx . mapValue [ " comment " ] = params [ 2 ] . get_str ( ) ; if ( params . size ( ) > 3 && params [ 3 ] . type ( ) != null_type && ! params [ 3 ] . get_str ( ) . empty ( ) ) wtx . mapValue [ " to " ] = params [ 3 ] . get_str ( ) ; EnsureWalletIsUnlocked ( ) ; string strError = pwalletMain -> SendMoneyToDestination ( address . Get ( ) , nAmount , wtx ) ; if ( strError != " " ) throw JSONRPCError ( RPC_WALLET_ERROR , strError ) ; return wtx . GetHash ( ) . GetHex ( ) ; }
Value listaddressgroupings ( const Array & params , bool fHelp ) { if ( fHelp ) throw runtime_error ( " listaddressgroupings \n " " Lists ▁ groups ▁ of ▁ addresses ▁ which ▁ have ▁ had ▁ their ▁ common ▁ ownership \n " " made ▁ public ▁ by ▁ common ▁ use ▁ as ▁ inputs ▁ or ▁ as ▁ the ▁ resulting ▁ change \n " " in ▁ past ▁ transactions " ) ; Array jsonGroupings ; map < CTxDestination , int64 > balances = pwalletMain -> GetAddressBalances ( ) ; BOOST_FOREACH ( set < CTxDestination > grouping , pwalletMain -> GetAddressGroupings ( ) ) { Array jsonGrouping ; BOOST_FOREACH ( CTxDestination address , grouping ) { Array addressInfo ; addressInfo . push_back ( CBitcoinAddress ( address ) . ToString ( ) ) ; addressInfo . push_back ( ValueFromAmount ( balances [ address ] ) ) ; { LOCK ( pwalletMain -> cs_wallet ) ; if ( pwalletMain -> mapAddressBook . find ( CBitcoinAddress ( address ) . Get ( ) ) != pwalletMain -> mapAddressBook . end ( ) ) addressInfo . push_back ( pwalletMain -> mapAddressBook . find ( CBitcoinAddress ( address ) . Get ( ) ) -> second ) ; } jsonGrouping . push_back ( addressInfo ) ; } jsonGroupings . push_back ( jsonGrouping ) ; } return jsonGroupings ; }
Value signmessage ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) != 2 ) throw runtime_error ( " signmessage ▁ < iloveyoucoinsaddress > ▁ < message > \n " " Sign ▁ a ▁ message ▁ with ▁ the ▁ private ▁ key ▁ of ▁ an ▁ address " ) ; EnsureWalletIsUnlocked ( ) ; string strAddress = params [ 0 ] . get_str ( ) ; string strMessage = params [ 1 ] . get_str ( ) ; CBitcoinAddress addr ( strAddress ) ; if ( ! addr . IsValid ( ) ) throw JSONRPCError ( RPC_TYPE_ERROR , " Invalid ▁ address " ) ; CKeyID keyID ; if ( ! addr . GetKeyID ( keyID ) ) throw JSONRPCError ( RPC_TYPE_ERROR , " Address ▁ does ▁ not ▁ refer ▁ to ▁ key " ) ; CKey key ; if ( ! pwalletMain -> GetKey ( keyID , key ) ) throw JSONRPCError ( RPC_WALLET_ERROR , " Private ▁ key ▁ not ▁ available " ) ; CHashWriter ss ( SER_GETHASH , 0 ) ; ss << strMessageMagic ; ss << strMessage ; vector < unsigned char > vchSig ; if ( ! key . SignCompact ( ss . GetHash ( ) , vchSig ) ) throw JSONRPCError ( RPC_INVALID_ADDRESS_OR_KEY , " Sign ▁ failed " ) ; return EncodeBase64 ( & vchSig [ 0 ] , vchSig . size ( ) ) ; }
Value verifymessage ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) != 3 ) throw runtime_error ( " verifymessage ▁ < iloveyoucoinsaddress > ▁ < signature > ▁ < message > \n " " Verify ▁ a ▁ signed ▁ message " ) ; string strAddress = params [ 0 ] . get_str ( ) ; string strSign = params [ 1 ] . get_str ( ) ; string strMessage = params [ 2 ] . get_str ( ) ; CBitcoinAddress addr ( strAddress ) ; if ( ! addr . IsValid ( ) ) throw JSONRPCError ( RPC_TYPE_ERROR , " Invalid ▁ address " ) ; CKeyID keyID ; if ( ! addr . GetKeyID ( keyID ) ) throw JSONRPCError ( RPC_TYPE_ERROR , " Address ▁ does ▁ not ▁ refer ▁ to ▁ key " ) ; bool fInvalid = false ; vector < unsigned char > vchSig = DecodeBase64 ( strSign . c_str ( ) , & fInvalid ) ; if ( fInvalid ) throw JSONRPCError ( RPC_INVALID_ADDRESS_OR_KEY , " Malformed ▁ base64 ▁ encoding " ) ; CHashWriter ss ( SER_GETHASH , 0 ) ; ss << strMessageMagic ; ss << strMessage ; CPubKey pubkey ; if ( ! pubkey . RecoverCompact ( ss . GetHash ( ) , vchSig ) ) return false ; return ( pubkey . GetID ( ) == keyID ) ; }
Value getreceivedbyaddress ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) < 1 || params . size ( ) > 2 ) throw runtime_error ( " getreceivedbyaddress ▁ < iloveyoucoinsaddress > ▁ [ minconf = 1 ] \n " " Returns ▁ the ▁ total ▁ amount ▁ received ▁ by ▁ < iloveyoucoinsaddress > ▁ in ▁ transactions ▁ with ▁ at ▁ least ▁ [ minconf ] ▁ confirmations . " ) ; // ▁ Bitcoin ▁ address ENDCOM CBitcoinAddress address = CBitcoinAddress ( params [ 0 ] . get_str ( ) ) ; CScript scriptPubKey ; if ( ! address . IsValid ( ) ) throw JSONRPCError ( RPC_INVALID_ADDRESS_OR_KEY , " Invalid ▁ ILoveYouCoins ▁ address " ) ; scriptPubKey . SetDestination ( address . Get ( ) ) ; if ( ! IsMine ( * pwalletMain , scriptPubKey ) ) return ( double ) 0.0 ; // ▁ Minimum ▁ confirmations ENDCOM int nMinDepth = 1 ; if ( params . size ( ) > 1 ) nMinDepth = params [ 1 ] . get_int ( ) ; // ▁ Tally ENDCOM int64 nAmount = 0 ; for ( map < uint256 , CWalletTx > :: iterator it = pwalletMain -> mapWallet . begin ( ) ; it != pwalletMain -> mapWallet . end ( ) ; ++ it ) { const CWalletTx & wtx = ( * it ) . second ; if ( wtx . IsCoinBase ( ) || wtx . IsCoinStake ( ) || ! wtx . IsFinal ( ) ) continue ; BOOST_FOREACH ( const CTxOut & txout , wtx . vout ) if ( txout . scriptPubKey == scriptPubKey ) if ( wtx . GetDepthInMainChain ( ) >= nMinDepth ) nAmount += txout . nValue ; } return ValueFromAmount ( nAmount ) ; }
void GetAccountAddresses ( string strAccount , set < CTxDestination > & setAddress ) { BOOST_FOREACH ( const PAIRTYPE ( CTxDestination , string ) & item , pwalletMain -> mapAddressBook ) { const CTxDestination & address = item . first ; const string & strName = item . second ; if ( strName == strAccount ) setAddress . insert ( address ) ; } }
Value getreceivedbyaccount ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) < 1 || params . size ( ) > 2 ) throw runtime_error ( " getreceivedbyaccount ▁ < account > ▁ [ minconf = 1 ] \n " " Returns ▁ the ▁ total ▁ amount ▁ received ▁ by ▁ addresses ▁ with ▁ < account > ▁ in ▁ transactions ▁ with ▁ at ▁ least ▁ [ minconf ] ▁ confirmations . " ) ; // ▁ Minimum ▁ confirmations ENDCOM int nMinDepth = 1 ; if ( params . size ( ) > 1 ) nMinDepth = params [ 1 ] . get_int ( ) ; // ▁ Get ▁ the ▁ set ▁ of ▁ pub ▁ keys ▁ assigned ▁ to ▁ account ENDCOM string strAccount = AccountFromValue ( params [ 0 ] ) ; set < CTxDestination > setAddress ; GetAccountAddresses ( strAccount , setAddress ) ; // ▁ Tally ENDCOM int64 nAmount = 0 ; for ( map < uint256 , CWalletTx > :: iterator it = pwalletMain -> mapWallet . begin ( ) ; it != pwalletMain -> mapWallet . end ( ) ; ++ it ) { const CWalletTx & wtx = ( * it ) . second ; if ( wtx . IsCoinBase ( ) || wtx . IsCoinStake ( ) || ! wtx . IsFinal ( ) ) continue ; BOOST_FOREACH ( const CTxOut & txout , wtx . vout ) { CTxDestination address ; if ( ExtractDestination ( txout . scriptPubKey , address ) && IsMine ( * pwalletMain , address ) && setAddress . count ( address ) ) if ( wtx . GetDepthInMainChain ( ) >= nMinDepth ) nAmount += txout . nValue ; } } return ( double ) nAmount / ( double ) COIN ; }
int64 GetAccountBalance ( CWalletDB & walletdb , const string & strAccount , int nMinDepth ) { int64 nBalance = 0 ; // ▁ Tally ▁ wallet ▁ transactions ENDCOM for ( map < uint256 , CWalletTx > :: iterator it = pwalletMain -> mapWallet . begin ( ) ; it != pwalletMain -> mapWallet . end ( ) ; ++ it ) { const CWalletTx & wtx = ( * it ) . second ; if ( ! wtx . IsFinal ( ) ) continue ; int64 nReceived , nSent , nFee ; wtx . GetAccountAmounts ( strAccount , nReceived , nSent , nFee ) ; if ( nReceived != 0 && wtx . GetDepthInMainChain ( ) >= nMinDepth ) nBalance += nReceived ; nBalance -= nSent + nFee ; } // ▁ Tally ▁ internal ▁ accounting ▁ entries ENDCOM nBalance += walletdb . GetAccountCreditDebit ( strAccount ) ; return nBalance ; }
int64 GetAccountBalance ( const string & strAccount , int nMinDepth ) { CWalletDB walletdb ( pwalletMain -> strWalletFile ) ; return GetAccountBalance ( walletdb , strAccount , nMinDepth ) ; }
Value getbalance ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) > 2 ) throw runtime_error ( " getbalance ▁ [ account ] ▁ [ minconf = 1 ] \n " " If ▁ [ account ] ▁ is ▁ not ▁ specified , ▁ returns ▁ the ▁ server ' s ▁ total ▁ available ▁ balance . \n " " If ▁ [ account ] ▁ is ▁ specified , ▁ returns ▁ the ▁ balance ▁ in ▁ the ▁ account . " ) ; if ( params . size ( ) == 0 ) return ValueFromAmount ( pwalletMain -> GetBalance ( ) ) ; int nMinDepth = 1 ; if ( params . size ( ) > 1 ) nMinDepth = params [ 1 ] . get_int ( ) ; if ( params [ 0 ] . get_str ( ) == " * " ) { // ▁ Calculate ▁ total ▁ balance ▁ a ▁ different ▁ way ▁ from ▁ GetBalance ( ) ENDCOM // ▁ ( GetBalance ( ) ▁ sums ▁ up ▁ all ▁ unspent ▁ TxOuts ) ENDCOM // ▁ getbalance ▁ and ▁ getbalance ▁ ' * ' ▁ 0 ▁ should ▁ return ▁ the ▁ same ▁ number ENDCOM int64 nBalance = 0 ; for ( map < uint256 , CWalletTx > :: iterator it = pwalletMain -> mapWallet . begin ( ) ; it != pwalletMain -> mapWallet . end ( ) ; ++ it ) { const CWalletTx & wtx = ( * it ) . second ; if ( ! wtx . IsConfirmed ( ) ) continue ; int64 allFee ; string strSentAccount ; list < pair < CTxDestination , int64 > > listReceived ; list < pair < CTxDestination , int64 > > listSent ; wtx . GetAmounts ( listReceived , listSent , allFee , strSentAccount ) ; if ( wtx . GetDepthInMainChain ( ) >= nMinDepth ) { BOOST_FOREACH ( const PAIRTYPE ( CTxDestination , int64 ) & r , listReceived ) nBalance += r . second ; } BOOST_FOREACH ( const PAIRTYPE ( CTxDestination , int64 ) & r , listSent ) nBalance -= r . second ; nBalance -= allFee ; } return ValueFromAmount ( nBalance ) ; } string strAccount = AccountFromValue ( params [ 0 ] ) ; int64 nBalance = GetAccountBalance ( strAccount , nMinDepth ) ; return ValueFromAmount ( nBalance ) ; }
Value getunconfirmedbalance ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) > 0 ) throw runtime_error ( " getunconfirmedbalance \n " " Returns ▁ the ▁ server ' s ▁ total ▁ unconfirmed ▁ balance \n " ) ; return ValueFromAmount ( pwalletMain -> GetUnconfirmedBalance ( ) ) ; }
Value movecmd ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) < 3 || params . size ( ) > 5 ) throw runtime_error ( " move ▁ < fromaccount > ▁ < toaccount > ▁ < amount > ▁ [ minconf = 1 ] ▁ [ comment ] \n " " Move ▁ from ▁ one ▁ account ▁ in ▁ your ▁ wallet ▁ to ▁ another . " ) ; string strFrom = AccountFromValue ( params [ 0 ] ) ; string strTo = AccountFromValue ( params [ 1 ] ) ; int64 nAmount = AmountFromValue ( params [ 2 ] ) ; if ( params . size ( ) > 3 ) // ▁ unused ▁ parameter , ▁ used ▁ to ▁ be ▁ nMinDepth , ▁ keep ▁ type - checking ▁ it ▁ though ENDCOM ( void ) params [ 3 ] . get_int ( ) ; string strComment ; if ( params . size ( ) > 4 ) strComment = params [ 4 ] . get_str ( ) ; CWalletDB walletdb ( pwalletMain -> strWalletFile ) ; if ( ! walletdb . TxnBegin ( ) ) throw JSONRPCError ( RPC_DATABASE_ERROR , " database ▁ error " ) ; int64 nNow = GetAdjustedTime ( ) ; // ▁ Debit ENDCOM CAccountingEntry debit ; debit . nOrderPos = pwalletMain -> IncOrderPosNext ( & walletdb ) ; debit . strAccount = strFrom ; debit . nCreditDebit = - nAmount ; debit . nTime = nNow ; debit . strOtherAccount = strTo ; debit . strComment = strComment ; walletdb . WriteAccountingEntry ( debit ) ; // ▁ Credit ENDCOM CAccountingEntry credit ; credit . nOrderPos = pwalletMain -> IncOrderPosNext ( & walletdb ) ; credit . strAccount = strTo ; credit . nCreditDebit = nAmount ; credit . nTime = nNow ; credit . strOtherAccount = strFrom ; credit . strComment = strComment ; walletdb . WriteAccountingEntry ( credit ) ; if ( ! walletdb . TxnCommit ( ) ) throw JSONRPCError ( RPC_DATABASE_ERROR , " database ▁ error " ) ; return true ; }
Value sendfrom ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) < 3 || params . size ( ) > 6 ) throw runtime_error ( " sendfrom ▁ < fromaccount > ▁ < toiloveyoucoinsaddress > ▁ < amount > ▁ [ minconf = 1 ] ▁ [ comment ] ▁ [ comment - to ] \n " " < amount > ▁ is ▁ a ▁ real ▁ and ▁ is ▁ rounded ▁ to ▁ the ▁ nearest ▁ 0.00000001" + HelpRequiringPassphrase ( ) ) ; string strAccount = AccountFromValue ( params [ 0 ] ) ; CBitcoinAddress address ( params [ 1 ] . get_str ( ) ) ; if ( ! address . IsValid ( ) ) throw JSONRPCError ( RPC_INVALID_ADDRESS_OR_KEY , " Invalid ▁ ILoveYouCoins ▁ address " ) ; int64 nAmount = AmountFromValue ( params [ 2 ] ) ; int nMinDepth = 1 ; if ( params . size ( ) > 3 ) nMinDepth = params [ 3 ] . get_int ( ) ; CWalletTx wtx ; wtx . strFromAccount = strAccount ; if ( params . size ( ) > 4 && params [ 4 ] . type ( ) != null_type && ! params [ 4 ] . get_str ( ) . empty ( ) ) wtx . mapValue [ " comment " ] = params [ 4 ] . get_str ( ) ; if ( params . size ( ) > 5 && params [ 5 ] . type ( ) != null_type && ! params [ 5 ] . get_str ( ) . empty ( ) ) wtx . mapValue [ " to " ] = params [ 5 ] . get_str ( ) ; EnsureWalletIsUnlocked ( ) ; // ▁ Check ▁ funds ENDCOM int64 nBalance = GetAccountBalance ( strAccount , nMinDepth ) ; if ( nAmount > nBalance ) throw JSONRPCError ( RPC_WALLET_INSUFFICIENT_FUNDS , " Account ▁ has ▁ insufficient ▁ funds " ) ; // ▁ Send ENDCOM string strError = pwalletMain -> SendMoneyToDestination ( address . Get ( ) , nAmount , wtx ) ; if ( strError != " " ) throw JSONRPCError ( RPC_WALLET_ERROR , strError ) ; return wtx . GetHash ( ) . GetHex ( ) ; }
Value sendmany ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) < 2 || params . size ( ) > 4 ) throw runtime_error ( " sendmany ▁ < fromaccount > ▁ { address : amount , . . . } ▁ [ minconf = 1 ] ▁ [ comment ] \n " " amounts ▁ are ▁ double - precision ▁ floating ▁ point ▁ numbers " + HelpRequiringPassphrase ( ) ) ; string strAccount = AccountFromValue ( params [ 0 ] ) ; Object sendTo = params [ 1 ] . get_obj ( ) ; int nMinDepth = 1 ; if ( params . size ( ) > 2 ) nMinDepth = params [ 2 ] . get_int ( ) ; CWalletTx wtx ; wtx . strFromAccount = strAccount ; if ( params . size ( ) > 3 && params [ 3 ] . type ( ) != null_type && ! params [ 3 ] . get_str ( ) . empty ( ) ) wtx . mapValue [ " comment " ] = params [ 3 ] . get_str ( ) ; set < CBitcoinAddress > setAddress ; vector < pair < CScript , int64 > > vecSend ; int64 totalAmount = 0 ; BOOST_FOREACH ( const Pair & s , sendTo ) { CBitcoinAddress address ( s . name_ ) ; if ( ! address . IsValid ( ) ) throw JSONRPCError ( RPC_INVALID_ADDRESS_OR_KEY , string ( " Invalid ▁ ILoveYouCoins ▁ address : ▁ " ) + s . name_ ) ; if ( setAddress . count ( address ) ) throw JSONRPCError ( RPC_INVALID_PARAMETER , string ( " Invalid ▁ parameter , ▁ duplicated ▁ address : ▁ " ) + s . name_ ) ; setAddress . insert ( address ) ; CScript scriptPubKey ; scriptPubKey . SetDestination ( address . Get ( ) ) ; int64 nAmount = AmountFromValue ( s . value_ ) ; totalAmount += nAmount ; vecSend . push_back ( make_pair ( scriptPubKey , nAmount ) ) ; } EnsureWalletIsUnlocked ( ) ; // ▁ Check ▁ funds ENDCOM int64 nBalance = GetAccountBalance ( strAccount , nMinDepth ) ; if ( totalAmount > nBalance ) throw JSONRPCError ( RPC_WALLET_INSUFFICIENT_FUNDS , " Account ▁ has ▁ insufficient ▁ funds " ) ; // ▁ Send ENDCOM CReserveKey keyChange ( pwalletMain ) ; int64 nFeeRequired = 0 ; string strFailReason ; bool fCreated = pwalletMain -> CreateTransaction ( vecSend , wtx , keyChange , nFeeRequired , strFailReason ) ; if ( ! fCreated ) throw JSONRPCError ( RPC_WALLET_INSUFFICIENT_FUNDS , strFailReason ) ; if ( ! pwalletMain -> CommitTransaction ( wtx , keyChange ) ) throw JSONRPCError ( RPC_WALLET_ERROR , " Transaction ▁ commit ▁ failed " ) ; return wtx . GetHash ( ) . GetHex ( ) ; }
// ▁ Used ▁ by ▁ addmultisigaddress ▁ / ▁ createmultisig : ENDCOM static CScript _createmultisig ( const Array & params ) { int nRequired = params [ 0 ] . get_int ( ) ; const Array & keys = params [ 1 ] . get_array ( ) ; // ▁ Gather ▁ public ▁ keys ENDCOM if ( nRequired < 1 ) throw runtime_error ( " a ▁ multisignature ▁ address ▁ must ▁ require ▁ at ▁ least ▁ one ▁ key ▁ to ▁ redeem " ) ; if ( ( int ) keys . size ( ) < nRequired ) throw runtime_error ( strprintf ( " not ▁ enough ▁ keys ▁ supplied ▁ " " ( got ▁ % " PRIszu " ▁ keys , ▁ but ▁ need ▁ at ▁ least ▁ % d ▁ to ▁ redeem ) " , keys . size ( ) , nRequired ) ) ; std :: vector < CPubKey > pubkeys ; pubkeys . resize ( keys . size ( ) ) ; for ( unsigned int i = 0 ; i < keys . size ( ) ; i ++ ) { const std :: string & ks = keys [ i ] . get_str ( ) ; // ▁ Case ▁ 1 : ▁ ILoveYouCoins ▁ address ▁ and ▁ we ▁ have ▁ full ▁ public ▁ key : ENDCOM CBitcoinAddress address ( ks ) ; if ( pwalletMain && address . IsValid ( ) ) { CKeyID keyID ; if ( ! address . GetKeyID ( keyID ) ) throw runtime_error ( strprintf ( " % s ▁ does ▁ not ▁ refer ▁ to ▁ a ▁ key " , ks . c_str ( ) ) ) ; CPubKey vchPubKey ; if ( ! pwalletMain -> GetPubKey ( keyID , vchPubKey ) ) throw runtime_error ( strprintf ( " no ▁ full ▁ public ▁ key ▁ for ▁ address ▁ % s " , ks . c_str ( ) ) ) ; if ( ! vchPubKey . IsFullyValid ( ) ) throw runtime_error ( " ▁ Invalid ▁ public ▁ key : ▁ " + ks ) ; pubkeys [ i ] = vchPubKey ; } // ▁ Case ▁ 2 : ▁ hex ▁ public ▁ key ENDCOM else if ( IsHex ( ks ) ) { CPubKey vchPubKey ( ParseHex ( ks ) ) ; if ( ! vchPubKey . IsFullyValid ( ) ) throw runtime_error ( " ▁ Invalid ▁ public ▁ key : ▁ " + ks ) ; pubkeys [ i ] = vchPubKey ; } else { throw runtime_error ( " ▁ Invalid ▁ public ▁ key : ▁ " + ks ) ; } } CScript result ; result . SetMultisig ( nRequired , pubkeys ) ; return result ; }
Value addmultisigaddress ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) < 2 || params . size ( ) > 3 ) { string msg = " addmultisigaddress ▁ < nrequired > ▁ < ' [ \ " key \ " , \ " key \ " ] ' > ▁ [ account ] \n " " Add ▁ a ▁ nrequired - to - sign ▁ multisignature ▁ address ▁ to ▁ the ▁ wallet\ " \ n " " each ▁ key ▁ is ▁ a ▁ ILoveYouCoins ▁ address ▁ or ▁ hex - encoded ▁ public ▁ key \ n " " If ▁ [ account ] ▁ is ▁ specified , ▁ assign ▁ address ▁ to ▁ [ account ] . " ; throw runtime_error ( msg ) ; } string strAccount ; if ( params . size ( ) > 2 ) strAccount = AccountFromValue ( params [ 2 ] ) ; // ▁ Construct ▁ using ▁ pay - to - script - hash :  CScript inner = _createmultisig ( params ) ; CScriptID innerID = inner . GetID ( ) ; pwalletMain -> AddCScript ( inner ) ; pwalletMain -> SetAddressBookName ( innerID , strAccount ) ; return CBitcoinAddress ( innerID ) . ToString ( ) ; } Value createmultisig ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) < 2 || params . size ( ) > 2 ) { string msg = " createmultisig ▁ < nrequired > ▁ < ' [ \ " key \ " , \ " key \ " ] ' > \n " " Creates ▁ a ▁ multi - signature ▁ address ▁ and ▁ returns ▁ a ▁ json ▁ object \n " " with ▁ keys : \n " " address ▁ : ▁ iloveyoucoins ▁ address \n " " redeemScript ▁ : ▁ hex - encoded ▁ redemption ▁ script " ; throw runtime_error ( msg ) ; } // ▁ Construct ▁ using ▁ pay - to - script - hash : ENDCOM CScript inner = _createmultisig ( params ) ; CScriptID innerID = inner . GetID ( ) ; CBitcoinAddress address ( innerID ) ; Object result ; result . push_back ( Pair ( " address " , address . ToString ( ) ) ) ; result . push_back ( Pair ( " redeemScript " , HexStr ( inner . begin ( ) , inner . end ( ) ) ) ) ; return result ; } struct tallyitem { int64 nAmount ; int nConf ; vector < uint256 > txids ; tallyitem ( ) { nAmount = 0 ; nConf = std :: numeric_limits < int > :: max ( ) ; } } ; Value ListReceived ( const Array & params , bool fByAccounts ) { // ▁ Minimum ▁ confirmations ENDCOM int nMinDepth = 1 ; if ( params . size ( ) > 0 ) nMinDepth = params [ 0 ] . get_int ( ) ; // ▁ Whether ▁ to ▁ include ▁ empty ▁ accounts ENDCOM bool fIncludeEmpty = false ; if ( params . size ( ) > 1 ) fIncludeEmpty = params [ 1 ] . get_bool ( ) ; // ▁ Tally ENDCOM map < CBitcoinAddress , tallyitem > mapTally ; for ( map < uint256 , CWalletTx > :: iterator it = pwalletMain -> mapWallet . begin ( ) ; it != pwalletMain -> mapWallet . end ( ) ; ++ it ) { const CWalletTx & wtx = ( * it ) . second ; if ( wtx . IsCoinBase ( ) || wtx . IsCoinStake ( ) || ! wtx . IsFinal ( ) ) continue ; int nDepth = wtx . GetDepthInMainChain ( ) ; if ( nDepth < nMinDepth ) continue ; BOOST_FOREACH ( const CTxOut & txout , wtx . vout ) { CTxDestination address ; if ( ! ExtractDestination ( txout . scriptPubKey , address ) || ! IsMine ( * pwalletMain , address ) ) continue ; tallyitem & item = mapTally [ address ] ; item . nAmount += txout . nValue ; item . nConf = min ( item . nConf , nDepth ) ; item . txids . push_back ( wtx . GetHash ( ) ) ; } } // ▁ Reply ENDCOM Array ret ; map < string , tallyitem > mapAccountTally ; BOOST_FOREACH ( const PAIRTYPE ( CBitcoinAddress , string ) & item , pwalletMain -> mapAddressBook ) { const CBitcoinAddress & address = item . first ; const string & strAccount = item . second ; map < CBitcoinAddress , tallyitem > :: iterator it = mapTally . find ( address ) ; if ( it == mapTally . end ( ) && ! fIncludeEmpty ) continue ; int64 nAmount = 0 ; int nConf = std :: numeric_limits < int > :: max ( ) ; if ( it != mapTally . end ( ) ) { nAmount = ( * it ) . second . nAmount ; nConf = ( * it ) . second . nConf ; } if ( fByAccounts ) { tallyitem & item = mapAccountTally [ strAccount ] ; item . nAmount += nAmount ; item . nConf = min ( item . nConf , nConf ) ; } else { Object obj ; obj . push_back ( Pair ( " address " , address . ToString ( ) ) ) ; obj . push_back ( Pair ( " account " , strAccount ) ) ; obj . push_back ( Pair ( " amount " , ValueFromAmount ( nAmount ) ) ) ; obj . push_back ( Pair ( " confirmations " , ( nConf == std :: numeric_limits < int > :: max ( ) ? 0 : nConf ) ) ) ; Array transactions ; if ( it != mapTally . end ( ) ) { BOOST_FOREACH ( const uint256 & item , ( * it ) . second . txids ) { transactions . push_back ( item . GetHex ( ) ) ; } } obj . push_back ( Pair ( " txids " , transactions ) ) ; ret . push_back ( obj ) ; } } if ( fByAccounts ) { for ( map < string , tallyitem > :: iterator it = mapAccountTally . begin ( ) ; it != mapAccountTally . end ( ) ; ++ it ) { int64 nAmount = ( * it ) . second . nAmount ; int nConf = ( * it ) . second . nConf ; Object obj ; obj . push_back ( Pair ( " account " , ( * it ) . first ) ) ; obj . push_back ( Pair ( " amount " , ValueFromAmount ( nAmount ) ) ) ; obj . push_back ( Pair ( " confirmations " , ( nConf == std :: numeric_limits < int > :: max ( ) ? 0 : nConf ) ) ) ; ret . push_back ( obj ) ; } } return ret ; } Value listreceivedbyaddress ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) > 2 ) throw runtime_error ( " listreceivedbyaddress ▁ [ minconf = 1 ] ▁ [ includeempty = false ] \n " " [ minconf ] ▁ is ▁ the ▁ minimum ▁ number ▁ of ▁ confirmations ▁ before ▁ payments ▁ are ▁ included . \n " " [ includeempty ] ▁ whether ▁ to ▁ include ▁ addresses ▁ that ▁ haven ' t ▁ received ▁ any ▁ payments . \n " " Returns ▁ an ▁ array ▁ of ▁ objects ▁ containing : \n " " ▁ ▁ \ " address \ " ▁ : ▁ receiving ▁ address \n " " ▁ ▁ \ " account \ " ▁ : ▁ the ▁ account ▁ of ▁ the ▁ receiving ▁ address \n " " ▁ ▁ \ " amount \ " ▁ : ▁ total ▁ amount ▁ received ▁ by ▁ the ▁ address \n " " ▁ ▁ \ " confirmations \ " ▁ : ▁ number ▁ of ▁ confirmations ▁ of ▁ the ▁ most ▁ recent ▁ transaction ▁ included \n " " ▁ ▁ \ " txids \ " ▁ : ▁ list ▁ of ▁ transactions ▁ with ▁ outputs ▁ to ▁ the ▁ address \n " ) ; return ListReceived ( params , false ) ; } Value listreceivedbyaccount ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) > 2 ) throw runtime_error ( " listreceivedbyaccount ▁ [ minconf = 1 ] ▁ [ includeempty = false ] \n " " [ minconf ] ▁ is ▁ the ▁ minimum ▁ number ▁ of ▁ confirmations ▁ before ▁ payments ▁ are ▁ included . \n " " [ includeempty ] ▁ whether ▁ to ▁ include ▁ accounts ▁ that ▁ haven ' t ▁ received ▁ any ▁ payments . \n " " Returns ▁ an ▁ array ▁ of ▁ objects ▁ containing : \n " " ▁ ▁ \ " account \ " ▁ : ▁ the ▁ account ▁ of ▁ the ▁ receiving ▁ addresses \n " " ▁ ▁ \ " amount \ " ▁ : ▁ total ▁ amount ▁ received ▁ by ▁ addresses ▁ with ▁ this ▁ account \n " " ▁ ▁ \ " confirmations \ " ▁ : ▁ number ▁ of ▁ confirmations ▁ of ▁ the ▁ most ▁ recent ▁ transaction ▁ included " ) ; return ListReceived ( params , true ) ; } static void MaybePushAddress ( Object & entry , const CTxDestination & dest ) { CBitcoinAddress addr ; if ( addr . Set ( dest ) ) entry . push_back ( Pair ( " address " , addr . ToString ( ) ) ) ; } void ListTransactions ( const CWalletTx & wtx , const string & strAccount , int nMinDepth , bool fLong , Array & ret ) { int64 nFee ; string strSentAccount ; list < pair < CTxDestination , int64 > > listReceived ; list < pair < CTxDestination , int64 > > listSent ; wtx . GetAmounts ( listReceived , listSent , nFee , strSentAccount ) ; bool fAllAccounts = ( strAccount == string ( " * " ) ) ; // ▁ Sent ENDCOM if ( ! wtx . IsCoinStake ( ) && ( ! listSent . empty ( ) || nFee != 0 ) && ( fAllAccounts || strAccount == strSentAccount ) ) { BOOST_FOREACH ( const PAIRTYPE ( CTxDestination , int64 ) & s , listSent ) { Object entry ; entry . push_back ( Pair ( " account " , strSentAccount ) ) ; MaybePushAddress ( entry , s . first ) ; entry . push_back ( Pair ( " category " , " send " ) ) ; entry . push_back ( Pair ( " amount " , ValueFromAmount ( - s . second ) ) ) ; entry . push_back ( Pair ( " fee " , ValueFromAmount ( - nFee ) ) ) ; if ( fLong ) WalletTxToJSON ( wtx , entry ) ; ret . push_back ( entry ) ; } } // ▁ Received ENDCOM if ( listReceived . size ( ) > 0 && wtx . GetDepthInMainChain ( ) >= nMinDepth ) { bool stop = false ; BOOST_FOREACH ( const PAIRTYPE ( CTxDestination , int64 ) & r , listReceived ) { string account ; if ( pwalletMain -> mapAddressBook . count ( r . first ) ) account = pwalletMain -> mapAddressBook [ r . first ] ; if ( fAllAccounts || ( account == strAccount ) ) { Object entry ; entry . push_back ( Pair ( " account " , account ) ) ; MaybePushAddress ( entry , r . first ) ; if ( wtx . IsCoinBase ( ) || wtx . IsCoinStake ( ) ) { if ( wtx . GetDepthInMainChain ( ) < 1 ) entry . push_back ( Pair ( " category " , " orphan " ) ) ; else if ( wtx . GetBlocksToMaturity ( ) > 0 ) entry . push_back ( Pair ( " category " , " immature " ) ) ; else if ( wtx . IsCoinStake ( ) ) entry . push_back ( Pair ( " category " , " stake " ) ) ; else entry . push_back ( Pair ( " category " , " generate " ) ) ; } else { entry . push_back ( Pair ( " category " , " receive " ) ) ; } if ( ! wtx . IsCoinStake ( ) ) entry . push_back ( Pair ( " amount " , ValueFromAmount ( r . second ) ) ) ; else { entry . push_back ( Pair ( " amount " , ValueFromAmount ( - nFee ) ) ) ; stop = true ; // ▁ only ▁ one ▁ coinstake ▁ output ENDCOM } if ( fLong ) WalletTxToJSON ( wtx , entry ) ; ret . push_back ( entry ) ; } if ( stop ) break ; } } } void AcentryToJSON ( const CAccountingEntry & acentry , const string & strAccount , Array & ret ) { bool fAllAccounts = ( strAccount == string ( " * " ) ) ; if ( fAllAccounts || acentry . strAccount == strAccount ) { Object entry ; entry . push_back ( Pair ( " account " , acentry . strAccount ) ) ; entry . push_back ( Pair ( " category " , " move " ) ) ; entry . push_back ( Pair ( " time " , ( boost :: int64_t ) acentry . nTime ) ) ; entry . push_back ( Pair ( " amount " , ValueFromAmount ( acentry . nCreditDebit ) ) ) ; entry . push_back ( Pair ( " otheraccount " , acentry . strOtherAccount ) ) ; entry . push_back ( Pair ( " comment " , acentry . strComment ) ) ; ret . push_back ( entry ) ; } } Value listtransactions ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) > 3 ) throw runtime_error ( " listtransactions ▁ [ account ] ▁ [ count = 10 ] ▁ [ from = 0 ] \n " " Returns ▁ up ▁ to ▁ [ count ] ▁ most ▁ recent ▁ transactions ▁ skipping ▁ the ▁ first ▁ [ from ] ▁ transactions ▁ for ▁ account ▁ [ account ] . " ) ; string strAccount = " * " ; if ( params . size ( ) > 0 ) strAccount = params [ 0 ] . get_str ( ) ; int nCount = 10 ; if ( params . size ( ) > 1 ) nCount = params [ 1 ] . get_int ( ) ; int nFrom = 0 ; if ( params . size ( ) > 2 ) nFrom = params [ 2 ] . get_int ( ) ; if ( nCount < 0 ) throw JSONRPCError ( RPC_INVALID_PARAMETER , " Negative ▁ count " ) ; if ( nFrom < 0 ) throw JSONRPCError ( RPC_INVALID_PARAMETER , " Negative ▁ from " ) ; Array ret ; std :: list < CAccountingEntry > acentries ; CWallet :: TxItems txOrdered = pwalletMain -> OrderedTxItems ( acentries , strAccount ) ; // ▁ iterate ▁ backwards ▁ until ▁ we ▁ have ▁ nCount ▁ items ▁ to ▁ return : ENDCOM for ( CWallet :: TxItems :: reverse_iterator it = txOrdered . rbegin ( ) ; it != txOrdered . rend ( ) ; ++ it ) { CWalletTx * const pwtx = ( * it ) . second . first ; if ( pwtx != 0 ) ListTransactions ( * pwtx , strAccount , 0 , true , ret ) ; CAccountingEntry * const pacentry = ( * it ) . second . second ; if ( pacentry != 0 ) AcentryToJSON ( * pacentry , strAccount , ret ) ; if ( ( int ) ret . size ( ) >= ( nCount + nFrom ) ) break ; } // ▁ ret ▁ is ▁ newest ▁ to ▁ oldest ENDCOM if ( nFrom > ( int ) ret . size ( ) ) nFrom = ret . size ( ) ; if ( ( nFrom + nCount ) > ( int ) ret . size ( ) ) nCount = ret . size ( ) - nFrom ; Array :: iterator first = ret . begin ( ) ; std :: advance ( first , nFrom ) ; Array :: iterator last = ret . begin ( ) ; std :: advance ( last , nFrom + nCount ) ; if ( last != ret . end ( ) ) ret . erase ( last , ret . end ( ) ) ; if ( first != ret . begin ( ) ) ret . erase ( ret . begin ( ) , first ) ; std :: reverse ( ret . begin ( ) , ret . end ( ) ) ; // ▁ Return ▁ oldest ▁ to ▁ newest ENDCOM return ret ; } Value listaccounts ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) > 1 ) throw runtime_error ( " listaccounts ▁ [ minconf = 1 ] \n " " Returns ▁ Object ▁ that ▁ has ▁ account ▁ names ▁ as ▁ keys , ▁ account ▁ balances ▁ as ▁ values . " ) ; int nMinDepth = 1 ; if ( params . size ( ) > 0 ) nMinDepth = params [ 0 ] . get_int ( ) ; map < string , int64 > mapAccountBalances ; BOOST_FOREACH ( const PAIRTYPE ( CTxDestination , string ) & entry , pwalletMain -> mapAddressBook ) { if ( IsMine ( * pwalletMain , entry . first ) ) // ▁ This ▁ address ▁ belongs ▁ to ▁ me ENDCOM mapAccountBalances [ entry . second ] = 0 ; } for ( map < uint256 , CWalletTx > :: iterator it = pwalletMain -> mapWallet . begin ( ) ; it != pwalletMain -> mapWallet . end ( ) ; ++ it ) { const CWalletTx & wtx = ( * it ) . second ; int64 nFee ; string strSentAccount ; list < pair < CTxDestination , int64 > > listReceived ; list < pair < CTxDestination , int64 > > listSent ; wtx . GetAmounts ( listReceived , listSent , nFee , strSentAccount ) ; mapAccountBalances [ strSentAccount ] -= nFee ; BOOST_FOREACH ( const PAIRTYPE ( CTxDestination , int64 ) & s , listSent ) mapAccountBalances [ strSentAccount ] -= s . second ; if ( wtx . GetDepthInMainChain ( ) >= nMinDepth ) { BOOST_FOREACH ( const PAIRTYPE ( CTxDestination , int64 ) & r , listReceived ) if ( pwalletMain -> mapAddressBook . count ( r . first ) ) mapAccountBalances [ pwalletMain -> mapAddressBook [ r . first ] ] += r . second ; else mapAccountBalances [ " " ] += r . second ; } } list < CAccountingEntry > acentries ; CWalletDB ( pwalletMain -> strWalletFile ) . ListAccountCreditDebit ( " * " , acentries ) ; BOOST_FOREACH ( const CAccountingEntry & entry , acentries ) mapAccountBalances [ entry . strAccount ] += entry . nCreditDebit ; Object ret ; BOOST_FOREACH ( const PAIRTYPE ( string , int64 ) & accountBalance , mapAccountBalances ) { ret . push_back ( Pair ( accountBalance . first , ValueFromAmount ( accountBalance . second ) ) ) ; } return ret ; } Value listsinceblock ( const Array & params , bool fHelp ) { if ( fHelp ) throw runtime_error ( " listsinceblock ▁ [ blockhash ] ▁ [ target - confirmations ] \n " " Get ▁ all ▁ transactions ▁ in ▁ blocks ▁ since ▁ block ▁ [ blockhash ] , ▁ or ▁ all ▁ transactions ▁ if ▁ omitted " ) ; CBlockIndex * pindex = NULL ; int target_confirms = 1 ; if ( params . size ( ) > 0 ) { uint256 blockId = 0 ; blockId . SetHex ( params [ 0 ] . get_str ( ) ) ; pindex = CBlockLocator ( blockId ) . GetBlockIndex ( ) ; } if ( params . size ( ) > 1 ) { target_confirms = params [ 1 ] . get_int ( ) ; if ( target_confirms < 1 ) throw JSONRPCError ( RPC_INVALID_PARAMETER , " Invalid ▁ parameter " ) ; } int depth = pindex ? ( 1 + nBestHeight - pindex -> nHeight ) : - 1 ; Array transactions ; for ( map < uint256 , CWalletTx > :: iterator it = pwalletMain -> mapWallet . begin ( ) ; it != pwalletMain -> mapWallet . end ( ) ; it ++ ) { CWalletTx tx = ( * it ) . second ; if ( depth == - 1 || tx . GetDepthInMainChain ( ) < depth ) ListTransactions ( tx , " * " , 0 , true , transactions ) ; } uint256 lastblock ; if ( target_confirms == 1 ) { lastblock = hashBestChain ; } else { int target_height = pindexBest -> nHeight + 1 - target_confirms ; CBlockIndex * block ; for ( block = pindexBest ; block && block -> nHeight > target_height ; block = block -> pprev ) { } lastblock = block ? block -> GetBlockHash ( ) : 0 ; } Object ret ; ret . push_back ( Pair ( " transactions " , transactions ) ) ; ret . push_back ( Pair ( " lastblock " , lastblock . GetHex ( ) ) ) ; return ret ; } Value gettransaction ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) != 1 ) throw runtime_error ( " gettransaction ▁ < txid > \n " " Get ▁ detailed ▁ information ▁ about ▁ in - wallet ▁ transaction ▁ < txid > " ) ; uint256 hash ; hash . SetHex ( params [ 0 ] . get_str ( ) ) ; Object entry ; if ( ! pwalletMain -> mapWallet . count ( hash ) ) throw JSONRPCError ( RPC_INVALID_ADDRESS_OR_KEY , " Invalid ▁ or ▁ non - wallet ▁ transaction ▁ id " ) ; const CWalletTx & wtx = pwalletMain -> mapWallet [ hash ] ; int64 nCredit = wtx . GetCredit ( ) ; int64 nDebit = wtx . GetDebit ( ) ; int64 nNet = nCredit - nDebit ; int64 nFee = ( wtx . IsFromMe ( ) ? wtx . GetValueOut ( ) - nDebit : 0 ) ; entry . push_back ( Pair ( " amount " , ValueFromAmount ( nNet - nFee ) ) ) ; if ( wtx . IsFromMe ( ) ) entry . push_back ( Pair ( " fee " , ValueFromAmount ( nFee ) ) ) ; WalletTxToJSON ( wtx , entry ) ; Array details ; ListTransactions ( wtx , " * " , 0 , false , details ) ; entry . push_back ( Pair ( " details " , details ) ) ; return entry ; } Value backupwallet ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) != 1 ) throw runtime_error ( " backupwallet ▁ < destination > \n " " Safely ▁ copies ▁ wallet . dat ▁ to ▁ destination , ▁ which ▁ can ▁ be ▁ a ▁ directory ▁ or ▁ a ▁ path ▁ with ▁ filename . " ) ; string strDest = params [ 0 ] . get_str ( ) ; if ( ! BackupWallet ( * pwalletMain , strDest ) ) throw JSONRPCError ( RPC_WALLET_ERROR , " Error : ▁ Wallet ▁ backup ▁ failed ! " ) ; return Value :: null ; } Value keypoolrefill ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) > 0 ) throw runtime_error ( " keypoolrefill \n " " Fills ▁ the ▁ keypool . " + HelpRequiringPassphrase ( ) ) ; EnsureWalletIsUnlocked ( ) ; pwalletMain -> TopUpKeyPool ( ) ; if ( pwalletMain -> GetKeyPoolSize ( ) < GetArg ( " - keypool " , 100 ) ) throw JSONRPCError ( RPC_WALLET_ERROR , " Error ▁ refreshing ▁ keypool . " ) ; return Value :: null ; } void ThreadTopUpKeyPool ( void * parg ) { // ▁ Make ▁ this ▁ thread ▁ recognisable ▁ as ▁ the ▁ key - topping - up ▁ thread ENDCOM RenameThread ( " iloveyoucoins - key - top " ) ; pwalletMain -> TopUpKeyPool ( ) ; } void ThreadCleanWalletPassphrase ( void * parg ) { // ▁ Make ▁ this ▁ thread ▁ recognisable ▁ as ▁ the ▁ wallet ▁ relocking ▁ thread ENDCOM RenameThread ( " iloveyoucoins - lock - wa " ) ; int64 nMyWakeTime = GetTimeMillis ( ) + * ( ( int64 * ) parg ) * 1000 ; ENTER_CRITICAL_SECTION ( cs_nWalletUnlockTime ) ; if ( nWalletUnlockTime == 0 ) { nWalletUnlockTime = nMyWakeTime ; do { if ( nWalletUnlockTime == 0 ) break ; int64 nToSleep = nWalletUnlockTime - GetTimeMillis ( ) ; if ( nToSleep <= 0 ) break ; LEAVE_CRITICAL_SECTION ( cs_nWalletUnlockTime ) ; MilliSleep ( nToSleep ) ; ENTER_CRITICAL_SECTION ( cs_nWalletUnlockTime ) ; } while ( 1 ) ; if ( nWalletUnlockTime ) { nWalletUnlockTime = 0 ; pwalletMain -> Lock ( ) ; } } else { if ( nWalletUnlockTime < nMyWakeTime ) nWalletUnlockTime = nMyWakeTime ; } LEAVE_CRITICAL_SECTION ( cs_nWalletUnlockTime ) ; delete ( int64 * ) parg ; } Value walletpassphrase ( const Array & params , bool fHelp ) { if ( pwalletMain -> IsCrypted ( ) && ( fHelp || params . size ( ) < 2 || params . size ( ) > 3 ) ) throw runtime_error ( " walletpassphrase ▁ < passphrase > ▁ < timeout > ▁ [ stakingonly ] \n " " Stores ▁ the ▁ wallet ▁ decryption ▁ key ▁ in ▁ memory ▁ for ▁ < timeout > ▁ seconds . \n " " if ▁ [ stakingonly ] ▁ is ▁ true ▁ sending ▁ functions ▁ are ▁ disabled . " ) ; if ( fHelp ) return true ; if ( ! pwalletMain -> IsCrypted ( ) ) throw JSONRPCError ( RPC_WALLET_WRONG_ENC_STATE , " Error : ▁ running ▁ with ▁ an ▁ unencrypted ▁ wallet , ▁ but ▁ walletpassphrase ▁ was ▁ called . " ) ; if ( ! pwalletMain -> IsLocked ( ) ) throw JSONRPCError ( RPC_WALLET_ALREADY_UNLOCKED , " Error : ▁ Wallet ▁ is ▁ already ▁ unlocked . " ) ; // ▁ Note ▁ that ▁ the ▁ walletpassphrase ▁ is ▁ stored ▁ in ▁ params [ 0 ] ▁ which ▁ is ▁ not ▁ mlock ( ) ed ENDCOM SecureString strWalletPass ; strWalletPass . reserve ( 100 ) ; // ▁ TODO : ▁ get ▁ rid ▁ of ▁ this ▁ . c _ str ( ) ▁ by ▁ implementing ▁ SecureString : : operator = ( std : : string ) ENDCOM // ▁ Alternately , ▁ find ▁ a ▁ way ▁ to ▁ make ▁ params [ 0 ] ▁ mlock ( ) ' d ▁ to ▁ begin ▁ with . ENDCOM strWalletPass = params [ 0 ] . get_str ( ) . c_str ( ) ; if ( strWalletPass . length ( ) > 0 ) { if ( ! pwalletMain -> Unlock ( strWalletPass ) ) throw JSONRPCError ( RPC_WALLET_PASSPHRASE_INCORRECT , " Error : ▁ The ▁ wallet ▁ passphrase ▁ entered ▁ was ▁ incorrect . " ) ; } else throw runtime_error ( " walletpassphrase ▁ < passphrase > ▁ < timeout > \n " " Stores ▁ the ▁ wallet ▁ decryption ▁ key ▁ in ▁ memory ▁ for ▁ < timeout > ▁ seconds . " ) ; NewThread ( ThreadTopUpKeyPool , NULL ) ; int64 * pnSleepTime = new int64 ( params [ 1 ] . get_int64 ( ) ) ; NewThread ( ThreadCleanWalletPassphrase , pnSleepTime ) ; // ▁ ppcoin : ▁ if ▁ user ▁ OS ▁ account ▁ compromised ▁ prevent ▁ trivial ▁ sendmoney ▁ commands ENDCOM if ( params . size ( ) > 2 ) fWalletUnlockStakingOnly = params [ 2 ] . get_bool ( ) ; else fWalletUnlockStakingOnly = false ; return Value :: null ; } Value walletpassphrasechange ( const Array & params , bool fHelp ) { if ( pwalletMain -> IsCrypted ( ) && ( fHelp || params . size ( ) != 2 ) ) throw runtime_error ( " walletpassphrasechange ▁ < oldpassphrase > ▁ < newpassphrase > \n " " Changes ▁ the ▁ wallet ▁ passphrase ▁ from ▁ < oldpassphrase > ▁ to ▁ < newpassphrase > . " ) ; if ( fHelp ) return true ; if ( ! pwalletMain -> IsCrypted ( ) ) throw JSONRPCError ( RPC_WALLET_WRONG_ENC_STATE , " Error : ▁ running ▁ with ▁ an ▁ unencrypted ▁ wallet , ▁ but ▁ walletpassphrasechange ▁ was ▁ called . " ) ; // ▁ TODO : ▁ get ▁ rid ▁ of ▁ these ▁ . c _ str ( ) ▁ calls ▁ by ▁ implementing ▁ SecureString : : operator = ( std : : string ) ENDCOM // ▁ Alternately , ▁ find ▁ a ▁ way ▁ to ▁ make ▁ params [ 0 ] ▁ mlock ( ) ' d ▁ to ▁ begin ▁ with . ENDCOM SecureString strOldWalletPass ; strOldWalletPass . reserve ( 100 ) ; strOldWalletPass = params [ 0 ] . get_str ( ) . c_str ( ) ; SecureString strNewWalletPass ; strNewWalletPass . reserve ( 100 ) ; strNewWalletPass = params [ 1 ] . get_str ( ) . c_str ( ) ; if ( strOldWalletPass . length ( ) < 1 || strNewWalletPass . length ( ) < 1 ) throw runtime_error ( " walletpassphrasechange ▁ < oldpassphrase > ▁ < newpassphrase > \n " " Changes ▁ the ▁ wallet ▁ passphrase ▁ from ▁ < oldpassphrase > ▁ to ▁ < newpassphrase > . " ) ; if ( ! pwalletMain -> ChangeWalletPassphrase ( strOldWalletPass , strNewWalletPass ) ) throw JSONRPCError ( RPC_WALLET_PASSPHRASE_INCORRECT , " Error : ▁ The ▁ wallet ▁ passphrase ▁ entered ▁ was ▁ incorrect . " ) ; return Value :: null ; } Value walletlock ( const Array & params , bool fHelp ) { if ( pwalletMain -> IsCrypted ( ) && ( fHelp || params . size ( ) != 0 ) ) throw runtime_error ( " walletlock \n " " Removes ▁ the ▁ wallet ▁ encryption ▁ key ▁ from ▁ memory , ▁ locking ▁ the ▁ wallet . \n " " After ▁ calling ▁ this ▁ method , ▁ you ▁ will ▁ need ▁ to ▁ call ▁ walletpassphrase ▁ again \n " " before ▁ being ▁ able ▁ to ▁ call ▁ any ▁ methods ▁ which ▁ require ▁ the ▁ wallet ▁ to ▁ be ▁ unlocked . " ) ; if ( fHelp ) return true ; if ( ! pwalletMain -> IsCrypted ( ) ) throw JSONRPCError ( RPC_WALLET_WRONG_ENC_STATE , " Error : ▁ running ▁ with ▁ an ▁ unencrypted ▁ wallet , ▁ but ▁ walletlock ▁ was ▁ called . " ) ; { LOCK ( cs_nWalletUnlockTime ) ; pwalletMain -> Lock ( ) ; nWalletUnlockTime = 0 ; } return Value :: null ; } Value encryptwallet ( const Array & params , bool fHelp ) { if ( ! pwalletMain -> IsCrypted ( ) && ( fHelp || params . size ( ) != 1 ) ) throw runtime_error ( " encryptwallet ▁ < passphrase > \n " " Encrypts ▁ the ▁ wallet ▁ with ▁ < passphrase > . " ) ; if ( fHelp ) return true ; if ( pwalletMain -> IsCrypted ( ) ) throw JSONRPCError ( RPC_WALLET_WRONG_ENC_STATE , " Error : ▁ running ▁ with ▁ an ▁ encrypted ▁ wallet , ▁ but ▁ encryptwallet ▁ was ▁ called . " ) ; // ▁ TODO : ▁ get ▁ rid ▁ of ▁ this ▁ . c _ str ( ) ▁ by ▁ implementing ▁ SecureString : : operator = ( std : : string ) ENDCOM // ▁ Alternately , ▁ find ▁ a ▁ way ▁ to ▁ make ▁ params [ 0 ] ▁ mlock ( ) ' d ▁ to ▁ begin ▁ with . ENDCOM SecureString strWalletPass ; strWalletPass . reserve ( 100 ) ; strWalletPass = params [ 0 ] . get_str ( ) . c_str ( ) ; if ( strWalletPass . length ( ) < 1 ) throw runtime_error ( " encryptwallet ▁ < passphrase > \n " " Encrypts ▁ the ▁ wallet ▁ with ▁ < passphrase > . " ) ; if ( ! pwalletMain -> EncryptWallet ( strWalletPass ) ) throw JSONRPCError ( RPC_WALLET_ENCRYPTION_FAILED , " Error : ▁ Failed ▁ to ▁ encrypt ▁ the ▁ wallet . " ) ; // ▁ BDB ▁ seems ▁ to ▁ have ▁ a ▁ bad ▁ habit ▁ of ▁ writing ▁ old ▁ data ▁ into ENDCOM // ▁ slack ▁ space ▁ in ▁ . dat ▁ files ; ▁ that ▁ is ▁ bad ▁ if ▁ the ▁ old ▁ data ▁ is ENDCOM // ▁ unencrypted ▁ private ▁ keys . ▁ So : ENDCOM StartShutdown ( ) ; return " wallet ▁ encrypted ; ▁ ILoveYouCoins ▁ server ▁ stopping , ▁ restart ▁ to ▁ run ▁ with ▁ encrypted ▁ wallet . ▁ The ▁ keypool ▁ has ▁ been ▁ flushed , ▁ you ▁ need ▁ to ▁ make ▁ a ▁ new ▁ backup . " ; } class DescribeAddressVisitor : public boost :: static_visitor < Object > { public : Object operator ( ) ( const CNoDestination & dest ) const { return Object ( ) ; } Object operator ( ) ( const CKeyID & keyID ) const { Object obj ; CPubKey vchPubKey ; pwalletMain -> GetPubKey ( keyID , vchPubKey ) ; obj . push_back ( Pair ( " isscript " , false ) ) ; obj . push_back ( Pair ( " pubkey " , HexStr ( vchPubKey ) ) ) ; obj . push_back ( Pair ( " iscompressed " , vchPubKey . IsCompressed ( ) ) ) ; return obj ; } Object operator ( ) ( const CScriptID & scriptID ) const { Object obj ; obj . push_back ( Pair ( " isscript " , true ) ) ; CScript subscript ; pwalletMain -> GetCScript ( scriptID , subscript ) ; std :: vector < CTxDestination > addresses ; txnouttype whichType ; int nRequired ; ExtractDestinations ( subscript , whichType , addresses , nRequired ) ; obj . push_back ( Pair ( " script " , GetTxnOutputType ( whichType ) ) ) ; Array a ; BOOST_FOREACH ( const CTxDestination & addr , addresses ) a . push_back ( CBitcoinAddress ( addr ) . ToString ( ) ) ; obj . push_back ( Pair ( " addresses " , a ) ) ; if ( whichType == TX_MULTISIG ) obj . push_back ( Pair ( " sigsrequired " , nRequired ) ) ; return obj ; } } ; Value validateaddress ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) != 1 ) throw runtime_error ( " validateaddress ▁ < iloveyoucoinsaddress > \n " " Return ▁ information ▁ about ▁ < iloveyoucoinsaddress > . " ) ; CBitcoinAddress address ( params [ 0 ] . get_str ( ) ) ; bool isValid = address . IsValid ( ) ; Object ret ; ret . push_back ( Pair ( " isvalid " , isValid ) ) ; if ( isValid ) { CTxDestination dest = address . Get ( ) ; string currentAddress = address . ToString ( ) ; ret . push_back ( Pair ( " address " , currentAddress ) ) ; bool fMine = pwalletMain ? IsMine ( * pwalletMain , dest ) : false ; ret . push_back ( Pair ( " ismine " , fMine ) ) ; if ( fMine ) { Object detail = boost :: apply_visitor ( DescribeAddressVisitor ( ) , dest ) ; ret . insert ( ret . end ( ) , detail . begin ( ) , detail . end ( ) ) ; } if ( pwalletMain && pwalletMain -> mapAddressBook . count ( dest ) ) ret . push_back ( Pair ( " account " , pwalletMain -> mapAddressBook [ dest ] ) ) ; } return ret ; } // ▁ ppcoin : ▁ reserve ▁ balance ▁ from ▁ being ▁ staked ▁ for ▁ network ▁ protection ENDCOM Value reservebalance ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) > 2 ) throw runtime_error ( " reservebalance ▁ [ < reserve > ▁ [ amount ] ] \n " " < reserve > ▁ is ▁ true ▁ or ▁ false ▁ to ▁ turn ▁ balance ▁ reserve ▁ on ▁ or ▁ off . \n " " < amount > ▁ is ▁ a ▁ real ▁ and ▁ rounded ▁ to ▁ cent . \n " " Set ▁ reserve ▁ amount ▁ not ▁ participating ▁ in ▁ network ▁ protection . \n " " If ▁ no ▁ parameters ▁ provided ▁ current ▁ setting ▁ is ▁ printed . \n " ) ; if ( params . size ( ) > 0 ) { bool fReserve = params [ 0 ] . get_bool ( ) ; if ( fReserve ) { if ( params . size ( ) == 1 ) throw runtime_error ( " must ▁ provide ▁ amount ▁ to ▁ reserve ▁ balance . \n " ) ; int64 nAmount = AmountFromValue ( params [ 1 ] ) ; nAmount = ( nAmount / CENT ) * CENT ; // ▁ round ▁ to ▁ cent ENDCOM if ( nAmount < 0 ) throw runtime_error ( " amount ▁ cannot ▁ be ▁ negative . \n " ) ; nReserveBalance = nAmount ; } else { if ( params . size ( ) > 1 ) throw runtime_error ( " cannot ▁ specify ▁ amount ▁ to ▁ turn ▁ off ▁ reserve . \n " ) ; nReserveBalance = 0 ; } } Object result ; result . push_back ( Pair ( " reserve " , ( nReserveBalance > 0 ) ) ) ; result . push_back ( Pair ( " amount " , ValueFromAmount ( nReserveBalance ) ) ) ; return result ; } // ▁ posv : ▁ interest ▁ received ENDCOM Value getinterest ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) > 2 ) throw runtime_error ( " getinterest ▁ [ start ] ▁ [ end ] \n " " Both ▁ [ start ] ▁ and ▁ [ end ] ▁ are ▁ inclusive ▁ and ▁ in ▁ the ▁ form ▁ of ▁ UNIX ▁ timestamps . " ) ; unsigned int nTimeStart = 0 ; unsigned int nTimeEnd = - 1 ; if ( params . size ( ) >= 1 ) nTimeStart = ( unsigned int ) ( params [ 0 ] . get_int ( ) ) ; if ( params . size ( ) == 2 ) nTimeEnd = ( unsigned int ) ( params [ 1 ] . get_int ( ) ) ; int64 nInterest = 0 ; for ( map < uint256 , CWalletTx > :: iterator it = pwalletMain -> mapWallet . begin ( ) ; it != pwalletMain -> mapWallet . end ( ) ; ++ it ) { const CWalletTx & wtx = ( * it ) . second ; if ( ! wtx . IsCoinStake ( ) || wtx . nTime < nTimeStart || wtx . nTime > nTimeEnd ) continue ; int64 nDebit = wtx . GetDebit ( ) ; int64 nCredit = wtx . GetCredit ( ) ; if ( nDebit <= 0 || nCredit <= 0 || nDebit >= nCredit ) continue ; else nInterest += nCredit - nDebit ; } return ValueFromAmount ( nInterest ) ; } Value lockunspent ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) < 1 || params . size ( ) > 2 ) throw runtime_error ( " lockunspent ▁ unlock ? ▁ [ array - of - Objects ] \n " " Updates ▁ list ▁ of ▁ temporarily ▁ unspendable ▁ outputs . " ) ; if ( params . size ( ) == 1 ) RPCTypeCheck ( params , list_of ( bool_type ) ) ; else RPCTypeCheck ( params , list_of ( bool_type ) ( array_type ) ) ; bool fUnlock = params [ 0 ] . get_bool ( ) ; if ( params . size ( ) == 1 ) { if ( fUnlock ) pwalletMain -> UnlockAllCoins ( ) ; return true ; } Array outputs = params [ 1 ] . get_array ( ) ; BOOST_FOREACH ( Value & output , outputs ) { if ( output . type ( ) != obj_type ) throw JSONRPCError ( - 8 , " Invalid ▁ parameter , ▁ expected ▁ object " ) ; const Object & o = output . get_obj ( ) ; RPCTypeCheck ( o , map_list_of ( " txid " , str_type ) ( " vout " , int_type ) ) ; string txid = find_value ( o , " txid " ) . get_str ( ) ; if ( ! IsHex ( txid ) ) throw JSONRPCError ( - 8 , " Invalid ▁ parameter , ▁ expected ▁ hex ▁ txid " ) ; int nOutput = find_value ( o , " vout " ) . get_int ( ) ; if ( nOutput < 0 ) throw JSONRPCError ( - 8 , " Invalid ▁ parameter , ▁ vout ▁ must ▁ be ▁ positive " ) ; COutPoint outpt ( uint256 ( txid ) , nOutput ) ; if ( fUnlock ) pwalletMain -> UnlockCoin ( outpt ) ; else pwalletMain -> LockCoin ( outpt ) ; } return true ; } Value listlockunspent ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) > 0 ) throw runtime_error ( " listlockunspent \n " " Returns ▁ list ▁ of ▁ temporarily ▁ unspendable ▁ outputs . " ) ; vector < COutPoint > vOutpts ; pwalletMain -> ListLockedCoins ( vOutpts ) ; Array ret ; BOOST_FOREACH ( COutPoint & outpt , vOutpts ) { Object o ; o . push_back ( Pair ( " txid " , outpt . hash . GetHex ( ) ) ) ; o . push_back ( Pair ( " vout " , ( int ) outpt . n ) ) ; ret . push_back ( o ) ; } return ret ; } < / DOCUMENT >
AS_API const char * asGetLibraryVersion ( ) { return ANGELSCRIPT_VERSION_STRING " ▁ DEBUG " ; return ANGELSCRIPT_VERSION_STRING ; }
AS_API const char * asGetLibraryOptions ( ) { const char * string = " ▁ " // ▁ Options ENDCOM " AS _ MAX _ PORTABILITY ▁ " " AS _ DEBUG ▁ " " AS _ NO _ CLASS _ METHODS ▁ " " AS _ USE _ DOUBLE _ AS _ FLOAT ▁ " " AS _ 64BIT _ PTR ▁ " " AS _ NO _ THREADS ▁ " " AS _ NO _ ATOMIC ▁ " // ▁ Target ▁ system ENDCOM " AS _ WIN ▁ " " AS _ LINUX ▁ " " AS _ MAC ▁ " " AS _ BSD ▁ " " AS _ XBOX ▁ " " AS _ XBOX360 ▁ " " AS _ PSP ▁ " " AS _ PS2 ▁ " " AS _ PS3 ▁ " " AS _ DC ▁ " " AS _ GC ▁ " " AS _ WII ▁ " " AS _ IPHONE ▁ " " AS _ ANDROID ▁ " // ▁ CPU ▁ family ENDCOM " AS _ PPC ▁ " " AS _ PPC _ 64 ▁ " " AS _ X86 ▁ " " AS _ MIPS ▁ " " AS _ SH4 ▁ " " AS _ XENON ▁ " " AS _ ARM ▁ " ; return string ; }
AS_API asIScriptEngine * asCreateScriptEngine ( asDWORD version ) { // ▁ Verify ▁ the ▁ version ▁ that ▁ the ▁ application ▁ expects ENDCOM if ( ( version / 10000 ) != ( ANGELSCRIPT_VERSION / 10000 ) ) return 0 ; if ( ( version / 100 ) % 100 != ( ANGELSCRIPT_VERSION / 100 ) % 100 ) return 0 ; if ( ( version % 100 ) > ( ANGELSCRIPT_VERSION % 100 ) ) return 0 ; // ▁ Verify ▁ the ▁ size ▁ of ▁ the ▁ types ENDCOM asASSERT ( sizeof ( asBYTE ) == 1 ) ; asASSERT ( sizeof ( asWORD ) == 2 ) ; asASSERT ( sizeof ( asDWORD ) == 4 ) ; asASSERT ( sizeof ( asQWORD ) == 8 ) ; asASSERT ( sizeof ( asPWORD ) == sizeof ( void * ) ) ; // ▁ Verify ▁ the ▁ boolean ▁ type ENDCOM asASSERT ( sizeof ( bool ) == AS_SIZEOF_BOOL ) ; asASSERT ( true == VALUE_OF_BOOLEAN_TRUE ) ; // ▁ Verify ▁ endianess ENDCOM asASSERT ( * ( asDWORD * ) " \x00\x01\x02\x03" == 0x00010203 ) ; asASSERT ( * ( asQWORD * ) " \x00\x01\x02\x03\x04\x05\x06\x07" == I64 ( 0x0001020304050607 ) ) ; asASSERT ( * ( asDWORD * ) " \x00\x01\x02\x03" == 0x03020100 ) ; asASSERT ( * ( asQWORD * ) " \x00\x01\x02\x03\x04\x05\x06\x07" == I64 ( 0x0706050403020100 ) ) ; return asNEW ( asCScriptEngine ) ( ) ; }
