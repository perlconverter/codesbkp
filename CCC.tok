<DOCUMENT_ID="duncanchen/KeyKey/tree/master/YahooKeyKey-Source-1.1.2528/Utilities/reform-auto-complete.pl"> # ! / usr / bin / perl ENDCOM # Copyright ▁ ( c ) ▁ 2012 , ▁ Yahoo ! ▁ Inc . ▁ All ▁ rights ▁ reserved . ENDCOM # Copyrights ▁ licensed ▁ under ▁ the ▁ New ▁ BSD ▁ License . ▁ See ▁ the ▁ accompanying ▁ LICENSE ENDCOM # file ▁ for ▁ terms . ENDCOM # ▁ skip ▁ the ▁ first ▁ line ENDCOM @ phrases = ( ) ; while ( < > ) { chomp ; split ( / \ t / ) ; # ▁ print ▁ " $ _ [0 ] ▁ = > ▁ $ _ [1 ] \n " ; ENDCOM push ( @ phrases , [ $_ [ 0 ] , $_ [ 1 ] ] ) ; } @ phrases = sort { int ( $b -> [ 0 ] ) <= > int ( $a -> [ 0 ] ) } @ phrases ; # ▁ remove ▁ the ▁ first ▁ line ▁ which ▁ is ▁ the ▁ column ▁ header ENDCOM shift @ phrases ; for $x ( @ phrases ) { print $x -> [ 0 ] , " ▁ " , $x -> [ 1 ] , " \n " ; } </DOCUMENT>
<DOCUMENT_ID="bmajoros/RSVP/tree/master/perl/genomics/sort-gff.pl"> # ! / usr / bin / perl ENDCOM use strict ; # use ▁ lib ( ' / home / bmajoros / genomics / perl ' ) ; ENDCOM use GffReader ; my $usage = " $ 0 ▁ < * . gff > " ; die " $ usage \n " unless @ ARGV == 1 ; my ( $filename ) = @ ARGV ; my $reader = new GffReader ; my $array = $reader -> loadGFF ( $filename ) ; my @ sorted = sort { $a -> { fivePrime } != $b -> { fivePrime } ? $a -> { fivePrime } <= > $b -> { fivePrime } : $a -> { threePrime } <= > $b -> { threePrime } } @ $array ; my $n = @ sorted ; for ( my $i = 0 ; $i < $n ; ++ $i ) { my $feature = $sorted [ $i ] ; print $feature -> toGff ( ) ; } </DOCUMENT>
<DOCUMENT_ID="toidi/hypertable/tree/master/src/perl/ThriftClient/client_test.pl"> # ▁ Copyright ▁ ( C ) ▁ 2007-2012 ▁ Hypertable , ▁ Inc . ENDCOM # ▁ This ▁ file ▁ is ▁ part ▁ of ▁ Hypertable . ENDCOM # ▁ Hypertable ▁ is ▁ free ▁ software ; ▁ you ▁ can ▁ redistribute ▁ it ▁ and / or ENDCOM # ▁ modify ▁ it ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ENDCOM # ▁ as ▁ published ▁ by ▁ the ▁ Free ▁ Software ▁ Foundation ; ▁ either ▁ version ▁ 3 ENDCOM # ▁ of ▁ the ▁ License , ▁ or ▁ any ▁ later ▁ version . ENDCOM # ▁ Hypertable ▁ is ▁ distributed ▁ in ▁ the ▁ hope ▁ that ▁ it ▁ will ▁ be ▁ useful , ENDCOM # ▁ but ▁ WITHOUT ▁ ANY ▁ WARRANTY ; ▁ without ▁ even ▁ the ▁ implied ▁ warranty ▁ of ENDCOM # ▁ MERCHANTABILITY ▁ or ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE . ▁ See ▁ the ENDCOM # ▁ GNU ▁ General ▁ Public ▁ License ▁ for ▁ more ▁ details . ENDCOM # ▁ You ▁ should ▁ have ▁ received ▁ a ▁ copy ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ENDCOM # ▁ along ▁ with ▁ this ▁ program ; ▁ if ▁ not , ▁ write ▁ to ▁ the ▁ Free ▁ Software ENDCOM # ▁ Foundation , ▁ Inc . , ▁ 51 ▁ Franklin ▁ Street , ▁ Fifth ▁ Floor , ▁ Boston , ▁ MA ENDCOM # ▁ 02110-1301 , ▁ USA . ENDCOM # ! / usr / bin / env ▁ perl ENDCOM use Hypertable :: ThriftClient ; use Data :: Dumper ; my $client = new Hypertable :: ThriftClient ( " localhost " , 38080 ) ; print " HQL ▁ examples \n " ; my $namespace = $client -> namespace_open ( " test " ) ; print Dumper ( $client -> hql_exec ( $namespace , " show ▁ tables " ) ) ; print Dumper ( $client -> hql_exec ( $namespace , " select ▁ * ▁ from ▁ thrift _ test ▁ max _ versions ▁ 1" ) ) ; print " mutator ▁ examples \n " ; my $mutator = $client -> mutator_open ( $namespace , " thrift _ test " ) ; my $key = new Hypertable :: ThriftGen :: Key ( { row = > ' perl - k1' , column_family = > ' col ' } ) ; my $cell = new Hypertable :: ThriftGen :: Cell ( { key = > $key , value = > ' perl - v1' } ) ; $client -> mutator_set_cell ( $mutator , $cell ) ; $client -> mutator_flush ( $mutator ) ; $client -> mutator_close ( $mutator ) ; print " shared ▁ mutator ▁ examples \n " ; my $mutate_spec = new Hypertable :: ThriftGen :: MutateSpec ( { appname = > " test - perl " , flush_interval = > 1000 , flags = > 0 } ) ; $key = new Hypertable :: ThriftGen :: Key ( { row = > ' perl - put - k1' , column_family = > ' col ' } ) ; $cell = new Hypertable :: ThriftGen :: Cell ( { key = > $key , value = > ' perl - put - v1' } ) ; $client -> shared_mutator_set_cell ( $namespace , " thrift _ test " , $mutate_spec , $cell ) ; $key = new Hypertable :: ThriftGen :: Key ( { row = > ' perl - put - k2' , column_family = > ' col ' } ) ; $cell = new Hypertable :: ThriftGen :: Cell ( { key = > $key , column_family = > ' col ' , value = > ' perl - put - v2' } ) ; $client -> shared_mutator_refresh ( $namespace , " thrift _ test " , $mutate_spec ) ; $client -> shared_mutator_set_cell ( $namespace , " thrift _ test " , $mutate_spec , $cell ) ; sleep ( 2 ) ; print " scanner ▁ examples \n " ; my $scanner = $client -> scanner_open ( $namespace , " thrift _ test " , new Hypertable :: ThriftGen :: ScanSpec ( { versions = > 1 } ) ) ; my $cells = $client -> scanner_get_cells ( $scanner ) ; while ( scalar @ $cells ) { print Dumper ( $cells ) ; $cells = $client -> scanner_get_cells ( $scanner ) ; } $client -> scanner_close ( $scanner ) ; print " asynchronous ▁ examples \n " ; my $future = $client -> future_open ( ) ; my $color_scanner = $client -> async_scanner_open ( $namespace , " FruitColor " , $future , new Hypertable :: ThriftGen :: ScanSpec ( { versions = > 1 } ) ) ; my $location_scanner = $client -> async_scanner_open ( $namespace , " FruitLocation " , $future , new Hypertable :: ThriftGen :: ScanSpec ( { versions = > 1 } ) ) ; my $energy_scanner = $client -> async_scanner_open ( $namespace , " FruitEnergy " , $future , new Hypertable :: ThriftGen :: ScanSpec ( { versions = > 1 } ) ) ; my $expected_cells = 6 ; my $num_cells = 0 ; while ( 1 ) { my $result = $client -> future_get_result ( $future ) ; print Dumper ( $result ) ; last if ( $result -> { is_empty } == 1 || $result -> { is_error } == 1 || $result -> { is_scan } != 1 ) ; my $cells = $result -> { cells } ; foreach my $cell ( @ $cells ) { print Dumper ( $cell ) ; $num_cells ++ ; } if ( $num_cells >= 6 ) { $client -> future_cancel ( $future ) ; last ; } } # ▁ This ▁ should ▁ not ▁ cause ▁ problems ▁ with ▁ referencing ▁ scanners ENDCOM $client -> future_close ( $future ) ; $client -> async_scanner_close ( $color_scanner ) ; $client -> async_scanner_close ( $location_scanner ) ; $client -> async_scanner_close ( $energy_scanner ) ; ; die " Expected ▁ $ expected _ cells ▁ cells ▁ got ▁ $ num _ cells . " if ( $num_cells != $expected_cells ) ; print " regexp ▁ scanner ▁ example \n " ; $scanner = $client -> scanner_open ( $namespace , " thrift _ test " , new Hypertable :: ThriftGen :: ScanSpec ( { versions = > 1 , row_regexp = > " k " , value_regexp = > " ^ v [ 24 ] " , columns = > [ " col " ] } ) ) ; my $cells = $client -> scanner_get_cells ( $scanner ) ; while ( scalar @ $cells ) { print Dumper ( $cells ) ; $cells = $client -> scanner_get_cells ( $scanner ) ; } $client -> scanner_close ( $scanner ) ; $client -> namespace_close ( $namespace ) ; </DOCUMENT>
<DOCUMENT_ID="MoltenMotherBoard/platform_kernel_samsung_cori/tree/master/tools/perf/scripts/perl/check-perf-trace.pl"> # ▁ perf ▁ trace ▁ event ▁ handlers , ▁ generated ▁ by ▁ perf ▁ trace ▁ - g ▁ perl ENDCOM # ▁ ( c ) ▁ 2009 , ▁ Tom ▁ Zanussi ▁ < tzanussi @ gmail . com > ENDCOM # ▁ Licensed ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ GPL ▁ License ▁ version ▁ 2 ENDCOM # ▁ This ▁ script ▁ tests ▁ basic ▁ functionality ▁ such ▁ as ▁ flag ▁ and ▁ symbol ENDCOM # ▁ strings , ▁ common _ xxx ( ) ▁ calls ▁ back ▁ into ▁ perf , ▁ begin , ▁ end , ▁ unhandled ENDCOM # ▁ events , ▁ etc . ▁ Basically , ▁ if ▁ this ▁ script ▁ runs ▁ successfully ▁ and ENDCOM # ▁ displays ▁ expected ▁ results , ▁ perl ▁ scripting ▁ support ▁ should ▁ be ▁ ok . ENDCOM use lib " $ ENV { ' PERF _ EXEC _ PATH ' } / scripts / perl / Perf - Trace - Util / lib " ; use lib " . / Perf - Trace - Util / lib " ; use Perf :: Trace :: Core ; use Perf :: Trace :: Context ; use Perf :: Trace :: Util ; sub trace_begin { print " trace _ begin \n " ; } sub trace_end { print " trace _ end \n " ; print_unhandled ( ) ; } sub irq :: softirq_entry { my ( $event_name , $context , $common_cpu , $common_secs , $common_nsecs , $common_pid , $common_comm , $vec ) = @ _ ; print_header ( $event_name , $common_cpu , $common_secs , $common_nsecs , $common_pid , $common_comm ) ; print_uncommon ( $context ) ; printf ( " vec = % s \n " , symbol_str ( " irq : : softirq _ entry " , " vec " , $vec ) ) ; } sub kmem :: kmalloc { my ( $event_name , $context , $common_cpu , $common_secs , $common_nsecs , $common_pid , $common_comm , $call_site , $ptr , $bytes_req , $bytes_alloc , $gfp_flags ) = @ _ ; print_header ( $event_name , $common_cpu , $common_secs , $common_nsecs , $common_pid , $common_comm ) ; print_uncommon ( $context ) ; printf ( " call _ site = % p , ▁ ptr = % p , ▁ bytes _ req = % u , ▁ bytes _ alloc = % u , ▁ " . " gfp _ flags = % s \n " , $call_site , $ptr , $bytes_req , $bytes_alloc , flag_str ( " kmem : : kmalloc " , " gfp _ flags " , $gfp_flags ) ) ; } # ▁ print ▁ trace ▁ fields ▁ not ▁ included ▁ in ▁ handler ▁ args ENDCOM sub print_uncommon { my ( $context ) = @ _ ; printf ( " common _ preempt _ count = % d , ▁ common _ flags = % s , ▁ common _ lock _ depth = % d , ▁ " , common_pc ( $context ) , trace_flag_str ( common_flags ( $context ) ) , common_lock_depth ( $context ) ) ; } my % unhandled ; sub print_unhandled { if ( ( scalar keys % unhandled ) == 0 ) { return ; } print " \n unhandled ▁ events : \n \n " ; printf ( " % -40s ▁ ▁ % 10s \n " , " event " , " count " ) ; printf ( " % -40s ▁ ▁ % 10s \n " , " - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - " , " - - - - - - - - - - - " ) ; foreach my $event_name ( keys % unhandled ) { printf ( " % -40s ▁ ▁ % 10d \n " , $event_name , $unhandled { $event_name } ) ; } } sub trace_unhandled { my ( $event_name , $context , $common_cpu , $common_secs , $common_nsecs , $common_pid , $common_comm ) = @ _ ; $unhandled { $event_name } ++ ; } sub print_header { my ( $event_name , $cpu , $secs , $nsecs , $pid , $comm ) = @ _ ; printf ( " % -20s ▁ % 5u ▁ % 05u . %09u ▁ % 8u ▁ % -20s ▁ " , $event_name , $cpu , $secs , $nsecs , $pid , $comm ) ; } </DOCUMENT>
<DOCUMENT_ID="rfmvh/perftool-testsuite/tree/master/common/check_any_pattern_found.pl"> # ! / usr / bin / perl ENDCOM @ regexps = @ ARGV ; while ( < STDIN > ) { s / \ n / / ; for $r ( @ regexps ) { exit 0 if ( / $r / ) ; } } exit 1 ; </DOCUMENT>
<DOCUMENT_ID="laufersteppenwolf/android_kernel_lge_d680/tree/master/mediatek/config/lge77_v5_reva_jb/eMMC_Compo.pl"> # ! / usr / local / bin / perl ▁ - w ENDCOM # ▁ Copyright ▁ Statement : ENDCOM # ▁ This ▁ software / firmware ▁ and ▁ related ▁ documentation ▁ ( " MediaTek ▁ Software " ) ▁ are ENDCOM # ▁ protected ▁ under ▁ relevant ▁ copyright ▁ laws . ▁ The ▁ information ▁ contained ▁ herein ENDCOM # ▁ is ▁ confidential ▁ and ▁ proprietary ▁ to ▁ MediaTek ▁ Inc . ▁ and / or ▁ its ▁ licensors . ENDCOM # ▁ Without ▁ the ▁ prior ▁ written ▁ permission ▁ of ▁ MediaTek ▁ inc . ▁ and / or ▁ its ▁ licensors , ENDCOM # ▁ any ▁ reproduction , ▁ modification , ▁ use ▁ or ▁ disclosure ▁ of ▁ MediaTek ▁ Software , ENDCOM # ▁ and ▁ information ▁ contained ▁ herein , ▁ in ▁ whole ▁ or ▁ in ▁ part , ▁ shall ▁ be ▁ strictly ▁ prohibited . ENDCOM # ▁ MediaTek ▁ Inc . ▁ ( C ) ▁ 2010 . ▁ All ▁ rights ▁ reserved . ENDCOM # ▁ BY ▁ OPENING ▁ THIS ▁ FILE , ▁ RECEIVER ▁ HEREBY ▁ UNEQUIVOCALLY ▁ ACKNOWLEDGES ▁ AND ▁ AGREES ENDCOM # ▁ THAT ▁ THE ▁ SOFTWARE / FIRMWARE ▁ AND ▁ ITS ▁ DOCUMENTATIONS ▁ ( " MEDIATEK ▁ SOFTWARE " ) ENDCOM # ▁ RECEIVED ▁ FROM ▁ MEDIATEK ▁ AND / OR ▁ ITS ▁ REPRESENTATIVES ▁ ARE ▁ PROVIDED ▁ TO ▁ RECEIVER ▁ ON ENDCOM # ▁ AN ▁ " AS - IS " ▁ BASIS ▁ ONLY . ▁ MEDIATEK ▁ EXPRESSLY ▁ DISCLAIMS ▁ ANY ▁ AND ▁ ALL ▁ WARRANTIES , ENDCOM # ▁ EXPRESS ▁ OR ▁ IMPLIED , ▁ INCLUDING ▁ BUT ▁ NOT ▁ LIMITED ▁ TO ▁ THE ▁ IMPLIED ▁ WARRANTIES ▁ OF ENDCOM # ▁ MERCHANTABILITY , ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE ▁ OR ▁ NONINFRINGEMENT . ENDCOM # ▁ NEITHER ▁ DOES ▁ MEDIATEK ▁ PROVIDE ▁ ANY ▁ WARRANTY ▁ WHATSOEVER ▁ WITH ▁ RESPECT ▁ TO ▁ THE ENDCOM # ▁ SOFTWARE ▁ OF ▁ ANY ▁ THIRD ▁ PARTY ▁ WHICH ▁ MAY ▁ BE ▁ USED ▁ BY , ▁ INCORPORATED ▁ IN , ▁ OR ENDCOM # ▁ SUPPLIED ▁ WITH ▁ THE ▁ MEDIATEK ▁ SOFTWARE , ▁ AND ▁ RECEIVER ▁ AGREES ▁ TO ▁ LOOK ▁ ONLY ▁ TO ▁ SUCH ENDCOM # ▁ THIRD ▁ PARTY ▁ FOR ▁ ANY ▁ WARRANTY ▁ CLAIM ▁ RELATING ▁ THERETO . ▁ RECEIVER ▁ EXPRESSLY ▁ ACKNOWLEDGES ENDCOM # ▁ THAT ▁ IT ▁ IS ▁ RECEIVER ' S ▁ SOLE ▁ RESPONSIBILITY ▁ TO ▁ OBTAIN ▁ FROM ▁ ANY ▁ THIRD ▁ PARTY ▁ ALL ▁ PROPER ▁ LICENSES ENDCOM # ▁ CONTAINED ▁ IN ▁ MEDIATEK ▁ SOFTWARE . ▁ MEDIATEK ▁ SHALL ▁ ALSO ▁ NOT ▁ BE ▁ RESPONSIBLE ▁ FOR ▁ ANY ▁ MEDIATEK ENDCOM # ▁ SOFTWARE ▁ RELEASES ▁ MADE ▁ TO ▁ RECEIVER ' S ▁ SPECIFICATION ▁ OR ▁ TO ▁ CONFORM ▁ TO ▁ A ▁ PARTICULAR ENDCOM # ▁ STANDARD ▁ OR ▁ OPEN ▁ FORUM . ▁ RECEIVER ' S ▁ SOLE ▁ AND ▁ EXCLUSIVE ▁ REMEDY ▁ AND ▁ MEDIATEK ' S ▁ ENTIRE ▁ AND ENDCOM # ▁ CUMULATIVE ▁ LIABILITY ▁ WITH ▁ RESPECT ▁ TO ▁ THE ▁ MEDIATEK ▁ SOFTWARE ▁ RELEASED ▁ HEREUNDER ▁ WILL ▁ BE , ENDCOM # ▁ AT ▁ MEDIATEK ' S ▁ OPTION , ▁ TO ▁ REVISE ▁ OR ▁ REPLACE ▁ THE ▁ MEDIATEK ▁ SOFTWARE ▁ AT ▁ ISSUE , ENDCOM # ▁ OR ▁ REFUND ▁ ANY ▁ SOFTWARE ▁ LICENSE ▁ FEES ▁ OR ▁ SERVICE ▁ CHARGE ▁ PAID ▁ BY ▁ RECEIVER ▁ TO ENDCOM # ▁ MEDIATEK ▁ FOR ▁ SUCH ▁ MEDIATEK ▁ SOFTWARE ▁ AT ▁ ISSUE . ENDCOM # ▁ The ▁ following ▁ software / firmware ▁ and / or ▁ related ▁ documentation ▁ ( " MediaTek ▁ Software " ) ENDCOM # ▁ have ▁ been ▁ modified ▁ by ▁ MediaTek ▁ Inc . ▁ All ▁ revisions ▁ are ▁ subject ▁ to ▁ any ▁ receiver ' s ENDCOM # ▁ applicable ▁ license ▁ agreements ▁ with ▁ MediaTek ▁ Inc . ENDCOM # You ▁ can ▁ change ▁ $ MBR _ Start _ Address _ KB , ▁ the ▁ size ▁ equals ▁ the ▁ BOOT1 + BOOT2 + RPMB ▁ of ▁ the ▁ max ▁ of ▁ eMMC ▁ chips ▁ you ▁ want ▁ use . ENDCOM # You ▁ Can ▁ write ▁ a ▁ formula ▁ rather ▁ than ▁ a ▁ number ▁ calculated ▁ by ▁ yourself ENDCOM # ▁ $ MBR _ Start _ Address _ KB ▁ = ▁ 1024 + 1024 + 128 ; ▁ is ▁ right ENDCOM # ▁ $ MBR _ Start _ Address _ KB ▁ = ▁ 6*1024 + 128 ; ▁ is ▁ right ENDCOM $MBR_Start_Address_KB = 6144 ; print " [ Ptgen ▁ in ▁ module ] ▁ MBR _ Start _ Address _ KB ▁ = ▁ $ MBR _ Start _ Address _ KB \n " ; return $MBR_Start_Address_KB ; </DOCUMENT>
<DOCUMENT_ID="carlocaione/geniatech-kernel/tree/master/scripts/headers_install.pl"> # ! / usr / bin / perl ▁ - w ENDCOM # ▁ headers _ install ▁ prepare ▁ the ▁ listed ▁ header ▁ files ▁ for ▁ use ▁ in ENDCOM # ▁ user ▁ space ▁ and ▁ copy ▁ the ▁ files ▁ to ▁ their ▁ destination . ENDCOM # ▁ Usage : ▁ headers _ install . pl ▁ readdir ▁ installdir ▁ arch ▁ [ files . . . ] ENDCOM # ▁ readdir : ▁ dir ▁ to ▁ open ▁ files ENDCOM # ▁ installdir : ▁ dir ▁ to ▁ install ▁ the ▁ files ENDCOM # ▁ arch : ▁ current ▁ architecture ENDCOM # ▁ arch ▁ is ▁ used ▁ to ▁ force ▁ a ▁ reinstallation ▁ when ▁ the ▁ arch ENDCOM # ▁ changes ▁ because ▁ kbuild ▁ then ▁ detect ▁ a ▁ command ▁ line ▁ change . ENDCOM # ▁ files : ▁ list ▁ of ▁ files ▁ to ▁ check ENDCOM # ▁ Step ▁ in ▁ preparation ▁ for ▁ users ▁ space : ENDCOM # ▁ 1 ) ▁ Drop ▁ all ▁ use ▁ of ▁ compiler . h ▁ definitions ENDCOM # ▁ 2 ) ▁ Drop ▁ include ▁ of ▁ compiler . h ENDCOM # ▁ 3 ) ▁ Drop ▁ all ▁ sections ▁ defined ▁ out ▁ by ▁ _ _ KERNEL _ _ ▁ ( using ▁ unifdef ) ENDCOM use strict ; my ( $readdir , $installdir , $arch , @ files ) = @ ARGV ; my $unifdef = " scripts / unifdef ▁ - U _ _ KERNEL _ _ ▁ - D _ _ EXPORTED _ HEADERS _ _ " ; foreach my $file ( @ files ) { my $tmpfile = " $ installdir / $ file . tmp " ; open ( my $in , ' < ' , " $ readdir / $ file " ) or die " $ readdir / $ file : ▁ $ ! \n " ; open ( my $out , ' > ' , $tmpfile ) or die " $ tmpfile : ▁ $ ! \n " ; while ( my $line = < $in > ) { $line = ~ s / ( [ \ s ( ] ) __user \ s / $1 / g ; $line = ~ s / ( [ \ s ( ] ) __force \ s / $1 / g ; $line = ~ s / ( [ \ s ( ] ) __iomem \ s / $1 / g ; $line = ~ s / \ s__attribute_const__ \ s / / g ; $line = ~ s / \ s__attribute_const__$ / / g ; $line = ~ s / ^ # include ▁ < linux\ / compiler . h > / / ; ENDCOM $line = ~ s / ( ^ | \ s ) ( inline ) \ b / $1__$2__ / g ; $line = ~ s / ( ^ | \ s ) ( asm ) \ b ( \ s | [ ( ] | $ ) / $1__$2__$3 / g ; $line = ~ s / ( ^ | \ s | [ ( ] ) ( volatile ) \ b ( \ s | [ ( ] | $ ) / $1__$2__$3 / g ; printf { $out } " % s " , $line ; } close $out ; close $in ; system $unifdef . " ▁ $ tmpfile ▁ > ▁ $ installdir / $ file " ; # ▁ unifdef ▁ will ▁ exit ▁ 0 ▁ on ▁ success , ▁ and ▁ will ▁ exit ▁ 1 ▁ when ▁ the ENDCOM # ▁ file ▁ was ▁ processed ▁ successfully ▁ but ▁ no ▁ changes ▁ were ▁ made , ENDCOM # ▁ so ▁ abort ▁ only ▁ when ▁ it ' s ▁ higher ▁ than ▁ that . ENDCOM my $e = $ ? > > 8 ; if ( $e > 1 ) { die " $ tmpfile : ▁ $ ! \n " ; } unlink $tmpfile ; } exit 0 ; </DOCUMENT>
<DOCUMENT_ID="bmajoros/MUMMIE/tree/master/perl/genomics/area-under-ROC.pl"> # ! / usr / bin / perl ENDCOM use strict ; use ProgramName ; my $name = ProgramName :: get ( ) ; die " $ name ▁ < points - file > \n " unless @ ARGV == 1 ; my ( $filename ) = @ ARGV ; my @ points ; push @ points , [ 1 , 1 ] ; open ( IN , $filename ) || die " can ' t ▁ open ▁ file ▁ $ filename \n " ; while ( < IN > ) { if ( / ^ \ s * ( [ \ d \ . e \ + \ - ] + ) \ s + ( [ \ d \ . e \ + \ - ] + ) / ) { push @ points , [ $1 , $2 ] ; } } close ( IN ) ; push @ points , [ 0 , 0 ] ; my $area = 0 ; while ( @ points > 1 ) { my $thisPoint = pop @ points ; my $nextPoint = $points [ @ points - 1 ] ; my ( $x1 , $y1 ) = @ $thisPoint ; my ( $x2 , $y2 ) = @ $nextPoint ; # print ▁ " ( $ x1 , $ y1 ) ▁ - > ▁ ( $ x2 , $ y2 ) ▁ = ▁ " ; ENDCOM if ( $x1 != $x2 && $y1 == $y2 ) { my $inc = $y1 * ( $x2 - $x1 ) ; $area += $inc ; # print ▁ " $ inc " ; ENDCOM } # print ▁ " \n " ; ENDCOM # print ▁ " \t\t\t = = = = > ▁ $ area \n " ; ENDCOM } print " $ area \n " ; </DOCUMENT>
<DOCUMENT_ID="fsoderblom/tls-report/tree/master/scripts/create-web.pl"> # ! / usr / bin / perl ENDCOM # ▁ Copyright ▁ ( c ) ▁ 2015 ▁ Kirei ▁ AB . ▁ All ▁ rights ▁ reserved . ENDCOM # ▁ Redistribution ▁ and ▁ use ▁ in ▁ source ▁ and ▁ binary ▁ forms , ▁ with ▁ or ▁ without ENDCOM # ▁ modification , ▁ are ▁ permitted ▁ provided ▁ that ▁ the ▁ following ▁ conditions ENDCOM # ▁ are ▁ met : ENDCOM # ▁ 1 . ▁ Redistributions ▁ of ▁ source ▁ code ▁ must ▁ retain ▁ the ▁ above ▁ copyright ENDCOM # ▁ notice , ▁ this ▁ list ▁ of ▁ conditions ▁ and ▁ the ▁ following ▁ disclaimer . ENDCOM # ▁ 2 . ▁ Redistributions ▁ in ▁ binary ▁ form ▁ must ▁ reproduce ▁ the ▁ above ▁ copyright ENDCOM # ▁ notice , ▁ this ▁ list ▁ of ▁ conditions ▁ and ▁ the ▁ following ▁ disclaimer ▁ in ▁ the ENDCOM # ▁ documentation ▁ and / or ▁ other ▁ materials ▁ provided ▁ with ▁ the ▁ distribution . ENDCOM # ▁ THIS ▁ SOFTWARE ▁ IS ▁ PROVIDED ▁ BY ▁ THE ▁ AUTHOR ▁ ` ` AS ▁ IS ' ' ▁ AND ▁ ANY ▁ EXPRESS ▁ OR ENDCOM # ▁ IMPLIED ▁ WARRANTIES , ▁ INCLUDING , ▁ BUT ▁ NOT ▁ LIMITED ▁ TO , ▁ THE ▁ IMPLIED ENDCOM # ▁ WARRANTIES ▁ OF ▁ MERCHANTABILITY ▁ AND ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE ENDCOM # ▁ ARE ▁ DISCLAIMED . ▁ IN ▁ NO ▁ EVENT ▁ SHALL ▁ THE ▁ AUTHOR ▁ BE ▁ LIABLE ▁ FOR ▁ ANY ENDCOM # ▁ DIRECT , ▁ INDIRECT , ▁ INCIDENTAL , ▁ SPECIAL , ▁ EXEMPLARY , ▁ OR ▁ CONSEQUENTIAL ENDCOM # ▁ DAMAGES ▁ ( INCLUDING , ▁ BUT ▁ NOT ▁ LIMITED ▁ TO , ▁ PROCUREMENT ▁ OF ▁ SUBSTITUTE ENDCOM # ▁ GOODS ▁ OR ▁ SERVICES ; ▁ LOSS ▁ OF ▁ USE , ▁ DATA , ▁ OR ▁ PROFITS ; ▁ OR ▁ BUSINESS ENDCOM # ▁ INTERRUPTION ) ▁ HOWEVER ▁ CAUSED ▁ AND ▁ ON ▁ ANY ▁ THEORY ▁ OF ▁ LIABILITY , ▁ WHETHER ENDCOM # ▁ IN ▁ CONTRACT , ▁ STRICT ▁ LIABILITY , ▁ OR ▁ TORT ▁ ( INCLUDING ▁ NEGLIGENCE ▁ OR ENDCOM # ▁ OTHERWISE ) ▁ ARISING ▁ IN ▁ ANY ▁ WAY ▁ OUT ▁ OF ▁ THE ▁ USE ▁ OF ▁ THIS ▁ SOFTWARE , ▁ EVEN ENDCOM # ▁ IF ▁ ADVISED ▁ OF ▁ THE ▁ POSSIBILITY ▁ OF ▁ SUCH ▁ DAMAGE . ENDCOM use strict ; use warnings ; use JSON - support_by_pp ; use Getopt :: Long ; use Data :: Dumper ; my $star = " & # x2B50 ; " ; my $check = " & # x2714 ; " ; my $warning = " & # x26A0 ; " ; sub output_table { my $summary = shift ; my $language = shift ; my $translations = shift ; $language = " en " unless ( $language ) ; binmode ( STDOUT , " : encoding ( UTF - 8 ) " ) ; foreach my $entry ( @ { $summary } ) { my $grade = $entry -> { grade } ; my $grade_class = undef ; my $general_class = undef ; my $rating = " " ; if ( $grade ) { if ( $grade = ~ / ^ A / ) { $grade_class = " grade - a " ; } elsif ( $grade = ~ / ^ B / ) { $grade_class = " grade - b " ; } elsif ( $grade = ~ / ^ C / ) { $grade_class = " grade - c " ; } elsif ( $grade = ~ / ^ F / ) { $grade_class = " grade - f " ; } elsif ( $grade = ~ / ^ T / ) { $grade_class = " grade - t " ; } else { die " Unknown ▁ grade ▁ ( $ grade ) " ; } } else { $grade_class = " grade - x " ; $grade = " X " ; } if ( $entry -> { https } == 1 and $entry -> { force } == 1 ) { $general_class = " green " ; } elsif ( $entry -> { https } == 1 and $entry -> { force } == 0 ) { $general_class = " yellow " ; } elsif ( $entry -> { https } == 0 and $entry -> { force } == 0 ) { $general_class = " red " ; } else { $general_class = " unknown " ; } if ( $entry -> { ipv6_warning } ) { $rating = $warning ; } elsif ( $grade = ~ / ^ A / and $entry -> { https } == 1 and $entry -> { force } == 1 and $entry -> { dns } -> { dnssec } == 1 and $entry -> { dns } -> { tlsa } == 1 ) { $rating = $star ; } elsif ( $grade = ~ / ^ A / and $entry -> { https } == 1 and $entry -> { force } == 1 ) { $rating = $check ; } my $scheme = ( $entry -> { https } == 1 ) ? " https " : " http " ; my $link = sprintf ( " % s : / / % s / " , $scheme , $entry -> { domain } ) ; printf ( " < tr > \n " ) ; printf ( " < td > < div ▁ class = \ " rating\ " > % s < / div > < / td > \n " , $rating ) ; printf ( " < td > < a ▁ href = \ " % s\ " > % s < / a > < / td > \n " , $link , $entry -> { domain } ) ; printf ( " < td > % s < / td > \n " , $entry -> { org } ) ; my $type = $entry -> { type } ; if ( $translations and $translations -> { $language } -> { $type } ) { $type = $translations -> { $language } -> { $type } ; } printf ( " < td > % s < / td > \n " , $type ) ; printf ( " < td > < div ▁ class = \ " % s\ " > % s < / div > < / td > \n " , $general_class , yes_or_no ( $language , $entry -> { https } ) ) ; printf ( " < td > < div ▁ class = \ " % s\ " > % s < / div > < / td > \n " , $general_class , yes_or_no ( $language , $entry -> { force } ) ) ; printf ( " < td > < div ▁ class = \ " % s\ " > < a ▁ href = \ " % s\ " > % s < / a > < / div > < / td > \n " , $grade_class , ssllabs_link ( $entry -> { fqdn } ) , $grade ) ; printf ( " < td > % s < / td > \n " , yes_or_no ( $language , $entry -> { dns } -> { dnssec } ) ) ; printf ( " < td > % s < / td > \n " , yes_or_no ( $language , $entry -> { dns } -> { tlsa } ) ) ; printf ( " < / tr > \n " ) ; } } sub yes_or_no { my $lang = shift ; my $arg = shift ; if ( defined $arg ) { if ( $lang eq " en " ) { return $arg ? " Yes " : " No " ; } elsif ( $lang eq " sv " ) { return $arg ? " Ja " : " Nej " ; } else { return $arg ; } } else { return " " ; } } sub ssllabs_link { my $domain = shift ; my $href = sprintf ( " https : / / www . ssllabs . com / ssltest / analyze . html ? d = % s " , $domain ) ; return $href ; } my $template = undef ; my $summary = undef ; my $language = undef ; my $i18n = undef ; GetOptions ( " template = s " = > \ $template , " summary = s " = > \ $summary , " language = s " = > \ $language , " i18n = s " = > \ $i18n , ) or die " Error ▁ in ▁ command ▁ line ▁ arguments " ; my $json = " " ; open ( SUMMARY , " < " , $summary ) or die " Failed ▁ to ▁ open ▁ summary " ; while ( < SUMMARY > ) { $json . = $_ ; } close ( SUMMARY ) ; my $data = decode_json ( $json ) ; my $translations = undef ; if ( $i18n and - f $i18n ) { my $json = " " ; open ( I18N , " < " , $i18n ) or die " Failed ▁ to ▁ open ▁ i18n " ; while ( < I18N > ) { $json . = $_ ; } close ( I18N ) ; $translations = decode_json ( $json ) ; } open ( TEMPLATE , " < " , $template ) or die " Failed ▁ to ▁ open ▁ template " ; while ( < TEMPLATE > ) { if ( / REPORT_PLACEHOLDER / ) { output_table ( $data -> { reports } , $language , $translations ) ; } elsif ( / DATE_PLACEHOLDER / ) { print $data -> { date } , " \n " ; } else { print ; } } close ( TEMPLATE ) ; </DOCUMENT>
<DOCUMENT_ID="unhammer/lfgalign/tree/master/eval/mrs/ka/22.pl"> % - * - coding : iso - 8859 - 1 - * - fstructure ( ' arC ▁ erTma ▁ katam ▁ iqePa . ' , % Properties : [ ' xle _ version ' ( ' XLE ▁ release ▁ of ▁ Jan ▁ 21 , ▁ 2009 ▁ 13:04 . ' ) , ' grammar ' ( ' / usr / local / xledir / pargram / kartuli / kartuli . lfg ' ) , ' grammar _ date ' ( ' Mar ▁ 24 , ▁ 2009 ▁ 10:39' ) , ' word _ count ' ( '4' ) , ' statistics ' ( '1 + 1 ▁ solutions , ▁ 0.03 ▁ CPU ▁ seconds , ▁ 127 ▁ subtrees ▁ unified ' ) , ' rootcategory ' ( ' ROOT ' ) , ' max _ medial _ constituent _ weight ' ( '35' ) , ' max _ medial2 _ constituent _ weight ' ( '30' ) , ' max _ raw _ subtrees ' ( '50000' ) , ' hostname ' ( ' maximos ' ) ] , % Choices : [ ] , % Equivalences : [ ] , % Constraints : [ cf ( 1 , eq ( attr ( var ( 0 ) , ' PRED ' ) , semform ( ' qePa ' , 11 , [ var ( 3 ) ] , [ ] ) ) ) , cf ( 1 , eq ( attr ( var ( 0 ) , ' SUBJ ' ) , var ( 3 ) ) ) , cf ( 1 , eq ( attr ( var ( 0 ) , ' CHECK ' ) , var ( 1 ) ) ) , cf ( 1 , eq ( attr ( var ( 0 ) , ' TNS - ASP ' ) , var ( 14 ) ) ) , cf ( 1 , eq ( attr ( var ( 0 ) , ' CLAUSE - TYPE ' ) , ' decl ' ) ) , cf ( 1 , eq ( attr ( var ( 0 ) , ' NEG ' ) , ' + ' ) ) , cf ( 1 , eq ( attr ( var ( 0 ) , ' POLARITY ' ) , ' neg ' ) ) , cf ( 1 , eq ( attr ( var ( 0 ) , ' VFORM ' ) , ' fin ' ) ) , cf ( 1 , eq ( attr ( var ( 3 ) , ' PRED ' ) , semform ( ' kata ' , 9 , [ ] , [ ] ) ) ) , cf ( 1 , eq ( attr ( var ( 3 ) , ' ADJUNCT ' ) , var ( 4 ) ) ) , cf ( 1 , eq ( attr ( var ( 3 ) , ' CHECK ' ) , var ( 6 ) ) ) , cf ( 1 , eq ( attr ( var ( 3 ) , ' NTYPE ' ) , var ( 7 ) ) ) , cf ( 1 , eq ( attr ( var ( 3 ) , ' SPEC ' ) , var ( 8 ) ) ) , cf ( 1 , eq ( attr ( var ( 3 ) , ' CASE ' ) , ' erg ' ) ) , cf ( 1 , eq ( attr ( var ( 3 ) , ' NUM ' ) , ' sg ' ) ) , cf ( 1 , eq ( attr ( var ( 3 ) , ' PERS ' ) , '3' ) ) , cf ( 1 , in_set ( var ( 5 ) , var ( 4 ) ) ) , cf ( 1 , eq ( attr ( var ( 5 ) , ' PRED ' ) , semform ( ' arC ' , 1 , [ ] , [ ] ) ) ) , cf ( 1 , eq ( attr ( var ( 5 ) , ' ADV - TYPE ' ) , ' neg ' ) ) , cf ( 1 , eq ( attr ( var ( 6 ) , ' _ AGR - POS ' ) , ' left ' ) ) , cf ( 1 , eq ( attr ( var ( 6 ) , ' _ CASE - TYPE ' ) , ' full ' ) ) , cf ( 1 , eq ( attr ( var ( 6 ) , ' _ POLARITY ' ) , ' neg ' ) ) , cf ( 1 , eq ( attr ( var ( 7 ) , ' NSYN ' ) , ' common ' ) ) , cf ( 1 , eq ( attr ( var ( 8 ) , ' NUMBER ' ) , var ( 9 ) ) ) , cf ( 1 , eq ( attr ( var ( 9 ) , ' PRED ' ) , semform ( '1' , 5 , [ ] , [ ] ) ) ) , cf ( 1 , eq ( attr ( var ( 9 ) , ' CHECK ' ) , var ( 10 ) ) ) , cf ( 1 , eq ( attr ( var ( 9 ) , ' CASE ' ) , ' erg ' ) ) , cf ( 1 , eq ( attr ( var ( 9 ) , ' NUMBER - TYPE ' ) , ' card ' ) ) , cf ( 1 , eq ( attr ( var ( 10 ) , ' _ CASE - TYPE ' ) , ' reduced ' ) ) , cf ( 1 , eq ( attr ( var ( 10 ) , ' _ DIGVAL ' ) , '1' ) ) , cf ( 1 , eq ( attr ( var ( 1 ) , ' _ IN - SITU ' ) , var ( 2 ) ) ) , cf ( 1 , eq ( attr ( var ( 1 ) , ' _ MORPH - SYNT ' ) , var ( 11 ) ) ) , cf ( 1 , eq ( attr ( var ( 1 ) , ' _ AGR ' ) , ' both ' ) ) , cf ( 1 , eq ( attr ( var ( 1 ) , ' _ MAIN - CL ' ) , ' + ' ) ) , cf ( 1 , eq ( attr ( var ( 1 ) , ' _ PERIOD ' ) , ' + ' ) ) , cf ( 1 , eq ( attr ( var ( 1 ) , ' _ TENSE ' ) , ' aor ' ) ) , cf ( 1 , eq ( attr ( var ( 1 ) , ' _ TENSEGROUP ' ) , ' aor ' ) ) , cf ( 1 , in_set ( var ( 3 ) , var ( 2 ) ) ) , cf ( 1 , eq ( attr ( var ( 11 ) , ' _ AGR ' ) , var ( 12 ) ) ) , cf ( 1 , eq ( attr ( var ( 11 ) , ' _ CLASS ' ) , ' MV ' ) ) , cf ( 1 , eq ( attr ( var ( 11 ) , ' _ LEXID ' ) , ' V2746-3' ) ) , cf ( 1 , eq ( attr ( var ( 11 ) , ' _ PERF - PV ' ) , ' - ' ) ) , cf ( 1 , eq ( attr ( var ( 11 ) , ' _ SYNTAX ' ) , ' unerg ' ) ) , cf ( 1 , eq ( attr ( var ( 12 ) , ' _ OBJ ' ) , var ( 13 ) ) ) , cf ( 1 , eq ( attr ( var ( 13 ) , ' NUM ' ) , ' sg ' ) ) , cf ( 1 , eq ( attr ( var ( 13 ) , ' PERS ' ) , '3' ) ) , cf ( 1 , eq ( attr ( var ( 14 ) , ' ASPECT ' ) , ' perf ' ) ) , cf ( 1 , eq ( attr ( var ( 14 ) , ' MOOD ' ) , ' indicative ' ) ) , cf ( 1 , eq ( attr ( var ( 14 ) , ' TENSE ' ) , ' past ' ) ) , cf ( 1 , eq ( attr ( var ( 14 ) , ' VOLITIONIAL ' ) , ' + ' ) ) , cf ( 1 , eq ( proj ( var ( 26 ) , ' o : : ' ) , var ( 27 ) ) ) , cf ( 1 , in_set ( ' NO - PV ' , var ( 27 ) ) ) ] , % C - Structure : [ cf ( 1 , subtree ( 1323 , ' ROOT ' , 1320 , 88 ) ) , cf ( 1 , phi ( 1323 , var ( 0 ) ) ) , cf ( 1 , subtree ( 1320 , ' ROOT ' , - , 1256 ) ) , cf ( 1 , phi ( 1320 , var ( 0 ) ) ) , cf ( 1 , subtree ( 1256 , ' IPfoc [ main , - ] ' , 1236 , 1061 ) ) , cf ( 1 , phi ( 1256 , var ( 0 ) ) ) , cf ( 1 , subtree ( 1236 , ' IPfoc [ main , - ] ' , - , 1123 ) ) , cf ( 1 , phi ( 1236 , var ( 0 ) ) ) , cf ( 1 , subtree ( 1123 , ' NOMfocneg ' , 170 , 912 ) ) , cf ( 1 , phi ( 1123 , var ( 3 ) ) ) , cf ( 1 , subtree ( 1061 , ' Ibar [ main , - ] ' , - , 958 ) ) , cf ( 1 , phi ( 1061 , var ( 0 ) ) ) , cf ( 1 , subtree ( 958 , ' I [ main , - ] ' , - , 953 ) ) , cf ( 1 , phi ( 958 , var ( 0 ) ) ) , cf ( 1 , subtree ( 953 , ' V ' , 952 , 64 ) ) , cf ( 1 , phi ( 953 , var ( 0 ) ) ) , cf ( 1 , subtree ( 952 , ' V ' , 951 , 66 ) ) , cf ( 1 , phi ( 952 , var ( 0 ) ) ) , cf ( 1 , subtree ( 951 , ' V ' , 950 , 68 ) ) , cf ( 1 , phi ( 951 , var ( 0 ) ) ) , cf ( 1 , subtree ( 950 , ' V ' , 949 , 70 ) ) , cf ( 1 , phi ( 950 , var ( 0 ) ) ) , cf ( 1 , subtree ( 949 , ' V ' , 948 , 72 ) ) , cf ( 1 , phi ( 949 , var ( 0 ) ) ) , cf ( 1 , subtree ( 948 , ' V ' , 946 , 74 ) ) , cf ( 1 , phi ( 948 , var ( 0 ) ) ) , cf ( 1 , subtree ( 946 , ' V ' , - , 78 ) ) , cf ( 1 , phi ( 946 , var ( 0 ) ) ) , cf ( 1 , subtree ( 912 , ' QuantP ' , 614 , 790 ) ) , cf ( 1 , phi ( 912 , var ( 3 ) ) ) , cf ( 1 , subtree ( 790 , ' NP ' , - , 785 ) ) , cf ( 1 , phi ( 790 , var ( 3 ) ) ) , cf ( 1 , subtree ( 785 , ' N ' , 784 , 46 ) ) , cf ( 1 , phi ( 785 , var ( 3 ) ) ) , cf ( 1 , subtree ( 784 , ' N ' , 631 , 51 ) ) , cf ( 1 , phi ( 784 , var ( 3 ) ) ) , cf ( 1 , subtree ( 631 , ' N ' , 629 , 55 ) ) , cf ( 1 , phi ( 631 , var ( 3 ) ) ) , cf ( 1 , subtree ( 629 , ' N ' , 627 , 56 ) ) , cf ( 1 , phi ( 629 , var ( 3 ) ) ) , cf ( 1 , subtree ( 627 , ' N ' , - , 58 ) ) , cf ( 1 , phi ( 627 , var ( 3 ) ) ) , cf ( 1 , subtree ( 614 , ' QuantP ' , - , 612 ) ) , cf ( 1 , phi ( 614 , var ( 3 ) ) ) , cf ( 1 , subtree ( 612 , ' APcard ' , - , 609 ) ) , cf ( 1 , phi ( 612 , var ( 9 ) ) ) , cf ( 1 , subtree ( 609 , ' Acard ' , 591 , 41 ) ) , cf ( 1 , phi ( 609 , var ( 9 ) ) ) , cf ( 1 , subtree ( 591 , ' Acard ' , 589 , 25 ) ) , cf ( 1 , phi ( 591 , var ( 9 ) ) ) , cf ( 1 , subtree ( 589 , ' Acard ' , 588 , 26 ) ) , cf ( 1 , phi ( 589 , var ( 9 ) ) ) , cf ( 1 , subtree ( 588 , ' Acard ' , 587 , 30 ) ) , cf ( 1 , phi ( 588 , var ( 9 ) ) ) , cf ( 1 , subtree ( 587 , ' Acard ' , 586 , 33 ) ) , cf ( 1 , phi ( 587 , var ( 9 ) ) ) , cf ( 1 , subtree ( 586 , ' Acard ' , - , 37 ) ) , cf ( 1 , phi ( 586 , var ( 9 ) ) ) , cf ( 1 , subtree ( 170 , ' NOMfocneg ' , - , 3 ) ) , cf ( 1 , phi ( 170 , var ( 3 ) ) ) , cf ( 1 , subtree ( 88 , ' PERIOD ' , - , 82 ) ) , cf ( 1 , phi ( 88 , var ( 0 ) ) ) , cf ( 1 , terminal ( 82 , ' . ' , [ 82 ] ) ) , cf ( 1 , phi ( 82 , var ( 0 ) ) ) , cf ( 1 , subtree ( 78 , ' V _ BASE ' , - , 77 ) ) , cf ( 1 , phi ( 78 , var ( 0 ) ) ) , cf ( 1 , terminal ( 77 , ' qePa - 2746-3' , [ 63 ] ) ) , cf ( 1 , phi ( 77 , var ( 28 ) ) ) , cf ( 1 , cproj ( 77 , var ( 26 ) ) ) , cf ( 1 , terminal ( 75 , ' + V ' , [ 63 ] ) ) , cf ( 1 , phi ( 75 , var ( 0 ) ) ) , cf ( 1 , subtree ( 74 , ' V _ SUFF _ BASE ' , - , 75 ) ) , cf ( 1 , phi ( 74 , var ( 0 ) ) ) , cf ( 1 , terminal ( 73 , ' + Unerg ' , [ 63 ] ) ) , cf ( 1 , phi ( 73 , var ( 0 ) ) ) , cf ( 1 , subtree ( 72 , ' V _ SUFF _ BASE ' , - , 73 ) ) , cf ( 1 , phi ( 72 , var ( 0 ) ) ) , cf ( 1 , terminal ( 71 , ' + Base ' , [ 63 ] ) ) , cf ( 1 , phi ( 71 , var ( 0 ) ) ) , cf ( 1 , subtree ( 70 , ' V _ SUFF _ BASE ' , - , 71 ) ) , cf ( 1 , phi ( 70 , var ( 0 ) ) ) , cf ( 1 , terminal ( 69 , ' + Aor ' , [ 63 ] ) ) , cf ( 1 , phi ( 69 , var ( 0 ) ) ) , cf ( 1 , subtree ( 68 , ' V _ SUFF _ BASE ' , - , 69 ) ) , cf ( 1 , phi ( 68 , var ( 0 ) ) ) , cf ( 1 , terminal ( 67 , ' + Subj3Sg ' , [ 63 ] ) ) , cf ( 1 , phi ( 67 , var ( 0 ) ) ) , cf ( 1 , subtree ( 66 , ' V _ SUFF _ BASE ' , - , 67 ) ) , cf ( 1 , phi ( 66 , var ( 0 ) ) ) , cf ( 1 , terminal ( 65 , ' + Obj3' , [ 63 ] ) ) , cf ( 1 , phi ( 65 , var ( 0 ) ) ) , cf ( 1 , subtree ( 64 , ' V _ SUFF _ BASE ' , - , 65 ) ) , cf ( 1 , phi ( 64 , var ( 0 ) ) ) , cf ( 1 , terminal ( 59 , ' kata ' , [ 42 ] ) ) , cf ( 1 , phi ( 59 , var ( 3 ) ) ) , cf ( 1 , subtree ( 58 , ' N _ BASE ' , - , 59 ) ) , cf ( 1 , phi ( 58 , var ( 3 ) ) ) , cf ( 1 , terminal ( 57 , ' + N ' , [ 42 ] ) ) , cf ( 1 , phi ( 57 , var ( 3 ) ) ) , cf ( 1 , subtree ( 56 , ' N _ SUFF _ BASE ' , - , 57 ) ) , cf ( 1 , phi ( 56 , var ( 3 ) ) ) , cf ( 1 , subtree ( 55 , ' N _ SUFF _ BASE ' , - , 53 ) ) , cf ( 1 , phi ( 55 , var ( 3 ) ) ) , cf ( 1 , terminal ( 53 , ' + Erg ' , [ 42 ] ) ) , cf ( 1 , phi ( 53 , var ( 3 ) ) ) , cf ( 1 , subtree ( 51 , ' N _ SUFF _ BASE ' , - , 48 ) ) , cf ( 1 , phi ( 51 , var ( 3 ) ) ) , cf ( 1 , terminal ( 48 , ' + Sg ' , [ 42 ] ) ) , cf ( 1 , phi ( 48 , var ( 3 ) ) ) , cf ( 1 , subtree ( 46 , ' N _ SUFF _ BASE ' , - , 44 ) ) , cf ( 1 , phi ( 46 , var ( 3 ) ) ) , cf ( 1 , terminal ( 44 , ' + Full ' , [ 42 ] ) ) , cf ( 1 , phi ( 44 , var ( 3 ) ) ) , cf ( 1 , subtree ( 41 , ' N _ SUFF _ BASE ' , - , 39 ) ) , cf ( 1 , phi ( 41 , var ( 9 ) ) ) , cf ( 1 , terminal ( 39 , ' + Reduced ' , [ 12 ] ) ) , cf ( 1 , phi ( 39 , var ( 9 ) ) ) , cf ( 1 , subtree ( 37 , ' Acard _ BASE ' , - , 35 ) ) , cf ( 1 , phi ( 37 , var ( 9 ) ) ) , cf ( 1 , terminal ( 35 , '1' , [ 12 ] ) ) , cf ( 1 , phi ( 35 , var ( 9 ) ) ) , cf ( 1 , subtree ( 33 , ' CARD _ SUFF _ BASE ' , - , 32 ) ) , cf ( 1 , phi ( 33 , var ( 9 ) ) ) , cf ( 1 , terminal ( 32 , ' + Card ' , [ 12 ] ) ) , cf ( 1 , phi ( 32 , var ( 9 ) ) ) , cf ( 1 , subtree ( 30 , ' CARD _ SUFF _ BASE ' , - , 29 ) ) , cf ( 1 , phi ( 30 , var ( 9 ) ) ) , cf ( 1 , terminal ( 29 , ' + Alphabetic ' , [ 12 ] ) ) , cf ( 1 , phi ( 29 , var ( 9 ) ) ) , cf ( 1 , terminal ( 27 , ' + A ' , [ 12 ] ) ) , cf ( 1 , phi ( 27 , var ( 9 ) ) ) , cf ( 1 , subtree ( 26 , ' A _ SUFF _ BASE ' , - , 27 ) ) , cf ( 1 , phi ( 26 , var ( 9 ) ) ) , cf ( 1 , subtree ( 25 , ' N _ SUFF _ BASE ' , - , 23 ) ) , cf ( 1 , phi ( 25 , var ( 9 ) ) ) , cf ( 1 , terminal ( 23 , ' + Erg ' , [ 12 ] ) ) , cf ( 1 , phi ( 23 , var ( 9 ) ) ) , cf ( 1 , subtree ( 3 , ' ADVfocneg ' , - , 1 ) ) , cf ( 1 , phi ( 3 , var ( 5 ) ) ) , cf ( 1 , terminal ( 1 , ' arC ' , [ 1 ] ) ) , cf ( 1 , phi ( 1 , var ( 5 ) ) ) , cf ( 1 , semform_data ( 1 , 3 , 1 , 4 ) ) , cf ( 1 , semform_data ( 5 , 37 , 5 , 7 ) ) , cf ( 1 , semform_data ( 9 , 58 , 11 , 14 ) ) , cf ( 1 , semform_data ( 11 , 78 , 17 , 21 ) ) , cf ( 1 , fspan ( var ( 0 ) , 1 , 23 ) ) , cf ( 1 , fspan ( var ( 3 ) , 1 , 16 ) ) , cf ( 1 , fspan ( var ( 5 ) , 1 , 4 ) ) , cf ( 1 , fspan ( var ( 9 ) , 5 , 10 ) ) , cf ( 1 , surfaceform ( 1 , ' arC ' , 1 , 4 ) ) , cf ( 1 , surfaceform ( 12 , ' erTma ' , 5 , 10 ) ) , cf ( 1 , surfaceform ( 42 , ' katam ' , 11 , 16 ) ) , cf ( 1 , surfaceform ( 63 , ' iqePa ' , 17 , 22 ) ) , cf ( 1 , surfaceform ( 82 , ' . ' , 22 , 23 ) ) ] ) . </DOCUMENT>
<DOCUMENT_ID="mgood7123/UPM/tree/master/Files/Code/perl/lib/site_perl/5.26.1/auto/share/dist/DateTime-Locale/en-SG.pl"> { am_pm_abbreviated = > [ " AM " , " PM " ] , available_formats = > { E = > " ccc " , EHm = > " E ▁ HH : mm " , EHms = > " E ▁ HH : mm : ss " , Ed = > " E ▁ d " , Ehm = > " E ▁ h : mm ▁ a " , Ehms = > " E ▁ h : mm : ss ▁ a " , Gy = > " y ▁ G " , GyMMM = > " MMM ▁ y ▁ G " , GyMMMEd = > " E , ▁ d ▁ MMM ▁ y ▁ G " , GyMMMd = > " d ▁ MMM ▁ y ▁ G " , H = > " HH " , Hm = > " HH : mm " , Hms = > " HH : mm : ss " , Hmsv = > " HH : mm : ss ▁ v " , Hmv = > " HH : mm ▁ v " , M = > " L " , MEd = > " E , ▁ dd / MM " , MMM = > " LLL " , MMMEd = > " E , ▁ d ▁ MMM " , " MMMMW - count - one " = > " ' week ' ▁ W ▁ ' of ' ▁ MMMM " , " MMMMW - count - other " = > " ' week ' ▁ W ▁ ' of ' ▁ MMMM " , MMMMd = > " d ▁ MMMM " , MMMd = > " d ▁ MMM " , MMdd = > " dd / MM " , Md = > " dd / MM " , d = > " d " , h = > " h ▁ a " , hm = > " h : mm ▁ a " , hms = > " h : mm : ss ▁ a " , hmsv = > " h : mm : ss ▁ a ▁ v " , hmv = > " h : mm ▁ a ▁ v " , ms = > " mm : ss " , y = > " y " , yM = > " MM / y " , yMEd = > " E , ▁ dd / MM / y " , yMMM = > " MMM ▁ y " , yMMMEd = > " E , ▁ d ▁ MMM ▁ y " , yMMMM = > " MMMM ▁ y " , yMMMd = > " d ▁ MMM ▁ y " , yMd = > " dd / MM / y " , yQQQ = > " QQQ ▁ y " , yQQQQ = > " QQQQ ▁ y " , " yw - count - one " = > " ' week ' ▁ w ▁ ' of ' ▁ y " , " yw - count - other " = > " ' week ' ▁ w ▁ ' of ' ▁ y " } , code = > " en - SG " , date_format_full = > " EEEE , ▁ d ▁ MMMM ▁ y " , date_format_long = > " d ▁ MMMM ▁ y " , date_format_medium = > " d ▁ MMM ▁ y " , date_format_short = > " d / M / yy " , datetime_format_full = > " { 1 } ▁ ' at ' ▁ { 0 } " , datetime_format_long = > " { 1 } ▁ ' at ' ▁ { 0 } " , datetime_format_medium = > " { 1 } , ▁ { 0 } " , datetime_format_short = > " { 1 } , ▁ { 0 } " , day_format_abbreviated = > [ " Mon " , " Tue " , " Wed " , " Thu " , " Fri " , " Sat " , " Sun " ] , day_format_narrow = > [ " M " , " T " , " W " , " T " , " F " , " S " , " S " ] , day_format_wide = > [ " Monday " , " Tuesday " , " Wednesday " , " Thursday " , " Friday " , " Saturday " , " Sunday " ] , day_stand_alone_abbreviated = > [ " Mon " , " Tue " , " Wed " , " Thu " , " Fri " , " Sat " , " Sun " ] , day_stand_alone_narrow = > [ " M " , " T " , " W " , " T " , " F " , " S " , " S " ] , day_stand_alone_wide = > [ " Monday " , " Tuesday " , " Wednesday " , " Thursday " , " Friday " , " Saturday " , " Sunday " ] , era_abbreviated = > [ " BC " , " AD " ] , era_narrow = > [ " B " , " A " ] , era_wide = > [ " Before ▁ Christ " , " Anno ▁ Domini " ] , first_day_of_week = > 7 , glibc_date_1_format = > " % a ▁ % b ▁ % e ▁ % H : % M : % S ▁ % Z ▁ % Y " , glibc_date_format = > " % d / % m / % Y " , glibc_datetime_format = > " % a ▁ % d ▁ % b ▁ % Y ▁ % r " , glibc_time_12_format = > " % I : % M : % S ▁ % p " , glibc_time_format = > " % T " , language = > " English " , month_format_abbreviated = > [ " Jan " , " Feb " , " Mar " , " Apr " , " May " , " Jun " , " Jul " , " Aug " , " Sep " , " Oct " , " Nov " , " Dec " ] , month_format_narrow = > [ " J " , " F " , " M " , " A " , " M " , " J " , " J " , " A " , " S " , " O " , " N " , " D " ] , month_format_wide = > [ " January " , " February " , " March " , " April " , " May " , " June " , " July " , " August " , " September " , " October " , " November " , " December " ] , month_stand_alone_abbreviated = > [ " Jan " , " Feb " , " Mar " , " Apr " , " May " , " Jun " , " Jul " , " Aug " , " Sep " , " Oct " , " Nov " , " Dec " ] , month_stand_alone_narrow = > [ " J " , " F " , " M " , " A " , " M " , " J " , " J " , " A " , " S " , " O " , " N " , " D " ] , month_stand_alone_wide = > [ " January " , " February " , " March " , " April " , " May " , " June " , " July " , " August " , " September " , " October " , " November " , " December " ] , name = > " English ▁ Singapore " , native_language = > " English " , native_name = > " English ▁ Singapore " , native_script = > undef , native_territory = > " Singapore " , native_variant = > undef , quarter_format_abbreviated = > [ " Q1" , " Q2" , " Q3" , " Q4" ] , quarter_format_narrow = > [ 1 , 2 , 3 , 4 ] , quarter_format_wide = > [ "1st ▁ quarter " , "2nd ▁ quarter " , "3rd ▁ quarter " , "4th ▁ quarter " ] , quarter_stand_alone_abbreviated = > [ " Q1" , " Q2" , " Q3" , " Q4" ] , quarter_stand_alone_narrow = > [ 1 , 2 , 3 , 4 ] , quarter_stand_alone_wide = > [ "1st ▁ quarter " , "2nd ▁ quarter " , "3rd ▁ quarter " , "4th ▁ quarter " ] , script = > undef , territory = > " Singapore " , time_format_full = > " h : mm : ss ▁ a ▁ zzzz " , time_format_long = > " h : mm : ss ▁ a ▁ z " , time_format_medium = > " h : mm : ss ▁ a " , time_format_short = > " h : mm ▁ a " , variant = > undef , version = > 31 } </DOCUMENT>
<DOCUMENT_ID="zcop/lg_f160s_custom_kernel/tree/master/tools/perf/scripts/perl/workqueue-stats.pl"> # ! / usr / bin / perl ▁ - w ENDCOM # ▁ ( c ) ▁ 2009 , ▁ Tom ▁ Zanussi ▁ < tzanussi @ gmail . com > ENDCOM # ▁ Licensed ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ GPL ▁ License ▁ version ▁ 2 ENDCOM # ▁ Displays ▁ workqueue ▁ stats ENDCOM # ▁ Usage : ENDCOM # ▁ perf ▁ record ▁ - c ▁ 1 ▁ - f ▁ - a ▁ - R ▁ - e ▁ workqueue : workqueue _ creation ▁ - e ENDCOM # ▁ workqueue : workqueue _ destruction ▁ - e ▁ workqueue : workqueue _ execution ENDCOM # ▁ - e ▁ workqueue : workqueue _ insertion ENDCOM # ▁ perf ▁ script ▁ - p ▁ - s ▁ tools / perf / scripts / perl / workqueue - stats . pl ENDCOM use 5.010000 ; use strict ; use warnings ; use lib " $ ENV { ' PERF _ EXEC _ PATH ' } / scripts / perl / Perf - Trace - Util / lib " ; use lib " . / Perf - Trace - Util / lib " ; use Perf :: Trace :: Core ; use Perf :: Trace :: Util ; my @ cpus ; sub workqueue :: workqueue_destruction { my ( $event_name , $context , $common_cpu , $common_secs , $common_nsecs , $common_pid , $common_comm , $thread_comm , $thread_pid ) = @ _ ; $cpus [ $common_cpu ] { $thread_pid } { destroyed } ++ ; $cpus [ $common_cpu ] { $thread_pid } { comm } = $thread_comm ; } sub workqueue :: workqueue_creation { my ( $event_name , $context , $common_cpu , $common_secs , $common_nsecs , $common_pid , $common_comm , $thread_comm , $thread_pid , $cpu ) = @ _ ; $cpus [ $common_cpu ] { $thread_pid } { created } ++ ; $cpus [ $common_cpu ] { $thread_pid } { comm } = $thread_comm ; } sub workqueue :: workqueue_execution { my ( $event_name , $context , $common_cpu , $common_secs , $common_nsecs , $common_pid , $common_comm , $thread_comm , $thread_pid , $func ) = @ _ ; $cpus [ $common_cpu ] { $thread_pid } { executed } ++ ; $cpus [ $common_cpu ] { $thread_pid } { comm } = $thread_comm ; } sub workqueue :: workqueue_insertion { my ( $event_name , $context , $common_cpu , $common_secs , $common_nsecs , $common_pid , $common_comm , $thread_comm , $thread_pid , $func ) = @ _ ; $cpus [ $common_cpu ] { $thread_pid } { inserted } ++ ; $cpus [ $common_cpu ] { $thread_pid } { comm } = $thread_comm ; } sub trace_end { print " workqueue ▁ work ▁ stats : \n \n " ; my $cpu = 0 ; printf ( " % 3s ▁ % 6s ▁ % 6s\t % -20s \n " , " cpu " , " ins " , " exec " , " name " ) ; printf ( " % 3s ▁ % 6s ▁ % 6s\t % -20s \n " , " - - - " , " - - - " , " - - - - " , " - - - - " ) ; foreach my $pidhash ( @ cpus ) { while ( ( my $pid , my $wqhash ) = each % $pidhash ) { my $ins = $$wqhash { ' inserted ' } || 0 ; my $exe = $$wqhash { ' executed ' } || 0 ; my $comm = $$wqhash { ' comm ' } || " " ; if ( $ins || $exe ) { printf ( " % 3u ▁ % 6u ▁ % 6u\t % -20s \n " , $cpu , $ins , $exe , $comm ) ; } } $cpu ++ ; } $cpu = 0 ; print " \n workqueue ▁ lifecycle ▁ stats : \n \n " ; printf ( " % 3s ▁ % 6s ▁ % 6s\t % -20s \n " , " cpu " , " created " , " destroyed " , " name " ) ; printf ( " % 3s ▁ % 6s ▁ % 6s\t % -20s \n " , " - - - " , " - - - - - - - " , " - - - - - - - - - " , " - - - - " ) ; foreach my $pidhash ( @ cpus ) { while ( ( my $pid , my $wqhash ) = each % $pidhash ) { my $created = $$wqhash { ' created ' } || 0 ; my $destroyed = $$wqhash { ' destroyed ' } || 0 ; my $comm = $$wqhash { ' comm ' } || " " ; if ( $created || $destroyed ) { printf ( " % 3u ▁ % 6u ▁ % 6u\t % -20s \n " , $cpu , $created , $destroyed , $comm ) ; } } $cpu ++ ; } print_unhandled ( ) ; } my % unhandled ; sub print_unhandled { if ( ( scalar keys % unhandled ) == 0 ) { return ; } print " \n unhandled ▁ events : \n \n " ; printf ( " % -40s ▁ ▁ % 10s \n " , " event " , " count " ) ; printf ( " % -40s ▁ ▁ % 10s \n " , " - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - " , " - - - - - - - - - - - " ) ; foreach my $event_name ( keys % unhandled ) { printf ( " % -40s ▁ ▁ % 10d \n " , $event_name , $unhandled { $event_name } ) ; } } sub trace_unhandled { my ( $event_name , $context , $common_cpu , $common_secs , $common_nsecs , $common_pid , $common_comm ) = @ _ ; $unhandled { $event_name } ++ ; } </DOCUMENT>
<DOCUMENT_ID="davebx/tools-iuc/tree/master/tools/fasta_stats/fasta-stats.pl"> # ! / usr / bin / env ▁ perl ENDCOM # ▁ fasta - stats ENDCOM # ▁ written ▁ by ▁ torsten . seemann @ monash . edu ▁ ENDCOM # ▁ oct ▁ 2012 ENDCOM use strict ; use warnings ; use List :: Util qw ( sum min max ) ; # ▁ stat ▁ storage ENDCOM my $n = 0 ; my $seq = ' ' ; my % stat ; my @ len ; # ▁ MAIN ▁ LOOP ▁ collecting ▁ sequences ENDCOM while ( my $line = < ARGV > ) { chomp $line ; if ( $line = ~ m / ^ \ s * > / ) { process ( $seq ) if $n ; $n ++ ; $seq = ' ' ; } else { $seq . = $line ; } } process ( $seq ) if $n ; # ▁ sort ▁ length ▁ array ▁ ENDCOM # ▁ ( should ▁ use ▁ hash ▁ here ▁ for ▁ efficiency ▁ with ▁ huge ▁ no ▁ of ▁ short ▁ reads ? ) ENDCOM @ len = sort { $a <= > $b } @ len ; # ▁ compute ▁ more ▁ stats ENDCOM $stat { ' num _ seq ' } = scalar ( @ len ) ; if ( @ len ) { $stat { ' num _ bp ' } = sum ( @ len ) ; $stat { ' len _ min ' } = $len [ 0 ] ; $stat { ' len _ max ' } = $len [ - 1 ] ; $stat { ' len _ median ' } = $len [ int ( @ len / 2 ) ] ; $stat { ' len _ mean ' } = int ( $stat { ' num _ bp ' } / $stat { ' num _ seq ' } ) ; # ▁ calculate ▁ n50 ENDCOM $stat { ' len _ N50' } = 0 ; my $cum = 0 ; my $thresh = int 0.5 * $stat { ' num _ bp ' } ; for my $i ( 0 . . $ # len ) ▁ { ENDCOM $cum += $len [ $i ] ; if ( $cum >= $thresh ) { $stat { ' len _ N50' } = $len [ $i ] ; last ; } } } # calculate ▁ GC ▁ content ENDCOM $stat { ' num _ bp _ not _ N ' } = $stat { ' num _ G ' } + $stat { ' num _ C ' } + $stat { ' num _ A ' } + $stat { ' num _ T ' } ; $stat { ' GC _ content ' } = ( $stat { ' num _ G ' } + $stat { ' num _ C ' } ) / $stat { ' num _ bp _ not _ N ' } * 100 ; # ▁ print ▁ stats ▁ as ▁ . tsv ENDCOM for my $name ( sort keys % stat ) { if ( $name = ~ m / GC_content / ) { printf " % s\t % 0.1f \n " , $name , $stat { $name } ; } else { printf " % s\t % s \n " , $name , $stat { $name } ; } } # ▁ run ▁ for ▁ each ▁ sequence ENDCOM sub process { my ( $s ) = @ _ ; # ▁ base ▁ composition ENDCOM for my $x ( qw ( A G T C N ) ) { my $count = $s = ~ s / $x / $x / gi ; $stat { " num _ $ x " } += $count ; } # ▁ keep ▁ list ▁ of ▁ all ▁ lengths ▁ encountered ENDCOM push @ len , length ( $s ) ; } </DOCUMENT>
<DOCUMENT_ID="kthlnktng/Tn-Seq_pipeline/tree/master/parse_withinGenes_samestrand.pl"> # ! / usr / bin / perl ENDCOM use strict ; use warnings ; my $usage = " ▁ parse _ withinGenes . pl ▁ < * input _ withinGene _ file _ from _ bedtools _ intersect > ▁ STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ < * output _ BED _ file > STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ \n * = required ▁ " ; unless ( $ # ARGV ▁ = = ▁ 1 ) { die ▁ $ usage ; } ENDCOM open ( my $rdfl , " < " , " $ ARGV [ 0 ] " ) || die " you ▁ suck ▁ at ▁ opening ▁ reading ▁ FH : $ ! \n " ; open ( my $wrtfl , " > " , " $ ARGV [ 1 ] " ) || die " you ▁ suck ▁ at ▁ opening ▁ writing ▁ FH : $ ! \n " ; my % wInGeneAnnotation ; LINE : while ( my $line = < $rdfl > ) { chomp $line ; if ( $line = ~ m / ^ ( NC_01685 \ d \ . \ d \ t \ d + \ t \ d + \ t ( NC . * [ - + ] ) \ t \ d + \ t [ - + ] ) \ tNC . * \ tRefSeq \ t \ D \ D \ D \ D * \ t \ d + \ t \ d + . * \ t [ - + ] \ t . * \ ttranscript_id \ s " ( . * ) " ; \ sgene_id . * gene_name \ s " ( . * ) " ; / ) { if ( $wInGeneAnnotation { $2 } ) { my $prev_value = $wInGeneAnnotation { $2 } { $1 } ; my $new_value = $prev_value . " = " . $3 . " - " . $4 . " _ sameStrand " ; # ▁ my ▁ $ new _ value ▁ = ▁ $ prev _ value ▁ . " = " ▁ . ▁ $ 3 ▁ . ▁ " - " ▁ . ▁ $ 4 ▁ . ▁ " _ wrongStrand " ; ENDCOM $wInGeneAnnotation { $2 } { $1 } = $new_value ; } else { my $value = $3 . " - " . $4 . " _ sameStrand " ; # my ▁ $ value ▁ = ▁ $ 3 ▁ . ▁ " - " ▁ . ▁ $ 4 ▁ . ▁ " _ wrongStrand " ; ENDCOM $wInGeneAnnotation { $2 } { $1 } = $value ; } } else { print $line ; } } # ▁ while ▁ close ENDCOM foreach my $gene ( keys % wInGeneAnnotation ) { for my $annotation ( keys % { $wInGeneAnnotation { $gene } } ) { print $wrtfl " $ annotation\t $ wInGeneAnnotation { $ gene } { $ annotation } \n " ; } } close $rdfl ; close $wrtfl ; </DOCUMENT>
<DOCUMENT_ID="haldai/Logic-Vision/tree/master/src/src/MetagolD/polygons/raw/polygons_3_te_label.pl"> triangle ( pol_12 ) . triangle ( pol_17 ) . triangle ( pol_2 ) . triangle ( pol_7 ) . not_triangle ( pol_22 ) . not_triangle ( pol_27 ) . not_triangle ( pol_32 ) . not_triangle ( pol_37 ) . not_triangle ( pol_42 ) . not_triangle ( pol_47 ) . not_triangle ( pol_52 ) . not_triangle ( pol_57 ) . not_triangle ( pol_62 ) . not_triangle ( pol_67 ) . not_triangle ( pol_72 ) . not_triangle ( pol_77 ) . quadrangle ( pol_22 ) . quadrangle ( pol_27 ) . quadrangle ( pol_32 ) . quadrangle ( pol_37 ) . not_quadrangle ( pol_12 ) . not_quadrangle ( pol_17 ) . not_quadrangle ( pol_2 ) . not_quadrangle ( pol_42 ) . not_quadrangle ( pol_47 ) . not_quadrangle ( pol_52 ) . not_quadrangle ( pol_57 ) . not_quadrangle ( pol_62 ) . not_quadrangle ( pol_67 ) . not_quadrangle ( pol_7 ) . not_quadrangle ( pol_72 ) . not_quadrangle ( pol_77 ) . pentagon ( pol_42 ) . pentagon ( pol_47 ) . pentagon ( pol_52 ) . pentagon ( pol_57 ) . not_pentagon ( pol_12 ) . not_pentagon ( pol_17 ) . not_pentagon ( pol_2 ) . not_pentagon ( pol_22 ) . not_pentagon ( pol_27 ) . not_pentagon ( pol_32 ) . not_pentagon ( pol_37 ) . not_pentagon ( pol_62 ) . not_pentagon ( pol_67 ) . not_pentagon ( pol_7 ) . not_pentagon ( pol_72 ) . not_pentagon ( pol_77 ) . hexagon ( pol_62 ) . hexagon ( pol_67 ) . hexagon ( pol_72 ) . hexagon ( pol_77 ) . not_hexagon ( pol_12 ) . not_hexagon ( pol_17 ) . not_hexagon ( pol_2 ) . not_hexagon ( pol_22 ) . not_hexagon ( pol_27 ) . not_hexagon ( pol_32 ) . not_hexagon ( pol_37 ) . not_hexagon ( pol_42 ) . not_hexagon ( pol_47 ) . not_hexagon ( pol_52 ) . not_hexagon ( pol_57 ) . not_hexagon ( pol_7 ) . </DOCUMENT>
<DOCUMENT_ID="Bytewerk/uClinux-ipcam/tree/master/lib/lzo/util/notime.pl"> # ! ▁ / usr / bin / perl ENDCOM # # ▁ vi : ts = 4 ENDCOM # # ▁ Author : ENDCOM # # ▁ Markus ▁ F . X . J . ▁ Oberhumer ▁ < markus @ oberhumer . com > ENDCOM # # ▁ Description : ENDCOM # # ▁ Remove ▁ timing ▁ values ▁ from ▁ a ▁ table ▁ created ▁ by ▁ table . pl ENDCOM # # ▁ Copyright ▁ ( C ) ▁ 1996-2005 ▁ Markus ▁ Franz ▁ Xaver ▁ Johannes ▁ Oberhumer ENDCOM while ( < > ) { if ( substr ( $_ , 56 ) = ~ / ^ \ s + [ \ d \ . ] + \ s + [ \ d \ . ] + \ s + \ | \ s * \ n$ / ) { substr ( $_ , 56 ) = " ▁ ▁ ▁ ▁ ▁ 0.000 ▁ ▁ ▁ ▁ ▁ 0.000 ▁ | \n " ; } print ; } exit ( 0 ) ; </DOCUMENT>
<DOCUMENT_ID="friedrich420/Galaxy-S6-Edge-AEL-Kernel-G925F-/tree/master/scripts/namespace.pl"> # ! / usr / bin / perl ▁ - w ENDCOM # TABSYMBOL namespace . pl . ▁ Mon ▁ Aug ▁ 30 ▁ 2004 ENDCOM # TABSYMBOL Perform ▁ a ▁ name ▁ space ▁ analysis ▁ on ▁ the ▁ linux ▁ kernel . ENDCOM # TABSYMBOL Copyright ▁ Keith ▁ Owens ▁ < kaos @ ocs . com . au > . ▁ GPL . ENDCOM # TABSYMBOL Invoke ▁ by ▁ changing ▁ directory ▁ to ▁ the ▁ top ▁ of ▁ the ▁ kernel ▁ object ENDCOM # TABSYMBOL tree ▁ then ▁ namespace . pl , ▁ no ▁ parameters . ENDCOM # TABSYMBOL Tuned ▁ for ▁ 2.1 . x ▁ kernels ▁ with ▁ the ▁ new ▁ module ▁ handling , ▁ it ▁ will ENDCOM # TABSYMBOL work ▁ with ▁ 2.0 ▁ kernels ▁ as ▁ well . ENDCOM # TABSYMBOL Last ▁ change ▁ 2.6.9 - rc1 , ▁ adding ▁ support ▁ for ▁ separate ▁ source ▁ and ▁ object ENDCOM # TABSYMBOL trees . ENDCOM # TABSYMBOL The ▁ source ▁ must ▁ be ▁ compiled / assembled ▁ first , ▁ the ▁ object ▁ files ENDCOM # TABSYMBOL are ▁ the ▁ primary ▁ input ▁ to ▁ this ▁ script . ▁ Incomplete ▁ or ▁ missing ENDCOM # TABSYMBOL objects ▁ will ▁ result ▁ in ▁ a ▁ flawed ▁ analysis . ▁ Compile ▁ both ▁ vmlinux ENDCOM # TABSYMBOL and ▁ modules . ENDCOM # TABSYMBOL Even ▁ with ▁ complete ▁ objects , ▁ treat ▁ the ▁ result ▁ of ▁ the ▁ analysis ENDCOM # TABSYMBOL with ▁ caution . ▁ Some ▁ external ▁ references ▁ are ▁ only ▁ used ▁ by ENDCOM # TABSYMBOL certain ▁ architectures , ▁ others ▁ with ▁ certain ▁ combinations ▁ of ENDCOM # TABSYMBOL configuration ▁ parameters . ▁ Ideally ▁ the ▁ source ▁ should ▁ include ENDCOM # TABSYMBOL something ▁ like ENDCOM # TABSYMBOL # ifndef ▁ CONFIG _ . . . ENDCOM # TABSYMBOL static ENDCOM # TABSYMBOL # endif ENDCOM # TABSYMBOL symbol _ definition ; ENDCOM # TABSYMBOL so ▁ the ▁ symbols ▁ are ▁ defined ▁ as ▁ static ▁ unless ▁ a ▁ particular ENDCOM # TABSYMBOL CONFIG _ . . . ▁ requires ▁ it ▁ to ▁ be ▁ external . ENDCOM # TABSYMBOL A ▁ symbol ▁ that ▁ is ▁ suffixed ▁ with ▁ ' ( export ▁ only ) ' ▁ has ▁ these ▁ properties ENDCOM # TABSYMBOL * ▁ It ▁ is ▁ global . ENDCOM # TABSYMBOL * ▁ It ▁ is ▁ marked ▁ EXPORT _ SYMBOL ▁ or ▁ EXPORT _ SYMBOL _ GPL , ▁ either ▁ in ▁ the ▁ same ENDCOM # TABSYMBOL ▁ source ▁ file ▁ or ▁ a ▁ different ▁ source ▁ file . ENDCOM # TABSYMBOL * ▁ Given ▁ the ▁ current ▁ . config , ▁ nothing ▁ uses ▁ the ▁ symbol . ENDCOM # TABSYMBOL The ▁ symbol ▁ is ▁ a ▁ candidate ▁ for ▁ conversion ▁ to ▁ static , ▁ plus ▁ removal ▁ of ▁ the ENDCOM # TABSYMBOL export . ▁ But ▁ be ▁ careful ▁ that ▁ a ▁ different ▁ . config ▁ might ▁ use ▁ the ▁ symbol . ENDCOM # TABSYMBOL Name ▁ space ▁ analysis ▁ and ▁ cleanup ▁ is ▁ an ▁ iterative ▁ process . ▁ You ▁ cannot ENDCOM # TABSYMBOL expect ▁ to ▁ find ▁ all ▁ the ▁ problems ▁ in ▁ a ▁ single ▁ pass . ENDCOM # TABSYMBOL * ▁ Identify ▁ possibly ▁ unnecessary ▁ global ▁ declarations , ▁ verify ▁ that ▁ they ENDCOM # TABSYMBOL ▁ really ▁ are ▁ unnecessary ▁ and ▁ change ▁ them ▁ to ▁ static . ENDCOM # TABSYMBOL * ▁ Compile ▁ and ▁ fix ▁ up ▁ gcc ▁ warnings ▁ about ▁ static , ▁ removing ▁ dead ▁ symbols ENDCOM # TABSYMBOL ▁ as ▁ necessary . ENDCOM # TABSYMBOL * ▁ make ▁ clean ▁ and ▁ rebuild ▁ with ▁ different ▁ configs ▁ ( especially ENDCOM # TABSYMBOL ▁ CONFIG _ MODULES = n ) ▁ to ▁ see ▁ which ▁ symbols ▁ are ▁ being ▁ defined ▁ when ▁ the ENDCOM # TABSYMBOL ▁ config ▁ does ▁ not ▁ require ▁ them . ▁ These ▁ symbols ▁ bloat ▁ the ▁ kernel ▁ object ENDCOM # TABSYMBOL ▁ for ▁ no ▁ good ▁ reason , ▁ which ▁ is ▁ frustrating ▁ for ▁ embedded ▁ systems . ENDCOM # TABSYMBOL * ▁ Wrap ▁ config ▁ sensitive ▁ symbols ▁ in ▁ # ifdef ▁ CONFIG _ foo , ▁ as ▁ long ▁ as ▁ the ENDCOM # TABSYMBOL ▁ code ▁ does ▁ not ▁ get ▁ too ▁ ugly . ENDCOM # TABSYMBOL * ▁ Repeat ▁ the ▁ name ▁ space ▁ analysis ▁ until ▁ you ▁ can ▁ live ▁ with ▁ with ▁ the ENDCOM # TABSYMBOL ▁ result . ENDCOM require 5 ; # ▁ at ▁ least ▁ perl ▁ 5 ENDCOM use strict ; use File :: Find ; my $nm = ( $ENV { ' NM ' } || " nm " ) . " ▁ - p " ; my $objdump = ( $ENV { ' OBJDUMP ' } || " objdump " ) . " ▁ - s ▁ - j ▁ . comment " ; my $srctree = " " ; my $objtree = " " ; $srctree = " $ ENV { ' srctree ' } / " if ( exists ( $ENV { ' srctree ' } ) ) ; $objtree = " $ ENV { ' objtree ' } / " if ( exists ( $ENV { ' objtree ' } ) ) ; if ( $ # ARGV ▁ ! = ▁ - 1 ) ▁ { ENDCOM print STDERR " usage : ▁ $ 0 ▁ takes ▁ no ▁ parameters \n " ; die ( " giving ▁ up \n " ) ; } my % nmdata = ( ) ; # ▁ nm ▁ data ▁ for ▁ each ▁ object ENDCOM my % def = ( ) ; # ▁ all ▁ definitions ▁ for ▁ each ▁ name ENDCOM my % ksymtab = ( ) ; # ▁ names ▁ that ▁ appear ▁ in ▁ _ _ ksymtab _ ENDCOM my % ref = ( ) ; # ▁ $ ref { $ name } ▁ exists ▁ if ▁ there ▁ is ▁ a ▁ true ▁ external ▁ reference ▁ to ▁ $ name ENDCOM my % export = ( ) ; # ▁ $ export { $ name } ▁ exists ▁ if ▁ there ▁ is ▁ an ▁ EXPORT _ . . . ▁ of ▁ $ name ENDCOM my % nmexception = ( ' fs / ext3 / bitmap ' = > 1 , ' fs / ext4 / bitmap ' = > 1 , ' arch / x86 / lib / thunk _ 32' = > 1 , ' arch / x86 / lib / cmpxchg ' = > 1 , ' arch / x86 / vdso / vdso32 / note ' = > 1 , ' lib / irq _ regs ' = > 1 , ' usr / initramfs _ data ' = > 1 , ' drivers / scsi / aic94xx / aic94xx _ dump ' = > 1 , ' drivers / scsi / libsas / sas _ dump ' = > 1 , ' lib / dec _ and _ lock ' = > 1 , ' drivers / ide / ide - probe - mini ' = > 1 , ' usr / initramfs _ data ' = > 1 , ' drivers / acpi / acpia / exdump ' = > 1 , ' drivers / acpi / acpia / rsdump ' = > 1 , ' drivers / acpi / acpia / nsdumpdv ' = > 1 , ' drivers / acpi / acpia / nsdump ' = > 1 , ' arch / ia64 / sn / kernel / sn2 / io ' = > 1 , ' arch / ia64 / kernel / gate - data ' = > 1 , ' security / capability ' = > 1 , ' fs / ntfs / sysctl ' = > 1 , ' fs / jfs / jfs _ debug ' = > 1 , ) ; my % nameexception = ( ' mod _ use _ count _ ' = > 1 , ' _ _ initramfs _ end ' = > 1 , ' _ _ initramfs _ start ' = > 1 , ' _ einittext ' = > 1 , ' _ sinittext ' = > 1 , ' kallsyms _ names ' = > 1 , ' kallsyms _ num _ syms ' = > 1 , ' kallsyms _ addresses ' = > 1 , ' _ _ this _ module ' = > 1 , ' _ etext ' = > 1 , ' _ edata ' = > 1 , ' _ end ' = > 1 , ' _ _ bss _ start ' = > 1 , ' _ text ' = > 1 , ' _ stext ' = > 1 , ' _ _ gp ' = > 1 , ' ia64 _ unw _ start ' = > 1 , ' ia64 _ unw _ end ' = > 1 , ' _ _ init _ begin ' = > 1 , ' _ _ init _ end ' = > 1 , ' _ _ bss _ stop ' = > 1 , ' _ _ nosave _ begin ' = > 1 , ' _ _ nosave _ end ' = > 1 , ' pg0' = > 1 , ' vdso _ enabled ' = > 1 , ' _ _ stack _ chk _ fail ' = > 1 , ' VDSO32 _ PRELINK ' = > 1 , ' VDSO32 _ vsyscall ' = > 1 , ' VDSO32 _ rt _ sigreturn ' = > 1 , ' VDSO32 _ sigreturn ' = > 1 , ) ; & find ( \ & linux_objects , ' . ' ) ; # ▁ find ▁ the ▁ objects ▁ and ▁ do _ nm ▁ on ▁ them ENDCOM & list_multiply_defined ( ) ; & resolve_external_references ( ) ; & list_extra_externals ( ) ; exit ( 0 ) ; sub linux_objects { # ▁ Select ▁ objects , ▁ ignoring ▁ objects ▁ which ▁ are ▁ only ▁ created ▁ by ENDCOM # ▁ merging ▁ other ▁ objects . ▁ Also ▁ ignore ▁ all ▁ of ▁ modules , ▁ scripts ENDCOM # ▁ and ▁ compressed . ▁ Most ▁ conglomerate ▁ objects ▁ are ▁ handled ▁ by ▁ do _ nm , ENDCOM # ▁ this ▁ list ▁ only ▁ contains ▁ the ▁ special ▁ cases . ▁ These ▁ include ▁ objects ENDCOM # ▁ that ▁ are ▁ linked ▁ from ▁ just ▁ one ▁ other ▁ object ▁ and ▁ objects ▁ for ▁ which ENDCOM # ▁ there ▁ is ▁ really ▁ no ▁ permanent ▁ source ▁ file . ENDCOM my $basename = $_ ; $_ = $File :: Find :: name ; s : ^ \ . / :: ; if ( / . * \ . o$ / && ! ( m : / built - in . o$ : || m : arch / x86 / vdso / : || m : arch / x86 / boot / : || m : arch / ia64 / ia32 / ia32 . o$ : || m : arch / ia64 / kernel / gate - syms . o$ : || m : arch / ia64 / lib / __divdi3 . o$ : || m : arch / ia64 / lib / __divsi3 . o$ : || m : arch / ia64 / lib / __moddi3 . o$ : || m : arch / ia64 / lib / __modsi3 . o$ : || m : arch / ia64 / lib / __udivdi3 . o$ : || m : arch / ia64 / lib / __udivsi3 . o$ : || m : arch / ia64 / lib / __umoddi3 . o$ : || m : arch / ia64 / lib / __umodsi3 . o$ : || m : arch / ia64 / scripts / check_gas_for_hint . o$ : || m : arch / ia64 / sn / kernel / xp . o$ : || m : boot / bbootsect . o$ : || m : boot / bsetup . o$ : || m : / bootsect . o$ : || m : / boot / setup . o$ : || m : / compressed / : || m : drivers / cdrom / driver . o$ : || m : drivers / char / drm / tdfx_drv . o$ : || m : drivers / ide / ide - detect . o$ : || m : drivers / ide / pci / idedriver - pci . o$ : || m : drivers / media / media . o$ : || m : drivers / scsi / sd_mod . o$ : || m : drivers / video / video . o$ : || m : fs / devpts / devpts . o$ : || m : fs / exportfs / exportfs . o$ : || m : fs / hugetlbfs / hugetlbfs . o$ : || m : fs / msdos / msdos . o$ : || m : fs / nls / nls . o$ : || m : fs / ramfs / ramfs . o$ : || m : fs / romfs / romfs . o$ : || m : fs / vfat / vfat . o$ : || m : init / mounts . o$ : || m : ^ modules / : || m : net / netlink / netlink . o$ : || m : net / sched / sched . o$ : || m : / piggy . o$ : || m : ^ scripts / : || m : sound / . * / snd - : || m : ^ . * / \ . tmp_ : || m : ^ \ . tmp_ : || m : / vmlinux - obj . o$ : || m : ^ tools / : ) ) { do_nm ( $basename , $_ ) ; } $_ = $basename ; # ▁ File : : Find ▁ expects ▁ $ _ ▁ untouched ▁ ( undocumented ) ENDCOM } sub do_nm { my ( $basename , $fullname ) = @ _ ; my ( $source , $type , $name ) ; if ( ! - e $basename ) { printf STDERR " $ basename ▁ does ▁ not ▁ exist \n " ; return ; } if ( $fullname ! ~ / \ . o$ / ) { printf STDERR " $ fullname ▁ is ▁ not ▁ an ▁ object ▁ file \n " ; return ; } ( $source = $basename ) = ~ s / \ . o$ / / ; if ( - e " $ source . c " || - e " $ source . S " ) { $source = " $ objtree $ File : : Find : : dir / $ source " ; } else { $source = " $ srctree $ File : : Find : : dir / $ source " ; } if ( ! - e " $ source . c " && ! - e " $ source . S " ) { # ▁ No ▁ obvious ▁ source , ▁ exclude ▁ the ▁ object ▁ if ▁ it ▁ is ▁ conglomerate ENDCOM open ( my $objdumpdata , " $ objdump ▁ $ basename | " ) or die " $ objdump ▁ $ fullname ▁ failed ▁ $ ! \n " ; my $comment ; while ( < $objdumpdata > ) { chomp ( ) ; if ( / ^ In archive / ) { # ▁ Archives ▁ are ▁ always ▁ conglomerate ENDCOM $comment = " GCC : GCC : " ; last ; } next if ( ! / ^ [ 0 - 9 a - f ] { 5 , } / ) ; $comment . = substr ( $_ , 43 ) ; } close ( $objdumpdata ) ; if ( ! defined ( $comment ) || $comment ! ~ / GCC \ : . * GCC \ : / m ) { printf STDERR " No ▁ source ▁ file ▁ found ▁ for ▁ $ fullname \n " ; } return ; } open ( my $nmdata , " $ nm ▁ $ basename | " ) or die " $ nm ▁ $ fullname ▁ failed ▁ $ ! \n " ; my @ nmdata ; while ( < $nmdata > ) { chop ; ( $type , $name ) = ( split ( / + / , $_ , 3 ) ) [ 1. .2 ] ; # ▁ Expected ▁ types ENDCOM # ▁ A ▁ absolute ▁ symbol ENDCOM # ▁ B ▁ weak ▁ external ▁ reference ▁ to ▁ data ▁ that ▁ has ▁ been ▁ resolved ENDCOM # ▁ C ▁ global ▁ variable , ▁ uninitialised ENDCOM # ▁ D ▁ global ▁ variable , ▁ initialised ENDCOM # ▁ G ▁ global ▁ variable , ▁ initialised , ▁ small ▁ data ▁ section ENDCOM # ▁ R ▁ global ▁ array , ▁ initialised ENDCOM # ▁ S ▁ global ▁ variable , ▁ uninitialised , ▁ small ▁ bss ENDCOM # ▁ T ▁ global ▁ label / procedure ENDCOM # ▁ U ▁ external ▁ reference ENDCOM # ▁ W ▁ weak ▁ external ▁ reference ▁ to ▁ text ▁ that ▁ has ▁ been ▁ resolved ENDCOM # ▁ V ▁ similar ▁ to ▁ W , ▁ but ▁ the ▁ value ▁ of ▁ the ▁ weak ▁ symbol ▁ becomes ▁ zero ▁ with ▁ no ▁ error . ENDCOM # ▁ a ▁ assembler ▁ equate ENDCOM # ▁ b ▁ static ▁ variable , ▁ uninitialised ENDCOM # ▁ d ▁ static ▁ variable , ▁ initialised ENDCOM # ▁ g ▁ static ▁ variable , ▁ initialised , ▁ small ▁ data ▁ section ENDCOM # ▁ r ▁ static ▁ array , ▁ initialised ENDCOM # ▁ s ▁ static ▁ variable , ▁ uninitialised , ▁ small ▁ bss ENDCOM # ▁ t ▁ static ▁ label / procedures ENDCOM # ▁ w ▁ weak ▁ external ▁ reference ▁ to ▁ text ▁ that ▁ has ▁ not ▁ been ▁ resolved ENDCOM # ▁ v ▁ similar ▁ to ▁ w ENDCOM # ▁ ? ▁ undefined ▁ type , ▁ used ▁ a ▁ lot ▁ by ▁ modules ENDCOM if ( $type ! ~ / ^ [ ABCDGRSTUWVabdgrstwv ? ] $ / ) { printf STDERR " nm ▁ output ▁ for ▁ $ fullname ▁ contains ▁ unknown ▁ type ▁ ' $ _ ' \n " ; } elsif ( $name = ~ / \ . / ) { # ▁ name ▁ with ▁ ' . ' ▁ is ▁ local ▁ static ENDCOM } else { $type = ' R ' if ( $type eq ' ? ' ) ; # ▁ binutils ▁ replaced ▁ ? ▁ with ▁ R ▁ at ▁ one ▁ point ENDCOM # ▁ binutils ▁ keeps ▁ changing ▁ the ▁ type ▁ for ▁ exported ▁ symbols , ▁ force ▁ it ▁ to ▁ R ENDCOM $type = ' R ' if ( $name = ~ / ^ __ksymtab / || $name = ~ / ^ __kstrtab / ) ; $name = ~ s / _R [ a - f0 - 9 ] { 8 } $ / / ; # ▁ module ▁ versions ▁ adds ▁ this ENDCOM if ( $type = ~ / [ ABCDGRSTWV ] / && $name ne ' init _ module ' && $name ne ' cleanup _ module ' && $name ne ' Using _ Versions ' && $name ! ~ / ^ Version_ [ 0 - 9 ] + $ / && $name ! ~ / ^ __parm_ / && $name ! ~ / ^ __kstrtab / && $name ! ~ / ^ __ksymtab / && $name ! ~ / ^ __kcrctab_ / && $name ! ~ / ^ __exitcall_ / && $name ! ~ / ^ __initcall_ / && $name ! ~ / ^ __kdb_initcall_ / && $name ! ~ / ^ __kdb_exitcall_ / && $name ! ~ / ^ __module_ / && $name ! ~ / ^ __mod_ / && $name ! ~ / ^ __crc_ / && $name ne ' _ _ this _ module ' && $name ne ' kernel _ version ' ) { if ( ! exists ( $def { $name } ) ) { $def { $name } = [ ] ; } push ( @ { $def { $name } } , $fullname ) ; } push ( @ nmdata , " $ type ▁ $ name " ) ; if ( $name = ~ / ^ __ksymtab_ / ) { $name = substr ( $name , 10 ) ; if ( ! exists ( $ksymtab { $name } ) ) { $ksymtab { $name } = [ ] ; } push ( @ { $ksymtab { $name } } , $fullname ) ; } } } close ( $nmdata ) ; if ( $ # nmdata ▁ < ▁ 0 ) ▁ { ENDCOM printf " No ▁ nm ▁ data ▁ for ▁ $ fullname \n " unless $nmexception { $fullname } ; return ; } $nmdata { $fullname } = \ @ nmdata ; } sub drop_def { my ( $object , $name ) = @ _ ; my $nmdata = $nmdata { $object } ; my ( $i , $j ) ; for ( $i = 0 ; $i <= $ # { $ nmdata } ; ▁ + + $ i ) ▁ { ENDCOM if ( $name eq ( split ( ' ▁ ' , $nmdata -> [ $i ] , 2 ) ) [ 1 ] ) { splice ( @ { $nmdata { $object } } , $i , 1 ) ; my $def = $def { $name } ; for ( $j = 0 ; $j < $ # { $ def { $ name } } ; ▁ + + $ j ) ▁ { ENDCOM if ( $def { $name } [ $j ] eq $object ) { splice ( @ { $def { $name } } , $j , 1 ) ; } } last ; } } } sub list_multiply_defined { foreach my $name ( keys ( % def ) ) { if ( $ # { $ def { $ name } } ▁ > ▁ 0 ) ▁ { ENDCOM # ▁ Special ▁ case ▁ for ▁ cond _ syscall ENDCOM if ( $ # { $ def { $ name } } ▁ = = ▁ 1 ▁ & & ENDCOM ( $name = ~ / ^ sys_ / || $name = ~ / ^ compat_sys_ / || $name = ~ / ^ sys32_ / ) ) { if ( $def { $name } [ 0 ] eq " kernel / sys _ ni . o " || $def { $name } [ 1 ] eq " kernel / sys _ ni . o " ) { & drop_def ( " kernel / sys _ ni . o " , $name ) ; next ; } } printf " $ name ▁ is ▁ multiply ▁ defined ▁ in ▁ : - \n " ; foreach my $module ( @ { $def { $name } } ) { printf " \t $ module \n " ; } } } } sub resolve_external_references { my ( $kstrtab , $ksymtab , $export ) ; printf " \n " ; foreach my $object ( keys ( % nmdata ) ) { my $nmdata = $nmdata { $object } ; for ( my $i = 0 ; $i <= $ # { $ nmdata } ; ▁ + + $ i ) ▁ { ENDCOM my ( $type , $name ) = split ( ' ▁ ' , $nmdata -> [ $i ] , 2 ) ; if ( $type eq " U " || $type eq " w " ) { if ( exists ( $def { $name } ) || exists ( $ksymtab { $name } ) ) { # ▁ add ▁ the ▁ owning ▁ object ▁ to ▁ the ▁ nmdata ENDCOM $nmdata -> [ $i ] = " $ type ▁ $ name ▁ $ object " ; # ▁ only ▁ count ▁ as ▁ a ▁ reference ▁ if ▁ it ▁ is ▁ not ▁ EXPORT _ . . . ENDCOM $kstrtab = " R ▁ _ _ kstrtab _ $ name " ; $ksymtab = " R ▁ _ _ ksymtab _ $ name " ; $export = 0 ; for ( my $j = 0 ; $j <= $ # { $ nmdata } ; ▁ + + $ j ) ▁ { ENDCOM if ( $nmdata -> [ $j ] eq $kstrtab || $nmdata -> [ $j ] eq $ksymtab ) { $export = 1 ; last ; } } if ( $export ) { $export { $name } = " " ; } else { $ref { $name } = " " } } elsif ( ! $nameexception { $name } && $name ! ~ / ^ __sched_text_ / && $name ! ~ / ^ __start_ / && $name ! ~ / ^ __end_ / && $name ! ~ / ^ __stop_ / && $name ! ~ / ^ __scheduling_functions_ . * _here / && $name ! ~ / ^ __ . * initcall_ / && $name ! ~ / ^ __ . * per_cpu_start / && $name ! ~ / ^ __ . * per_cpu_end / && $name ! ~ / ^ __alt_instructions / && $name ! ~ / ^ __setup_ / && $name ! ~ / ^ __mod_timer / && $name ! ~ / ^ __mod_page_state / && $name ! ~ / ^ init_module / && $name ! ~ / ^ cleanup_module / ) { printf " Cannot ▁ resolve ▁ " ; printf " weak ▁ " if ( $type eq " w " ) ; printf " reference ▁ to ▁ $ name ▁ from ▁ $ object \n " ; } } } } } sub list_extra_externals { my % noref = ( ) ; foreach my $name ( keys ( % def ) ) { if ( ! exists ( $ref { $name } ) ) { my @ module = @ { $def { $name } } ; foreach my $module ( @ module ) { if ( ! exists ( $noref { $module } ) ) { $noref { $module } = [ ] ; } push ( @ { $noref { $module } } , $name ) ; } } } if ( % noref ) { printf " \n Externally ▁ defined ▁ symbols ▁ with ▁ no ▁ external ▁ references \n " ; foreach my $module ( sort ( keys ( % noref ) ) ) { printf " ▁ ▁ $ module \n " ; foreach ( sort ( @ { $noref { $module } } ) ) { my $export ; if ( exists ( $export { $_ } ) ) { $export = " ▁ ( export ▁ only ) " ; } else { $export = " " ; } printf " ▁ ▁ ▁ ▁ $ _ $ export \n " ; } } } } </DOCUMENT>
<DOCUMENT_ID="mrenvoize/Koha/tree/master/patroncards/manage.pl"> # ! / usr / bin / perl ENDCOM # ▁ Copyright ▁ 2006 ▁ Katipo ▁ Communications . ENDCOM # ▁ Parts ▁ Copyright ▁ 2009 ▁ Foundations ▁ Bible ▁ College . ENDCOM # ▁ This ▁ file ▁ is ▁ part ▁ of ▁ Koha . ENDCOM # ▁ Koha ▁ is ▁ free ▁ software ; ▁ you ▁ can ▁ redistribute ▁ it ▁ and / or ▁ modify ▁ it ENDCOM # ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ as ▁ published ▁ by ENDCOM # ▁ the ▁ Free ▁ Software ▁ Foundation ; ▁ either ▁ version ▁ 3 ▁ of ▁ the ▁ License , ▁ or ENDCOM # ▁ ( at ▁ your ▁ option ) ▁ any ▁ later ▁ version . ENDCOM # ▁ Koha ▁ is ▁ distributed ▁ in ▁ the ▁ hope ▁ that ▁ it ▁ will ▁ be ▁ useful , ▁ but ENDCOM # ▁ WITHOUT ▁ ANY ▁ WARRANTY ; ▁ without ▁ even ▁ the ▁ implied ▁ warranty ▁ of ENDCOM # ▁ MERCHANTABILITY ▁ or ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE . ▁ See ▁ the ENDCOM # ▁ GNU ▁ General ▁ Public ▁ License ▁ for ▁ more ▁ details . ENDCOM # ▁ You ▁ should ▁ have ▁ received ▁ a ▁ copy ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ENDCOM # ▁ along ▁ with ▁ Koha ; ▁ if ▁ not , ▁ see ▁ < http : / / www . gnu . org / licenses > . ENDCOM use Modern :: Perl ; use vars qw ( $debug ) ; use CGI qw ( - utf8 ) ; use autouse ' Data : : Dumper ' = > qw ( Dumper ) ; use C4 :: Auth qw ( get_template_and_user ) ; use C4 :: Output qw ( output_html_with_http_headers ) ; use C4 :: Creators ; use C4 :: Patroncards ; use C4 :: Labels ; use Koha :: List :: Patron ; my $cgi = CGI -> new ; my ( $template , $loggedinuser , $cookie ) = get_template_and_user ( { template_name = > " patroncards / manage . tt " , query = > $cgi , type = > " intranet " , flagsrequired = > { tools = > ' label _ creator ' } , debug = > 1 , } ) ; my $op = $cgi -> param ( ' op ' ) || ' none ' ; my $card_element = $cgi -> param ( ' card _ element ' ) || ' template ' ; # ▁ default ▁ to ▁ template ▁ management ENDCOM my $element_id = $cgi -> param ( ' element _ id ' ) || 0 ; # ▁ there ▁ should ▁ never ▁ be ▁ an ▁ element ▁ with ▁ a ▁ id ▁ of ▁ 0 ▁ so ▁ this ▁ is ▁ a ▁ safe ▁ default ENDCOM my $db_rows = { } ; my $display_columns = { layout = > [ # ▁ db ▁ column ▁ = > ▁ { col ▁ label ▁ is ▁ link ? ENDCOM { layout_id = > { label = > ' Layout ▁ ID ' , link_field = > 0 } } , { layout_name = > { label = > ' Layout ' , link_field = > 0 } } , { _action = > { label = > ' Action ' , link_field = > 0 } } , # { layout _ xml ▁ = > ▁ { label ▁ = > ▁ ' Layout ▁ XML ' , ▁ link _ field ▁ = > ▁ 0 } } , ENDCOM { select = > { label = > ' Select ' , value = > ' layout _ id ' } } , ] , template = > [ { template_id = > { label = > ' Template ▁ ID ' , link_field = > 0 } } , { template_code = > { label = > ' Template ▁ Name ' , link_field = > 0 } } , { template_desc = > { label = > ' Description ' , link_field = > 0 } } , { _action = > { label = > ' Action ' , link_field = > 0 } } , { select = > { label = > ' Select ' , value = > ' template _ id ' } } , ] , profile = > [ { profile_id = > { label = > ' Profile ▁ ID ' , link_field = > 0 } } , { printer_name = > { label = > ' Printer ▁ Name ' , link_field = > 0 } } , { paper_bin = > { label = > ' Paper ▁ Bin ' , link_field = > 0 } } , { _template_code = > { label = > ' Template ▁ Name ' , link_field = > 0 } } , # ▁ this ▁ display ▁ column ▁ does ▁ not ▁ have ▁ a ▁ corresponding ▁ db ▁ column ▁ in ▁ the ▁ profile ▁ table , ▁ hence ▁ the ▁ underscore ENDCOM { _action = > { label = > ' Action ' , link_field = > 0 } } , { select = > { label = > ' Select ' , value = > ' profile _ id ' } } , ] , batch = > [ { batch_id = > { label = > ' Batch ▁ ID ' , link_field = > 0 } } , { description = > { label = > ' Description ' , link_field = > 0 } } , { _item_count = > { label = > ' Patron ▁ Count ' , link_field = > 0 } } , { _action = > { label = > ' Actions ' , link_field = > 0 } } , { select = > { label = > ' Select ' , value = > ' batch _ id ' } } , ] , } ; my $errstr = ( $cgi -> param ( ' error ' ) ? $cgi -> param ( ' error ' ) : ' ' ) ; my $branch_code = ( $card_element eq ' batch ' ? C4 :: Context -> userenv -> { ' branch ' } : ' ' ) ; if ( $op eq ' delete ' ) { my $err = 0 ; my @ element_ids = split ( / , / , $element_id ) ; foreach my $element_id ( @ element_ids ) { if ( $card_element eq ' layout ' ) { $err = C4 :: Patroncards :: Layout :: delete ( layout_id = > $element_id ) ; } elsif ( $card_element eq ' template ' ) { $err = C4 :: Patroncards :: Template :: delete ( template_id = > $element_id ) ; } elsif ( $card_element eq ' profile ' ) { $err = C4 :: Patroncards :: Profile :: delete ( profile_id = > $element_id ) ; } elsif ( $card_element eq ' batch ' ) { $err = C4 :: Labels :: Batch :: delete ( batch_id = > $element_id , branch_code = > $branch_code ) ; } else { warn sprintf ( " Unknown ▁ card ▁ element ▁ passed ▁ in ▁ for ▁ delete ▁ operation : ▁ % s . " , $card_element ) ; $errstr = 202 ; } } print $cgi -> redirect ( " manage . pl ? card _ element = $ card _ element " . ( $err ? " & error = 102" : ' ' ) ) ; exit ; } elsif ( $op eq ' none ' ) { if ( $card_element eq ' layout ' ) { $db_rows = get_all_layouts ( { filters = > { creator = > ' Patroncards ' } } ) ; } elsif ( $card_element eq ' template ' ) { $db_rows = get_all_templates ( { filters = > { creator = > ' Patroncards ' } } ) ; } elsif ( $card_element eq ' profile ' ) { $db_rows = get_all_profiles ( { filters = > { creator = > ' Patroncards ' } } ) ; } elsif ( $card_element eq ' batch ' ) { $db_rows = get_batch_summary ( { filters = > { branch_code = > [ $branch_code , ' NB ' ] , creator = > ' Patroncards ' } } ) ; } else { warn sprintf ( " Unknown ▁ card ▁ element ▁ passed ▁ in : ▁ % s . " , $card_element ) ; $errstr = 202 ; } } else { # ▁ trap ▁ unsupported ▁ operations ▁ here ENDCOM warn sprintf ( ' Manage ▁ interface ▁ called ▁ an ▁ unsupported ▁ operation : ▁ % s ' , $op ) ; print $cgi -> redirect ( " manage . pl ? card _ element = $ card _ element & error = 201" ) ; exit ; } my $table = html_table ( $display_columns -> { $card_element } , $db_rows ) ; $template -> param ( print = > 1 ) if ( $card_element eq ' batch ' ) ; $template -> param ( patron_lists = > [ GetPatronLists ( ) ] ) if ( $card_element eq ' batch ' ) ; $template -> param ( error = > $errstr , ) ; $template -> param ( op = > $op , element_id = > $element_id , table_loop = > $table , card_element = > $card_element , card_element_title = > ( $card_element eq ' layout ' ? ' Layouts ' : $card_element eq ' template ' ? ' Templates ' : $card_element eq ' profile ' ? ' Profiles ' : $card_element eq ' batch ' ? ' Batches ' : ' ' ) , ) ; output_html_with_http_headers $cgi , $cookie , $template -> output ; </DOCUMENT>
<DOCUMENT_ID="SouthGreenPlatform/TOGGLE-DEV/tree/master/test/allTestPipeline.pl"> # ! / usr / bin / env ▁ perl ENDCOM # ▁ Copyright ▁ 2014-2018 ▁ IRD - CIRAD - INRA - ADNid ENDCOM # ▁ This ▁ program ▁ is ▁ free ▁ software ; ▁ you ▁ can ▁ redistribute ▁ it ▁ and / or ▁ modify ENDCOM # ▁ it ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ as ▁ published ▁ by ENDCOM # ▁ the ▁ Free ▁ Software ▁ Foundation ; ▁ either ▁ version ▁ 3 ▁ of ▁ the ▁ License , ▁ or ENDCOM # ▁ ( at ▁ your ▁ option ) ▁ any ▁ later ▁ version . ENDCOM # ▁ This ▁ program ▁ is ▁ distributed ▁ in ▁ the ▁ hope ▁ that ▁ it ▁ will ▁ be ▁ useful , ENDCOM # ▁ but ▁ WITHOUT ▁ ANY ▁ WARRANTY ; ▁ without ▁ even ▁ the ▁ implied ▁ warranty ▁ of ENDCOM # ▁ MERCHANTABILITY ▁ or ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE . ▁ See ▁ the ENDCOM # ▁ GNU ▁ General ▁ Public ▁ License ▁ for ▁ more ▁ details . ENDCOM # ▁ You ▁ should ▁ have ▁ received ▁ a ▁ copy ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ENDCOM # ▁ along ▁ with ▁ this ▁ program ; ▁ if ▁ not , ▁ see ▁ < http : / / www . gnu . org / licenses / > ▁ or ENDCOM # ▁ write ▁ to ▁ the ▁ Free ▁ Software ▁ Foundation , ▁ Inc . , ENDCOM # ▁ 51 ▁ Franklin ▁ Street , ▁ Fifth ▁ Floor , ▁ Boston , ENDCOM # ▁ MA ▁ 02110-1301 , ▁ USA . ENDCOM # ▁ You ▁ should ▁ have ▁ received ▁ a ▁ copy ▁ of ▁ the ▁ CeCILL - C ▁ license ▁ with ▁ this ▁ program . ENDCOM # If ▁ not ▁ see ▁ < http : / / www . cecill . info / licences / Licence _ CeCILL - C _ V1 - en . txt > ENDCOM # ▁ Intellectual ▁ property ▁ belongs ▁ to ▁ IRD , ▁ CIRAD ▁ and ▁ South ▁ Green ▁ developpement ▁ plateform ▁ for ▁ all ▁ versions ▁ also ▁ for ▁ ADNid ▁ for ▁ v2 ▁ and ▁ v3 ▁ and ▁ INRA ▁ for ▁ v3 ENDCOM # ▁ Version ▁ 1 ▁ written ▁ by ▁ Cecile ▁ Monat , ▁ Ayite ▁ Kougbeadjo , ▁ Christine ▁ Tranchant , ▁ Cedric ▁ Farcy , ▁ Mawusse ▁ Agbessi , ▁ Maryline ▁ Summo , ▁ and ▁ Francois ▁ Sabot ENDCOM # ▁ Version ▁ 2 ▁ written ▁ by ▁ Cecile ▁ Monat , ▁ Christine ▁ Tranchant , ▁ Cedric ▁ Farcy , ▁ Enrique ▁ Ortega - Abboud , ▁ Julie ▁ Orjuela - Bouniol , ▁ Sebastien ▁ Ravel , ▁ Souhila ▁ Amanzougarene , ▁ and ▁ Francois ▁ Sabot ENDCOM # ▁ Version ▁ 3 ▁ written ▁ by ▁ Cecile ▁ Monat , ▁ Christine ▁ Tranchant , ▁ Laura ▁ Helou , ▁ Abdoulaye ▁ Diallo , ▁ Julie ▁ Orjuela - Bouniol , ▁ Sebastien ▁ Ravel , ▁ Gautier ▁ Sarah , ▁ and ▁ Francois ▁ Sabot ENDCOM use strict ; use warnings ; use localConfig ; # # ▁ PIPELINE ▁ TEST ENDCOM print " \n \n # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # \n " ; print " # # # # ▁ PIPELINE ▁ TEST ▁ \n " ; print " # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # \n " ; system ( " perl ▁ $ toggle / test / pipelines / pairedOneIndividuArcad . pl " ) and warn " ERROR : ▁ $ 0 : ▁ Cannot ▁ run ▁ test ▁ for ▁ pairedOneIndividuArcad . pl ▁ ▁ \n $ ! \n " ; system ( " perl ▁ $ toggle / test / pipelines / pairedTwoIndividusGzippedIrigin . pl " ) and warn " ERROR : ▁ $ 0 : ▁ Cannot ▁ run ▁ test ▁ for ▁ pairedTwoIndividusGzippedIrigin . pl ▁ ▁ \n $ ! \n " ; system ( " perl ▁ $ toggle / test / pipelines / pairedTwoIndividusIrigin . pl " ) and warn " ERROR : ▁ $ 0 : ▁ Cannot ▁ run ▁ test ▁ for ▁ pairedTwoIndividusIrigin . pl ▁ ▁ \n $ ! \n " ; system ( " perl ▁ $ toggle / test / pipelines / pairedTwoIndividusIriginSGE . pl " ) and warn " ERROR : ▁ $ 0 : ▁ Cannot ▁ run ▁ test ▁ for ▁ pairedTwoIndividusIriginSGE . pl ▁ ▁ \n $ ! \n " ; system ( " perl ▁ $ toggle / test / pipelines / processRadtags . pl " ) and warn " ERROR : ▁ $ 0 : ▁ Cannot ▁ run ▁ test ▁ for ▁ processRadtags . pl ▁ ▁ \n $ ! \n " ; system ( " perl ▁ $ toggle / test / pipelines / rnaSeqPairedOneIndividu . pl " ) and warn " ERROR : ▁ $ 0 : ▁ Cannot ▁ run ▁ test ▁ for ▁ rnaSeqPairedOneIndividu . pl ▁ ▁ \n $ ! \n " ; system ( " perl ▁ $ toggle / test / pipelines / samBam . pl " ) and warn " ERROR : ▁ $ 0 : ▁ Cannot ▁ run ▁ test ▁ for ▁ samBam . pl ▁ ▁ \n $ ! \n " ; system ( " perl ▁ $ toggle / test / pipelines / singleOneIndividuIrigin . pl " ) and warn " ERROR : ▁ $ 0 : ▁ Cannot ▁ run ▁ test ▁ for ▁ singleOneIndividuIrigin . pl ▁ ▁ \n $ ! \n " ; system ( " perl ▁ $ toggle / test / pipelines / singleTwoIndividuIrigin . pl " ) and warn " ERROR : ▁ $ 0 : ▁ Cannot ▁ run ▁ test ▁ for ▁ singleTwoIndividuIrigin . pl ▁ ▁ \n $ ! \n " ; </DOCUMENT>
<DOCUMENT_ID="cristiana214/cristianachavez214-cristianachavez/tree/master/perl/src/ext/POSIX/hints/svr4.pl"> # ▁ For ▁ NCR ▁ MP - RAS ▁ systems ▁ with ▁ uname ▁ - a ▁ output ▁ like ▁ the ▁ following : ENDCOM # TABSYMBOL foo ▁ foo ▁ 4.0 ▁ 3.0 ▁ 3441 ▁ Pentium ▁ III ( TM ) - ISA / PCI ENDCOM # TABSYMBOL foo ▁ foo ▁ 4.0 ▁ 3.0 ▁ 4400 ▁ Pentium ▁ II ( TM ) - ISA / PCI ENDCOM # TABSYMBOL foo ▁ foo ▁ 4.2 ▁ 1.1.2 ▁ shg2 ▁ 386at ENDCOM # ▁ the ▁ system ▁ needs ▁ to ▁ explicitly ▁ link ▁ against ▁ - lmw ▁ to ▁ pull ▁ in ▁ some ENDCOM # ▁ symbols ▁ such ▁ as ▁ _ mwoflocheckl ▁ and ▁ possibly ▁ others . ENDCOM # ▁ For ▁ the ▁ first ▁ two , ▁ Configure ▁ sets ▁ archname = ' 3441 - svr4.0 ' ▁ or ▁ ' 4400 - svr4.0 ' . ENDCOM # ▁ The ▁ regex ▁ below ▁ is ▁ an ▁ attempt ▁ to ▁ get ▁ both ▁ systems ▁ as ▁ well ▁ as ENDCOM # ▁ any ▁ reasonable ▁ future ▁ permutations . ENDCOM # ▁ Thanks ▁ to ▁ Doug ▁ Hendricks ▁ for ▁ the ▁ original ▁ info . ENDCOM # ▁ ( See ▁ hints / svr4 . sh ▁ for ▁ more ▁ details . ) ENDCOM # TABSYMBOL A . ▁ Dougherty ▁ Tue ▁ Oct ▁ 30 ▁ 10:20:07 ▁ EST ▁ 2001 ENDCOM if ( $Config { ' archname ' } = ~ / [ 34 ] 4 [ 0 - 9 ] [ 0 - 9 ] - svr4 / ) { $self -> { LIBS } = [ ' - lm ▁ - posix ▁ - lcposix ▁ - lmw ' ] ; } # ▁ A ▁ better ▁ NCR ▁ MP - RAS ▁ test , ▁ thanks ▁ to ▁ W . ▁ Geoffrey ▁ Rommel , ▁ is ▁ to ENDCOM # ▁ look ▁ for ▁ / etc / issue ▁ and ▁ / etc / . relid . ▁ A . ▁ Dougherty , ▁ September ▁ 16 , ▁ 2003 ENDCOM elsif ( - e ' / etc / issue ' && - e ' / etc / . relid ' ) { $self -> { LIBS } = [ ' - lm ▁ - posix ▁ - lcposix ▁ - lmw ' ] ; } # ▁ Not ▁ sure ▁ what ▁ OS ▁ this ▁ one ▁ is . ENDCOM elsif ( $Config { archname } = ~ / RM \ d \ d \ d - svr4 / ) { $self -> { LIBS } = [ ' - lm ▁ - lc ▁ - lposix ▁ - lcposix ' ] ; } </DOCUMENT>
<DOCUMENT_ID="zhaochengw/ef40s_kernel-4.2/tree/master/scripts/headerdep.pl"> # ! ▁ / usr / bin / perl ENDCOM # ▁ Detect ▁ cycles ▁ in ▁ the ▁ header ▁ file ▁ dependency ▁ graph ENDCOM # ▁ Vegard ▁ Nossum ▁ < vegardno @ ifi . uio . no > ENDCOM use strict ; use warnings ; use Getopt :: Long ; my $opt_all ; my @ opt_include ; my $opt_graph ; & Getopt :: Long :: Configure ( qw ( bundling pass_through ) ) ; & GetOptions ( help = > \ & help , version = > \ & version , all = > \ $opt_all , " I = s " = > \ @ opt_include , graph = > \ $opt_graph , ) ; push @ opt_include , ' include ' ; my % deps = ( ) ; my % linenos = ( ) ; my @ headers = grep { strip ( $_ ) } @ ARGV ; parse_all ( @ headers ) ; if ( $opt_graph ) { graph ( ) ; } else { detect_cycles ( @ headers ) ; } sub help { print " Usage : ▁ $ 0 ▁ [ options ] ▁ file . . . \n " ; print " \n " ; print " Options : \n " ; print " ▁ ▁ - - all \n " ; print " ▁ ▁ - - graph \n " ; print " \n " ; print " ▁ ▁ - I ▁ includedir \n " ; print " \n " ; print " To ▁ make ▁ nice ▁ graphs , ▁ try : \n " ; print " ▁ ▁ $ 0 ▁ - - graph ▁ include / linux / kernel . h ▁ | ▁ dot ▁ - Tpng ▁ - o ▁ graph . png \n " ; exit ; } sub version { print " headerdep ▁ version ▁ 2 \n " ; exit ; } # ▁ Get ▁ a ▁ file ▁ name ▁ that ▁ is ▁ relative ▁ to ▁ our ▁ include ▁ paths ENDCOM sub strip { my $filename = shift ; for my $i ( @ opt_include ) { my $stripped = $filename ; $stripped = ~ s / ^ $i \ / / / ; return $stripped if $stripped ne $filename ; } return $filename ; } # ▁ Search ▁ for ▁ the ▁ file ▁ name ▁ in ▁ the ▁ list ▁ of ▁ include ▁ paths ENDCOM sub search { my $filename = shift ; return $filename if - f $filename ; for my $i ( @ opt_include ) { my $path = " $ i / $ filename " ; return $path if - f $path ; } return ; } sub parse_all { # ▁ Parse ▁ all ▁ the ▁ headers . ENDCOM my @ queue = @ _ ; while ( @ queue ) { my $header = pop @ queue ; next if exists $deps { $header } ; $deps { $header } = [ ] unless exists $deps { $header } ; my $path = search ( $header ) ; next unless $path ; open ( my $file , ' < ' , $path ) or die ( $ ! ) ; chomp ( my @ lines = < $file > ) ; close ( $file ) ; for my $i ( 0 . . $ # lines ) ▁ { ENDCOM my $line = $lines [ $i ] ; if ( my ( $dep ) = ( $line = ~ m / ^ # \s * include\s * < ( . * ? ) > / ) ) ▁ { ENDCOM push @ queue , $dep ; push @ { $deps { $header } } , [ $i + 1 , $dep ] ; } } } } sub print_cycle { # ▁ $ cycle [ n ] ▁ includes ▁ $ cycle [ n ▁ + ▁ 1 ] ; ENDCOM # ▁ $ cycle [ -1 ] ▁ will ▁ be ▁ the ▁ culprit ENDCOM my $cycle = shift ; # ▁ Adjust ▁ the ▁ line ▁ numbers ENDCOM for my $i ( 0 . . $ # $ cycle ▁ - ▁ 1 ) ▁ { ENDCOM $cycle -> [ $i ] -> [ 0 ] = $cycle -> [ $i + 1 ] -> [ 0 ] ; } $cycle -> [ - 1 ] -> [ 0 ] = 0 ; my $first = shift @ $cycle ; my $last = pop @ $cycle ; my $msg = " In ▁ file ▁ included " ; printf " % s ▁ from ▁ % s , \n " , $msg , $last -> [ 1 ] if defined $last ; for my $header ( reverse @ $cycle ) { printf " % s ▁ from ▁ % s : % d % s \n " , " ▁ " x length $msg , $header -> [ 1 ] , $header -> [ 0 ] , $header -> [ 1 ] eq $last -> [ 1 ] ? ' ▁ < - - ▁ here ' : ' ' ; } printf " % s : % d : ▁ warning : ▁ recursive ▁ header ▁ inclusion \n " , $first -> [ 1 ] , $first -> [ 0 ] ; } # ▁ Find ▁ and ▁ print ▁ the ▁ smallest ▁ cycle ▁ starting ▁ in ▁ the ▁ specified ▁ node . ENDCOM sub detect_cycles { my @ queue = map { [ [ 0 , $_ ] ] } @ _ ; while ( @ queue ) { my $top = pop @ queue ; my $name = $top -> [ - 1 ] -> [ 1 ] ; for my $dep ( @ { $deps { $name } } ) { my $chain = [ @ $top , [ $dep -> [ 0 ] , $dep -> [ 1 ] ] ] ; # ▁ If ▁ the ▁ dep ▁ already ▁ exists ▁ in ▁ the ▁ chain , ▁ we ▁ have ▁ a ENDCOM # ▁ cycle . . . ENDCOM if ( grep { $_ -> [ 1 ] eq $dep -> [ 1 ] } @ $top ) { print_cycle ( $chain ) ; next if $opt_all ; return ; } push @ queue , $chain ; } } } sub mangle { $_ = shift ; s / \ / / __ / g ; s / \ . / _ / g ; s / - / _ / g ; $_ ; } # ▁ Output ▁ dependency ▁ graph ▁ in ▁ GraphViz ▁ language . ENDCOM sub graph { print " digraph ▁ { \n " ; print " \t / * ▁ vertices ▁ * / \n " ; for my $header ( keys % deps ) { printf " \t % s ▁ [ label = \ " % s\ " ] ; \n " , mangle ( $header ) , $header ; } print " \n " ; print " \t / * ▁ edges ▁ * / \n " ; for my $header ( keys % deps ) { for my $dep ( @ { $deps { $header } } ) { printf " \t % s ▁ - > ▁ % s ; \n " , mangle ( $header ) , mangle ( $dep -> [ 1 ] ) ; } } print " } \n " ; } </DOCUMENT>
<DOCUMENT_ID="keishi/chromium/tree/master/third_party/talloc/script/mksigs.pl"> # ! / usr / bin / perl ENDCOM # ▁ mksigs . pl ▁ - ▁ extract ▁ signatures ▁ from ▁ C ▁ headers ENDCOM # ▁ Copyright ▁ ( C ) ▁ Michael ▁ Adam ▁ 2009 ENDCOM # ▁ This ▁ program ▁ is ▁ free ▁ software ; ▁ you ▁ can ▁ redistribute ▁ it ▁ and / or ▁ modify ▁ it ENDCOM # ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ as ▁ published ▁ by ▁ the ▁ Free ENDCOM # ▁ Software ▁ Foundation ; ▁ either ▁ version ▁ 3 ▁ of ▁ the ▁ License , ▁ or ▁ ( at ▁ your ▁ option ) ENDCOM # ▁ any ▁ later ▁ version . ENDCOM # ▁ This ▁ program ▁ is ▁ distributed ▁ in ▁ the ▁ hope ▁ that ▁ it ▁ will ▁ be ▁ useful , ▁ but ▁ WITHOUT ENDCOM # ▁ ANY ▁ WARRANTY ; ▁ without ▁ even ▁ the ▁ implied ▁ warranty ▁ of ▁ MERCHANTABILITY ▁ or ENDCOM # ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE . ▁ See ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ for ENDCOM # ▁ more ▁ details . ENDCOM # ▁ You ▁ should ▁ have ▁ received ▁ a ▁ copy ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ along ▁ with ENDCOM # ▁ this ▁ program ; ▁ if ▁ not , ▁ see ▁ < http : / / www . gnu . org / licenses / > . ENDCOM # ▁ USAGE : ▁ cat ▁ $ header _ files ▁ | ▁ mksigs . pl ▁ > ▁ $ signature _ file ENDCOM # ▁ The ▁ header ▁ files ▁ to ▁ parse ▁ are ▁ read ▁ from ▁ stdin . ENDCOM # ▁ The ▁ output ▁ is ▁ in ▁ a ▁ form ▁ as ▁ produced ▁ by ▁ gcc ▁ with ▁ the ▁ - aux - info ▁ switch ENDCOM # ▁ and ▁ printed ▁ to ▁ stdout . ENDCOM use strict ; use warnings ; my $in_comment = 0 ; my $extern_C_block = 0 ; while ( my $LINE = < > ) { # ▁ find ▁ end ▁ of ▁ started ▁ multi - line - comment ENDCOM if ( $in_comment ) { if ( $LINE = ~ / ^ . * ? \ * \ / ( . * ) $ / ) { $LINE = $1 ; $in_comment = 0 ; } else { # ▁ whole ▁ line ▁ within ▁ comment ENDCOM next ; } } # ▁ strip ▁ C + + - style ▁ comments ENDCOM $LINE = ~ s / ^ ( . * ? ) \ / \ / . * $ / $1 / ; # ▁ strip ▁ in - line - comments : ENDCOM while ( $LINE = ~ / \ / \ * . * ? \ * \ / / ) { $LINE = ~ s / \ / \ * . * ? \ * \ / / / ; } # ▁ find ▁ starts ▁ of ▁ multi - line - comments ENDCOM if ( $LINE = ~ / ^ ( . * ) \ / \ * / ) { $in_comment = 1 ; $LINE = $1 ; } # ▁ skip ▁ empty ▁ lines ENDCOM next if $LINE = ~ / ^ \ s * $ / ; # ▁ remove ▁ leading ▁ spaces ENDCOM $LINE = ~ s / ^ \ s * ( . * ) $ / $1 / ; # ▁ concatenate ▁ lines ▁ split ▁ with ▁ " \ " ▁ ( usually ▁ macro ▁ defines ) ENDCOM while ( $LINE = ~ / ^ ( . * ? ) \ s + \ \ $ / ) { my $LINE2 = < > ; $LINE = $1 ; $LINE2 = ~ s / ^ \ s * ( . * ) $ / $1 / ; $LINE . = " ▁ " . $LINE2 ; } # ▁ remove ▁ all ▁ preprocessor ▁ directives ENDCOM next if ( $LINE = ~ / ^ if ( $LINE = ~ / ^ extern \ s + " C " \ s + \ { / ) { $extern_C_block = 1 ; next ; } if ( ( $LINE = ~ / ^ [ ^ \ { ] * \ } / ) and $extern_C_block ) { $extern_C_block = 0 ; next ; } $LINE = ~ s / ^ extern \ s / / ; # ▁ concatenate ▁ braces ▁ stretched ▁ over ▁ multiple ▁ lines ENDCOM # ▁ ( from ▁ structs ▁ or ▁ enums ) ENDCOM my $REST = $LINE ; my $braces = 0 ; while ( ( $REST = ~ / [ \ { \ } ] / ) or ( $braces ) ) { while ( $REST = ~ / [ \ { \ } ] / ) { # ▁ collect ▁ opening ENDCOM while ( $REST = ~ / ^ [ ^ \ { \ } ] * \ { ( . * ) $ / ) { $braces ++ ; $REST = $1 ; } # ▁ collect ▁ closing ENDCOM while ( $REST = ~ / ^ [ ^ \ { \ } ] * \ } ( . * ) $ / ) { $braces -- ; $REST = $1 ; } } # ▁ concatenate ▁ if ▁ not ▁ balanced ENDCOM if ( $braces ) { if ( my $LINE2 = < > ) { $LINE2 = ~ s / ^ \ s * ( . * ) $ / $1 / ; chomp ( $LINE ) ; $LINE . = " ▁ " . $LINE2 ; chomp $REST ; $REST . = " ▁ " . $LINE2 ; } else { print " ERROR : ▁ unbalanced ▁ braces ▁ ( $ braces ) \n " ; last ; } } } # ▁ concetenate ▁ function ▁ prototypes ▁ that ▁ stretch ▁ over ▁ multiple ▁ lines ENDCOM $REST = $LINE ; my $parenthesis = 0 ; while ( ( $REST = ~ / [ \ ( \ ) ] / ) or ( $parenthesis ) ) { while ( $REST = ~ / [ \ ( \ ) ] / ) { # ▁ collect ▁ opening ENDCOM while ( $REST = ~ / ^ [ ^ \ ( \ ) ] * \ ( ( . * ) $ / ) { $parenthesis ++ ; $REST = $1 ; } # ▁ collect ▁ closing ENDCOM while ( $REST = ~ / ^ [ ^ \ ( \ ) ] * \ ) ( . * ) $ / ) { $parenthesis -- ; $REST = $1 ; } } # ▁ concatenate ▁ if ▁ not ▁ balanced ENDCOM if ( $parenthesis ) { if ( my $LINE2 = < > ) { $LINE2 = ~ s / ^ \ s * ( . * ) $ / $1 / ; chomp ( $LINE ) ; $LINE . = " ▁ " . $LINE2 ; chomp ( $REST ) ; $REST . = " ▁ " . $LINE2 ; } else { print " ERROR : ▁ unbalanced ▁ parantheses ▁ ( $ parenthesis ) \n " ; last ; } } } next if ( $LINE = ~ / ^ typedef \ s / ) ; next if ( $LINE = ~ / ^ enum \ s + [ ^ \ { \ ( ] + \ s + \ { / ) ; next if ( $LINE = ~ / ^ struct \ s + [ ^ \ { \ ( ] + \ s + \ { . * \ } \ s * ; / ) ; next if ( $LINE = ~ / ^ struct \ s + [ a - zA - Z0 - 9 _ ] + \ s * ; / ) ; # ▁ remove ▁ trailing ▁ spaces ENDCOM $LINE = ~ s / ( . * ? ) \ s * $ / $1 / ; $LINE = ~ s / ^ ( . * \ ) ) \ s + PRINTF_ATTRIBUTE \ ( [ ^ \ ) ] * \ ) ( \ s * [ ; , ] ) / $1$2 / ; $LINE = ~ s / ^ ( . * \ ) ) \ s * [ a - zA - Z0 - 9 _ ] + \ s * ; $ / $1 ; / ; # ▁ remove ▁ parameter ▁ names ▁ - ▁ slightly ▁ too ▁ coarse ▁ probably ENDCOM $LINE = ~ s / ( [ \ s \ ( ] \ * ? ) [ _0 - 9 a - zA - Z ] + \ s * ( [ , \ ) ] ) / $1$2 / g ; # ▁ remedy ▁ ( void ) ▁ from ▁ last ▁ line ENDCOM $LINE = ~ s / \ ( \ ) / ( void ) / g ; # ▁ normalize ▁ spaces ENDCOM $LINE = ~ s / \ s * \ ) \ s * / ) / g ; $LINE = ~ s / \ s * \ ( \ s * / ( / g ; $LINE = ~ s / \ s * , \ s * / , / g ; # ▁ normalize ▁ unsigned ENDCOM $LINE = ~ s / ( [ \ s , \ ( ] ) unsigned ( [ , \ ) ] ) / $1unsigned int$2 / g ; # ▁ normalize ▁ bool ENDCOM $LINE = ~ s / ( \ b ) bool ( \ b ) / _Bool / g ; print $LINE . " \n " ; } </DOCUMENT>
<DOCUMENT_ID="vincentchen/lede/tree/master/scripts/flashing/adam2flash.pl"> # ! / usr / bin / env ▁ perl ENDCOM # ▁ D - Link ▁ DSL - G6x4T ▁ flash ▁ utility ENDCOM # ▁ Copyright ▁ ( C ) ▁ 2005 ▁ Felix ▁ Fietkau ▁ < mailto @ nbd . name > ENDCOM # ▁ based ▁ on ▁ fbox ▁ recovery ▁ util ▁ by ▁ Enrik ▁ Berkhan ENDCOM # ▁ This ▁ program ▁ is ▁ free ▁ software ; ▁ you ▁ can ▁ redistribute ▁ it ▁ and / or ▁ modify ENDCOM # ▁ it ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ as ▁ published ▁ by ENDCOM # ▁ the ▁ Free ▁ Software ▁ Foundation ; ▁ either ▁ version ▁ 2 ▁ of ▁ the ▁ License , ▁ or ENDCOM # ▁ ( at ▁ your ▁ option ) ▁ any ▁ later ▁ version . ENDCOM # ▁ This ▁ program ▁ is ▁ distributed ▁ in ▁ the ▁ hope ▁ that ▁ it ▁ will ▁ be ▁ useful , ENDCOM # ▁ but ▁ WITHOUT ▁ ANY ▁ WARRANTY ; ▁ without ▁ even ▁ the ▁ implied ▁ warranty ▁ of ENDCOM # ▁ MERCHANTABILITY ▁ or ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE . ▁ See ▁ the ENDCOM # ▁ GNU ▁ General ▁ Public ▁ License ▁ for ▁ more ▁ details . ENDCOM # ▁ You ▁ should ▁ have ▁ received ▁ a ▁ copy ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ENDCOM # ▁ along ▁ with ▁ this ▁ program ; ▁ if ▁ not , ▁ write ▁ to ▁ the ▁ Free ▁ Software ENDCOM # ▁ Foundation , ▁ Inc . , ▁ 59 ▁ Temple ▁ Place , ▁ Suite ▁ 330 , ▁ Boston , ▁ MA ▁ 02111-1307 ▁ USA ENDCOM use IO :: Socket :: INET ; use Socket ; use strict ; use warnings ; sub usage ( ) { print STDERR " Usage : ▁ $ 0 ▁ < ip > ▁ [ firmware . bin ] \n \n " ; exit 0 ; } my $ip = shift @ ARGV ; $ip and $ip = ~ / \ d { 1 , 3 } \ . \ d { 1 , 3 } \ . \ d { 1 , 3 } \ . \ d { 1 , 3 } / or usage ( ) ; my $probe = IO :: Socket :: INET -> new ( Proto = > ' udp ' , Broadcast = > 1 , LocalPort = > 5035 ) or die " socket : ▁ $ ! " ; my $setip = unpack ( " N " , inet_aton ( $ip ) ) ; $setip > 0 or usage ( ) ; my @ packets ; foreach my $ver ( [ 18 , 1 ] , [ 22 , 2 ] ) { push @ packets , pack ( " vCCVNV " , 0 , @ $ver , 1 , $setip , 0 ) ; } print STDERR " Looking ▁ for ▁ device : ▁ " ; my $broadcast = sockaddr_in ( 5035 , INADDR_BROADCAST ) ; my $scanning ; my $box ; $SIG { " ALRM " } = sub { return if -- $scanning <= 0 ; foreach my $packet ( @ packets ) { $probe -> send ( $packet , 0 , $broadcast ) ; } print STDERR " . " ; } ; $scanning = 10 ; foreach my $packet ( @ packets ) { $probe -> send ( $packet , 0 , $broadcast ) ; } print STDERR " . " ; while ( $scanning ) { my $reply ; alarm ( 1 ) ; if ( my $peer = $probe -> recv ( $reply , 16 ) ) { next if ( length ( $reply ) < 16 ) ; my ( $port , $addr ) = sockaddr_in ( $peer ) ; my ( $major , $minor1 , $minor2 , $code , $addr2 ) = unpack ( " vCCVV " , $reply ) ; $addr2 = pack ( " N " , $addr2 ) ; if ( $code == 2 ) { $scanning = 0 ; printf STDERR " ▁ found ! \n ADAM2 ▁ version ▁ $ major . $ minor1 . $ minor2 ▁ at ▁ % s ▁ ( % s ) \n " , inet_ntoa ( $addr ) , inet_ntoa ( $addr2 ) ; $box = inet_ntoa ( $addr ) ; } } } $box or die " ▁ not ▁ found ! \n " ; { package ADAM2FTP ; use base qw ( Net :: FTP ) ; # ▁ ADAM2 ▁ requires ▁ upper ▁ case ▁ commands , ▁ some ▁ brain ▁ dead ▁ firewall ▁ doesn ' t ▁ ; - ) ENDCOM sub _USER { shift -> command ( " USER " , @ _ ) -> response ( ) } sub _GETENV { my $ftp = shift ; my ( $ok , $name , $value ) ; $ftp -> command ( " GETENV " , @ _ ) ; while ( length ( $ok = $ftp -> response ( ) ) < 1 ) { my $line = $ftp -> getline ( ) ; unless ( defined ( $value ) ) { chomp ( $line ) ; ( $name , $value ) = split ( / \ s + / , $line , 2 ) ; } } $ftp -> debug_print ( 0 , " getenv : ▁ $ value \n " ) if $ftp -> debug ( ) ; return $value ; } sub getenv { my $ftp = shift ; my $name = shift ; return $ftp -> _GETENV ( $name ) ; } sub _REBOOT { shift -> command ( " REBOOT " ) -> response ( ) == Net :: FTP :: CMD_OK } sub reboot { my $ftp = shift ; $ftp -> _REBOOT ; $ftp -> close ; } } my $file = shift @ ARGV ; $file || exit 0 ; open FILE , " < $ file " or die " can ' t ▁ open ▁ firmware ▁ file \n " ; my $ftp = ADAM2FTP -> new ( $box , Debug = > 0 , Timeout = > 600 ) or die " can ' t ▁ open ▁ control ▁ connection \n " ; $ftp -> login ( " adam2" , " adam2" ) or die " can ' t ▁ login \n " ; my $mtd0 = $ftp -> getenv ( " mtd0" ) ; my $mtd1 = $ftp -> getenv ( " mtd1" ) ; my ( $ksize , $fssize ) ; $mtd1 = ~ / ^ ( 0x \ w + ) , ( 0x \ w + ) $ / and $ksize = hex ( $2 ) - hex ( $1 ) ; $mtd0 = ~ / ^ ( 0x \ w + ) , ( 0x \ w + ) $ / and $fssize = hex ( $2 ) - hex ( $1 ) ; $ksize and $fssize or die ' cannot ▁ read ▁ partition ▁ offsets ' ; printf STDERR " Available ▁ flash ▁ space : ▁ 0x % 08x ▁ ( 0x % 08x ▁ + ▁ 0x % 08x ) \n " , $ksize + $fssize , $ksize , $fssize ; $ftp -> command ( " MEDIA ▁ FLSH " ) -> response ( ) ; $ftp -> binary ( ) ; print STDERR " Writing ▁ to ▁ mtd1 . . . \n " ; my $dc = $ftp -> stor ( " fs ▁ mtd1" ) ; $dc or die " can ' t ▁ open ▁ data ▁ connection \n " ; my $rbytes = 1 ; while ( ( $ksize > 0 ) and ( $rbytes > 0 ) ) { my $buffer ; my $len = ( $ksize > 1024 ? 1024 : $ksize ) ; $rbytes = read FILE , $buffer , $len ; $rbytes and $ksize -= $dc -> write ( $buffer , $rbytes , 600 ) ; } $dc -> close ( ) ; $rbytes or die " no ▁ more ▁ data ▁ left ▁ to ▁ write \n " ; print STDERR " Writing ▁ to ▁ mtd0 . . . \n " ; $dc = $ftp -> stor ( " fs ▁ mtd0" ) ; $dc or die " can ' t ▁ open ▁ data ▁ connection \n " ; while ( ( $fssize > 0 ) and ( $rbytes > 0 ) ) { my $buffer ; my $len = ( $fssize > 1024 ? 1024 : $fssize ) ; $rbytes = read FILE , $buffer , $len ; $rbytes and $fssize -= $dc -> write ( $buffer , $rbytes , 600 ) ; } $dc -> close ( ) ; $ftp -> reboot ( ) ; </DOCUMENT>
<DOCUMENT_ID="dgrove727/autopsy/tree/master/thirdparty/rr-full/plugins/dcom.pl"> # ▁ dcom . pl ENDCOM # ▁ DCOM ▁ ports ▁ can ▁ be ▁ set , ▁ and ▁ in ▁ Matt ▁ Graeber ' s ▁ BlackHat ▁ 2015 ▁ paper , ENDCOM # ▁ he ▁ recommends ▁ modifying ▁ the ▁ ports ENDCOM # ▁ https : / / www . blackhat . com / docs / us - 15 / materials / us - 15 - Graeber - Abusing - Windows ENDCOM # ▁ - Management - Instrumentation - WMI - To - Build - A - Persistent % 20Asynchronous - And - Fileless - Backdoor - wp . pdf ▁ ENDCOM # ▁ Change ▁ history ENDCOM # ▁ 20151203 ▁ - ▁ created ENDCOM # ▁ References ENDCOM # ▁ http : / / blog . backslasher . net / setting - dynamic - rpc - port - ranges . html ENDCOM # ▁ Copyright ▁ ( c ) ▁ 2015 ▁ QAR , ▁ LLC ENDCOM # ▁ Author : ▁ H . ▁ Carvey , ▁ keydet89 @ yahoo . com ENDCOM package dcom ; use strict ; # ▁ Declarations ▁ # ENDCOM my % config = ( hive = > " Software " , hasShortDescr = > 1 , hasDescr = > 0 , hasRefs = > 0 , osmask = > 22 , category = > " system ▁ config " , version = > 20151203 ) ; my $VERSION = getVersion ( ) ; # ▁ Functions ▁ # ENDCOM sub getConfig { return % config } sub getHive { return $config { hive } ; } sub getVersion { return $config { version } ; } sub getDescr { } sub getShortDescr { return " Check ▁ DCOM ▁ Ports " ; } sub getRefs { } sub pluginmain { my $class = shift ; my $hive = shift ; :: logMsg ( " Launching ▁ dcom ▁ v . " . $VERSION ) ; :: rptMsg ( " dcom ▁ v . " . $VERSION ) ; :: rptMsg ( " ( " . $config { hive } . " ) ▁ " . getShortDescr ( ) . " \n " ) ; my $reg = Parse :: Win32Registry -> new ( $hive ) ; my $root_key = $reg -> get_root_key ; my $key ; my $ports ; my $key_path = " Microsoft\\Rpc\\Internet " ; if ( $key = $root_key -> get_subkey ( $key_path ) ) { :: rptMsg ( $key_path ) ; :: rptMsg ( " LastWrite ▁ Time ▁ " . gmtime ( $key -> get_timestamp ( ) ) . " ▁ ( UTC ) " ) ; :: rptMsg ( " " ) ; eval { $ports = $key -> get_value ( " Ports " ) -> get_data ( ) ; :: rptMsg ( " Ports ▁ value ▁ found : ▁ " . $ports ) ; } ; eval { $ports = $key -> get_value ( " PortsInternetAvailable " ) -> get_data ( ) ; :: rptMsg ( " PortsInternetAvailable ▁ value ▁ found : ▁ " . $ports ) ; } ; eval { $ports = $key -> get_value ( " UseInternetPorts " ) -> get_data ( ) ; :: rptMsg ( " UseInternetPorts ▁ value ▁ found : ▁ " . $ports ) ; } ; } else { } } 1 ; </DOCUMENT>
<DOCUMENT_ID="fb39ca4/mongoose/tree/master/test/all_build_flags.pl"> # ! / usr / bin / env ▁ perl ENDCOM @ flags = ( " NO _ POPEN " , " NO _ SSL " , " NDEBUG " , " DEBUG " , " NO _ CGI " ) ; my $num_flags = @ flags ; sub fail { print " FAILED : ▁ @ _ \n " ; exit 1 ; } my $platform = $ARGV [ 0 ] || " linux " ; for ( my $i = 0 ; $i < 2 * * $num_flags ; $i ++ ) { my $bitmask = sprintf ( " % * . * b " , $num_flags , $num_flags , $i ) ; my @ combination = ( ) ; for ( my $j = 0 ; $j < $num_flags ; $j ++ ) { push @ combination , $flags [ $j ] if substr ( $bitmask , $j , 1 ) ; } my $defines = join ( " ▁ " , map { " - D $ _ " } @ combination ) ; my $cmd = " CFLAGS = \ " $ defines\ " ▁ make ▁ clean ▁ $ platform ▁ > / dev / null " ; system ( $cmd ) == 0 or fail " build ▁ failed : ▁ $ _ " ; print " Build ▁ succeeded , ▁ flags : ▁ [ $ defines ] \n " ; system ( " perl ▁ test / test . pl ▁ basic _ tests ▁ > / dev / null " ) == 0 or fail " basic ▁ tests " ; print " Basic ▁ tests : ▁ OK \n " ; } print " PASS : ▁ All ▁ builds ▁ passed ! \n " ; </DOCUMENT>
<DOCUMENT_ID="jondo/paperpile/tree/master/plack/perl5/win32/lib/unicore/lib/In/3_1.pl"> # ▁ ! ! ! ! ! ▁ DO ▁ NOT ▁ EDIT ▁ THIS ▁ FILE ▁ ! ! ! ! ! ENDCOM # ▁ This ▁ file ▁ is ▁ machine - generated ▁ by ▁ mktables ▁ from ▁ the ▁ Unicode ENDCOM # ▁ database , ▁ Version ▁ 5.2.0 . ▁ Any ▁ changes ▁ made ▁ here ▁ will ▁ be ▁ lost ! ENDCOM # ▁ ! ! ! ! ! ▁ INTERNAL ▁ PERL ▁ USE ▁ ONLY ▁ ! ! ! ! ! ENDCOM # ▁ This ▁ file ▁ is ▁ for ▁ internal ▁ use ▁ by ▁ the ▁ Perl ▁ program ▁ only . ▁ The ▁ format ▁ and ▁ even ENDCOM # ▁ the ▁ name ▁ or ▁ existence ▁ of ▁ this ▁ file ▁ are ▁ subject ▁ to ▁ change ▁ without ▁ notice . ENDCOM # ▁ Don ' t ▁ use ▁ it ▁ directly . ENDCOM # ▁ This ▁ file ▁ returns ▁ the ▁ 233_787 ▁ code ▁ points ▁ in ▁ Unicode ▁ Version ▁ 5.2.0 ▁ that ENDCOM # ▁ match ▁ any ▁ of ▁ the ▁ following ▁ regular ▁ expression ▁ constructs : ENDCOM # ▁ \p { Present _ In = 3.1 } ENDCOM # ▁ \p { In = 3.1 } ENDCOM # ▁ Meaning : ▁ Code ▁ point ' s ▁ usage ▁ introduced ▁ in ▁ version ▁ 3.1 ▁ or ▁ earlier ENDCOM # ▁ perluniprops . pod ▁ should ▁ be ▁ consulted ▁ for ▁ the ▁ syntax ▁ rules ▁ for ▁ any ▁ of ▁ these , ENDCOM # ▁ including ▁ if ▁ adding ▁ or ▁ subtracting ▁ white ▁ space , ▁ underscore , ▁ and ▁ hyphen ENDCOM # ▁ characters ▁ matters ▁ or ▁ doesn ' t ▁ matter , ▁ and ▁ other ▁ permissible ▁ syntactic ENDCOM # ▁ variants . ▁ Upper / lower ▁ case ▁ distinctions ▁ never ▁ matter . ENDCOM # ▁ A ▁ colon ▁ can ▁ be ▁ substituted ▁ for ▁ the ▁ equals ▁ sign , ▁ and ▁ anything ▁ to ▁ the ▁ left ▁ of ENDCOM # ▁ the ▁ equals ▁ ( or ▁ colon ) ▁ can ▁ be ▁ combined ▁ with ▁ anything ▁ to ▁ the ▁ right . ▁ Thus , ENDCOM # ▁ for ▁ example , ENDCOM # ▁ \p { In : ▁ 3.1 } ENDCOM # ▁ is ▁ also ▁ valid . ENDCOM # ▁ The ▁ format ▁ of ▁ the ▁ lines ▁ of ▁ this ▁ file ▁ is : ▁ START\tSTOP\twhere ▁ START ▁ is ▁ the ENDCOM # ▁ starting ▁ code ▁ point ▁ of ▁ the ▁ range , ▁ in ▁ hex ; ▁ STOP ▁ is ▁ the ▁ ending ▁ point , ▁ or ▁ if ENDCOM # ▁ omitted , ▁ the ▁ range ▁ has ▁ just ▁ one ▁ code ▁ point . ▁ Numbers ▁ in ▁ comments ▁ in ENDCOM # ▁ [ brackets ] ▁ indicate ▁ how ▁ many ▁ code ▁ points ▁ are ▁ in ▁ the ▁ range . ENDCOM return << ' END ' ; 0000 021 F # ▁ [ 544 ] ENDCOM 0222 0233 # ▁ [ 18 ] ENDCOM 0250 02 AD # ▁ [ 94 ] ENDCOM 02 B0 02 EE # ▁ [ 63 ] ENDCOM 0300 034 E # ▁ [ 79 ] ENDCOM 0360 0362 0374 0375 037 A 037 E 03 84 03 8 A 03 8 C 03 8E 03 A1 # ▁ [ 20 ] ENDCOM 03 A3 03 CE # ▁ [ 44 ] ENDCOM 03 D0 03 D7 03 DA 03 F5 # ▁ [ 28 ] ENDCOM 0400 04 86 # ▁ [ 135 ] ENDCOM 04 88 04 89 04 8 C 04 C4 # ▁ [ 57 ] ENDCOM 04 C7 04 C8 04 CB 04 CC 04 D0 04 F5 # ▁ [ 38 ] ENDCOM 04 F8 04 F9 0531 0556 # ▁ [ 38 ] ENDCOM 055 9 055 F 0561 05 87 # ▁ [ 39 ] ENDCOM 05 89 05 8 A 05 91 05 A1 # ▁ [ 17 ] ENDCOM 05 A3 05 B9 # ▁ [ 23 ] ENDCOM 05 BB 05 C4 # ▁ [ 10 ] ENDCOM 05 D0 05 EA # ▁ [ 27 ] ENDCOM 05 F0 05 F4 060 C 061 B 061 F 0621 063 A # ▁ [ 26 ] ENDCOM 0640 0655 # ▁ [ 22 ] ENDCOM 0660 066 D # ▁ [ 14 ] ENDCOM 0670 06 ED # ▁ [ 126 ] ENDCOM 06 F0 06 FE # ▁ [ 15 ] ENDCOM 0700 070 D # ▁ [ 14 ] ENDCOM 070 F 072 C # ▁ [ 30 ] ENDCOM 0730 074 A # ▁ [ 27 ] ENDCOM 07 80 07 B0 # ▁ [ 49 ] ENDCOM 0901 0903 0905 0939 # ▁ [ 53 ] ENDCOM 093 C 094D # ▁ [ 18 ] ENDCOM 0950 0954 0958 0970 # ▁ [ 25 ] ENDCOM 0981 0983 0985 098 C 098F 0990 0993 09 A8 # ▁ [ 22 ] ENDCOM 09 AA 09 B0 09 B2 09 B6 09 B9 09 BC 09 BE 09 C4 09 C7 09 C8 09 CB 09 CD 09D 7 09D C 09D D 09D F 09E3 09E6 09F A # ▁ [ 21 ] ENDCOM 0 A02 0 A05 0 A0A 0 A0F 0 A10 0 A13 0 A28 # ▁ [ 22 ] ENDCOM 0 A2A 0 A30 0 A32 0 A33 0 A35 0 A36 0 A38 0 A39 0 A3C 0 A3E 0 A42 0 A47 0 A48 0 A4B 0 A4D 0 A59 0 A5C 0 A5E 0 A66 0 A74 # ▁ [ 15 ] ENDCOM 0 A81 0 A83 0 A85 0 A8B 0 A8D 0 A8F 0 A91 0 A93 0 AA8 # ▁ [ 22 ] ENDCOM 0 AAA 0 AB0 0 AB2 0 AB3 0 AB5 0 AB9 0 ABC 0 AC5 # ▁ [ 10 ] ENDCOM 0 AC7 0 AC9 0 ACB 0 ACD 0 AD0 0 AE0 0 AE6 0 AEF # ▁ [ 10 ] ENDCOM 0B01 0B0 3 0B0 5 0B0 C 0B0 F 0B10 0B1 3 0B 28 # ▁ [ 22 ] ENDCOM 0B 2 A 0B 30 0B 32 0B 33 0B 36 0B 39 0B 3 C 0B 43 0B 47 0B 48 0B 4 B 0B 4D 0B 56 0B 57 0B 5 C 0B 5D 0B 5F 0B 61 0B 66 0B 70 # ▁ [ 11 ] ENDCOM 0B 82 0B 83 0B 85 0B 8 A 0B 8E 0B 90 0B 92 0B 95 0B 99 0B 9 A 0B 9 C 0B 9E 0B 9F 0B A3 0B A4 0B A8 0B AA 0B AE 0B B5 0B B7 0B B9 0B BE 0B C2 0B C6 0B C8 0B CA 0B CD 0B D7 0B E7 0B F2 # ▁ [ 12 ] ENDCOM 0 C01 0 C03 0 C05 0 C0C 0 C0E 0 C10 0 C12 0 C28 # ▁ [ 23 ] ENDCOM 0 C2A 0 C33 # ▁ [ 10 ] ENDCOM 0 C35 0 C39 0 C3E 0 C44 0 C46 0 C48 0 C4A 0 C4D 0 C55 0 C56 0 C60 0 C61 0 C66 0 C6F # ▁ [ 10 ] ENDCOM 0 C82 0 C83 0 C85 0 C8C 0 C8E 0 C90 0 C92 0 CA8 # ▁ [ 23 ] ENDCOM 0 CAA 0 CB3 # ▁ [ 10 ] ENDCOM 0 CB5 0 CB9 0 CBE 0 CC4 0 CC6 0 CC8 0 CCA 0 CCD 0 CD5 0 CD6 0 CDE 0 CE0 0 CE1 0 CE6 0 CEF # ▁ [ 10 ] ENDCOM 0D 02 0D 03 0D 05 0D 0 C 0D 0E 0D 10 0D 12 0D 28 # ▁ [ 23 ] ENDCOM 0D 2 A 0D 39 # ▁ [ 16 ] ENDCOM 0D 3E 0D 43 0D 46 0D 48 0D 4 A 0D 4D 0D 57 0D 60 0D 61 0D 66 0D 6F # ▁ [ 10 ] ENDCOM 0D 82 0D 83 0D 85 0D 96 # ▁ [ 18 ] ENDCOM 0D 9 A 0D B1 # ▁ [ 24 ] ENDCOM 0D B3 0D BB 0D BD 0D C0 0D C6 0D CA 0D CF 0D D4 0D D6 0D D8 0D DF 0D F2 0D F4 0E01 0E3 A # ▁ [ 58 ] ENDCOM 0E3F 0E5 B # ▁ [ 29 ] ENDCOM 0E81 0E82 0E84 0E87 0E88 0E8 A 0E8D 0E94 0E97 0E99 0E9F 0E A1 0E A3 0E A5 0E A7 0E AA 0E AB 0E AD 0E B9 # ▁ [ 13 ] ENDCOM 0E BB 0E BD 0E C0 0E C4 0E C6 0E C8 0E CD 0ED 0 0ED 9 # ▁ [ 10 ] ENDCOM 0ED C 0ED D 0F 00 0F 47 # ▁ [ 72 ] ENDCOM 0F 49 0F 6 A # ▁ [ 34 ] ENDCOM 0F 71 0F 8 B # ▁ [ 27 ] ENDCOM 0F 90 0F 97 0F 99 0F BC # ▁ [ 36 ] ENDCOM 0F BE 0F CC # ▁ [ 15 ] ENDCOM 0F CF 1000 1021 # ▁ [ 34 ] ENDCOM 1023 1027 1029 102 A 102 C 1032 1036 1039 1040 1059 # ▁ [ 26 ] ENDCOM 10 A0 10 C5 # ▁ [ 38 ] ENDCOM 10D 0 10F 6 # ▁ [ 39 ] ENDCOM 10F B 1100 1159 # ▁ [ 90 ] ENDCOM 115F 11 A2 # ▁ [ 68 ] ENDCOM 11 A8 11F 9 # ▁ [ 82 ] ENDCOM 1200 1206 1208 1246 # ▁ [ 63 ] ENDCOM 1248 124 A 124D 1250 1256 1258 125 A 125D 1260 1286 # ▁ [ 39 ] ENDCOM 1288 128 A 128D 1290 12 AE # ▁ [ 31 ] ENDCOM 12 B0 12 B2 12 B5 12 B8 12 BE 12 C0 12 C2 12 C5 12 C8 12 CE 12D 0 12D 6 12D 8 12E E # ▁ [ 23 ] ENDCOM 12F 0 130E # ▁ [ 31 ] ENDCOM 1310 1312 1315 1318 131E 1320 1346 # ▁ [ 39 ] ENDCOM 1348 135 A # ▁ [ 19 ] ENDCOM 1361 137 C # ▁ [ 28 ] ENDCOM 13 A0 13F 4 # ▁ [ 85 ] ENDCOM 1401 1676 # ▁ [ 630 ] ENDCOM 1680 169 C # ▁ [ 29 ] ENDCOM 16 A0 16F 0 # ▁ [ 81 ] ENDCOM 1780 17D C # ▁ [ 93 ] ENDCOM 17E0 17E9 # ▁ [ 10 ] ENDCOM 1800 180E # ▁ [ 15 ] ENDCOM 1810 1819 # ▁ [ 10 ] ENDCOM 1820 1877 # ▁ [ 88 ] ENDCOM 1880 18 A9 # ▁ [ 42 ] ENDCOM 1E00 1E9 B # ▁ [ 156 ] ENDCOM 1E A0 1EF 9 # ▁ [ 90 ] ENDCOM 1F 00 1F 15 # ▁ [ 22 ] ENDCOM 1F 18 1F 1D 1F 20 1F 45 # ▁ [ 38 ] ENDCOM 1F 48 1F 4D 1F 50 1F 57 1F 59 1F 5 B 1F 5D 1F 5F 1F 7D # ▁ [ 31 ] ENDCOM 1F 80 1F B4 # ▁ [ 53 ] ENDCOM 1F B6 1F C4 # ▁ [ 15 ] ENDCOM 1F C6 1F D3 # ▁ [ 14 ] ENDCOM 1F D6 1F DB 1F DD 1F EF # ▁ [ 19 ] ENDCOM 1F F2 1F F4 1F F6 1F FE 2000 2046 # ▁ [ 71 ] ENDCOM 2048 204D 206 A 2070 2074 208E # ▁ [ 27 ] ENDCOM 20 A0 20 AF # ▁ [ 16 ] ENDCOM 20D 0 20E3 # ▁ [ 20 ] ENDCOM 2100 213 A # ▁ [ 59 ] ENDCOM 2153 2183 # ▁ [ 49 ] ENDCOM 2190 21F 3 # ▁ [ 100 ] ENDCOM 2200 22F 1 # ▁ [ 242 ] ENDCOM 2300 237 B # ▁ [ 124 ] ENDCOM 237D 239 A # ▁ [ 30 ] ENDCOM 2400 2426 # ▁ [ 39 ] ENDCOM 2440 244 A # ▁ [ 11 ] ENDCOM 2460 24E A # ▁ [ 139 ] ENDCOM 2500 2595 # ▁ [ 150 ] ENDCOM 25 A0 25F 7 # ▁ [ 88 ] ENDCOM 2600 2613 # ▁ [ 20 ] ENDCOM 2619 2671 # ▁ [ 89 ] ENDCOM 2701 2704 2706 2709 270 C 2727 # ▁ [ 28 ] ENDCOM 2729 274 B # ▁ [ 35 ] ENDCOM 274D 274F 2752 2756 2758 275E 2761 2767 2776 2794 # ▁ [ 31 ] ENDCOM 2798 27 AF # ▁ [ 24 ] ENDCOM 27 B1 27 BE # ▁ [ 14 ] ENDCOM 2800 28F F # ▁ [ 256 ] ENDCOM 2E80 2E99 # ▁ [ 26 ] ENDCOM 2E9 B 2EF 3 # ▁ [ 89 ] ENDCOM 2F 00 2F D5 # ▁ [ 214 ] ENDCOM 2F F0 2F FB # ▁ [ 12 ] ENDCOM 3000 303 A # ▁ [ 59 ] ENDCOM 303E 303F 3041 3094 # ▁ [ 84 ] ENDCOM 3099 309E 30 A1 30F E # ▁ [ 94 ] ENDCOM 3105 312 C # ▁ [ 40 ] ENDCOM 3131 318E # ▁ [ 94 ] ENDCOM 3190 31 B7 # ▁ [ 40 ] ENDCOM 3200 321 C # ▁ [ 29 ] ENDCOM 3220 3243 # ▁ [ 36 ] ENDCOM 3260 327 B # ▁ [ 28 ] ENDCOM 327F 32 B0 # ▁ [ 50 ] ENDCOM 32 C0 32 CB # ▁ [ 12 ] ENDCOM 32D 0 32F E # ▁ [ 47 ] ENDCOM 3300 3376 # ▁ [ 119 ] ENDCOM 337 B 33D D # ▁ [ 99 ] ENDCOM 33E0 33F E # ▁ [ 31 ] ENDCOM 3400 4D B5 # ▁ [ 6582 ] ENDCOM 4E00 9F A5 # ▁ [ 20_902 ] ENDCOM A000 A48C # ▁ [ 1165 ] ENDCOM A490 A4A1 # ▁ [ 18 ] ENDCOM A4A4 A4B3 # ▁ [ 16 ] ENDCOM A4B5 A4C0 # ▁ [ 12 ] ENDCOM A4C2 A4C4 A4C6 AC00 D7A3 # ▁ [ 11_172 ] ENDCOM D800 FA2D # ▁ [ 8750 ] ENDCOM FB00 FB06 FB13 FB17 FB1D FB36 # ▁ [ 26 ] ENDCOM FB38 FB3C FB3E FB40 FB41 FB43 FB44 FB46 FBB1 # ▁ [ 108 ] ENDCOM FBD3 FD3F # ▁ [ 365 ] ENDCOM FD50 FD8F # ▁ [ 64 ] ENDCOM FD92 FDC7 # ▁ [ 54 ] ENDCOM FDD0 FDFB # ▁ [ 44 ] ENDCOM FE20 FE23 FE30 FE44 # ▁ [ 21 ] ENDCOM FE49 FE52 # ▁ [ 10 ] ENDCOM FE54 FE66 # ▁ [ 19 ] ENDCOM FE68 FE6B FE70 FE72 FE74 FE76 FEFC # ▁ [ 135 ] ENDCOM FEFF FF01 FF5E # ▁ [ 94 ] ENDCOM FF61 FFBE # ▁ [ 94 ] ENDCOM FFC2 FFC7 FFCA FFCF FFD2 FFD7 FFDA FFDC FFE0 FFE6 FFE8 FFEE FFF9 FFFF 10300 1031E # ▁ [ 31 ] ENDCOM 10320 10323 10330 1034 A # ▁ [ 27 ] ENDCOM 10400 10425 # ▁ [ 38 ] ENDCOM 10428 1044D # ▁ [ 38 ] ENDCOM 1D 000 1D 0F 5 # ▁ [ 246 ] ENDCOM 1D 100 1D 126 # ▁ [ 39 ] ENDCOM 1D 12 A 1D 1D D # ▁ [ 180 ] ENDCOM 1D 400 1D 454 # ▁ [ 85 ] ENDCOM 1D 456 1D 49 C # ▁ [ 71 ] ENDCOM 1D 49E 1D 49F 1D 4 A2 1D 4 A5 1D 4 A6 1D 4 A9 1D 4 AC 1D 4 AE 1D 4 B9 # ▁ [ 12 ] ENDCOM 1D 4 BB 1D 4 BD 1D 4 C0 1D 4 C2 1D 4 C3 1D 4 C5 1D 505 # ▁ [ 65 ] ENDCOM 1D 507 1D 50 A 1D 50D 1D 514 1D 516 1D 51 C 1D 51E 1D 539 # ▁ [ 28 ] ENDCOM 1D 53 B 1D 53E 1D 540 1D 544 1D 546 1D 54 A 1D 550 1D 552 1D 6 A3 # ▁ [ 338 ] ENDCOM 1D 6 A8 1D 7 C9 # ▁ [ 290 ] ENDCOM 1D 7 CE 1D 7F F # ▁ [ 50 ] ENDCOM 1F FFE 2 A6D6 # ▁ [ 42_713 ] ENDCOM 2F 800 2F A1D # ▁ [ 542 ] ENDCOM 2F FFE 2F FFF 3F FFE 3F FFF 4F FFE 4F FFF 5F FFE 5F FFF 6F FFE 6F FFF 7F FFE 7F FFF 8F FFE 8F FFF 9F FFE 9F FFF AFFFE AFFFF BFFFE BFFFF CFFFE CFFFF DFFFE DFFFF E0001 E0020 E007F # ▁ [ 96 ] ENDCOM EFFFE 10F FFF # ▁ [ 131_074 ] ENDCOM END </DOCUMENT>
<DOCUMENT_ID="MetalPhoenix45/SmoothGKernel/tree/master/scripts/headers_check.pl"> # ! / usr / bin / perl ▁ - w ENDCOM # ▁ headers _ check . pl ▁ execute ▁ a ▁ number ▁ of ▁ trivial ▁ consistency ▁ checks ENDCOM # ▁ Usage : ▁ headers _ check . pl ▁ dir ▁ arch ▁ [ files . . . ] ENDCOM # ▁ dir : ▁ dir ▁ to ▁ look ▁ for ▁ included ▁ files ENDCOM # ▁ arch : ▁ architecture ENDCOM # ▁ files : ▁ list ▁ of ▁ files ▁ to ▁ check ENDCOM # ▁ The ▁ script ▁ reads ▁ the ▁ supplied ▁ files ▁ line ▁ by ▁ line ▁ and : ENDCOM # ▁ 1 ) ▁ for ▁ each ▁ include ▁ statement ▁ it ▁ checks ▁ if ▁ the ENDCOM # ▁ included ▁ file ▁ actually ▁ exists . ENDCOM # ▁ Only ▁ include ▁ files ▁ located ▁ in ▁ asm * ▁ and ▁ linux * ▁ are ▁ checked . ENDCOM # ▁ The ▁ rest ▁ are ▁ assumed ▁ to ▁ be ▁ system ▁ include ▁ files . ENDCOM # ▁ 2 ) ▁ It ▁ is ▁ checked ▁ that ▁ prototypes ▁ does ▁ not ▁ use ▁ " extern " ENDCOM # ▁ 3 ) ▁ Check ▁ for ▁ leaked ▁ CONFIG _ ▁ symbols ENDCOM use strict ; use File :: Basename ; my ( $dir , $arch , @ files ) = @ ARGV ; my $ret = 0 ; my $line ; my $lineno = 0 ; my $filename ; foreach my $file ( @ files ) { $filename = $file ; open ( my $fh , ' < ' , $filename ) or die " $ filename : ▁ $ ! \n " ; $lineno = 0 ; while ( $line = < $fh > ) { $lineno ++ ; & check_include ( ) ; & check_asm_types ( ) ; & check_sizetypes ( ) ; & check_declarations ( ) ; # ▁ Dropped ▁ for ▁ now . ▁ Too ▁ much ▁ noise ▁ & check _ config ( ) ; ENDCOM } close $fh ; } exit $ret ; sub check_include { if ( $line = ~ m / ^ \ s * # \s * include\s + < ( ( asm | linux ) . * ) > / ) ▁ { ENDCOM my $inc = $1 ; my $found ; $found = stat ( $dir . " / " . $inc ) ; if ( ! $found ) { $inc = ~ s # asm / # asm - $ arch / # ; ENDCOM $found = stat ( $dir . " / " . $inc ) ; } if ( ! $found ) { printf STDERR " $ filename : $ lineno : ▁ included ▁ file ▁ ' $ inc ' ▁ is ▁ not ▁ exported \n " ; $ret = 1 ; } } } sub check_declarations { if ( $line = ~ m / ^ ( \ s * extern | unsigned | char | short | int | long | void ) \ b / ) { printf STDERR " $ filename : $ lineno : ▁ " . " userspace ▁ cannot ▁ reference ▁ function ▁ or ▁ " . " variable ▁ defined ▁ in ▁ the ▁ kernel \n " ; } } sub check_config { if ( $line = ~ m / [ ^ a - zA - Z0 - 9 _ ] + CONFIG_ ( [ a - zA - Z0 - 9 _ ] + ) [ ^ a - zA - Z0 - 9 _ ] / ) { printf STDERR " $ filename : $ lineno : ▁ leaks ▁ CONFIG _ $ 1 ▁ to ▁ userspace ▁ where ▁ it ▁ is ▁ not ▁ valid \n " ; } } my $linux_asm_types ; sub check_asm_types { if ( $filename = ~ / types . h | int - l64 . h | int - ll64 . h / o ) { return ; } if ( $lineno == 1 ) { $linux_asm_types = 0 ; } elsif ( $linux_asm_types >= 1 ) { return ; } if ( $line = ~ m / ^ \ s * # \s * include\s + < asm\ / types . h > / ) ▁ { ENDCOM $linux_asm_types = 1 ; printf STDERR " $ filename : $ lineno : ▁ " . " include ▁ of ▁ < linux / types . h > ▁ is ▁ preferred ▁ over ▁ < asm / types . h > \n " # ▁ Warn ▁ until ▁ headers ▁ are ▁ all ▁ fixed ENDCOM # $ ret ▁ = ▁ 1 ; ENDCOM } } my $linux_types ; my % import_stack = ( ) ; sub check_include_typesh { my $path = $_ [ 0 ] ; my $import_path ; my $fh ; my @ file_paths = ( $path , $dir . " / " . $path , dirname ( $filename ) . " / " . $path ) ; for my $possible ( @ file_paths ) { if ( not $import_stack { $possible } and open ( $fh , ' < ' , $possible ) ) { $import_path = $possible ; $import_stack { $import_path } = 1 ; last ; } } if ( eof $fh ) { return ; } my $line ; while ( $line = < $fh > ) { if ( $line = ~ m / ^ \ s * # \s * include\s + < linux\ / types . h > / ) ▁ { ENDCOM $linux_types = 1 ; last ; } if ( my $included = ( $line = ~ / ^ \ s * # \s * include\s + [ < " ] ( \S + ) [ > " ] / ) [ 0 ] ) ▁ { ENDCOM check_include_typesh ( $included ) ; } } close $fh ; delete $import_stack { $import_path } ; } sub check_sizetypes { if ( $filename = ~ / types . h | int - l64 . h | int - ll64 . h / o ) { return ; } if ( $lineno == 1 ) { $linux_types = 0 ; } elsif ( $linux_types >= 1 ) { return ; } if ( $line = ~ m / ^ \ s * # \s * include\s + < linux\ / types . h > / ) ▁ { ENDCOM $linux_types = 1 ; return ; } if ( my $included = ( $line = ~ / ^ \ s * # \s * include\s + [ < " ] ( \S + ) [ > " ] / ) [ 0 ] ) ▁ { ENDCOM check_include_typesh ( $included ) ; } if ( $line = ~ m / __ [ us ] ( 8 | 16 | 32 | 64 ) \ b / ) { printf STDERR " $ filename : $ lineno : ▁ " . " found ▁ _ _ [ us ] {8,16,32,64 } ▁ type ▁ " . " without ▁ # include ▁ < linux / types . h > \n " ; $linux_types = 2 ; # ▁ Warn ▁ until ▁ headers ▁ are ▁ all ▁ fixed ENDCOM # $ ret ▁ = ▁ 1 ; ENDCOM } } </DOCUMENT>
<DOCUMENT_ID="koxda/android_kernel_samsung_msm8660-common/tree/master/tools/perf/scripts/perl/workqueue-stats.pl"> # ! / usr / bin / perl ▁ - w ENDCOM # ▁ ( c ) ▁ 2009 , ▁ Tom ▁ Zanussi ▁ < tzanussi @ gmail . com > ENDCOM # ▁ Licensed ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ GPL ▁ License ▁ version ▁ 2 ENDCOM # ▁ Displays ▁ workqueue ▁ stats ENDCOM # ▁ Usage : ENDCOM # ▁ perf ▁ record ▁ - c ▁ 1 ▁ - f ▁ - a ▁ - R ▁ - e ▁ workqueue : workqueue _ creation ▁ - e ENDCOM # ▁ workqueue : workqueue _ destruction ▁ - e ▁ workqueue : workqueue _ execution ENDCOM # ▁ - e ▁ workqueue : workqueue _ insertion ENDCOM # ▁ perf ▁ script ▁ - p ▁ - s ▁ tools / perf / scripts / perl / workqueue - stats . pl ENDCOM use 5.010000 ; use strict ; use warnings ; use lib " $ ENV { ' PERF _ EXEC _ PATH ' } / scripts / perl / Perf - Trace - Util / lib " ; use lib " . / Perf - Trace - Util / lib " ; use Perf :: Trace :: Core ; use Perf :: Trace :: Util ; my @ cpus ; sub workqueue :: workqueue_destruction { my ( $event_name , $context , $common_cpu , $common_secs , $common_nsecs , $common_pid , $common_comm , $thread_comm , $thread_pid ) = @ _ ; $cpus [ $common_cpu ] { $thread_pid } { destroyed } ++ ; $cpus [ $common_cpu ] { $thread_pid } { comm } = $thread_comm ; } sub workqueue :: workqueue_creation { my ( $event_name , $context , $common_cpu , $common_secs , $common_nsecs , $common_pid , $common_comm , $thread_comm , $thread_pid , $cpu ) = @ _ ; $cpus [ $common_cpu ] { $thread_pid } { created } ++ ; $cpus [ $common_cpu ] { $thread_pid } { comm } = $thread_comm ; } sub workqueue :: workqueue_execution { my ( $event_name , $context , $common_cpu , $common_secs , $common_nsecs , $common_pid , $common_comm , $thread_comm , $thread_pid , $func ) = @ _ ; $cpus [ $common_cpu ] { $thread_pid } { executed } ++ ; $cpus [ $common_cpu ] { $thread_pid } { comm } = $thread_comm ; } sub workqueue :: workqueue_insertion { my ( $event_name , $context , $common_cpu , $common_secs , $common_nsecs , $common_pid , $common_comm , $thread_comm , $thread_pid , $func ) = @ _ ; $cpus [ $common_cpu ] { $thread_pid } { inserted } ++ ; $cpus [ $common_cpu ] { $thread_pid } { comm } = $thread_comm ; } sub trace_end { print " workqueue ▁ work ▁ stats : \n \n " ; my $cpu = 0 ; printf ( " % 3s ▁ % 6s ▁ % 6s\t % -20s \n " , " cpu " , " ins " , " exec " , " name " ) ; printf ( " % 3s ▁ % 6s ▁ % 6s\t % -20s \n " , " - - - " , " - - - " , " - - - - " , " - - - - " ) ; foreach my $pidhash ( @ cpus ) { while ( ( my $pid , my $wqhash ) = each % $pidhash ) { my $ins = $$wqhash { ' inserted ' } || 0 ; my $exe = $$wqhash { ' executed ' } || 0 ; my $comm = $$wqhash { ' comm ' } || " " ; if ( $ins || $exe ) { printf ( " % 3u ▁ % 6u ▁ % 6u\t % -20s \n " , $cpu , $ins , $exe , $comm ) ; } } $cpu ++ ; } $cpu = 0 ; print " \n workqueue ▁ lifecycle ▁ stats : \n \n " ; printf ( " % 3s ▁ % 6s ▁ % 6s\t % -20s \n " , " cpu " , " created " , " destroyed " , " name " ) ; printf ( " % 3s ▁ % 6s ▁ % 6s\t % -20s \n " , " - - - " , " - - - - - - - " , " - - - - - - - - - " , " - - - - " ) ; foreach my $pidhash ( @ cpus ) { while ( ( my $pid , my $wqhash ) = each % $pidhash ) { my $created = $$wqhash { ' created ' } || 0 ; my $destroyed = $$wqhash { ' destroyed ' } || 0 ; my $comm = $$wqhash { ' comm ' } || " " ; if ( $created || $destroyed ) { printf ( " % 3u ▁ % 6u ▁ % 6u\t % -20s \n " , $cpu , $created , $destroyed , $comm ) ; } } $cpu ++ ; } print_unhandled ( ) ; } my % unhandled ; sub print_unhandled { if ( ( scalar keys % unhandled ) == 0 ) { return ; } print " \n unhandled ▁ events : \n \n " ; printf ( " % -40s ▁ ▁ % 10s \n " , " event " , " count " ) ; printf ( " % -40s ▁ ▁ % 10s \n " , " - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - " , " - - - - - - - - - - - " ) ; foreach my $event_name ( keys % unhandled ) { printf ( " % -40s ▁ ▁ % 10d \n " , $event_name , $unhandled { $event_name } ) ; } } sub trace_unhandled { my ( $event_name , $context , $common_cpu , $common_secs , $common_nsecs , $common_pid , $common_comm ) = @ _ ; $unhandled { $event_name } ++ ; } </DOCUMENT>
<DOCUMENT_ID="kurkale6ka/scripts/tree/master/rseverywhere.pl"> # ! ▁ / usr / bin / env ▁ perl ENDCOM # ▁ Sync ▁ my ▁ repos ▁ to ▁ remotes ENDCOM use v5 .12 ; use warnings ; use Getopt :: Long qw / GetOptions : config pass_through / ; use lib " $ ENV { REPOS _ BASE } / config / tmux " ; use Nodes ; # ▁ Help ENDCOM sub help ( ) { my $msg = << ' MSG ' ; Sync repos to remotes rseverywhere @ cluster ... node [ range ] ... [ - exclude ] ... Rsync options : -- ( no - ) delete - excluded , -- delete if ' no - ' -- dry MSG return $msg . Nodes :: help ( ) ; } die help if @ ARGV == 0 ; # ▁ Arguments ENDCOM my $user = ' dimitar ' ; my $base = ' github ' ; my $del = 1 ; my $dry ; GetOptions ( ' delete - excluded ! ' = > \ $del , ' dry ' = > \ $dry , ' help ' = > sub { print help ; exit ; } , ) or die " Error ▁ in ▁ command ▁ line ▁ arguments \n " ; $del = $del ? ' - - delete - excluded ' : ' - - delete ' ; $dry = $dry ? ' n ' : ' ' ; # ▁ Calculate ▁ hosts ENDCOM exit unless my @ hosts = nodes ( ) ; sub sync ( $ ) { my $remote = shift ; unless ( system ( " ssh ▁ - TG ▁ $ remote ▁ | ▁ grep ▁ ' user\\b ' ▁ | ▁ grep ▁ - q ▁ $ user " ) == 0 ) { $base = $user ; } system ' rsync ' , " - ai $ dry " , ' - - no - o ' , ' - - no - g ' , $del , ' - e ' , ' ssh ▁ - q ' , ' - f ' , ' - ▁ . git ' , ' - f ' , ' - ▁ . gitignore ' , ' - f ' , ' - ▁ LICENSE * ' , ' - f ' , ' - ▁ README * ' , ' - f ' , ' - ▁ bash / . bash _ history ' , # ▁ exclude ▁ from ▁ transfer , ENDCOM ' - f ' , ' P ▁ bash / . bash _ history ' , # ▁ but ▁ Protect ▁ against ▁ deletion ENDCOM ' - f ' , ' - ▁ bash / . bashrc _ after ' , ' - f ' , ' P ▁ bash / . bashrc _ after ' , ' - f ' , ' - ▁ bash / . bashrc . mini ' , ' - f ' , " . - ▁ $ ENV { REPOS _ BASE } / config / dotfiles / . gitignore " , ' - f ' , ' - ▁ config / dotfiles / . inputrc . mini ' , ' - f ' , ' + ▁ config / dotfiles / ' , ' - f ' , ' + ▁ config / dotfiles / * * ' , ' - f ' , ' - ▁ config / * * ' , ' - f ' , ' + ▁ scripts / db - create ' , ' - f ' , ' + ▁ scripts / pg . pl ' , ' - f ' , ' + ▁ scripts / mkconfig . sh ' , ' - f ' , ' - ▁ scripts / * * ' , ' - f ' , ' - ▁ zsh / after / ssh . alt ' , " $ ENV { REPOS _ BASE } / fzf " , " $ ENV { REPOS _ BASE } / bash " , " $ ENV { REPOS _ BASE } / config " , " $ ENV { REPOS _ BASE } / scripts " , " $ ENV { REPOS _ BASE } / zsh " , " $ remote : ~ / $ base " ; push my @ codes , $ ? ; # ▁ Vim ▁ repo ▁ sync ENDCOM # ▁ - f ' : - ▁ . gitignore ' ▁ can ' t ▁ be ▁ used , ▁ as ▁ this ▁ way ▁ we ▁ also ▁ exclude ▁ patterns ▁ from ENDCOM # ▁ the ▁ plugins ▁ . gitignore ▁ files ▁ and ▁ that ▁ is ▁ too ▁ much . ▁ also , ▁ . gitignore ▁ might ENDCOM # ▁ include ▁ peculiar ▁ patterns ▁ like ▁ ! plugged / vsearch ENDCOM # ▁ local ▁ check ▁ for ▁ CSApprox ▁ plugin ENDCOM if ( - d " $ ENV { REPOS _ BASE } / vim / plugged / csapprox " ) { system ' rsync ' , " - ai $ dry " , ' - - no - o ' , ' - - no - g ' , $del , ' - e ' , ' ssh ▁ - q ' , ' - f ' , ' - ▁ . git ' , ' - f ' , ' - ▁ . gitignore ' , ' - f ' , " . - ▁ $ ENV { REPOS _ BASE } / config / dotfiles / . gitignore " , ' - f ' , " . ▁ $ ENV { REPOS _ BASE } / vim / extra / excludes " , " $ ENV { REPOS _ BASE } / vim " , " $ remote : ~ / $ base " ; push @ codes , $ ? ; } else { warn << ' MSG ' ; The CSApprox plugin folder is missing . Please run the following in Vim : Plug ' godlygeek / csapprox ' | PlugInstall MSG } if ( grep { $_ != 0 } @ codes ) { return 0 ; } else { return 1 ; } } # ▁ Single ▁ host ENDCOM if ( @ hosts == 1 ) { sync shift ; exit ; } # ▁ Multiple ▁ hosts ENDCOM my @ children ; foreach ( @ hosts ) { # ▁ parent ENDCOM my $pid = fork / / die " failed ▁ to ▁ fork : ▁ $ ! " ; if ( $pid ) { push @ children , $pid ; next ; } # ▁ kid ENDCOM say ; sync $_ or die " Error ▁ with : ▁ $ _ \n " ; exit ; } waitpid $_ , 0 foreach @ children ; </DOCUMENT>
<DOCUMENT_ID="hbilar/engineering-web-tools/tree/master/cgi-bin/index-plate-image-gen.pl"> # ! / usr / bin / perl ENDCOM use GD :: Simple ; use CGI ; use CGI :: Carp qw ( fatalsToBrowser ) ; my @ circles = ( 9 , 10 , 11 ) ; # ▁ Number ▁ of ▁ dots ▁ on ▁ circles ENDCOM my $canvasX = 1024 ; # ▁ X ▁ size ▁ of ▁ canvas ENDCOM my $canvasY = 1024 ; # ▁ Y ▁ size ▁ of ▁ canvas ENDCOM my $centerX = $canvasX / 2 ; my $centerY = $canvasY / 2 ; my $holeDia = 10 ; # ▁ Diameter ▁ of ▁ indexing ▁ marks ENDCOM my $scaleX = 1 ; # ▁ X ▁ scale ▁ factor ENDCOM my $scaleY = 1 ; # ▁ Y ▁ scale ▁ factor ENDCOM my $initialCircleRad = 80 ; # ▁ Initial ▁ radius ▁ of ▁ first ▁ circle ENDCOM my $circleRadStep = 40 ; # ▁ How ▁ much ▁ further ▁ out ▁ the ▁ next ▁ circle ▁ will ▁ be ▁ drawn ENDCOM my $circleOutline = 1 ; # ▁ Set ▁ to ▁ 1 ▁ to ▁ generate ▁ a ▁ circle ▁ connecting ▁ the ▁ " dots " > ENDCOM my $numberHoles = 0 ; # ▁ Set ▁ to ▁ 1 ▁ / ▁ true ▁ to ▁ mark ▁ the ▁ holes ▁ with ▁ a ▁ " number " ▁ id ENDCOM my $numberTextSize = 12 ; # ▁ Size ▁ of ▁ font ▁ for ▁ hole ▁ numbers ENDCOM my $numberTextOffsetX = 10 ; # ▁ How ▁ far ▁ away ▁ the ▁ text ▁ should ▁ end ▁ up ENDCOM my $numberTextOffsetY = $numberTextSize / 2 ; my $drawScaleBars = 1 ; # ▁ If ▁ yes , ▁ draw ▁ an ▁ X / Y ▁ bar ▁ to ▁ calculate ▁ the ▁ scale ▁ factor ENDCOM my $img = GD :: Simple -> new ( $canvasX , $canvasY ) ; $img -> font ( ' Times : italic ' ) ; $img -> fontsize ( $numberTextSize ) ; sub DrawCentreHole { my $img = shift ; $img -> moveTo ( $centerX , $centerY ) ; $img -> ellipse ( $holeDia , $holeDia ) ; } sub DrawCircleOutlines { my $img = shift ; my $circleRad = shift ; $img -> moveTo ( $centerX , $centerY ) ; $img -> ellipse ( 2 * $scaleX * $circleRad , 2 * $scaleY * $circleRad ) ; } sub DrawHoleCircle { my $img = shift ; my $holes = shift ; my $circleRad = shift ; my $numberHoles = shift ; # ▁ Draw ▁ cirle ▁ of ▁ holes ENDCOM my $arcStep = 360.0 / $holes ; for ( my $i = 1 ; $i <= $holes ; $i ++ ) { # ▁ Move ▁ pointer ▁ to ▁ new ▁ location ENDCOM my $curX = $centerX + $scaleX * $circleRad * cos ( ( - 90 + ( $i - 1 ) * $arcStep ) * 3.14 / 180 ) ; my $curY = $centerY + $scaleY * $circleRad * sin ( ( - 90 + ( $i - 1 ) * $arcStep ) * 3.14 / 180 ) ; $img -> moveTo ( $curX , $curY ) ; $img -> fgcolor ( ' black ' ) ; $img -> bgcolor ( ' yellow ' ) ; $img -> ellipse ( $holeDia , $holeDia ) ; if ( $numberHoles == 1 ) { $img -> moveTo ( $curX + $numberTextOffsetX , $curY + $numberTextOffsetY ) ; $img -> string ( $i ) ; } } } my $q = CGI -> new ; # ▁ Get ▁ parameters ENDCOM { # ▁ open ▁ ( FILE , ▁ " > / tmp / f " ) ▁ or ▁ die ▁ " blah " ; ENDCOM # ▁ Get ▁ number ▁ of ▁ holes ▁ for ▁ circles ENDCOM if ( $q -> param ( ' numholes ' ) ) { my $v = $q -> param ( ' numholes ' ) ; my @ e = split ( " , " , $v ) ; my @ tmpCircles = ( ) ; foreach my $e ( @ e ) { if ( $e = ~ m / ( [ 0 - 9 ] + ) / ) { push @ tmpCircles , $1 ; } } @ circles = @ tmpCircles ; } # ▁ Should ▁ we ▁ draw ▁ outlines ENDCOM if ( $q -> param ( ' circleOutline ' ) eq " on " ) { $circleOutline = 1 ; } else { $circleOutline = 0 ; } # ▁ Should ▁ we ▁ label ▁ holes ENDCOM if ( $q -> param ( ' numberHoles ' ) eq " on " ) { $numberHoles = 1 ; } # ▁ Initial ▁ rad ENDCOM if ( $q -> param ( ' initialCircleRad ' ) ) { my $v = $q -> param ( ' initialCircleRad ' ) ; if ( $v = ~ m / ( [ 0 - 9 ] + ) / ) { my $v1 = $v ; if ( ( $v1 < 1000 ) && ( $v1 > 1 ) ) { $initialCircleRad = $v ; # TABSYMBOL TABSYMBOL print ▁ FILE ▁ " v ▁ = ▁ $ v1 \n " ; ENDCOM } } } # ▁ Rad ▁ step ENDCOM if ( $q -> param ( ' circleRadStep ' ) ) { my $v = $q -> param ( ' circleRadStep ' ) ; if ( $v = ~ m / ( [ 0 - 9 ] + ) / ) { my $v1 = $v ; if ( ( $v1 < 500 ) && ( $v1 > 1 ) ) { $circleRadStep = $v ; } } } # ▁ scaleX ENDCOM if ( $q -> param ( ' scaleX ' ) ) { my $v = $q -> param ( ' scaleX ' ) ; if ( $v = ~ m / ( [ 0 - 9 \ . ] + ) / ) { my $v1 = $v ; if ( ( $v1 < 30 ) && ( $v1 > 0 ) ) { $scaleX = $v1 ; # TABSYMBOL TABSYMBOL print ▁ FILE ▁ " scaleX ▁ = ▁ $ v1 \n " ; ENDCOM } } } # ▁ scaleY ENDCOM if ( $q -> param ( ' scaleY ' ) ) { my $v = $q -> param ( ' scaleY ' ) ; if ( $v = ~ m / ( [ 0 - 9 \ . ] + ) / ) { my $v1 = $v ; if ( ( $v1 < 30 ) && ( $v1 > 0 ) ) { $scaleY = $v1 ; # TABSYMBOL TABSYMBOL print ▁ FILE ▁ " scaleY ▁ = ▁ $ v1 \n " ; ENDCOM } } } # ▁ close ▁ FILE ; ENDCOM } # ▁ Draw ▁ outlines ▁ for ▁ the ▁ circles ▁ if ▁ required ENDCOM my $circleRad = $initialCircleRad + scalar ( @ circles ) * $circleRadStep ; if ( $circleOutline ) { foreach my $h ( @ circles ) { $circleRad -= $circleRadStep ; DrawCircleOutlines ( $img , $circleRad ) ; } } # ▁ Draw ▁ the ▁ centre ▁ marker ▁ ENDCOM DrawCentreHole ( $img ) ; # ▁ Draw ▁ the ▁ actual ▁ " hole ▁ circle " ENDCOM $circleRad = $initialCircleRad ; foreach my $h ( @ circles ) { DrawHoleCircle ( $img , $h , $circleRad , $numberHoles , $circleOutline ) ; $circleRad += $circleRadStep ; } # ▁ Draw ▁ scale ▁ bars ENDCOM if ( $drawScaleBars ) { # ▁ Draw ▁ two ▁ lines ▁ so ▁ that ▁ the ▁ user ▁ can ▁ calculate ▁ the ▁ print ▁ scale ENDCOM # ▁ X ▁ line ENDCOM $img -> moveTo ( $canvasX / 10 , ( 1 - 1 / 10 ) * $canvasY ) ; $img -> line ( 3 * $canvasX / 10 , 0 ) ; # ▁ Y ▁ line ENDCOM $img -> moveTo ( $canvasX / 10 , ( 1 - 1 / 10 ) * $canvasY ) ; $img -> line ( 0 , - 3 * $canvasX / 10 ) ; } print $q -> header ( ' image / png ' ) ; print $img -> png ; </DOCUMENT>
<DOCUMENT_ID="aferr/TemporalPartitioningMemCtl/tree/master/benchmarks/spec2k6bin/specint/perl_depends/lib/unicore/lib/hst/V.pl"> # ▁ ! ! ! ! ! ▁ DO ▁ NOT ▁ EDIT ▁ THIS ▁ FILE ▁ ! ! ! ! ! ▁ ENDCOM # ▁ This ▁ file ▁ is ▁ built ▁ by ▁ mktables ▁ from ▁ e . g . ▁ UnicodeData . txt . ENDCOM # ▁ Any ▁ changes ▁ made ▁ here ▁ will ▁ be ▁ lost ! ENDCOM # ▁ HangulSyllableType ▁ category ▁ ' Vowel _ Jamo ' ENDCOM return << ' END ' ; 1160 11 A2 END </DOCUMENT>
<DOCUMENT_ID="amidoimidazol/bio_info/tree/master/Beginning Perl for Bioinformatics/lib/unicore/lib/Scx/Armi.pl"> # ▁ ! ! ! ! ! ▁ DO ▁ NOT ▁ EDIT ▁ THIS ▁ FILE ▁ ! ! ! ! ! ENDCOM # ▁ This ▁ file ▁ is ▁ machine - generated ▁ by ▁ mktables ▁ from ▁ the ▁ Unicode ENDCOM # ▁ database , ▁ Version ▁ 6.1.0 . ▁ Any ▁ changes ▁ made ▁ here ▁ will ▁ be ▁ lost ! ENDCOM # ▁ ! ! ! ! ! ▁ INTERNAL ▁ PERL ▁ USE ▁ ONLY ▁ ! ! ! ! ! ENDCOM # ▁ This ▁ file ▁ is ▁ for ▁ internal ▁ use ▁ by ▁ core ▁ Perl ▁ only . ▁ The ▁ format ▁ and ▁ even ▁ the ENDCOM # ▁ name ▁ or ▁ existence ▁ of ▁ this ▁ file ▁ are ▁ subject ▁ to ▁ change ▁ without ▁ notice . ▁ Don ' t ENDCOM # ▁ use ▁ it ▁ directly . ENDCOM return << ' END ' ; 10840 10855 10857 1085F END </DOCUMENT>
<DOCUMENT_ID="kimrutherford/afra/tree/master/tests/pl/bin/fasta_to_fkfa.pl"> # ! / usr / bin / env ▁ perl ENDCOM use strict ; use warnings ; use JSON 2 ; use lib ' tests / perl _ tests / lib ' ; use FakeFasta ; my @ seqs ; for ( @ ARGV ) { push @ seqs , @ { FakeFasta -> fasta_to_fkfa ( $_ ) || [ ] } ; } print to_json ( \ @ seqs ) ; </DOCUMENT>
<DOCUMENT_ID="aliyun-beta/aliyun-openapi-cpp-sdk/tree/master/aliyun_api_core/third_party/mbedtls-2.1.2/tests/scripts/gen_ctr_drbg.pl"> # ! / usr / bin / perl ENDCOM # ▁ Based ▁ on ▁ NIST ▁ CTR _ DRBG . rsp ▁ validation ▁ file ENDCOM # ▁ Only ▁ uses ▁ AES - 256 - CTR ▁ cases ▁ that ▁ use ▁ a ▁ Derivation ▁ function ENDCOM # ▁ and ▁ concats ▁ nonce ▁ and ▁ personalization ▁ for ▁ initialization . ENDCOM use strict ; my $file = shift ; open ( TEST_DATA , " $ file " ) or die " Opening ▁ test ▁ cases ▁ ' $ file ' : ▁ $ ! " ; sub get_suite_val ( $ ) { my $name = shift ; my $val = " " ; my $line = < TEST_DATA > ; ( $val ) = ( $line = ~ / \ [ $name \ s \ = \ s ( \ w + ) \ ] / ) ; return $val ; } sub get_val ( $ ) { my $name = shift ; my $val = " " ; my $line ; while ( $line = < TEST_DATA > ) { next if ( $line ! ~ /= / ) ; last ; } ( $val ) = ( $line = ~ / ^ $name = ( \ w + ) / ) ; return $val ; } my $cnt = 1 ; ; while ( my $line = < TEST_DATA > ) { next if ( $line ! ~ / ^ \ [ AES - 256 use df / ) ; my $PredictionResistanceStr = get_suite_val ( " PredictionResistance " ) ; my $PredictionResistance = 0 ; $PredictionResistance = 1 if ( $PredictionResistanceStr eq ' True ' ) ; my $EntropyInputLen = get_suite_val ( " EntropyInputLen " ) ; my $NonceLen = get_suite_val ( " NonceLen " ) ; my $PersonalizationStringLen = get_suite_val ( " PersonalizationStringLen " ) ; my $AdditionalInputLen = get_suite_val ( " AdditionalInputLen " ) ; for ( $cnt = 0 ; $cnt < 15 ; $cnt ++ ) { my $Count = get_val ( " COUNT " ) ; my $EntropyInput = get_val ( " EntropyInput " ) ; my $Nonce = get_val ( " Nonce " ) ; my $PersonalizationString = get_val ( " PersonalizationString " ) ; my $AdditionalInput1 = get_val ( " AdditionalInput " ) ; my $EntropyInputPR1 = get_val ( " EntropyInputPR " ) if ( $PredictionResistance == 1 ) ; my $EntropyInputReseed = get_val ( " EntropyInputReseed " ) if ( $PredictionResistance == 0 ) ; my $AdditionalInputReseed = get_val ( " AdditionalInputReseed " ) if ( $PredictionResistance == 0 ) ; my $AdditionalInput2 = get_val ( " AdditionalInput " ) ; my $EntropyInputPR2 = get_val ( " EntropyInputPR " ) if ( $PredictionResistance == 1 ) ; my $ReturnedBits = get_val ( " ReturnedBits " ) ; if ( $PredictionResistance == 1 ) { print ( " CTR _ DRBG ▁ NIST ▁ Validation ▁ ( AES - 256 ▁ use ▁ df , $ PredictionResistanceStr , $ EntropyInputLen , $ NonceLen , $ PersonalizationStringLen , $ AdditionalInputLen ) ▁ # $ Count \n " ) ; print ( " ctr _ drbg _ validate _ pr " ) ; print ( " : \ " $ Nonce $ PersonalizationString\ " " ) ; print ( " : \ " $ EntropyInput $ EntropyInputPR1 $ EntropyInputPR2\ " " ) ; print ( " : \ " $ AdditionalInput1\ " " ) ; print ( " : \ " $ AdditionalInput2\ " " ) ; print ( " : \ " $ ReturnedBits\ " " ) ; print ( " \n \n " ) ; } else { print ( " CTR _ DRBG ▁ NIST ▁ Validation ▁ ( AES - 256 ▁ use ▁ df , $ PredictionResistanceStr , $ EntropyInputLen , $ NonceLen , $ PersonalizationStringLen , $ AdditionalInputLen ) ▁ # $ Count \n " ) ; print ( " ctr _ drbg _ validate _ nopr " ) ; print ( " : \ " $ Nonce $ PersonalizationString\ " " ) ; print ( " : \ " $ EntropyInput $ EntropyInputReseed\ " " ) ; print ( " : \ " $ AdditionalInput1\ " " ) ; print ( " : \ " $ AdditionalInputReseed\ " " ) ; print ( " : \ " $ AdditionalInput2\ " " ) ; print ( " : \ " $ ReturnedBits\ " " ) ; print ( " \n \n " ) ; } } } close ( TEST_DATA ) ; </DOCUMENT>
<DOCUMENT_ID="padovan/bluetooth-next/tree/master/scripts/namespace.pl"> # ! / usr / bin / perl ▁ - w ENDCOM # TABSYMBOL namespace . pl . ▁ Mon ▁ Aug ▁ 30 ▁ 2004 ENDCOM # TABSYMBOL Perform ▁ a ▁ name ▁ space ▁ analysis ▁ on ▁ the ▁ linux ▁ kernel . ENDCOM # TABSYMBOL Copyright ▁ Keith ▁ Owens ▁ < kaos @ ocs . com . au > . ▁ GPL . ENDCOM # TABSYMBOL Invoke ▁ by ▁ changing ▁ directory ▁ to ▁ the ▁ top ▁ of ▁ the ▁ kernel ▁ object ENDCOM # TABSYMBOL tree ▁ then ▁ namespace . pl , ▁ no ▁ parameters . ENDCOM # TABSYMBOL Tuned ▁ for ▁ 2.1 . x ▁ kernels ▁ with ▁ the ▁ new ▁ module ▁ handling , ▁ it ▁ will ENDCOM # TABSYMBOL work ▁ with ▁ 2.0 ▁ kernels ▁ as ▁ well . ENDCOM # TABSYMBOL Last ▁ change ▁ 2.6.9 - rc1 , ▁ adding ▁ support ▁ for ▁ separate ▁ source ▁ and ▁ object ENDCOM # TABSYMBOL trees . ENDCOM # TABSYMBOL The ▁ source ▁ must ▁ be ▁ compiled / assembled ▁ first , ▁ the ▁ object ▁ files ENDCOM # TABSYMBOL are ▁ the ▁ primary ▁ input ▁ to ▁ this ▁ script . ▁ Incomplete ▁ or ▁ missing ENDCOM # TABSYMBOL objects ▁ will ▁ result ▁ in ▁ a ▁ flawed ▁ analysis . ▁ Compile ▁ both ▁ vmlinux ENDCOM # TABSYMBOL and ▁ modules . ENDCOM # TABSYMBOL Even ▁ with ▁ complete ▁ objects , ▁ treat ▁ the ▁ result ▁ of ▁ the ▁ analysis ENDCOM # TABSYMBOL with ▁ caution . ▁ Some ▁ external ▁ references ▁ are ▁ only ▁ used ▁ by ENDCOM # TABSYMBOL certain ▁ architectures , ▁ others ▁ with ▁ certain ▁ combinations ▁ of ENDCOM # TABSYMBOL configuration ▁ parameters . ▁ Ideally ▁ the ▁ source ▁ should ▁ include ENDCOM # TABSYMBOL something ▁ like ENDCOM # TABSYMBOL # ifndef ▁ CONFIG _ . . . ENDCOM # TABSYMBOL static ENDCOM # TABSYMBOL # endif ENDCOM # TABSYMBOL symbol _ definition ; ENDCOM # TABSYMBOL so ▁ the ▁ symbols ▁ are ▁ defined ▁ as ▁ static ▁ unless ▁ a ▁ particular ENDCOM # TABSYMBOL CONFIG _ . . . ▁ requires ▁ it ▁ to ▁ be ▁ external . ENDCOM # TABSYMBOL A ▁ symbol ▁ that ▁ is ▁ suffixed ▁ with ▁ ' ( export ▁ only ) ' ▁ has ▁ these ▁ properties ENDCOM # TABSYMBOL * ▁ It ▁ is ▁ global . ENDCOM # TABSYMBOL * ▁ It ▁ is ▁ marked ▁ EXPORT _ SYMBOL ▁ or ▁ EXPORT _ SYMBOL _ GPL , ▁ either ▁ in ▁ the ▁ same ENDCOM # TABSYMBOL ▁ source ▁ file ▁ or ▁ a ▁ different ▁ source ▁ file . ENDCOM # TABSYMBOL * ▁ Given ▁ the ▁ current ▁ . config , ▁ nothing ▁ uses ▁ the ▁ symbol . ENDCOM # TABSYMBOL The ▁ symbol ▁ is ▁ a ▁ candidate ▁ for ▁ conversion ▁ to ▁ static , ▁ plus ▁ removal ▁ of ▁ the ENDCOM # TABSYMBOL export . ▁ But ▁ be ▁ careful ▁ that ▁ a ▁ different ▁ . config ▁ might ▁ use ▁ the ▁ symbol . ENDCOM # TABSYMBOL Name ▁ space ▁ analysis ▁ and ▁ cleanup ▁ is ▁ an ▁ iterative ▁ process . ▁ You ▁ cannot ENDCOM # TABSYMBOL expect ▁ to ▁ find ▁ all ▁ the ▁ problems ▁ in ▁ a ▁ single ▁ pass . ENDCOM # TABSYMBOL * ▁ Identify ▁ possibly ▁ unnecessary ▁ global ▁ declarations , ▁ verify ▁ that ▁ they ENDCOM # TABSYMBOL ▁ really ▁ are ▁ unnecessary ▁ and ▁ change ▁ them ▁ to ▁ static . ENDCOM # TABSYMBOL * ▁ Compile ▁ and ▁ fix ▁ up ▁ gcc ▁ warnings ▁ about ▁ static , ▁ removing ▁ dead ▁ symbols ENDCOM # TABSYMBOL ▁ as ▁ necessary . ENDCOM # TABSYMBOL * ▁ make ▁ clean ▁ and ▁ rebuild ▁ with ▁ different ▁ configs ▁ ( especially ENDCOM # TABSYMBOL ▁ CONFIG _ MODULES = n ) ▁ to ▁ see ▁ which ▁ symbols ▁ are ▁ being ▁ defined ▁ when ▁ the ENDCOM # TABSYMBOL ▁ config ▁ does ▁ not ▁ require ▁ them . ▁ These ▁ symbols ▁ bloat ▁ the ▁ kernel ▁ object ENDCOM # TABSYMBOL ▁ for ▁ no ▁ good ▁ reason , ▁ which ▁ is ▁ frustrating ▁ for ▁ embedded ▁ systems . ENDCOM # TABSYMBOL * ▁ Wrap ▁ config ▁ sensitive ▁ symbols ▁ in ▁ # ifdef ▁ CONFIG _ foo , ▁ as ▁ long ▁ as ▁ the ENDCOM # TABSYMBOL ▁ code ▁ does ▁ not ▁ get ▁ too ▁ ugly . ENDCOM # TABSYMBOL * ▁ Repeat ▁ the ▁ name ▁ space ▁ analysis ▁ until ▁ you ▁ can ▁ live ▁ with ▁ with ▁ the ENDCOM # TABSYMBOL ▁ result . ENDCOM require 5 ; # ▁ at ▁ least ▁ perl ▁ 5 ENDCOM use strict ; use File :: Find ; my $nm = ( $ENV { ' NM ' } || " nm " ) . " ▁ - p " ; my $objdump = ( $ENV { ' OBJDUMP ' } || " objdump " ) . " ▁ - s ▁ - j ▁ . comment " ; my $srctree = " " ; my $objtree = " " ; $srctree = " $ ENV { ' srctree ' } / " if ( exists ( $ENV { ' srctree ' } ) ) ; $objtree = " $ ENV { ' objtree ' } / " if ( exists ( $ENV { ' objtree ' } ) ) ; if ( $ # ARGV ▁ ! = ▁ - 1 ) ▁ { ENDCOM print STDERR " usage : ▁ $ 0 ▁ takes ▁ no ▁ parameters \n " ; die ( " giving ▁ up \n " ) ; } my % nmdata = ( ) ; # ▁ nm ▁ data ▁ for ▁ each ▁ object ENDCOM my % def = ( ) ; # ▁ all ▁ definitions ▁ for ▁ each ▁ name ENDCOM my % ksymtab = ( ) ; # ▁ names ▁ that ▁ appear ▁ in ▁ _ _ ksymtab _ ENDCOM my % ref = ( ) ; # ▁ $ ref { $ name } ▁ exists ▁ if ▁ there ▁ is ▁ a ▁ true ▁ external ▁ reference ▁ to ▁ $ name ENDCOM my % export = ( ) ; # ▁ $ export { $ name } ▁ exists ▁ if ▁ there ▁ is ▁ an ▁ EXPORT _ . . . ▁ of ▁ $ name ENDCOM my % nmexception = ( ' fs / ext3 / bitmap ' = > 1 , ' fs / ext4 / bitmap ' = > 1 , ' arch / x86 / lib / thunk _ 32' = > 1 , ' arch / x86 / lib / cmpxchg ' = > 1 , ' arch / x86 / vdso / vdso32 / note ' = > 1 , ' lib / irq _ regs ' = > 1 , ' usr / initramfs _ data ' = > 1 , ' drivers / scsi / aic94xx / aic94xx _ dump ' = > 1 , ' drivers / scsi / libsas / sas _ dump ' = > 1 , ' lib / dec _ and _ lock ' = > 1 , ' drivers / ide / ide - probe - mini ' = > 1 , ' usr / initramfs _ data ' = > 1 , ' drivers / acpi / acpia / exdump ' = > 1 , ' drivers / acpi / acpia / rsdump ' = > 1 , ' drivers / acpi / acpia / nsdumpdv ' = > 1 , ' drivers / acpi / acpia / nsdump ' = > 1 , ' arch / ia64 / sn / kernel / sn2 / io ' = > 1 , ' arch / ia64 / kernel / gate - data ' = > 1 , ' security / capability ' = > 1 , ' fs / ntfs / sysctl ' = > 1 , ' fs / jfs / jfs _ debug ' = > 1 , ) ; my % nameexception = ( ' mod _ use _ count _ ' = > 1 , ' _ _ initramfs _ end ' = > 1 , ' _ _ initramfs _ start ' = > 1 , ' _ einittext ' = > 1 , ' _ sinittext ' = > 1 , ' kallsyms _ names ' = > 1 , ' kallsyms _ num _ syms ' = > 1 , ' kallsyms _ addresses ' = > 1 , ' _ _ this _ module ' = > 1 , ' _ etext ' = > 1 , ' _ edata ' = > 1 , ' _ end ' = > 1 , ' _ _ bss _ start ' = > 1 , ' _ text ' = > 1 , ' _ stext ' = > 1 , ' _ _ gp ' = > 1 , ' ia64 _ unw _ start ' = > 1 , ' ia64 _ unw _ end ' = > 1 , ' _ _ init _ begin ' = > 1 , ' _ _ init _ end ' = > 1 , ' _ _ bss _ stop ' = > 1 , ' _ _ nosave _ begin ' = > 1 , ' _ _ nosave _ end ' = > 1 , ' pg0' = > 1 , ' vdso _ enabled ' = > 1 , ' _ _ stack _ chk _ fail ' = > 1 , ' VDSO32 _ PRELINK ' = > 1 , ' VDSO32 _ vsyscall ' = > 1 , ' VDSO32 _ rt _ sigreturn ' = > 1 , ' VDSO32 _ sigreturn ' = > 1 , ) ; & find ( \ & linux_objects , ' . ' ) ; # ▁ find ▁ the ▁ objects ▁ and ▁ do _ nm ▁ on ▁ them ENDCOM & list_multiply_defined ( ) ; & resolve_external_references ( ) ; & list_extra_externals ( ) ; exit ( 0 ) ; sub linux_objects { # ▁ Select ▁ objects , ▁ ignoring ▁ objects ▁ which ▁ are ▁ only ▁ created ▁ by ENDCOM # ▁ merging ▁ other ▁ objects . ▁ Also ▁ ignore ▁ all ▁ of ▁ modules , ▁ scripts ENDCOM # ▁ and ▁ compressed . ▁ Most ▁ conglomerate ▁ objects ▁ are ▁ handled ▁ by ▁ do _ nm , ENDCOM # ▁ this ▁ list ▁ only ▁ contains ▁ the ▁ special ▁ cases . ▁ These ▁ include ▁ objects ENDCOM # ▁ that ▁ are ▁ linked ▁ from ▁ just ▁ one ▁ other ▁ object ▁ and ▁ objects ▁ for ▁ which ENDCOM # ▁ there ▁ is ▁ really ▁ no ▁ permanent ▁ source ▁ file . ENDCOM my $basename = $_ ; $_ = $File :: Find :: name ; s : ^ \ . / :: ; if ( / . * \ . o$ / && ! ( m : / built - in . o$ : || m : arch / x86 / vdso / : || m : arch / x86 / boot / : || m : arch / ia64 / ia32 / ia32 . o$ : || m : arch / ia64 / kernel / gate - syms . o$ : || m : arch / ia64 / lib / __divdi3 . o$ : || m : arch / ia64 / lib / __divsi3 . o$ : || m : arch / ia64 / lib / __moddi3 . o$ : || m : arch / ia64 / lib / __modsi3 . o$ : || m : arch / ia64 / lib / __udivdi3 . o$ : || m : arch / ia64 / lib / __udivsi3 . o$ : || m : arch / ia64 / lib / __umoddi3 . o$ : || m : arch / ia64 / lib / __umodsi3 . o$ : || m : arch / ia64 / scripts / check_gas_for_hint . o$ : || m : arch / ia64 / sn / kernel / xp . o$ : || m : boot / bbootsect . o$ : || m : boot / bsetup . o$ : || m : / bootsect . o$ : || m : / boot / setup . o$ : || m : / compressed / : || m : drivers / cdrom / driver . o$ : || m : drivers / char / drm / tdfx_drv . o$ : || m : drivers / ide / ide - detect . o$ : || m : drivers / ide / pci / idedriver - pci . o$ : || m : drivers / media / media . o$ : || m : drivers / scsi / sd_mod . o$ : || m : drivers / video / video . o$ : || m : fs / devpts / devpts . o$ : || m : fs / exportfs / exportfs . o$ : || m : fs / hugetlbfs / hugetlbfs . o$ : || m : fs / msdos / msdos . o$ : || m : fs / nls / nls . o$ : || m : fs / ramfs / ramfs . o$ : || m : fs / romfs / romfs . o$ : || m : fs / vfat / vfat . o$ : || m : init / mounts . o$ : || m : ^ modules / : || m : net / netlink / netlink . o$ : || m : net / sched / sched . o$ : || m : / piggy . o$ : || m : ^ scripts / : || m : sound / . * / snd - : || m : ^ . * / \ . tmp_ : || m : ^ \ . tmp_ : || m : / vmlinux - obj . o$ : || m : ^ tools / : ) ) { do_nm ( $basename , $_ ) ; } $_ = $basename ; # ▁ File : : Find ▁ expects ▁ $ _ ▁ untouched ▁ ( undocumented ) ENDCOM } sub do_nm { my ( $basename , $fullname ) = @ _ ; my ( $source , $type , $name ) ; if ( ! - e $basename ) { printf STDERR " $ basename ▁ does ▁ not ▁ exist \n " ; return ; } if ( $fullname ! ~ / \ . o$ / ) { printf STDERR " $ fullname ▁ is ▁ not ▁ an ▁ object ▁ file \n " ; return ; } ( $source = $basename ) = ~ s / \ . o$ / / ; if ( - e " $ source . c " || - e " $ source . S " ) { $source = " $ objtree $ File : : Find : : dir / $ source " ; } else { $source = " $ srctree $ File : : Find : : dir / $ source " ; } if ( ! - e " $ source . c " && ! - e " $ source . S " ) { # ▁ No ▁ obvious ▁ source , ▁ exclude ▁ the ▁ object ▁ if ▁ it ▁ is ▁ conglomerate ENDCOM open ( my $objdumpdata , " $ objdump ▁ $ basename | " ) or die " $ objdump ▁ $ fullname ▁ failed ▁ $ ! \n " ; my $comment ; while ( < $objdumpdata > ) { chomp ( ) ; if ( / ^ In archive / ) { # ▁ Archives ▁ are ▁ always ▁ conglomerate ENDCOM $comment = " GCC : GCC : " ; last ; } next if ( ! / ^ [ 0 - 9 a - f ] { 5 , } / ) ; $comment . = substr ( $_ , 43 ) ; } close ( $objdumpdata ) ; if ( ! defined ( $comment ) || $comment ! ~ / GCC \ : . * GCC \ : / m ) { printf STDERR " No ▁ source ▁ file ▁ found ▁ for ▁ $ fullname \n " ; } return ; } open ( my $nmdata , " $ nm ▁ $ basename | " ) or die " $ nm ▁ $ fullname ▁ failed ▁ $ ! \n " ; my @ nmdata ; while ( < $nmdata > ) { chop ; ( $type , $name ) = ( split ( / + / , $_ , 3 ) ) [ 1. .2 ] ; # ▁ Expected ▁ types ENDCOM # ▁ A ▁ absolute ▁ symbol ENDCOM # ▁ B ▁ weak ▁ external ▁ reference ▁ to ▁ data ▁ that ▁ has ▁ been ▁ resolved ENDCOM # ▁ C ▁ global ▁ variable , ▁ uninitialised ENDCOM # ▁ D ▁ global ▁ variable , ▁ initialised ENDCOM # ▁ G ▁ global ▁ variable , ▁ initialised , ▁ small ▁ data ▁ section ENDCOM # ▁ R ▁ global ▁ array , ▁ initialised ENDCOM # ▁ S ▁ global ▁ variable , ▁ uninitialised , ▁ small ▁ bss ENDCOM # ▁ T ▁ global ▁ label / procedure ENDCOM # ▁ U ▁ external ▁ reference ENDCOM # ▁ W ▁ weak ▁ external ▁ reference ▁ to ▁ text ▁ that ▁ has ▁ been ▁ resolved ENDCOM # ▁ V ▁ similar ▁ to ▁ W , ▁ but ▁ the ▁ value ▁ of ▁ the ▁ weak ▁ symbol ▁ becomes ▁ zero ▁ with ▁ no ▁ error . ENDCOM # ▁ a ▁ assembler ▁ equate ENDCOM # ▁ b ▁ static ▁ variable , ▁ uninitialised ENDCOM # ▁ d ▁ static ▁ variable , ▁ initialised ENDCOM # ▁ g ▁ static ▁ variable , ▁ initialised , ▁ small ▁ data ▁ section ENDCOM # ▁ r ▁ static ▁ array , ▁ initialised ENDCOM # ▁ s ▁ static ▁ variable , ▁ uninitialised , ▁ small ▁ bss ENDCOM # ▁ t ▁ static ▁ label / procedures ENDCOM # ▁ w ▁ weak ▁ external ▁ reference ▁ to ▁ text ▁ that ▁ has ▁ not ▁ been ▁ resolved ENDCOM # ▁ v ▁ similar ▁ to ▁ w ENDCOM # ▁ ? ▁ undefined ▁ type , ▁ used ▁ a ▁ lot ▁ by ▁ modules ENDCOM if ( $type ! ~ / ^ [ ABCDGRSTUWVabdgrstwv ? ] $ / ) { printf STDERR " nm ▁ output ▁ for ▁ $ fullname ▁ contains ▁ unknown ▁ type ▁ ' $ _ ' \n " ; } elsif ( $name = ~ / \ . / ) { # ▁ name ▁ with ▁ ' . ' ▁ is ▁ local ▁ static ENDCOM } else { $type = ' R ' if ( $type eq ' ? ' ) ; # ▁ binutils ▁ replaced ▁ ? ▁ with ▁ R ▁ at ▁ one ▁ point ENDCOM # ▁ binutils ▁ keeps ▁ changing ▁ the ▁ type ▁ for ▁ exported ▁ symbols , ▁ force ▁ it ▁ to ▁ R ENDCOM $type = ' R ' if ( $name = ~ / ^ __ksymtab / || $name = ~ / ^ __kstrtab / ) ; $name = ~ s / _R [ a - f0 - 9 ] { 8 } $ / / ; # ▁ module ▁ versions ▁ adds ▁ this ENDCOM if ( $type = ~ / [ ABCDGRSTWV ] / && $name ne ' init _ module ' && $name ne ' cleanup _ module ' && $name ne ' Using _ Versions ' && $name ! ~ / ^ Version_ [ 0 - 9 ] + $ / && $name ! ~ / ^ __parm_ / && $name ! ~ / ^ __kstrtab / && $name ! ~ / ^ __ksymtab / && $name ! ~ / ^ __kcrctab_ / && $name ! ~ / ^ __exitcall_ / && $name ! ~ / ^ __initcall_ / && $name ! ~ / ^ __kdb_initcall_ / && $name ! ~ / ^ __kdb_exitcall_ / && $name ! ~ / ^ __module_ / && $name ! ~ / ^ __mod_ / && $name ! ~ / ^ __crc_ / && $name ne ' _ _ this _ module ' && $name ne ' kernel _ version ' ) { if ( ! exists ( $def { $name } ) ) { $def { $name } = [ ] ; } push ( @ { $def { $name } } , $fullname ) ; } push ( @ nmdata , " $ type ▁ $ name " ) ; if ( $name = ~ / ^ __ksymtab_ / ) { $name = substr ( $name , 10 ) ; if ( ! exists ( $ksymtab { $name } ) ) { $ksymtab { $name } = [ ] ; } push ( @ { $ksymtab { $name } } , $fullname ) ; } } } close ( $nmdata ) ; if ( $ # nmdata ▁ < ▁ 0 ) ▁ { ENDCOM printf " No ▁ nm ▁ data ▁ for ▁ $ fullname \n " unless $nmexception { $fullname } ; return ; } $nmdata { $fullname } = \ @ nmdata ; } sub drop_def { my ( $object , $name ) = @ _ ; my $nmdata = $nmdata { $object } ; my ( $i , $j ) ; for ( $i = 0 ; $i <= $ # { $ nmdata } ; ▁ + + $ i ) ▁ { ENDCOM if ( $name eq ( split ( ' ▁ ' , $nmdata -> [ $i ] , 2 ) ) [ 1 ] ) { splice ( @ { $nmdata { $object } } , $i , 1 ) ; my $def = $def { $name } ; for ( $j = 0 ; $j < $ # { $ def { $ name } } ; ▁ + + $ j ) ▁ { ENDCOM if ( $def { $name } [ $j ] eq $object ) { splice ( @ { $def { $name } } , $j , 1 ) ; } } last ; } } } sub list_multiply_defined { foreach my $name ( keys ( % def ) ) { if ( $ # { $ def { $ name } } ▁ > ▁ 0 ) ▁ { ENDCOM # ▁ Special ▁ case ▁ for ▁ cond _ syscall ENDCOM if ( $ # { $ def { $ name } } ▁ = = ▁ 1 ▁ & & ENDCOM ( $name = ~ / ^ sys_ / || $name = ~ / ^ compat_sys_ / || $name = ~ / ^ sys32_ / ) ) { if ( $def { $name } [ 0 ] eq " kernel / sys _ ni . o " || $def { $name } [ 1 ] eq " kernel / sys _ ni . o " ) { & drop_def ( " kernel / sys _ ni . o " , $name ) ; next ; } } printf " $ name ▁ is ▁ multiply ▁ defined ▁ in ▁ : - \n " ; foreach my $module ( @ { $def { $name } } ) { printf " \t $ module \n " ; } } } } sub resolve_external_references { my ( $kstrtab , $ksymtab , $export ) ; printf " \n " ; foreach my $object ( keys ( % nmdata ) ) { my $nmdata = $nmdata { $object } ; for ( my $i = 0 ; $i <= $ # { $ nmdata } ; ▁ + + $ i ) ▁ { ENDCOM my ( $type , $name ) = split ( ' ▁ ' , $nmdata -> [ $i ] , 2 ) ; if ( $type eq " U " || $type eq " w " ) { if ( exists ( $def { $name } ) || exists ( $ksymtab { $name } ) ) { # ▁ add ▁ the ▁ owning ▁ object ▁ to ▁ the ▁ nmdata ENDCOM $nmdata -> [ $i ] = " $ type ▁ $ name ▁ $ object " ; # ▁ only ▁ count ▁ as ▁ a ▁ reference ▁ if ▁ it ▁ is ▁ not ▁ EXPORT _ . . . ENDCOM $kstrtab = " R ▁ _ _ kstrtab _ $ name " ; $ksymtab = " R ▁ _ _ ksymtab _ $ name " ; $export = 0 ; for ( my $j = 0 ; $j <= $ # { $ nmdata } ; ▁ + + $ j ) ▁ { ENDCOM if ( $nmdata -> [ $j ] eq $kstrtab || $nmdata -> [ $j ] eq $ksymtab ) { $export = 1 ; last ; } } if ( $export ) { $export { $name } = " " ; } else { $ref { $name } = " " } } elsif ( ! $nameexception { $name } && $name ! ~ / ^ __sched_text_ / && $name ! ~ / ^ __start_ / && $name ! ~ / ^ __end_ / && $name ! ~ / ^ __stop_ / && $name ! ~ / ^ __scheduling_functions_ . * _here / && $name ! ~ / ^ __ . * initcall_ / && $name ! ~ / ^ __ . * per_cpu_start / && $name ! ~ / ^ __ . * per_cpu_end / && $name ! ~ / ^ __alt_instructions / && $name ! ~ / ^ __setup_ / && $name ! ~ / ^ __mod_timer / && $name ! ~ / ^ __mod_page_state / && $name ! ~ / ^ init_module / && $name ! ~ / ^ cleanup_module / ) { printf " Cannot ▁ resolve ▁ " ; printf " weak ▁ " if ( $type eq " w " ) ; printf " reference ▁ to ▁ $ name ▁ from ▁ $ object \n " ; } } } } } sub list_extra_externals { my % noref = ( ) ; foreach my $name ( keys ( % def ) ) { if ( ! exists ( $ref { $name } ) ) { my @ module = @ { $def { $name } } ; foreach my $module ( @ module ) { if ( ! exists ( $noref { $module } ) ) { $noref { $module } = [ ] ; } push ( @ { $noref { $module } } , $name ) ; } } } if ( % noref ) { printf " \n Externally ▁ defined ▁ symbols ▁ with ▁ no ▁ external ▁ references \n " ; foreach my $module ( sort ( keys ( % noref ) ) ) { printf " ▁ ▁ $ module \n " ; foreach ( sort ( @ { $noref { $module } } ) ) { my $export ; if ( exists ( $export { $_ } ) ) { $export = " ▁ ( export ▁ only ) " ; } else { $export = " " ; } printf " ▁ ▁ ▁ ▁ $ _ $ export \n " ; } } } } </DOCUMENT>
<DOCUMENT_ID="grgbr/linux-iio/tree/master/scripts/checkincludes.pl"> # ! / usr / bin / perl ENDCOM # ▁ checkincludes : ▁ find / remove ▁ files ▁ included ▁ more ▁ than ▁ once ENDCOM # ▁ Copyright ▁ abandoned , ▁ 2000 , ▁ Niels ▁ Kristian ▁ Bech ▁ Jensen ▁ < nkbj @ image . dk > . ENDCOM # ▁ Copyright ▁ 2009 ▁ Luis ▁ R . ▁ Rodriguez ▁ < mcgrof @ gmail . com > ENDCOM # ▁ This ▁ script ▁ checks ▁ for ▁ duplicate ▁ includes . ▁ It ▁ also ▁ has ▁ support ENDCOM # ▁ to ▁ remove ▁ them ▁ in ▁ place . ▁ Note ▁ that ▁ this ▁ will ▁ not ▁ take ▁ into ENDCOM # ▁ consideration ▁ macros ▁ so ▁ you ▁ should ▁ run ▁ this ▁ only ▁ if ▁ you ▁ know ENDCOM # ▁ you ▁ do ▁ have ▁ real ▁ dups ▁ and ▁ do ▁ not ▁ have ▁ them ▁ under ▁ # ifdef ' s . ▁ You ENDCOM # ▁ could ▁ also ▁ just ▁ review ▁ the ▁ results . ENDCOM use strict ; sub usage { print " Usage : ▁ checkincludes . pl ▁ [ - r ] \n " ; print " By ▁ default ▁ we ▁ just ▁ warn ▁ of ▁ duplicates \n " ; print " To ▁ remove ▁ duplicated ▁ includes ▁ in ▁ place ▁ use ▁ - r \n " ; exit 1 ; } my $remove = 0 ; if ( $ # ARGV ▁ < ▁ 0 ) ▁ { ENDCOM usage ( ) ; } if ( $ # ARGV ▁ > = ▁ 1 ) ▁ { ENDCOM if ( $ARGV [ 0 ] = ~ / ^ - / ) { if ( $ARGV [ 0 ] eq " - r " ) { $remove = 1 ; shift ; } else { usage ( ) ; } } } foreach my $file ( @ ARGV ) { open ( my $f , ' < ' , $file ) or die " Cannot ▁ open ▁ $ file : ▁ $ ! . \n " ; my % includedfiles = ( ) ; my @ file_lines = ( ) ; while ( < $f > ) { if ( m / ^ \ s * # \s * include\s * [ < " ] ( \S * ) [ > " ] / o ) ▁ { ENDCOM ++ $includedfiles { $1 } ; } push ( @ file_lines , $_ ) ; } close ( $f ) ; if ( ! $remove ) { foreach my $filename ( keys % includedfiles ) { if ( $includedfiles { $filename } > 1 ) { print " $ file : ▁ $ filename ▁ is ▁ included ▁ more ▁ than ▁ once . \n " ; } } next ; } open ( $f , ' > ' , $file ) or die ( " Cannot ▁ write ▁ to ▁ $ file : ▁ $ ! " ) ; my $dups = 0 ; foreach ( @ file_lines ) { if ( m / ^ \ s * # \s * include\s * [ < " ] ( \S * ) [ > " ] / o ) ▁ { ENDCOM foreach my $filename ( keys % includedfiles ) { if ( $1 eq $filename ) { if ( $includedfiles { $filename } > 1 ) { $includedfiles { $filename } -- ; $dups ++ ; } else { print { $f } $_ ; } } } } else { print { $f } $_ ; } } if ( $dups > 0 ) { print " $ file : ▁ removed ▁ $ dups ▁ duplicate ▁ includes \n " ; } close ( $f ) ; } </DOCUMENT>
<DOCUMENT_ID="weolar/miniblink49/tree/master/node/openssl/openssl/util/dirname.pl"> # ! / usr / local / bin / perl ENDCOM if ( $ # ARGV ▁ < ▁ 0 ) ▁ { ENDCOM die " dirname . pl : ▁ too ▁ few ▁ arguments \n " ; } elsif ( $ # ARGV ▁ > ▁ 0 ) ▁ { ENDCOM die " dirname . pl : ▁ too ▁ many ▁ arguments \n " ; } my $d = $ARGV [ 0 ] ; if ( $d = ~ m | . * / . * | ) { $d = ~ s | / [ ^ / ] * $ || ; } else { $d = " . " ; } print $d , " \n " ; exit ( 0 ) ; </DOCUMENT>
<DOCUMENT_ID="TakisBeskos/u8160-2.6.32.x-kernel/tree/master/Documentation/video4linux/extract_xc3028.pl"> # ! / usr / bin / perl ENDCOM # ▁ Copyright ▁ ( c ) ▁ Mauro ▁ Carvalho ▁ Chehab ▁ < mchehab @ infradead . org > ENDCOM # ▁ Released ▁ under ▁ GPLv2 ENDCOM # ▁ In ▁ order ▁ to ▁ use , ▁ you ▁ need ▁ to : ENDCOM # TABSYMBOL 1 ) ▁ Download ▁ the ▁ windows ▁ driver ▁ with ▁ something ▁ like : ENDCOM # TABSYMBOL TABSYMBOL wget ▁ http : / / www . steventoth . net / linux / xc5000 / HVR - 12x0-14x0-17x0_1_25_25271 _ WHQL . zip ENDCOM # TABSYMBOL 2 ) ▁ Extract ▁ the ▁ file ▁ hcw85bda . sys ▁ from ▁ the ▁ zip ▁ into ▁ the ▁ current ▁ dir : ENDCOM # TABSYMBOL TABSYMBOL unzip ▁ - j ▁ HVR - 12x0-14x0-17x0_1_25_25271 _ WHQL . zip ▁ Driver85 / hcw85bda . sys ENDCOM # TABSYMBOL 3 ) ▁ run ▁ the ▁ script : ENDCOM # TABSYMBOL TABSYMBOL . / extract _ xc3028 . pl ENDCOM # TABSYMBOL 4 ) ▁ copy ▁ the ▁ generated ▁ file : ENDCOM # TABSYMBOL TABSYMBOL cp ▁ xc3028 - v27 . fw ▁ / lib / firmware ENDCOM # use ▁ strict ; ENDCOM use IO :: Handle ; my $debug = 0 ; sub verify ( $$ ) { my ( $filename , $hash ) = @ _ ; my ( $testhash ) ; if ( system ( " which ▁ md5sum ▁ > ▁ / dev / null ▁ 2 > & 1" ) ) { die " This ▁ firmware ▁ requires ▁ the ▁ md5sum ▁ command ▁ - ▁ see ▁ http : / / www . gnu . org / software / coreutils / \n " ; } open ( CMD , " md5sum ▁ " . $filename . " | " ) ; $testhash = < CMD > ; $testhash = ~ / ( [ a - zA - Z0 - 9 ] * ) / ; $testhash = $1 ; close CMD ; die " Hash ▁ of ▁ extracted ▁ file ▁ does ▁ not ▁ match ▁ ( found ▁ $ testhash , ▁ expected ▁ $ hash ! \n " if ( $testhash ne $hash ) ; } sub get_hunk ( $$ ) { my ( $offset , $length ) = @ _ ; my ( $chunklength , $buf , $rcount , $out ) ; sysseek ( INFILE , $offset , SEEK_SET ) ; while ( $length > 0 ) { # ▁ Calc ▁ chunk ▁ size ENDCOM $chunklength = 2048 ; $chunklength = $length if ( $chunklength > $length ) ; $rcount = sysread ( INFILE , $buf , $chunklength ) ; die " Ran ▁ out ▁ of ▁ data \n " if ( $rcount != $chunklength ) ; $out . = $buf ; $length -= $rcount ; } return $out ; } sub write_le16 ( $ ) { my $val = shift ; my $msb = ( $val > > 8 ) & 0xff ; my $lsb = $val & 0xff ; syswrite ( OUTFILE , chr ( $lsb ) . chr ( $msb ) ) ; } sub write_le32 ( $ ) { my $val = shift ; my $l3 = ( $val > > 24 ) & 0xff ; my $l2 = ( $val > > 16 ) & 0xff ; my $l1 = ( $val > > 8 ) & 0xff ; my $l0 = $val & 0xff ; syswrite ( OUTFILE , chr ( $l0 ) . chr ( $l1 ) . chr ( $l2 ) . chr ( $l3 ) ) ; } sub write_le64 ( $$ ) { my $msb_val = shift ; my $lsb_val = shift ; my $l7 = ( $msb_val > > 24 ) & 0xff ; my $l6 = ( $msb_val > > 16 ) & 0xff ; my $l5 = ( $msb_val > > 8 ) & 0xff ; my $l4 = $msb_val & 0xff ; my $l3 = ( $lsb_val > > 24 ) & 0xff ; my $l2 = ( $lsb_val > > 16 ) & 0xff ; my $l1 = ( $lsb_val > > 8 ) & 0xff ; my $l0 = $lsb_val & 0xff ; syswrite ( OUTFILE , chr ( $l0 ) . chr ( $l1 ) . chr ( $l2 ) . chr ( $l3 ) . chr ( $l4 ) . chr ( $l5 ) . chr ( $l6 ) . chr ( $l7 ) ) ; } sub write_hunk ( $$ ) { my ( $offset , $length ) = @ _ ; my $out = get_hunk ( $offset , $length ) ; printf " ( len ▁ % d ) ▁ " , $length if ( $debug ) ; for ( my $i = 0 ; $i < $length ; $i ++ ) { printf " % 02x ▁ " , ord ( substr ( $out , $i , 1 ) ) if ( $debug ) ; } printf " \n " if ( $debug ) ; syswrite ( OUTFILE , $out ) ; } sub write_hunk_fix_endian ( $$ ) { my ( $offset , $length ) = @ _ ; my $out = get_hunk ( $offset , $length ) ; printf " ( len _ fix ▁ % d ) ▁ " , $length if ( $debug ) ; for ( my $i = 0 ; $i < $length ; $i ++ ) { printf " % 02x ▁ " , ord ( substr ( $out , $i , 1 ) ) if ( $debug ) ; } printf " \n " if ( $debug ) ; my $i = 0 ; while ( $i < $length ) { my $size = ord ( substr ( $out , $i , 1 ) ) * 256 + ord ( substr ( $out , $i + 1 , 1 ) ) ; syswrite ( OUTFILE , substr ( $out , $i + 1 , 1 ) ) ; syswrite ( OUTFILE , substr ( $out , $i , 1 ) ) ; $i += 2 ; if ( $size > 0 && $size < 0x8000 ) { for ( my $j = 0 ; $j < $size ; $j ++ ) { syswrite ( OUTFILE , substr ( $out , $j + $i , 1 ) ) ; } $i += $size ; } } } sub main_firmware ( $$$$ ) { my $out ; my $j = 0 ; my $outfile = shift ; my $name = shift ; my $version = shift ; my $nr_desc = shift ; for ( $j = length ( $name ) ; $j < 32 ; $j ++ ) { $name = $name . chr ( 0 ) ; } open OUTFILE , " > $ outfile " ; syswrite ( OUTFILE , $name ) ; write_le16 ( $version ) ; write_le16 ( $nr_desc ) ; # ▁ Firmware ▁ 0 , ▁ type : ▁ BASE ▁ FW ▁ F8MHZ ▁ ( 0x000003 ) , ▁ id : ▁ ( 00000 ) , ▁ size : ▁ 8718 ENDCOM write_le32 ( 0x00000003 ) ; # ▁ Type ENDCOM write_le64 ( 0x00000000 , 0x00000000 ) ; # ▁ ID ENDCOM write_le32 ( 8718 ) ; # ▁ Size ENDCOM write_hunk_fix_endian ( 813432 , 8718 ) ; # ▁ Firmware ▁ 1 , ▁ type : ▁ BASE ▁ FW ▁ F8MHZ ▁ MTS ▁ ( 0x000007 ) , ▁ id : ▁ ( 00000 ) , ▁ size : ▁ 8712 ENDCOM write_le32 ( 0x00000007 ) ; # ▁ Type ENDCOM write_le64 ( 0x00000000 , 0x00000000 ) ; # ▁ ID ENDCOM write_le32 ( 8712 ) ; # ▁ Size ENDCOM write_hunk_fix_endian ( 822152 , 8712 ) ; # ▁ Firmware ▁ 2 , ▁ type : ▁ BASE ▁ FW ▁ FM ▁ ( 0x00000401 ) , ▁ id : ▁ ( 00000 ) , ▁ size : ▁ 8562 ENDCOM write_le32 ( 0x00000401 ) ; # ▁ Type ENDCOM write_le64 ( 0x00000000 , 0x00000000 ) ; # ▁ ID ENDCOM write_le32 ( 8562 ) ; # ▁ Size ENDCOM write_hunk_fix_endian ( 830872 , 8562 ) ; # ▁ Firmware ▁ 3 , ▁ type : ▁ BASE ▁ FW ▁ FM ▁ INPUT1 ▁ ( 0x00000c01 ) , ▁ id : ▁ ( 00000 ) , ▁ size : ▁ 8576 ENDCOM write_le32 ( 0x00000c01 ) ; # ▁ Type ENDCOM write_le64 ( 0x00000000 , 0x00000000 ) ; # ▁ ID ENDCOM write_le32 ( 8576 ) ; # ▁ Size ENDCOM write_hunk_fix_endian ( 839440 , 8576 ) ; # ▁ Firmware ▁ 4 , ▁ type : ▁ BASE ▁ FW ▁ ( 0x000001 ) , ▁ id : ▁ ( 00000 ) , ▁ size : ▁ 8706 ENDCOM write_le32 ( 0x00000001 ) ; # ▁ Type ENDCOM write_le64 ( 0x00000000 , 0x00000000 ) ; # ▁ ID ENDCOM write_le32 ( 8706 ) ; # ▁ Size ENDCOM write_hunk_fix_endian ( 848024 , 8706 ) ; # ▁ Firmware ▁ 5 , ▁ type : ▁ BASE ▁ FW ▁ MTS ▁ ( 0x000005 ) , ▁ id : ▁ ( 00000 ) , ▁ size : ▁ 8682 ENDCOM write_le32 ( 0x00000005 ) ; # ▁ Type ENDCOM write_le64 ( 0x00000000 , 0x00000000 ) ; # ▁ ID ENDCOM write_le32 ( 8682 ) ; # ▁ Size ENDCOM write_hunk_fix_endian ( 856736 , 8682 ) ; # ▁ Firmware ▁ 6 , ▁ type : ▁ STD ▁ FW ▁ ( 0x00000 ) , ▁ id : ▁ PAL / BG ▁ A2 / A ▁ ( 000001000007 ) , ▁ size : ▁ 161 ENDCOM write_le32 ( 0x00000000 ) ; # ▁ Type ENDCOM write_le64 ( 0x00000001 , 0x00000007 ) ; # ▁ ID ENDCOM write_le32 ( 161 ) ; # ▁ Size ENDCOM write_hunk_fix_endian ( 865424 , 161 ) ; # ▁ Firmware ▁ 7 , ▁ type : ▁ STD ▁ FW ▁ MTS ▁ ( 0x000004 ) , ▁ id : ▁ PAL / BG ▁ A2 / A ▁ ( 000001000007 ) , ▁ size : ▁ 169 ENDCOM write_le32 ( 0x00000004 ) ; # ▁ Type ENDCOM write_le64 ( 0x00000001 , 0x00000007 ) ; # ▁ ID ENDCOM write_le32 ( 169 ) ; # ▁ Size ENDCOM write_hunk_fix_endian ( 865592 , 169 ) ; # ▁ Firmware ▁ 8 , ▁ type : ▁ STD ▁ FW ▁ ( 0x00000 ) , ▁ id : ▁ PAL / BG ▁ A2 / B ▁ ( 000002000007 ) , ▁ size : ▁ 161 ENDCOM write_le32 ( 0x00000000 ) ; # ▁ Type ENDCOM write_le64 ( 0x00000002 , 0x00000007 ) ; # ▁ ID ENDCOM write_le32 ( 161 ) ; # ▁ Size ENDCOM write_hunk_fix_endian ( 865424 , 161 ) ; # ▁ Firmware ▁ 9 , ▁ type : ▁ STD ▁ FW ▁ MTS ▁ ( 0x000004 ) , ▁ id : ▁ PAL / BG ▁ A2 / B ▁ ( 000002000007 ) , ▁ size : ▁ 169 ENDCOM write_le32 ( 0x00000004 ) ; # ▁ Type ENDCOM write_le64 ( 0x00000002 , 0x00000007 ) ; # ▁ ID ENDCOM write_le32 ( 169 ) ; # ▁ Size ENDCOM write_hunk_fix_endian ( 865592 , 169 ) ; # ▁ Firmware ▁ 10 , ▁ type : ▁ STD ▁ FW ▁ ( 0x00000 ) , ▁ id : ▁ PAL / BG ▁ NICAM / A ▁ ( 000004000007 ) , ▁ size : ▁ 161 ENDCOM write_le32 ( 0x00000000 ) ; # ▁ Type ENDCOM write_le64 ( 0x00000004 , 0x00000007 ) ; # ▁ ID ENDCOM write_le32 ( 161 ) ; # ▁ Size ENDCOM write_hunk_fix_endian ( 866112 , 161 ) ; # ▁ Firmware ▁ 11 , ▁ type : ▁ STD ▁ FW ▁ MTS ▁ ( 0x000004 ) , ▁ id : ▁ PAL / BG ▁ NICAM / A ▁ ( 000004000007 ) , ▁ size : ▁ 169 ENDCOM write_le32 ( 0x00000004 ) ; # ▁ Type ENDCOM write_le64 ( 0x00000004 , 0x00000007 ) ; # ▁ ID ENDCOM write_le32 ( 169 ) ; # ▁ Size ENDCOM write_hunk_fix_endian ( 866280 , 169 ) ; # ▁ Firmware ▁ 12 , ▁ type : ▁ STD ▁ FW ▁ ( 0x00000 ) , ▁ id : ▁ PAL / BG ▁ NICAM / B ▁ ( 000008000007 ) , ▁ size : ▁ 161 ENDCOM write_le32 ( 0x00000000 ) ; # ▁ Type ENDCOM write_le64 ( 0x00000008 , 0x00000007 ) ; # ▁ ID ENDCOM write_le32 ( 161 ) ; # ▁ Size ENDCOM write_hunk_fix_endian ( 866112 , 161 ) ; # ▁ Firmware ▁ 13 , ▁ type : ▁ STD ▁ FW ▁ MTS ▁ ( 0x000004 ) , ▁ id : ▁ PAL / BG ▁ NICAM / B ▁ ( 000008000007 ) , ▁ size : ▁ 169 ENDCOM write_le32 ( 0x00000004 ) ; # ▁ Type ENDCOM write_le64 ( 0x00000008 , 0x00000007 ) ; # ▁ ID ENDCOM write_le32 ( 169 ) ; # ▁ Size ENDCOM write_hunk_fix_endian ( 866280 , 169 ) ; # ▁ Firmware ▁ 14 , ▁ type : ▁ STD ▁ FW ▁ ( 0x00000 ) , ▁ id : ▁ PAL / DK ▁ A2 ▁ ( 00000300000e0 ) , ▁ size : ▁ 161 ENDCOM write_le32 ( 0x00000000 ) ; # ▁ Type ENDCOM write_le64 ( 0x00000003 , 0x000000e0 ) ; # ▁ ID ENDCOM write_le32 ( 161 ) ; # ▁ Size ENDCOM write_hunk_fix_endian ( 866800 , 161 ) ; # ▁ Firmware ▁ 15 , ▁ type : ▁ STD ▁ FW ▁ MTS ▁ ( 0x000004 ) , ▁ id : ▁ PAL / DK ▁ A2 ▁ ( 00000300000e0 ) , ▁ size : ▁ 169 ENDCOM write_le32 ( 0x00000004 ) ; # ▁ Type ENDCOM write_le64 ( 0x00000003 , 0x000000e0 ) ; # ▁ ID ENDCOM write_le32 ( 169 ) ; # ▁ Size ENDCOM write_hunk_fix_endian ( 866968 , 169 ) ; # ▁ Firmware ▁ 16 , ▁ type : ▁ STD ▁ FW ▁ ( 0x00000 ) , ▁ id : ▁ PAL / DK ▁ NICAM ▁ ( 00000c00000e0 ) , ▁ size : ▁ 161 ENDCOM write_le32 ( 0x00000000 ) ; # ▁ Type ENDCOM write_le64 ( 0x0000000c , 0x000000e0 ) ; # ▁ ID ENDCOM write_le32 ( 161 ) ; # ▁ Size ENDCOM write_hunk_fix_endian ( 867144 , 161 ) ; # ▁ Firmware ▁ 17 , ▁ type : ▁ STD ▁ FW ▁ MTS ▁ ( 0x000004 ) , ▁ id : ▁ PAL / DK ▁ NICAM ▁ ( 00000c00000e0 ) , ▁ size : ▁ 169 ENDCOM write_le32 ( 0x00000004 ) ; # ▁ Type ENDCOM write_le64 ( 0x0000000c , 0x000000e0 ) ; # ▁ ID ENDCOM write_le32 ( 169 ) ; # ▁ Size ENDCOM write_hunk_fix_endian ( 867312 , 169 ) ; # ▁ Firmware ▁ 18 , ▁ type : ▁ STD ▁ FW ▁ ( 0x00000 ) , ▁ id : ▁ SECAM / K1 ▁ ( 00000200000 ) , ▁ size : ▁ 161 ENDCOM write_le32 ( 0x00000000 ) ; # ▁ Type ENDCOM write_le64 ( 0x00000000 , 0x00200000 ) ; # ▁ ID ENDCOM write_le32 ( 161 ) ; # ▁ Size ENDCOM write_hunk_fix_endian ( 867488 , 161 ) ; # ▁ Firmware ▁ 19 , ▁ type : ▁ STD ▁ FW ▁ MTS ▁ ( 0x000004 ) , ▁ id : ▁ SECAM / K1 ▁ ( 00000200000 ) , ▁ size : ▁ 169 ENDCOM write_le32 ( 0x00000004 ) ; # ▁ Type ENDCOM write_le64 ( 0x00000000 , 0x00200000 ) ; # ▁ ID ENDCOM write_le32 ( 169 ) ; # ▁ Size ENDCOM write_hunk_fix_endian ( 867656 , 169 ) ; # ▁ Firmware ▁ 20 , ▁ type : ▁ STD ▁ FW ▁ ( 0x00000 ) , ▁ id : ▁ SECAM / K3 ▁ ( 00000400000 ) , ▁ size : ▁ 161 ENDCOM write_le32 ( 0x00000000 ) ; # ▁ Type ENDCOM write_le64 ( 0x00000000 , 0x04000000 ) ; # ▁ ID ENDCOM write_le32 ( 161 ) ; # ▁ Size ENDCOM write_hunk_fix_endian ( 867832 , 161 ) ; # ▁ Firmware ▁ 21 , ▁ type : ▁ STD ▁ FW ▁ MTS ▁ ( 0x000004 ) , ▁ id : ▁ SECAM / K3 ▁ ( 00000400000 ) , ▁ size : ▁ 169 ENDCOM write_le32 ( 0x00000004 ) ; # ▁ Type ENDCOM write_le64 ( 0x00000000 , 0x04000000 ) ; # ▁ ID ENDCOM write_le32 ( 169 ) ; # ▁ Size ENDCOM write_hunk_fix_endian ( 868000 , 169 ) ; # ▁ Firmware ▁ 22 , ▁ type : ▁ STD ▁ FW ▁ D2633 ▁ DTV6 ▁ ATSC ▁ ( 0x00010030 ) , ▁ id : ▁ ( 00000 ) , ▁ size : ▁ 149 ENDCOM write_le32 ( 0x00010030 ) ; # ▁ Type ENDCOM write_le64 ( 0x00000000 , 0x00000000 ) ; # ▁ ID ENDCOM write_le32 ( 149 ) ; # ▁ Size ENDCOM write_hunk_fix_endian ( 868176 , 149 ) ; # ▁ Firmware ▁ 23 , ▁ type : ▁ STD ▁ FW ▁ D2620 ▁ DTV6 ▁ QAM ▁ ( 0x0000068 ) , ▁ id : ▁ ( 00000 ) , ▁ size : ▁ 149 ENDCOM write_le32 ( 0x00000068 ) ; # ▁ Type ENDCOM write_le64 ( 0x00000000 , 0x00000000 ) ; # ▁ ID ENDCOM write_le32 ( 149 ) ; # ▁ Size ENDCOM write_hunk_fix_endian ( 868336 , 149 ) ; # ▁ Firmware ▁ 24 , ▁ type : ▁ STD ▁ FW ▁ D2633 ▁ DTV6 ▁ QAM ▁ ( 0x0000070 ) , ▁ id : ▁ ( 00000 ) , ▁ size : ▁ 149 ENDCOM write_le32 ( 0x00000070 ) ; # ▁ Type ENDCOM write_le64 ( 0x00000000 , 0x00000000 ) ; # ▁ ID ENDCOM write_le32 ( 149 ) ; # ▁ Size ENDCOM write_hunk_fix_endian ( 868488 , 149 ) ; # ▁ Firmware ▁ 25 , ▁ type : ▁ STD ▁ FW ▁ D2620 ▁ DTV7 ▁ ( 0x0000088 ) , ▁ id : ▁ ( 00000 ) , ▁ size : ▁ 149 ENDCOM write_le32 ( 0x00000088 ) ; # ▁ Type ENDCOM write_le64 ( 0x00000000 , 0x00000000 ) ; # ▁ ID ENDCOM write_le32 ( 149 ) ; # ▁ Size ENDCOM write_hunk_fix_endian ( 868648 , 149 ) ; # ▁ Firmware ▁ 26 , ▁ type : ▁ STD ▁ FW ▁ D2633 ▁ DTV7 ▁ ( 0x0000090 ) , ▁ id : ▁ ( 00000 ) , ▁ size : ▁ 149 ENDCOM write_le32 ( 0x00000090 ) ; # ▁ Type ENDCOM write_le64 ( 0x00000000 , 0x00000000 ) ; # ▁ ID ENDCOM write_le32 ( 149 ) ; # ▁ Size ENDCOM write_hunk_fix_endian ( 868800 , 149 ) ; # ▁ Firmware ▁ 27 , ▁ type : ▁ STD ▁ FW ▁ D2620 ▁ DTV78 ▁ ( 0x00000108 ) , ▁ id : ▁ ( 00000 ) , ▁ size : ▁ 149 ENDCOM write_le32 ( 0x00000108 ) ; # ▁ Type ENDCOM write_le64 ( 0x00000000 , 0x00000000 ) ; # ▁ ID ENDCOM write_le32 ( 149 ) ; # ▁ Size ENDCOM write_hunk_fix_endian ( 868960 , 149 ) ; # ▁ Firmware ▁ 28 , ▁ type : ▁ STD ▁ FW ▁ D2633 ▁ DTV78 ▁ ( 0x00000110 ) , ▁ id : ▁ ( 00000 ) , ▁ size : ▁ 149 ENDCOM write_le32 ( 0x00000110 ) ; # ▁ Type ENDCOM write_le64 ( 0x00000000 , 0x00000000 ) ; # ▁ ID ENDCOM write_le32 ( 149 ) ; # ▁ Size ENDCOM write_hunk_fix_endian ( 869112 , 149 ) ; # ▁ Firmware ▁ 29 , ▁ type : ▁ STD ▁ FW ▁ D2620 ▁ DTV8 ▁ ( 0x00000208 ) , ▁ id : ▁ ( 00000 ) , ▁ size : ▁ 149 ENDCOM write_le32 ( 0x00000208 ) ; # ▁ Type ENDCOM write_le64 ( 0x00000000 , 0x00000000 ) ; # ▁ ID ENDCOM write_le32 ( 149 ) ; # ▁ Size ENDCOM write_hunk_fix_endian ( 868648 , 149 ) ; # ▁ Firmware ▁ 30 , ▁ type : ▁ STD ▁ FW ▁ D2633 ▁ DTV8 ▁ ( 0x00000210 ) , ▁ id : ▁ ( 00000 ) , ▁ size : ▁ 149 ENDCOM write_le32 ( 0x00000210 ) ; # ▁ Type ENDCOM write_le64 ( 0x00000000 , 0x00000000 ) ; # ▁ ID ENDCOM write_le32 ( 149 ) ; # ▁ Size ENDCOM write_hunk_fix_endian ( 868800 , 149 ) ; # ▁ Firmware ▁ 31 , ▁ type : ▁ STD ▁ FW ▁ FM ▁ ( 0x00000400 ) , ▁ id : ▁ ( 00000 ) , ▁ size : ▁ 135 ENDCOM write_le32 ( 0x00000400 ) ; # ▁ Type ENDCOM write_le64 ( 0x00000000 , 0x00000000 ) ; # ▁ ID ENDCOM write_le32 ( 135 ) ; # ▁ Size ENDCOM write_hunk_fix_endian ( 869584 , 135 ) ; # ▁ Firmware ▁ 32 , ▁ type : ▁ STD ▁ FW ▁ ( 0x00000 ) , ▁ id : ▁ PAL / I ▁ ( 0000010 ) , ▁ size : ▁ 161 ENDCOM write_le32 ( 0x00000000 ) ; # ▁ Type ENDCOM write_le64 ( 0x00000000 , 0x00000010 ) ; # ▁ ID ENDCOM write_le32 ( 161 ) ; # ▁ Size ENDCOM write_hunk_fix_endian ( 869728 , 161 ) ; # ▁ Firmware ▁ 33 , ▁ type : ▁ STD ▁ FW ▁ MTS ▁ ( 0x000004 ) , ▁ id : ▁ PAL / I ▁ ( 0000010 ) , ▁ size : ▁ 169 ENDCOM write_le32 ( 0x00000004 ) ; # ▁ Type ENDCOM write_le64 ( 0x00000000 , 0x00000010 ) ; # ▁ ID ENDCOM write_le32 ( 169 ) ; # ▁ Size ENDCOM write_hunk_fix_endian ( 869896 , 169 ) ; # ▁ Firmware ▁ 34 , ▁ type : ▁ STD ▁ FW ▁ ( 0x00000 ) , ▁ id : ▁ SECAM / L ▁ AM ▁ ( 000001000400000 ) , ▁ size : ▁ 169 ENDCOM write_le32 ( 0x00000000 ) ; # ▁ Type ENDCOM write_le64 ( 0x00000010 , 0x00400000 ) ; # ▁ ID ENDCOM write_le32 ( 169 ) ; # ▁ Size ENDCOM write_hunk_fix_endian ( 870072 , 169 ) ; # ▁ Firmware ▁ 35 , ▁ type : ▁ STD ▁ FW ▁ ( 0x00000 ) , ▁ id : ▁ SECAM / L ▁ NICAM ▁ ( 00000c00400000 ) , ▁ size : ▁ 161 ENDCOM write_le32 ( 0x00000000 ) ; # ▁ Type ENDCOM write_le64 ( 0x0000000c , 0x00400000 ) ; # ▁ ID ENDCOM write_le32 ( 161 ) ; # ▁ Size ENDCOM write_hunk_fix_endian ( 870248 , 161 ) ; # ▁ Firmware ▁ 36 , ▁ type : ▁ STD ▁ FW ▁ ( 0x00000 ) , ▁ id : ▁ SECAM / Lc ▁ ( 00000800000 ) , ▁ size : ▁ 161 ENDCOM write_le32 ( 0x00000000 ) ; # ▁ Type ENDCOM write_le64 ( 0x00000000 , 0x00800000 ) ; # ▁ ID ENDCOM write_le32 ( 161 ) ; # ▁ Size ENDCOM write_hunk_fix_endian ( 870416 , 161 ) ; # ▁ Firmware ▁ 37 , ▁ type : ▁ STD ▁ FW ▁ ( 0x00000 ) , ▁ id : ▁ NTSC / M ▁ Kr ▁ ( 000008000 ) , ▁ size : ▁ 161 ENDCOM write_le32 ( 0x00000000 ) ; # ▁ Type ENDCOM write_le64 ( 0x00000000 , 0x00008000 ) ; # ▁ ID ENDCOM write_le32 ( 161 ) ; # ▁ Size ENDCOM write_hunk_fix_endian ( 870584 , 161 ) ; # ▁ Firmware ▁ 38 , ▁ type : ▁ STD ▁ FW ▁ LCD ▁ ( 0x00001000 ) , ▁ id : ▁ NTSC / M ▁ Kr ▁ ( 000008000 ) , ▁ size : ▁ 161 ENDCOM write_le32 ( 0x00001000 ) ; # ▁ Type ENDCOM write_le64 ( 0x00000000 , 0x00008000 ) ; # ▁ ID ENDCOM write_le32 ( 161 ) ; # ▁ Size ENDCOM write_hunk_fix_endian ( 870752 , 161 ) ; # ▁ Firmware ▁ 39 , ▁ type : ▁ STD ▁ FW ▁ LCD ▁ NOGD ▁ ( 0x00003000 ) , ▁ id : ▁ NTSC / M ▁ Kr ▁ ( 000008000 ) , ▁ size : ▁ 161 ENDCOM write_le32 ( 0x00003000 ) ; # ▁ Type ENDCOM write_le64 ( 0x00000000 , 0x00008000 ) ; # ▁ ID ENDCOM write_le32 ( 161 ) ; # ▁ Size ENDCOM write_hunk_fix_endian ( 870920 , 161 ) ; # ▁ Firmware ▁ 40 , ▁ type : ▁ STD ▁ FW ▁ MTS ▁ ( 0x000004 ) , ▁ id : ▁ NTSC / M ▁ Kr ▁ ( 000008000 ) , ▁ size : ▁ 169 ENDCOM write_le32 ( 0x00000004 ) ; # ▁ Type ENDCOM write_le64 ( 0x00000000 , 0x00008000 ) ; # ▁ ID ENDCOM write_le32 ( 169 ) ; # ▁ Size ENDCOM write_hunk_fix_endian ( 871088 , 169 ) ; # ▁ Firmware ▁ 41 , ▁ type : ▁ STD ▁ FW ▁ ( 0x00000 ) , ▁ id : ▁ NTSC ▁ PAL / M ▁ PAL / N ▁ ( 00000b700 ) , ▁ size : ▁ 161 ENDCOM write_le32 ( 0x00000000 ) ; # ▁ Type ENDCOM write_le64 ( 0x00000000 , 0x0000b700 ) ; # ▁ ID ENDCOM write_le32 ( 161 ) ; # ▁ Size ENDCOM write_hunk_fix_endian ( 871264 , 161 ) ; # ▁ Firmware ▁ 42 , ▁ type : ▁ STD ▁ FW ▁ LCD ▁ ( 0x00001000 ) , ▁ id : ▁ NTSC ▁ PAL / M ▁ PAL / N ▁ ( 00000b700 ) , ▁ size : ▁ 161 ENDCOM write_le32 ( 0x00001000 ) ; # ▁ Type ENDCOM write_le64 ( 0x00000000 , 0x0000b700 ) ; # ▁ ID ENDCOM write_le32 ( 161 ) ; # ▁ Size ENDCOM write_hunk_fix_endian ( 871432 , 161 ) ; # ▁ Firmware ▁ 43 , ▁ type : ▁ STD ▁ FW ▁ LCD ▁ NOGD ▁ ( 0x00003000 ) , ▁ id : ▁ NTSC ▁ PAL / M ▁ PAL / N ▁ ( 00000b700 ) , ▁ size : ▁ 161 ENDCOM write_le32 ( 0x00003000 ) ; # ▁ Type ENDCOM write_le64 ( 0x00000000 , 0x0000b700 ) ; # ▁ ID ENDCOM write_le32 ( 161 ) ; # ▁ Size ENDCOM write_hunk_fix_endian ( 871600 , 161 ) ; # ▁ Firmware ▁ 44 , ▁ type : ▁ STD ▁ FW ▁ ( 0x00000 ) , ▁ id : ▁ NTSC / M ▁ Jp ▁ ( 000002000 ) , ▁ size : ▁ 161 ENDCOM write_le32 ( 0x00000000 ) ; # ▁ Type ENDCOM write_le64 ( 0x00000000 , 0x00002000 ) ; # ▁ ID ENDCOM write_le32 ( 161 ) ; # ▁ Size ENDCOM write_hunk_fix_endian ( 871264 , 161 ) ; # ▁ Firmware ▁ 45 , ▁ type : ▁ STD ▁ FW ▁ MTS ▁ ( 0x000004 ) , ▁ id : ▁ NTSC ▁ PAL / M ▁ PAL / N ▁ ( 00000b700 ) , ▁ size : ▁ 169 ENDCOM write_le32 ( 0x00000004 ) ; # ▁ Type ENDCOM write_le64 ( 0x00000000 , 0x0000b700 ) ; # ▁ ID ENDCOM write_le32 ( 169 ) ; # ▁ Size ENDCOM write_hunk_fix_endian ( 871936 , 169 ) ; # ▁ Firmware ▁ 46 , ▁ type : ▁ STD ▁ FW ▁ MTS ▁ LCD ▁ ( 0x00001004 ) , ▁ id : ▁ NTSC ▁ PAL / M ▁ PAL / N ▁ ( 00000b700 ) , ▁ size : ▁ 169 ENDCOM write_le32 ( 0x00001004 ) ; # ▁ Type ENDCOM write_le64 ( 0x00000000 , 0x0000b700 ) ; # ▁ ID ENDCOM write_le32 ( 169 ) ; # ▁ Size ENDCOM write_hunk_fix_endian ( 872112 , 169 ) ; # ▁ Firmware ▁ 47 , ▁ type : ▁ STD ▁ FW ▁ MTS ▁ LCD ▁ NOGD ▁ ( 0x00003004 ) , ▁ id : ▁ NTSC ▁ PAL / M ▁ PAL / N ▁ ( 00000b700 ) , ▁ size : ▁ 169 ENDCOM write_le32 ( 0x00003004 ) ; # ▁ Type ENDCOM write_le64 ( 0x00000000 , 0x0000b700 ) ; # ▁ ID ENDCOM write_le32 ( 169 ) ; # ▁ Size ENDCOM write_hunk_fix_endian ( 872288 , 169 ) ; # ▁ Firmware ▁ 48 , ▁ type : ▁ SCODE ▁ FW ▁ HAS ▁ IF ▁ ( 0x600000 ) , ▁ IF ▁ = ▁ 3.28 ▁ MHz ▁ id : ▁ ( 00000 ) , ▁ size : ▁ 192 ENDCOM write_le32 ( 0x60000000 ) ; # ▁ Type ENDCOM write_le64 ( 0x00000000 , 0x00000000 ) ; # ▁ ID ENDCOM write_le16 ( 3280 ) ; # ▁ IF ENDCOM write_le32 ( 192 ) ; # ▁ Size ENDCOM write_hunk ( 811896 , 192 ) ; # ▁ Firmware ▁ 49 , ▁ type : ▁ SCODE ▁ FW ▁ HAS ▁ IF ▁ ( 0x600000 ) , ▁ IF ▁ = ▁ 3.30 ▁ MHz ▁ id : ▁ ( 00000 ) , ▁ size : ▁ 192 ENDCOM write_le32 ( 0x60000000 ) ; # ▁ Type ENDCOM write_le64 ( 0x00000000 , 0x00000000 ) ; # ▁ ID ENDCOM write_le16 ( 3300 ) ; # ▁ IF ENDCOM write_le32 ( 192 ) ; # ▁ Size ENDCOM write_hunk ( 813048 , 192 ) ; # ▁ Firmware ▁ 50 , ▁ type : ▁ SCODE ▁ FW ▁ HAS ▁ IF ▁ ( 0x600000 ) , ▁ IF ▁ = ▁ 3.44 ▁ MHz ▁ id : ▁ ( 00000 ) , ▁ size : ▁ 192 ENDCOM write_le32 ( 0x60000000 ) ; # ▁ Type ENDCOM write_le64 ( 0x00000000 , 0x00000000 ) ; # ▁ ID ENDCOM write_le16 ( 3440 ) ; # ▁ IF ENDCOM write_le32 ( 192 ) ; # ▁ Size ENDCOM write_hunk ( 812280 , 192 ) ; # ▁ Firmware ▁ 51 , ▁ type : ▁ SCODE ▁ FW ▁ HAS ▁ IF ▁ ( 0x600000 ) , ▁ IF ▁ = ▁ 3.46 ▁ MHz ▁ id : ▁ ( 00000 ) , ▁ size : ▁ 192 ENDCOM write_le32 ( 0x60000000 ) ; # ▁ Type ENDCOM write_le64 ( 0x00000000 , 0x00000000 ) ; # ▁ ID ENDCOM write_le16 ( 3460 ) ; # ▁ IF ENDCOM write_le32 ( 192 ) ; # ▁ Size ENDCOM write_hunk ( 812472 , 192 ) ; # ▁ Firmware ▁ 52 , ▁ type : ▁ SCODE ▁ FW ▁ DTV6 ▁ ATSC ▁ OREN36 ▁ HAS ▁ IF ▁ ( 0x60210020 ) , ▁ IF ▁ = ▁ 3.80 ▁ MHz ▁ id : ▁ ( 00000 ) , ▁ size : ▁ 192 ENDCOM write_le32 ( 0x60210020 ) ; # ▁ Type ENDCOM write_le64 ( 0x00000000 , 0x00000000 ) ; # ▁ ID ENDCOM write_le16 ( 3800 ) ; # ▁ IF ENDCOM write_le32 ( 192 ) ; # ▁ Size ENDCOM write_hunk ( 809784 , 192 ) ; # ▁ Firmware ▁ 53 , ▁ type : ▁ SCODE ▁ FW ▁ HAS ▁ IF ▁ ( 0x600000 ) , ▁ IF ▁ = ▁ 4.00 ▁ MHz ▁ id : ▁ ( 00000 ) , ▁ size : ▁ 192 ENDCOM write_le32 ( 0x60000000 ) ; # ▁ Type ENDCOM write_le64 ( 0x00000000 , 0x00000000 ) ; # ▁ ID ENDCOM write_le16 ( 4000 ) ; # ▁ IF ENDCOM write_le32 ( 192 ) ; # ▁ Size ENDCOM write_hunk ( 812088 , 192 ) ; # ▁ Firmware ▁ 54 , ▁ type : ▁ SCODE ▁ FW ▁ DTV6 ▁ ATSC ▁ TOYOTA388 ▁ HAS ▁ IF ▁ ( 0x60410020 ) , ▁ IF ▁ = ▁ 4.08 ▁ MHz ▁ id : ▁ ( 00000 ) , ▁ size : ▁ 192 ENDCOM write_le32 ( 0x60410020 ) ; # ▁ Type ENDCOM write_le64 ( 0x00000000 , 0x00000000 ) ; # ▁ ID ENDCOM write_le16 ( 4080 ) ; # ▁ IF ENDCOM write_le32 ( 192 ) ; # ▁ Size ENDCOM write_hunk ( 809976 , 192 ) ; # ▁ Firmware ▁ 55 , ▁ type : ▁ SCODE ▁ FW ▁ HAS ▁ IF ▁ ( 0x600000 ) , ▁ IF ▁ = ▁ 4.20 ▁ MHz ▁ id : ▁ ( 00000 ) , ▁ size : ▁ 192 ENDCOM write_le32 ( 0x60000000 ) ; # ▁ Type ENDCOM write_le64 ( 0x00000000 , 0x00000000 ) ; # ▁ ID ENDCOM write_le16 ( 4200 ) ; # ▁ IF ENDCOM write_le32 ( 192 ) ; # ▁ Size ENDCOM write_hunk ( 811704 , 192 ) ; # ▁ Firmware ▁ 56 , ▁ type : ▁ SCODE ▁ FW ▁ MONO ▁ HAS ▁ IF ▁ ( 0x60008000 ) , ▁ IF ▁ = ▁ 4.32 ▁ MHz ▁ id : ▁ NTSC / M ▁ Kr ▁ ( 000008000 ) , ▁ size : ▁ 192 ENDCOM write_le32 ( 0x60008000 ) ; # ▁ Type ENDCOM write_le64 ( 0x00000000 , 0x00008000 ) ; # ▁ ID ENDCOM write_le16 ( 4320 ) ; # ▁ IF ENDCOM write_le32 ( 192 ) ; # ▁ Size ENDCOM write_hunk ( 808056 , 192 ) ; # ▁ Firmware ▁ 57 , ▁ type : ▁ SCODE ▁ FW ▁ HAS ▁ IF ▁ ( 0x600000 ) , ▁ IF ▁ = ▁ 4.45 ▁ MHz ▁ id : ▁ ( 00000 ) , ▁ size : ▁ 192 ENDCOM write_le32 ( 0x60000000 ) ; # ▁ Type ENDCOM write_le64 ( 0x00000000 , 0x00000000 ) ; # ▁ ID ENDCOM write_le16 ( 4450 ) ; # ▁ IF ENDCOM write_le32 ( 192 ) ; # ▁ Size ENDCOM write_hunk ( 812664 , 192 ) ; # ▁ Firmware ▁ 58 , ▁ type : ▁ SCODE ▁ FW ▁ MTS ▁ LCD ▁ NOGD ▁ MONO ▁ IF ▁ HAS ▁ IF ▁ ( 0x6002b004 ) , ▁ IF ▁ = ▁ 4.50 ▁ MHz ▁ id : ▁ NTSC ▁ PAL / M ▁ PAL / N ▁ ( 00000b700 ) , ▁ size : ▁ 192 ENDCOM write_le32 ( 0x6002b004 ) ; # ▁ Type ENDCOM write_le64 ( 0x00000000 , 0x0000b700 ) ; # ▁ ID ENDCOM write_le16 ( 4500 ) ; # ▁ IF ENDCOM write_le32 ( 192 ) ; # ▁ Size ENDCOM write_hunk ( 807672 , 192 ) ; # ▁ Firmware ▁ 59 , ▁ type : ▁ SCODE ▁ FW ▁ LCD ▁ NOGD ▁ IF ▁ HAS ▁ IF ▁ ( 0x60023000 ) , ▁ IF ▁ = ▁ 4.60 ▁ MHz ▁ id : ▁ NTSC / M ▁ Kr ▁ ( 000008000 ) , ▁ size : ▁ 192 ENDCOM write_le32 ( 0x60023000 ) ; # ▁ Type ENDCOM write_le64 ( 0x00000000 , 0x00008000 ) ; # ▁ ID ENDCOM write_le16 ( 4600 ) ; # ▁ IF ENDCOM write_le32 ( 192 ) ; # ▁ Size ENDCOM write_hunk ( 807864 , 192 ) ; # ▁ Firmware ▁ 60 , ▁ type : ▁ SCODE ▁ FW ▁ DTV6 ▁ QAM ▁ DTV7 ▁ DTV78 ▁ DTV8 ▁ ZARLINK456 ▁ HAS ▁ IF ▁ ( 0x620003e0 ) , ▁ IF ▁ = ▁ 4.76 ▁ MHz ▁ id : ▁ ( 00000 ) , ▁ size : ▁ 192 ENDCOM write_le32 ( 0x620003e0 ) ; # ▁ Type ENDCOM write_le64 ( 0x00000000 , 0x00000000 ) ; # ▁ ID ENDCOM write_le16 ( 4760 ) ; # ▁ IF ENDCOM write_le32 ( 192 ) ; # ▁ Size ENDCOM write_hunk ( 807288 , 192 ) ; # ▁ Firmware ▁ 61 , ▁ type : ▁ SCODE ▁ FW ▁ HAS ▁ IF ▁ ( 0x600000 ) , ▁ IF ▁ = ▁ 4.94 ▁ MHz ▁ id : ▁ ( 00000 ) , ▁ size : ▁ 192 ENDCOM write_le32 ( 0x60000000 ) ; # ▁ Type ENDCOM write_le64 ( 0x00000000 , 0x00000000 ) ; # ▁ ID ENDCOM write_le16 ( 4940 ) ; # ▁ IF ENDCOM write_le32 ( 192 ) ; # ▁ Size ENDCOM write_hunk ( 811512 , 192 ) ; # ▁ Firmware ▁ 62 , ▁ type : ▁ SCODE ▁ FW ▁ HAS ▁ IF ▁ ( 0x600000 ) , ▁ IF ▁ = ▁ 5.26 ▁ MHz ▁ id : ▁ ( 00000 ) , ▁ size : ▁ 192 ENDCOM write_le32 ( 0x60000000 ) ; # ▁ Type ENDCOM write_le64 ( 0x00000000 , 0x00000000 ) ; # ▁ ID ENDCOM write_le16 ( 5260 ) ; # ▁ IF ENDCOM write_le32 ( 192 ) ; # ▁ Size ENDCOM write_hunk ( 810552 , 192 ) ; # ▁ Firmware ▁ 63 , ▁ type : ▁ SCODE ▁ FW ▁ MONO ▁ HAS ▁ IF ▁ ( 0x60008000 ) , ▁ IF ▁ = ▁ 5.32 ▁ MHz ▁ id : ▁ PAL / BG ▁ A2 ▁ NICAM ▁ ( 00000f000007 ) , ▁ size : ▁ 192 ENDCOM write_le32 ( 0x60008000 ) ; # ▁ Type ENDCOM write_le64 ( 0x0000000f , 0x00000007 ) ; # ▁ ID ENDCOM write_le16 ( 5320 ) ; # ▁ IF ENDCOM write_le32 ( 192 ) ; # ▁ Size ENDCOM write_hunk ( 810744 , 192 ) ; # ▁ Firmware ▁ 64 , ▁ type : ▁ SCODE ▁ FW ▁ DTV7 ▁ DTV78 ▁ DTV8 ▁ DIBCOM52 ▁ CHINA ▁ HAS ▁ IF ▁ ( 0x65000380 ) , ▁ IF ▁ = ▁ 5.40 ▁ MHz ▁ id : ▁ ( 00000 ) , ▁ size : ▁ 192 ENDCOM write_le32 ( 0x65000380 ) ; # ▁ Type ENDCOM write_le64 ( 0x00000000 , 0x00000000 ) ; # ▁ ID ENDCOM write_le16 ( 5400 ) ; # ▁ IF ENDCOM write_le32 ( 192 ) ; # ▁ Size ENDCOM write_hunk ( 807096 , 192 ) ; # ▁ Firmware ▁ 65 , ▁ type : ▁ SCODE ▁ FW ▁ DTV6 ▁ ATSC ▁ OREN538 ▁ HAS ▁ IF ▁ ( 0x60110020 ) , ▁ IF ▁ = ▁ 5.58 ▁ MHz ▁ id : ▁ ( 00000 ) , ▁ size : ▁ 192 ENDCOM write_le32 ( 0x60110020 ) ; # ▁ Type ENDCOM write_le64 ( 0x00000000 , 0x00000000 ) ; # ▁ ID ENDCOM write_le16 ( 5580 ) ; # ▁ IF ENDCOM write_le32 ( 192 ) ; # ▁ Size ENDCOM write_hunk ( 809592 , 192 ) ; # ▁ Firmware ▁ 66 , ▁ type : ▁ SCODE ▁ FW ▁ HAS ▁ IF ▁ ( 0x600000 ) , ▁ IF ▁ = ▁ 5.64 ▁ MHz ▁ id : ▁ PAL / BG ▁ A2 ▁ ( 000003000007 ) , ▁ size : ▁ 192 ENDCOM write_le32 ( 0x60000000 ) ; # ▁ Type ENDCOM write_le64 ( 0x00000003 , 0x00000007 ) ; # ▁ ID ENDCOM write_le16 ( 5640 ) ; # ▁ IF ENDCOM write_le32 ( 192 ) ; # ▁ Size ENDCOM write_hunk ( 808440 , 192 ) ; # ▁ Firmware ▁ 67 , ▁ type : ▁ SCODE ▁ FW ▁ HAS ▁ IF ▁ ( 0x600000 ) , ▁ IF ▁ = ▁ 5.74 ▁ MHz ▁ id : ▁ PAL / BG ▁ NICAM ▁ ( 00000c000007 ) , ▁ size : ▁ 192 ENDCOM write_le32 ( 0x60000000 ) ; # ▁ Type ENDCOM write_le64 ( 0x0000000c , 0x00000007 ) ; # ▁ ID ENDCOM write_le16 ( 5740 ) ; # ▁ IF ENDCOM write_le32 ( 192 ) ; # ▁ Size ENDCOM write_hunk ( 808632 , 192 ) ; # ▁ Firmware ▁ 68 , ▁ type : ▁ SCODE ▁ FW ▁ HAS ▁ IF ▁ ( 0x600000 ) , ▁ IF ▁ = ▁ 5.90 ▁ MHz ▁ id : ▁ ( 00000 ) , ▁ size : ▁ 192 ENDCOM write_le32 ( 0x60000000 ) ; # ▁ Type ENDCOM write_le64 ( 0x00000000 , 0x00000000 ) ; # ▁ ID ENDCOM write_le16 ( 5900 ) ; # ▁ IF ENDCOM write_le32 ( 192 ) ; # ▁ Size ENDCOM write_hunk ( 810360 , 192 ) ; # ▁ Firmware ▁ 69 , ▁ type : ▁ SCODE ▁ FW ▁ MONO ▁ HAS ▁ IF ▁ ( 0x60008000 ) , ▁ IF ▁ = ▁ 6.00 ▁ MHz ▁ id : ▁ PAL / DK ▁ PAL / I ▁ SECAM / K3 ▁ SECAM / L ▁ SECAM / Lc ▁ NICAM ▁ ( 00000c04c000f0 ) , ▁ size : ▁ 192 ENDCOM write_le32 ( 0x60008000 ) ; # ▁ Type ENDCOM write_le64 ( 0x0000000c , 0x04c000f0 ) ; # ▁ ID ENDCOM write_le16 ( 6000 ) ; # ▁ IF ENDCOM write_le32 ( 192 ) ; # ▁ Size ENDCOM write_hunk ( 808824 , 192 ) ; # ▁ Firmware ▁ 70 , ▁ type : ▁ SCODE ▁ FW ▁ DTV6 ▁ QAM ▁ ATSC ▁ LG60 ▁ F6MHZ ▁ HAS ▁ IF ▁ ( 0x68050060 ) , ▁ IF ▁ = ▁ 6.20 ▁ MHz ▁ id : ▁ ( 00000 ) , ▁ size : ▁ 192 ENDCOM write_le32 ( 0x68050060 ) ; # ▁ Type ENDCOM write_le64 ( 0x00000000 , 0x00000000 ) ; # ▁ ID ENDCOM write_le16 ( 6200 ) ; # ▁ IF ENDCOM write_le32 ( 192 ) ; # ▁ Size ENDCOM write_hunk ( 809400 , 192 ) ; # ▁ Firmware ▁ 71 , ▁ type : ▁ SCODE ▁ FW ▁ HAS ▁ IF ▁ ( 0x600000 ) , ▁ IF ▁ = ▁ 6.24 ▁ MHz ▁ id : ▁ PAL / I ▁ ( 0000010 ) , ▁ size : ▁ 192 ENDCOM write_le32 ( 0x60000000 ) ; # ▁ Type ENDCOM write_le64 ( 0x00000000 , 0x00000010 ) ; # ▁ ID ENDCOM write_le16 ( 6240 ) ; # ▁ IF ENDCOM write_le32 ( 192 ) ; # ▁ Size ENDCOM write_hunk ( 808248 , 192 ) ; # ▁ Firmware ▁ 72 , ▁ type : ▁ SCODE ▁ FW ▁ MONO ▁ HAS ▁ IF ▁ ( 0x60008000 ) , ▁ IF ▁ = ▁ 6.32 ▁ MHz ▁ id : ▁ SECAM / K1 ▁ ( 00000200000 ) , ▁ size : ▁ 192 ENDCOM write_le32 ( 0x60008000 ) ; # ▁ Type ENDCOM write_le64 ( 0x00000000 , 0x00200000 ) ; # ▁ ID ENDCOM write_le16 ( 6320 ) ; # ▁ IF ENDCOM write_le32 ( 192 ) ; # ▁ Size ENDCOM write_hunk ( 811320 , 192 ) ; # ▁ Firmware ▁ 73 , ▁ type : ▁ SCODE ▁ FW ▁ HAS ▁ IF ▁ ( 0x600000 ) , ▁ IF ▁ = ▁ 6.34 ▁ MHz ▁ id : ▁ SECAM / K1 ▁ ( 00000200000 ) , ▁ size : ▁ 192 ENDCOM write_le32 ( 0x60000000 ) ; # ▁ Type ENDCOM write_le64 ( 0x00000000 , 0x00200000 ) ; # ▁ ID ENDCOM write_le16 ( 6340 ) ; # ▁ IF ENDCOM write_le32 ( 192 ) ; # ▁ Size ENDCOM write_hunk ( 809208 , 192 ) ; # ▁ Firmware ▁ 74 , ▁ type : ▁ SCODE ▁ FW ▁ MONO ▁ HAS ▁ IF ▁ ( 0x60008000 ) , ▁ IF ▁ = ▁ 6.50 ▁ MHz ▁ id : ▁ PAL / DK ▁ SECAM / K3 ▁ SECAM / L ▁ NICAM ▁ ( 00000c044000e0 ) , ▁ size : ▁ 192 ENDCOM write_le32 ( 0x60008000 ) ; # ▁ Type ENDCOM write_le64 ( 0x0000000c , 0x044000e0 ) ; # ▁ ID ENDCOM write_le16 ( 6500 ) ; # ▁ IF ENDCOM write_le32 ( 192 ) ; # ▁ Size ENDCOM write_hunk ( 811128 , 192 ) ; # ▁ Firmware ▁ 75 , ▁ type : ▁ SCODE ▁ FW ▁ DTV6 ▁ ATSC ▁ ATI638 ▁ HAS ▁ IF ▁ ( 0x60090020 ) , ▁ IF ▁ = ▁ 6.58 ▁ MHz ▁ id : ▁ ( 00000 ) , ▁ size : ▁ 192 ENDCOM write_le32 ( 0x60090020 ) ; # ▁ Type ENDCOM write_le64 ( 0x00000000 , 0x00000000 ) ; # ▁ ID ENDCOM write_le16 ( 6580 ) ; # ▁ IF ENDCOM write_le32 ( 192 ) ; # ▁ Size ENDCOM write_hunk ( 807480 , 192 ) ; # ▁ Firmware ▁ 76 , ▁ type : ▁ SCODE ▁ FW ▁ HAS ▁ IF ▁ ( 0x600000 ) , ▁ IF ▁ = ▁ 6.60 ▁ MHz ▁ id : ▁ PAL / DK ▁ A2 ▁ ( 00000300000e0 ) , ▁ size : ▁ 192 ENDCOM write_le32 ( 0x60000000 ) ; # ▁ Type ENDCOM write_le64 ( 0x00000003 , 0x000000e0 ) ; # ▁ ID ENDCOM write_le16 ( 6600 ) ; # ▁ IF ENDCOM write_le32 ( 192 ) ; # ▁ Size ENDCOM write_hunk ( 809016 , 192 ) ; # ▁ Firmware ▁ 77 , ▁ type : ▁ SCODE ▁ FW ▁ MONO ▁ HAS ▁ IF ▁ ( 0x60008000 ) , ▁ IF ▁ = ▁ 6.68 ▁ MHz ▁ id : ▁ PAL / DK ▁ A2 ▁ ( 00000300000e0 ) , ▁ size : ▁ 192 ENDCOM write_le32 ( 0x60008000 ) ; # ▁ Type ENDCOM write_le64 ( 0x00000003 , 0x000000e0 ) ; # ▁ ID ENDCOM write_le16 ( 6680 ) ; # ▁ IF ENDCOM write_le32 ( 192 ) ; # ▁ Size ENDCOM write_hunk ( 810936 , 192 ) ; # ▁ Firmware ▁ 78 , ▁ type : ▁ SCODE ▁ FW ▁ DTV6 ▁ ATSC ▁ TOYOTA794 ▁ HAS ▁ IF ▁ ( 0x60810020 ) , ▁ IF ▁ = ▁ 8.14 ▁ MHz ▁ id : ▁ ( 00000 ) , ▁ size : ▁ 192 ENDCOM write_le32 ( 0x60810020 ) ; # ▁ Type ENDCOM write_le64 ( 0x00000000 , 0x00000000 ) ; # ▁ ID ENDCOM write_le16 ( 8140 ) ; # ▁ IF ENDCOM write_le32 ( 192 ) ; # ▁ Size ENDCOM write_hunk ( 810168 , 192 ) ; # ▁ Firmware ▁ 79 , ▁ type : ▁ SCODE ▁ FW ▁ HAS ▁ IF ▁ ( 0x600000 ) , ▁ IF ▁ = ▁ 8.20 ▁ MHz ▁ id : ▁ ( 00000 ) , ▁ size : ▁ 192 ENDCOM write_le32 ( 0x60000000 ) ; # ▁ Type ENDCOM write_le64 ( 0x00000000 , 0x00000000 ) ; # ▁ ID ENDCOM write_le16 ( 8200 ) ; # ▁ IF ENDCOM write_le32 ( 192 ) ; # ▁ Size ENDCOM write_hunk ( 812856 , 192 ) ; } sub extract_firmware { my $sourcefile = " hcw85bda . sys " ; my $hash = "0e44dbf63bb0169d57446aec21881ff2" ; my $outfile = " xc3028 - v27 . fw " ; my $name = " xc2028 ▁ firmware " ; my $version = 519 ; my $nr_desc = 80 ; my $out ; verify ( $sourcefile , $hash ) ; open INFILE , " < $ sourcefile " ; main_firmware ( $outfile , $name , $version , $nr_desc ) ; close INFILE ; } extract_firmware ; printf " Firmwares ▁ generated . \n " ; </DOCUMENT>
<DOCUMENT_ID="liblime/LibLime-Koha/tree/master/cgi/authorities/detail-biblio-search.pl"> # ! / usr / bin / env ▁ perl ENDCOM # ▁ Copyright ▁ 2000-2002 ▁ Katipo ▁ Communications ENDCOM # ▁ This ▁ file ▁ is ▁ part ▁ of ▁ Koha . ENDCOM # ▁ Koha ▁ is ▁ free ▁ software ; ▁ you ▁ can ▁ redistribute ▁ it ▁ and / or ▁ modify ▁ it ▁ under ▁ the ENDCOM # ▁ terms ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ as ▁ published ▁ by ▁ the ▁ Free ▁ Software ENDCOM # ▁ Foundation ; ▁ either ▁ version ▁ 2 ▁ of ▁ the ▁ License , ▁ or ▁ ( at ▁ your ▁ option ) ▁ any ▁ later ENDCOM # ▁ version . ENDCOM # ▁ Koha ▁ is ▁ distributed ▁ in ▁ the ▁ hope ▁ that ▁ it ▁ will ▁ be ▁ useful , ▁ but ▁ WITHOUT ▁ ANY ENDCOM # ▁ WARRANTY ; ▁ without ▁ even ▁ the ▁ implied ▁ warranty ▁ of ▁ MERCHANTABILITY ▁ or ▁ FITNESS ▁ FOR ENDCOM # ▁ A ▁ PARTICULAR ▁ PURPOSE . ▁ See ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ for ▁ more ▁ details . ENDCOM # ▁ You ▁ should ▁ have ▁ received ▁ a ▁ copy ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ along ▁ with ENDCOM # ▁ Koha ; ▁ if ▁ not , ▁ write ▁ to ▁ the ▁ Free ▁ Software ▁ Foundation , ▁ Inc . , ▁ 59 ▁ Temple ▁ Place , ENDCOM # ▁ Suite ▁ 330 , ▁ Boston , ▁ MA ▁ 02111-1307 ▁ USA ENDCOM = head1 NAME etail . pl : script to show an authority in MARC format = head1 SYNOPSIS = head1 DESCRIPTION This script needs an authid It shows the authority in a ( nice ) MARC format depending on authority MARC parameters tables . = head1 FUNCTIONS = over 2 = cut use Koha ; use Koha :: Authority ; use Koha :: HeadingMap ; use C4 :: Auth ; use C4 :: Context ; use C4 :: Output ; use CGI ; use C4 :: Koha ; my $query = CGI -> new ; my $authid = $query -> param ( ' authid ' ) ; my $auth = Koha :: Authority -> new ( id = > $authid ) ; my $index = $query -> param ( ' index ' ) ; my $authtypecode = $auth -> typecode ; my $tagslib = $auth -> code_labels ( 1 ) ; my $record = $auth -> marc ; # ▁ open ▁ template ENDCOM my ( $template , $loggedinuser , $cookie ) = get_template_and_user ( { template_name = > " authorities / detail - biblio - search . tmpl " , query = > $query , type = > " intranet " , authnotrequired = > 0 , flagsrequired = > { catalogue = > 1 } , debug = > 1 , } ) ; # ▁ fill ▁ arrays ENDCOM my @ loop_data = ( ) ; my $tag ; # ▁ loop ▁ through ▁ each ▁ tab ▁ 0 ▁ through ▁ 9 ENDCOM # ▁ for ▁ ( my ▁ $ tabloop ▁ = ▁ 0 ; ▁ $ tabloop < = 10 ; $ tabloop + + ) ▁ { ENDCOM # ▁ loop ▁ through ▁ each ▁ tag ENDCOM my @ fields = $record -> fields ( ) ; foreach my $field ( @ fields ) { my @ subfields_data ; # ▁ if ▁ tag ▁ < 10 , ▁ there ' s ▁ no ▁ subfield , ▁ use ▁ the ▁ " @ " ▁ trick ENDCOM if ( $field -> tag ( ) < 10 ) { # ▁ TABSYMBOL TABSYMBOL TABSYMBOL next ▁ if ▁ ( $ tagslib - > { $ field - > tag ( ) } - > { ' @ ' } - > { tab } ▁ ne ▁ $ tabloop ) ; ENDCOM next if ( $tagslib -> { $field -> tag ( ) } -> { ' @ ' } -> { hidden } ) ; my % subfield_data ; $subfield_data { marc_lib } = $tagslib -> { $field -> tag ( ) } -> { ' @ ' } -> { lib } ; $subfield_data { marc_value } = $field -> data ( ) ; $subfield_data { marc_subfield } = ' @ ' ; $subfield_data { marc_tag } = $field -> tag ( ) ; push ( @ subfields_data , \ % subfield_data ) ; } else { my @ subf = $field -> subfields ; # ▁ loop ▁ through ▁ each ▁ subfield ENDCOM for my $i ( 0. . $ # subf ) ▁ { ENDCOM $subf [ $i ] [ 0 ] = " @ " unless $subf [ $i ] [ 0 ] ; # ▁ TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL next ▁ if ▁ ( $ tagslib - > { $ field - > tag ( ) } - > { $ subf [ $ i ] [0 ] } - > { tab } ▁ ne ▁ $ tabloop ) ; ENDCOM next if ( $tagslib -> { $field -> tag ( ) } -> { $subf [ $i ] [ 0 ] } -> { hidden } ) ; my % subfield_data ; $subfield_data { marc_lib } = $tagslib -> { $field -> tag ( ) } -> { $subf [ $i ] [ 0 ] } -> { lib } ; if ( $tagslib -> { $field -> tag ( ) } -> { $subf [ $i ] [ 0 ] } -> { isurl } ) { $subfield_data { marc_value } = " < a ▁ href = \ " $ subf [ $ i ] [1 ] \ " > $ subf [ $ i ] [1 ] < / a > " ; } else { $subfield_data { marc_value } = $subf [ $i ] [ 1 ] ; } $subfield_data { marc_subfield } = $subf [ $i ] [ 0 ] ; $subfield_data { marc_tag } = $field -> tag ( ) ; push ( @ subfields_data , \ % subfield_data ) ; } } if ( $ # subfields _ data > = 0 ) ▁ { ENDCOM my % tag_data ; $tag_data { tag } = $field -> tag ( ) . ' ▁ - ' . $tagslib -> { $field -> tag ( ) } -> { lib } ; $tag_data { subfield } = \ @ subfields_data ; push ( @ loop_data , \ % tag_data ) ; } } $template -> param ( "0XX " = > \ @ loop_data ) ; my $authtypes = Koha :: HeadingMap -> auth_types ; my @ authtypesloop ; foreach my $thisauthtype ( keys % $authtypes ) { my $selected = 1 if $thisauthtype eq $authtypecode ; my % row = ( value = > $thisauthtype , selected = > $selected , authtypetext = > $authtypes -> { $thisauthtype } { ' authtypetext ' } , ) ; push @ authtypesloop , \ % row ; } $template -> param ( authid = > $authid , authtypesloop = > \ @ authtypesloop , index = > $index , ) ; output_html_with_http_headers $query , $cookie , $template -> output ; </DOCUMENT>
<DOCUMENT_ID="xvweirong/shadowsocks-android/tree/master/src/main/jni/openssl/crypto/bn/asm/x86/sqr.pl"> # ! / usr / local / bin / perl ENDCOM # ▁ x86 ▁ assember ENDCOM sub bn_sqr_words { local ( $name ) = @ _ ; & function_begin ( $name , " " ) ; & comment ( " " ) ; $r = " esi " ; $a = " edi " ; $num = " ebx " ; & mov ( $r , & wparam ( 0 ) ) ; & mov ( $a , & wparam ( 1 ) ) ; & mov ( $num , & wparam ( 2 ) ) ; & and ( $num , 0xfffffff8 ) ; # ▁ num ▁ / ▁ 8 ENDCOM & jz ( & label ( " sw _ finish " ) ) ; & set_label ( " sw _ loop " , 0 ) ; for ( $i = 0 ; $i < 32 ; $i += 4 ) { & comment ( " Round ▁ $ i " ) ; & mov ( " eax " , & DWP ( $i , $a , " " , 0 ) ) ; # ▁ XXX ENDCOM & mul ( " eax " ) ; # ▁ * a ▁ * ▁ * a ENDCOM & mov ( & DWP ( $i * 2 , $r , " " , 0 ) , " eax " ) ; & mov ( & DWP ( $i * 2 + 4 , $r , " " , 0 ) , " edx " ) ; } & comment ( " " ) ; & add ( $a , 32 ) ; & add ( $r , 64 ) ; & sub ( $num , 8 ) ; & jnz ( & label ( " sw _ loop " ) ) ; & set_label ( " sw _ finish " , 0 ) ; & mov ( $num , & wparam ( 2 ) ) ; # ▁ get ▁ num ENDCOM & and ( $num , 7 ) ; & jz ( & label ( " sw _ end " ) ) ; for ( $i = 0 ; $i < 7 ; $i ++ ) { & comment ( " Tail ▁ Round ▁ $ i " ) ; & mov ( " eax " , & DWP ( $i * 4 , $a , " " , 0 ) ) ; # ▁ XXX ENDCOM & mul ( " eax " ) ; # ▁ * a ▁ * ▁ * a ENDCOM & mov ( & DWP ( $i * 8 , $r , " " , 0 ) , " eax " ) ; & dec ( $num ) if ( $i != 7 - 1 ) ; & mov ( & DWP ( $i * 8 + 4 , $r , " " , 0 ) , " edx " ) ; & jz ( & label ( " sw _ end " ) ) if ( $i != 7 - 1 ) ; } & set_label ( " sw _ end " , 0 ) ; & function_end ( $name ) ; } 1 ; </DOCUMENT>
<DOCUMENT_ID="kohascanbit/tabakaleraubik/tree/master/cataloguing/value_builder/marc21_field_008.pl"> # ! / usr / bin / perl ENDCOM # ▁ Copyright ▁ 2000-2002 ▁ Katipo ▁ Communications ENDCOM # ▁ This ▁ file ▁ is ▁ part ▁ of ▁ Koha .  ENDCOM # ▁ Koha ▁ is ▁ free ▁ software ; ▁ you ▁ can ▁ redistribute ▁ it ▁ and / or ▁ modify ▁ it ▁ under ▁ the ENDCOM # ▁ terms ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ as ▁ published ▁ by ▁ the ▁ Free ▁ Software ENDCOM # ▁ Foundation ; ▁ either ▁ version ▁ 2 ▁ of ▁ the ▁ License , ▁ or ▁ ( at ▁ your ▁ option ) ▁ any ▁ later ENDCOM # ▁ version .  ENDCOM # ▁ Koha ▁ is ▁ distributed ▁ in ▁ the ▁ hope ▁ that ▁ it ▁ will ▁ be ▁ useful , ▁ but ▁ WITHOUT ▁ ANY ENDCOM # ▁ WARRANTY ; ▁ without ▁ even ▁ the ▁ implied ▁ warranty ▁ of ▁ MERCHANTABILITY ▁ or ▁ FITNESS ▁ FOR ENDCOM # ▁ A ▁ PARTICULAR ▁ PURPOSE . ▁ See ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ for ▁ more ▁ details .  ENDCOM # ▁ You ▁ should ▁ have ▁ received ▁ a ▁ copy ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ along ENDCOM # ▁ with ▁ Koha ; ▁ if ▁ not , ▁ write ▁ to ▁ the ▁ Free ▁ Software ▁ Foundation , ▁ Inc . ,  ENDCOM # ▁ 51 ▁ Franklin ▁ Street , ▁ Fifth ▁ Floor , ▁ Boston , ▁ MA ▁ 02110-1301 ▁ USA .  ENDCOM use strict ; # use ▁ warnings ; ▁ FIXME ▁ - ▁ Bug ▁ 2505 ENDCOM use C4 :: Auth ; use CGI ; use C4 :: Context ; use C4 :: Search ; use C4 :: Output ; use XML :: LibXML ; = head1 DESCRIPTION plugin_parameters : other parameters added when the plugin is called by the dopop function = cut # ▁ find ▁ today ' s ▁ date ENDCOM my ( $sec , $min , $hour , $mday , $mon , $year , $wday , $yday , $isdst ) = localtime ( time ) ; $year += 1900 ; $mon += 1 ; my $dateentered = substr ( $year , 2 , 2 ) . sprintf ( " % 0.2d " , $mon ) . sprintf ( " % 0.2d " , $mday ) ; sub plugin_parameters { my ( $dbh , $record , $tagslib , $i , $tabloop ) = @ _ ; return " " ; } sub plugin_javascript { my $lang = C4 :: Context -> preference ( ' DefaultLanguageField008' ) ; $lang = " eng " unless $lang ; $lang = pack ( " A3" , $lang ) ; my ( $dbh , $record , $tagslib , $field_number , $tabloop ) = @ _ ; my $function_name = $field_number ; my $res = "  STRNEWLINE < script ▁ type = \ " text / javascript\ " >  STRNEWLINE / / < ! [ CDATA [  STRNEWLINE  STRNEWLINE function ▁ Focus $ function _ name ( subfield _ managed ) ▁ {  STRNEWLINE TABSYMBOL if ▁ ( ▁ document . getElementById ( \ " $ field _ number\ " ) . value ▁ ) ▁ {  STRNEWLINE TABSYMBOL }  STRNEWLINE TABSYMBOL else ▁ {  STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ document . getElementById ( \ " $ field _ number\ " ) . value = ' $ dateentered ' ▁ + ▁ ' b ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ xxu | | | | | ▁ | | | | ▁ 00 | ▁ 0 ▁ $ lang ▁ d ' ;  STRNEWLINE TABSYMBOL }  STRNEWLINE ▁ ▁ ▁ ▁ return ▁ 1 ;  STRNEWLINE }  STRNEWLINE  STRNEWLINE function ▁ Blur $ function _ name ( subfield _ managed ) ▁ {  STRNEWLINE TABSYMBOL return ▁ 1 ;  STRNEWLINE }  STRNEWLINE  STRNEWLINE function ▁ Clic $ function _ name ( i ) ▁ {  STRNEWLINE ▁  STRNEWLINE ▁ TABSYMBOL var ▁ tag _ 000 ▁ = ▁ findChildWithIdLike ( document . body , ▁ ' tag _ 000 _ subfield ' ) . value ;  STRNEWLINE ▁ TABSYMBOL var ▁ mat ▁ = ▁ tag _ 000 . charAt ( '6 ' ) ▁ + ▁ tag _ 000 . charAt ( '7 ' ) ;  STRNEWLINE TABSYMBOL defaultvalue = mat ▁ + ▁ document . getElementById ( \ " $ field _ number\ " ) . value ;  STRNEWLINE TABSYMBOL newin = window . open ( \ " . . / cataloguing / plugin _ launcher . pl ? plugin _ name = marc21 _ field _ 008 . pl & index = $ field _ number & result = \ " + defaultvalue , \ " tag _ editor\ " , ' width = 1000 , height = 600 , toolbar = false , scrollbars = yes ' ) ;  STRNEWLINE }  STRNEWLINE  STRNEWLINE function ▁ findChildWithIdLike ( node , ▁ prefix ) ▁ {  STRNEWLINE ▁ ▁ ▁ ▁ if ▁ ( node ▁ & & ▁ node . id ▁ & & ▁ node . id . indexOf ( prefix ) ▁ = = ▁ 0 ) ▁ {  STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ / / match ▁ found STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ return ▁ node ;  STRNEWLINE ▁ ▁ ▁ ▁ }  STRNEWLINE TABSYMBOL  STRNEWLINE ▁ ▁ ▁ ▁ / / no ▁ match , ▁ check ▁ child ▁ nodes STRNEWLINE ▁ ▁ ▁ ▁ for ▁ ( var ▁ index ▁ = ▁ 0 ; ▁ index ▁ < ▁ node . childNodes . length ; ▁ index + + ) ▁ {  STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ var ▁ child ▁ = ▁ node . childNodes [ index ] ;  STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ var ▁ childResult ▁ = ▁ findChildWithIdLike ( child , ▁ prefix ) ;  STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ if ▁ ( childResult ) ▁ {  STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ return ▁ childResult ;  STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ }  STRNEWLINE ▁ ▁ ▁ ▁ }  STRNEWLINE }  STRNEWLINE / / ] ] >  STRNEWLINE < / script >  STRNEWLINE " ; return ( $function_name , $res ) ; } sub plugin { my $lang = C4 :: Context -> preference ( ' DefaultLanguageField008' ) ; $lang = " eng " unless $lang ; $lang = pack ( " A3" , $lang ) ; my ( $input ) = @ _ ; my $index = $input -> param ( ' index ' ) ; my $result = $input -> param ( ' result ' ) ; my $dbh = C4 :: Context -> dbh ; my ( $template , $loggedinuser , $cookie ) = get_template_and_user ( { template_name = > " cataloguing / value _ builder / marc21 _ field _ 008 . tmpl " , query = > $input , type = > " intranet " , authnotrequired = > 0 , flagsrequired = > { editcatalogue = > ' * ' } , debug = > 1 , } ) ; if ( $result eq ' ' ) { $result = " $ dateentered " . " b ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ xxu | | | | | ▁ | | | | ▁ 00 | ▁ 0 ▁ $ lang ▁ d " unless $result ; } else { my $materialType = substr $result , 0 , 2 ; my $result2 = substr $result , 2 ; $result = $materialType . " $ dateentered " . " b ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ xxu | | | | | ▁ | | | | ▁ 00 | ▁ 0 ▁ $ lang ▁ d " unless $result2 ; } my $errorXml = ' ' ; # ▁ Check ▁ if ▁ the ▁ xml , ▁ xsd ▁ exists ▁ and ▁ is ▁ validated ENDCOM my $dir = C4 :: Context -> config ( ' intrahtdocs ' ) . ' / prog / ' . $template -> { lang } . ' / modules / cataloguing / value _ builder / ' ; if ( - r $dir . ' marc21 _ field _ 008 . xml ' ) { my $doc = XML :: LibXML -> new -> parse_file ( $dir . ' marc21 _ field _ 008 . xml ' ) ; if ( - r $dir . ' marc21 _ field _ CF . xsd ' ) { my $xmlschema = XML :: LibXML :: Schema -> new ( location = > $dir . ' marc21 _ field _ CF . xsd ' ) ; eval { $xmlschema -> validate ( $doc ) ; } ; $errorXml = ' Can\ ' t ▁ validate ▁ the ▁ xml ▁ data ▁ from ▁ ' . $dir . ' marc21 _ field _ 008 . xml ' if ( $ @ ) ; } } else { $errorXml = ' Can\ ' t ▁ read ▁ the ▁ xml ▁ file ▁ ' . $dir . ' marc21 _ field _ 008 . xml ' ; } $template -> param ( tagfield = > '008' , index = > $index , result = > $result , errorXml = > $errorXml , ) ; output_html_with_http_headers $input , $cookie , $template -> output ; } 1 ; </DOCUMENT>
<DOCUMENT_ID="mtw/RNAwl/tree/master/Perl/eval_sampledDOS.pl"> # ! / usr / bin / env ▁ perl ENDCOM # ▁ - * - CPerl - * - ENDCOM # ▁ Last ▁ changed ▁ Time - stamp : ▁ < 2014-07-17 ▁ 17:08:34 ▁ mtw > ENDCOM # ▁ Evaluate ▁ ( sampled ) ▁ Density ▁ of ▁ States ▁ ( DOS ) ▁ vs . ▁ reference ▁ DOS ENDCOM # ▁ usage : ▁ eval _ sampledDOS . pl ▁ - s ▁ samples . dos ▁ - r ▁ reference . dos ENDCOM # ▁ * ▁ Copyright ▁ notice ENDCOM # ▁ * ▁ Copyright ▁ 2014 ▁ Michael ▁ Thomas ▁ Wolfinger ▁ < michael @ wolfinger . eu > ENDCOM # ▁ * ▁ All ▁ rights ▁ reserved ENDCOM # ▁ * ▁ This ▁ program ▁ is ▁ free ▁ software : ▁ you ▁ can ▁ redistribute ▁ it ▁ and / or ▁ modify ENDCOM # ▁ * ▁ it ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ as ▁ published ▁ by ENDCOM # ▁ * ▁ the ▁ Free ▁ Software ▁ Foundation , ▁ either ▁ version ▁ 3 ▁ of ▁ the ▁ License , ▁ or ENDCOM # ▁ * ▁ ( at ▁ your ▁ option ) ▁ any ▁ later ▁ version . ENDCOM # ▁ * ▁ This ▁ program ▁ is ▁ distributed ▁ in ▁ the ▁ hope ▁ that ▁ it ▁ will ▁ be ▁ useful , ENDCOM # ▁ * ▁ but ▁ WITHOUT ▁ ANY ▁ WARRANTY ; ▁ without ▁ even ▁ the ▁ implied ▁ warranty ▁ of ENDCOM # ▁ * ▁ MERCHANTABILITY ▁ or ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE . ▁ See ▁ the ENDCOM # ▁ * ▁ GNU ▁ General ▁ Public ▁ License ▁ for ▁ more ▁ details . ENDCOM # ▁ * ▁ You ▁ should ▁ have ▁ received ▁ a ▁ copy ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ENDCOM # ▁ * ▁ along ▁ with ▁ this ▁ program . ▁ If ▁ not , ▁ see ▁ < http : / / www . gnu . org / licenses / > . ENDCOM # ▁ * ▁ This ▁ copyright ▁ notice ▁ MUST ▁ APPEAR ▁ in ▁ all ▁ copies ▁ of ▁ the ▁ script ! ENDCOM use strict ; use warnings ; use Getopt :: Long ; use Data :: Dumper ; use File :: Basename ; # ^ ^ ^ ^ ^ ▁ Variables ▁ ^ ^ ^ ^ ^ # ENDCOM my ( $infile_s , $infile_r , $bn_r , $dir_r , $ext_r , $bn_s , $dir_s , $ext_s , $cmd ) ; my $debug = 0 ; my % refDOS = ( ) ; # ^ ^ ^ ^ ^ ▁ Main ▁ ^ ^ ^ ^ ^ # ENDCOM Getopt :: Long :: config ( ' no _ ignore _ case ' ) ; & usage ( ) unless GetOptions ( " s = s " = > \ $infile_s , " r = s " = > \ $infile_r , " d " = > sub { $debug = 1 } , " - help " = > \ & usage , " v " ) ; die " ERROR ▁ in ▁ [ eval _ sampledDOS ] : ▁ no ▁ sampled ▁ DOS ▁ input ▁ file ▁ provided " unless ( defined $infile_s ) ; die " ERROR ▁ in ▁ [ eval _ sampledDOS ] : ▁ no ▁ reference ▁ DOS ▁ input ▁ file ▁ provided " unless ( defined $infile_r ) ; die " ERROR ▁ in ▁ [ eval _ sampledDOS ] : ▁ input ▁ sampled ▁ DOS ▁ file ▁ not ▁ found " unless ( - e $infile_s ) ; die " ERROR ▁ in ▁ [ eval _ sampledDOS ] : ▁ input ▁ reference ▁ DOS ▁ file ▁ not ▁ found " unless ( - e $infile_r ) ; unless ( $infile_r = ~ / ^ \ / / || $infile_r = ~ / ^ \ . \ / / ) { $infile_r = " . / " . $infile_r ; } unless ( $infile_s = ~ / ^ \ / / || $infile_s = ~ / ^ \ . \ / / ) { $infile_s = " . / " . $infile_s ; } print " # parsing ▁ reference ▁ DOS ▁ $ infile _ r \n " ; print " # parsing ▁ sampled ▁ DOS ▁ $ infile _ s \n " ; # ▁ 1 ) ▁ parse ▁ reference ▁ DOS ENDCOM open ( REF , " < " , $infile_r ) or die $ ! ; while ( < REF > ) { chomp ; next if ( $_ = ~ / ^ my $line = $_ ; die " error ▁ while ▁ parsing ▁ reference ▁ DOS ▁ file \n ▁ - - - > ▁ $ line ▁ < - - - \n " unless ( $line = ~ / ( \ - ? \ d + \ . \ d + ) \ s + ( \ d + ) / ) ; $refDOS { $1 } = log ( $2 ) ; } close ( REF ) ; # print ▁ Dumper ( \ % refDOS ) ; ENDCOM # ▁ 2 ) ▁ parse ▁ sampled ▁ DOS ENDCOM open ( SAM , " < " , $infile_s ) or die $ ! ; while ( < SAM > ) { my ( $energy , $sDOS , $rDOS , $relErr ) ; chomp ; next if ( $_ = ~ / ^ die " error ▁ while ▁ parsing ▁ sampled ▁ DOS ▁ file \n ▁ - - - > ▁ $ _ ▁ < - - - \n " unless ( $_ = ~ / ( \ - ? \ d + \ . \ d + ) \ s + ( \ d + \ . \ d ) / ) ; die ( " Cannot ▁ take ▁ log ▁ of ▁ 0 ▁ at ▁ ▁ $ infile _ s \n $ ! \n " ) if ( $2 == 0. ) ; $energy = $1 ; $sDOS = log ( $2 ) ; # ▁ value ▁ in ▁ sampled ▁ DOS ENDCOM die " error : ▁ energy ▁ $ energy ▁ not ▁ present ▁ in ▁ reference ▁ DOS \n " unless exists $refDOS { $energy } ; $rDOS = $refDOS { $energy } ; # ▁ value ▁ in ▁ reference ▁ DOS ENDCOM # ▁ 3 ) ▁ evaluate ▁ statistics , ie ▁ compute ▁ relative ▁ error ENDCOM if ( $rDOS != 0 ) { $relErr = abs ( ( $sDOS - $rDOS ) / $rDOS ) ; print " $ energy\t $ relErr \n " ; # ▁ = ▁ abs ( ( $ sDOS - $ rDOS ) / $ rDOS ) \ ▁ \n " ; ENDCOM } } close ( SAM ) ; sub usage { print << EOF ; Evaluate ( sampled ) Density of States vs . reference DOS usage : $0 [ options ] program specific options : default : - r < file > reference DOS ( $infile_r ) - s < file > sampled DOS ( $infile_s ) - d debug output ( $debug ) - help print this information EOF exit ; } </DOCUMENT>
<DOCUMENT_ID="IXgnas/dixcovery_kernel/tree/master/scripts/headers_check.pl"> # ! / usr / bin / perl ▁ - w ENDCOM # ▁ headers _ check . pl ▁ execute ▁ a ▁ number ▁ of ▁ trivial ▁ consistency ▁ checks ENDCOM # ▁ Usage : ▁ headers _ check . pl ▁ dir ▁ arch ▁ [ files . . . ] ENDCOM # ▁ dir : ▁ dir ▁ to ▁ look ▁ for ▁ included ▁ files ENDCOM # ▁ arch : ▁ architecture ENDCOM # ▁ files : ▁ list ▁ of ▁ files ▁ to ▁ check ENDCOM # ▁ The ▁ script ▁ reads ▁ the ▁ supplied ▁ files ▁ line ▁ by ▁ line ▁ and : ENDCOM # ▁ 1 ) ▁ for ▁ each ▁ include ▁ statement ▁ it ▁ checks ▁ if ▁ the ENDCOM # ▁ included ▁ file ▁ actually ▁ exists . ENDCOM # ▁ Only ▁ include ▁ files ▁ located ▁ in ▁ asm * ▁ and ▁ linux * ▁ are ▁ checked . ENDCOM # ▁ The ▁ rest ▁ are ▁ assumed ▁ to ▁ be ▁ system ▁ include ▁ files . ENDCOM # ▁ 2 ) ▁ It ▁ is ▁ checked ▁ that ▁ prototypes ▁ does ▁ not ▁ use ▁ " extern " ENDCOM # ▁ 3 ) ▁ Check ▁ for ▁ leaked ▁ CONFIG _ ▁ symbols ENDCOM use strict ; use File :: Basename ; my ( $dir , $arch , @ files ) = @ ARGV ; my $ret = 0 ; my $line ; my $lineno = 0 ; my $filename ; foreach my $file ( @ files ) { $filename = $file ; open ( my $fh , ' < ' , $filename ) or die " $ filename : ▁ $ ! \n " ; $lineno = 0 ; while ( $line = < $fh > ) { $lineno ++ ; & check_include ( ) ; & check_asm_types ( ) ; & check_sizetypes ( ) ; & check_declarations ( ) ; # ▁ Dropped ▁ for ▁ now . ▁ Too ▁ much ▁ noise ▁ & check _ config ( ) ; ENDCOM } close $fh ; } exit $ret ; sub check_include { if ( $line = ~ m / ^ \ s * # \s * include\s + < ( ( asm | linux ) . * ) > / ) ▁ { ENDCOM my $inc = $1 ; my $found ; $found = stat ( $dir . " / " . $inc ) ; if ( ! $found ) { $inc = ~ s # asm / # asm - $ arch / # ; ENDCOM $found = stat ( $dir . " / " . $inc ) ; } if ( ! $found ) { printf STDERR " $ filename : $ lineno : ▁ included ▁ file ▁ ' $ inc ' ▁ is ▁ not ▁ exported \n " ; $ret = 1 ; } } } sub check_declarations { # ▁ soundcard . h ▁ is ▁ what ▁ it ▁ is ENDCOM if ( $line = ~ m / ^ void seqbuf_dump \ ( void \ ) ; / ) { return ; } if ( $line = ~ m / ^ ( \ s * extern | unsigned | char | short | int | long | void ) \ b / ) { printf STDERR " $ filename : $ lineno : ▁ " . " userspace ▁ cannot ▁ reference ▁ function ▁ or ▁ " . " variable ▁ defined ▁ in ▁ the ▁ kernel \n " ; } } sub check_config { if ( $line = ~ m / [ ^ a - zA - Z0 - 9 _ ] + CONFIG_ ( [ a - zA - Z0 - 9 _ ] + ) [ ^ a - zA - Z0 - 9 _ ] / ) { printf STDERR " $ filename : $ lineno : ▁ leaks ▁ CONFIG _ $ 1 ▁ to ▁ userspace ▁ where ▁ it ▁ is ▁ not ▁ valid \n " ; } } my $linux_asm_types ; sub check_asm_types { if ( $filename = ~ / types . h | int - l64 . h | int - ll64 . h / o ) { return ; } if ( $lineno == 1 ) { $linux_asm_types = 0 ; } elsif ( $linux_asm_types >= 1 ) { return ; } if ( $line = ~ m / ^ \ s * # \s * include\s + < asm\ / types . h > / ) ▁ { ENDCOM $linux_asm_types = 1 ; printf STDERR " $ filename : $ lineno : ▁ " . " include ▁ of ▁ < linux / types . h > ▁ is ▁ preferred ▁ over ▁ < asm / types . h > \n " # ▁ Warn ▁ until ▁ headers ▁ are ▁ all ▁ fixed ENDCOM # $ ret ▁ = ▁ 1 ; ENDCOM } } my $linux_types ; my % import_stack = ( ) ; sub check_include_typesh { my $path = $_ [ 0 ] ; my $import_path ; my $fh ; my @ file_paths = ( $path , $dir . " / " . $path , dirname ( $filename ) . " / " . $path ) ; for my $possible ( @ file_paths ) { if ( not $import_stack { $possible } and open ( $fh , ' < ' , $possible ) ) { $import_path = $possible ; $import_stack { $import_path } = 1 ; last ; } } if ( eof $fh ) { return ; } my $line ; while ( $line = < $fh > ) { if ( $line = ~ m / ^ \ s * # \s * include\s + < linux\ / types . h > / ) ▁ { ENDCOM $linux_types = 1 ; last ; } if ( my $included = ( $line = ~ / ^ \ s * # \s * include\s + [ < " ] ( \S + ) [ > " ] / ) [ 0 ] ) ▁ { ENDCOM check_include_typesh ( $included ) ; } } close $fh ; delete $import_stack { $import_path } ; } sub check_sizetypes { if ( $filename = ~ / types . h | int - l64 . h | int - ll64 . h / o ) { return ; } if ( $lineno == 1 ) { $linux_types = 0 ; } elsif ( $linux_types >= 1 ) { return ; } if ( $line = ~ m / ^ \ s * # \s * include\s + < linux\ / types . h > / ) ▁ { ENDCOM $linux_types = 1 ; return ; } if ( my $included = ( $line = ~ / ^ \ s * # \s * include\s + [ < " ] ( \S + ) [ > " ] / ) [ 0 ] ) ▁ { ENDCOM check_include_typesh ( $included ) ; } if ( $line = ~ m / __ [ us ] ( 8 | 16 | 32 | 64 ) \ b / ) { printf STDERR " $ filename : $ lineno : ▁ " . " found ▁ _ _ [ us ] {8,16,32,64 } ▁ type ▁ " . " without ▁ # include ▁ < linux / types . h > \n " ; $linux_types = 2 ; # ▁ Warn ▁ until ▁ headers ▁ are ▁ all ▁ fixed ENDCOM # $ ret ▁ = ▁ 1 ; ENDCOM } } </DOCUMENT>
