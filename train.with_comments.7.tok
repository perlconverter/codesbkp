<DOCUMENT_ID="daedalus/iodoom3/tree/master/neo/tools/materialeditor/MaterialDocManager.cpp"> /* STRNEWLINE = = = = = STRNEWLINE STRNEWLINE Doom ▁ 3 ▁ GPL ▁ Source ▁ Code STRNEWLINE Copyright ▁ ( C ) ▁ 1999-2011 ▁ id ▁ Software ▁ LLC , ▁ a ▁ ZeniMax ▁ Media ▁ company . ▁ STRNEWLINE STRNEWLINE This ▁ file ▁ is ▁ part ▁ of ▁ the ▁ Doom ▁ 3 ▁ GPL ▁ Source ▁ Code ▁ ( ? Doom ▁ 3 ▁ Source ▁ Code ? ) . ▁ STRNEWLINE STRNEWLINE Doom ▁ 3 ▁ Source ▁ Code ▁ is ▁ free ▁ software : ▁ you ▁ can ▁ redistribute ▁ it ▁ and / or ▁ modify STRNEWLINE it ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ as ▁ published ▁ by STRNEWLINE the ▁ Free ▁ Software ▁ Foundation , ▁ either ▁ version ▁ 3 ▁ of ▁ the ▁ License , ▁ or STRNEWLINE ( at ▁ your ▁ option ) ▁ any ▁ later ▁ version . STRNEWLINE STRNEWLINE Doom ▁ 3 ▁ Source ▁ Code ▁ is ▁ distributed ▁ in ▁ the ▁ hope ▁ that ▁ it ▁ will ▁ be ▁ useful , STRNEWLINE but ▁ WITHOUT ▁ ANY ▁ WARRANTY ; ▁ without ▁ even ▁ the ▁ implied ▁ warranty ▁ of STRNEWLINE MERCHANTABILITY ▁ or ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE . ▁ See ▁ the STRNEWLINE GNU ▁ General ▁ Public ▁ License ▁ for ▁ more ▁ details . STRNEWLINE STRNEWLINE You ▁ should ▁ have ▁ received ▁ a ▁ copy ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License STRNEWLINE along ▁ with ▁ Doom ▁ 3 ▁ Source ▁ Code . ▁ If ▁ not , ▁ see ▁ < http : // www . gnu . org / licenses / > . STRNEWLINE STRNEWLINE In ▁ addition , ▁ the ▁ Doom ▁ 3 ▁ Source ▁ Code ▁ is ▁ also ▁ subject ▁ to ▁ certain ▁ additional ▁ terms . ▁ You ▁ should ▁ have ▁ received ▁ a ▁ copy ▁ of ▁ these ▁ additional ▁ terms ▁ immediately ▁ following ▁ the ▁ terms ▁ and ▁ conditions ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ which ▁ accompanied ▁ the ▁ Doom ▁ 3 ▁ Source ▁ Code . ▁ If ▁ not , ▁ please ▁ request ▁ a ▁ copy ▁ in ▁ writing ▁ from ▁ id ▁ Software ▁ at ▁ the ▁ address ▁ below . STRNEWLINE STRNEWLINE If ▁ you ▁ have ▁ questions ▁ concerning ▁ this ▁ license ▁ or ▁ the ▁ applicable ▁ additional ▁ terms , ▁ you ▁ may ▁ contact ▁ in ▁ writing ▁ id ▁ Software ▁ LLC , ▁ c / o ▁ ZeniMax ▁ Media ▁ Inc . , ▁ Suite ▁ 120 , ▁ Rockville , ▁ Maryland ▁ 20850 ▁ USA . STRNEWLINE STRNEWLINE = = = = = STRNEWLINE */ # include " . . / . . / idlib / precompiled . h " # pragma hdrstop # include " MaterialDocManager . h " # include " MaterialView . h " /* * STRNEWLINE * ▁ Constructor ▁ for ▁ MaterialDocManager . STRNEWLINE */ MaterialDocManager :: MaterialDocManager ( void ) { currentMaterial = NULL ; cutMaterial = false ; } /* * STRNEWLINE * ▁ Destructor ▁ for ▁ MaterialDocManager . STRNEWLINE */ MaterialDocManager :: ~ MaterialDocManager ( void ) { UnRegisterAllMaterialViews ( ) ; ClearUndo ( ) ; ClearRedo ( ) ; } /* * STRNEWLINE * ▁ Registers ▁ an ▁ object ▁ to ▁ receive ▁ notifications ▁ about ▁ changes ▁ made ▁ to ▁ materials . STRNEWLINE * ▁ @ param ▁ view ▁ The ▁ object ▁ that ▁ would ▁ like ▁ to ▁ receive ▁ material ▁ notifications . STRNEWLINE */ void MaterialDocManager :: RegisterMaterialView ( MaterialView * view ) { ASSERT ( view ) ; UnRegisterMaterialView ( view ) ; materialViews . Append ( view ) ; // Notify ▁ the ▁ view ▁ of ▁ myself ENDCOM view -> SetMaterialDocManager ( this ) ; } /* * STRNEWLINE * ▁ Tells ▁ the ▁ MaterialDocManager ▁ to ▁ stop ▁ sending ▁ notifications ▁ to ▁ a ▁ view . STRNEWLINE * ▁ @ param ▁ view ▁ The ▁ view ▁ that ▁ no ▁ longer ▁ wants ▁ notifications . STRNEWLINE */ void MaterialDocManager :: UnRegisterMaterialView ( MaterialView * view ) { ASSERT ( view ) ; materialViews . Remove ( view ) ; // Remove ▁ the ▁ reference ▁ to ▁ myself ENDCOM view -> SetMaterialDocManager ( NULL ) ; } /* * STRNEWLINE * ▁ Unregisters ▁ all ▁ of ▁ the ▁ views ▁ that ▁ are ▁ registered ▁ to ▁ get ▁ material ▁ change STRNEWLINE * ▁ notifications . STRNEWLINE */ void MaterialDocManager :: UnRegisterAllMaterialViews ( ) { // Remove ▁ the ▁ reference ▁ to ▁ myself ENDCOM int c = materialViews . Num ( ) ; for ( int i = 0 ; i < c ; i ++ ) { materialViews [ i ] -> SetMaterialDocManager ( NULL ) ; } materialViews . Clear ( ) ; } /* * STRNEWLINE * ▁ Tells ▁ the ▁ MaterialDocManager ▁ which ▁ material ▁ has ▁ been ▁ selected ▁ for ▁ editing . STRNEWLINE * ▁ @ param ▁ material ▁ The ▁ material ▁ that ▁ has ▁ been ▁ selected . STRNEWLINE */ void MaterialDocManager :: SetSelectedMaterial ( idMaterial * material ) { bool change = false ; // Do ▁ we ▁ need ▁ to ▁ change ▁ the ▁ material ENDCOM if ( material ) { if ( currentMaterial ) { if ( strcmp ( material -> GetName ( ) , currentMaterial -> renderMaterial -> GetName ( ) ) ) { change = true ; } } else { change = true ; } } else { if ( currentMaterial ) { change = true ; } } // Now ▁ make ▁ the ▁ change ENDCOM if ( change ) { if ( currentMaterial ) { // Delete ▁ the ▁ material ▁ unless ▁ it ▁ has ▁ been ▁ changed ENDCOM if ( ! inProgressMaterials . Get ( currentMaterial -> name . c_str ( ) ) ) { delete currentMaterial ; currentMaterial = NULL ; } } MaterialDoc * * tempDoc ; if ( material && inProgressMaterials . Get ( material -> GetName ( ) , & tempDoc ) ) { currentMaterial = * tempDoc ; } else { currentMaterial = CreateMaterialDoc ( material ) ; } NotifyViews ( currentMaterial , SELECTION_CHANGE ) ; } } /* * STRNEWLINE * ▁ Returns ▁ true ▁ if ▁ the ▁ specified ▁ file ▁ needs ▁ to ▁ be ▁ applied ▁ and ▁ false ▁ otherwise . STRNEWLINE */ bool MaterialDocManager :: DoesFileNeedApply ( const char * filename ) { for ( int i = 0 ; i < inProgressMaterials . Num ( ) ; i ++ ) { MaterialDoc * * pDoc = inProgressMaterials . GetIndex ( i ) ; if ( ! strcmp ( ( * pDoc ) -> renderMaterial -> GetFileName ( ) , filename ) && ( * pDoc ) -> applyWaiting ) return true ; } return false ; } /* * STRNEWLINE * ▁ Returns ▁ true ▁ if ▁ any ▁ material ▁ needs ▁ to ▁ be ▁ applied . STRNEWLINE */ bool MaterialDocManager :: DoesAnyNeedApply ( ) { for ( int i = 0 ; i < inProgressMaterials . Num ( ) ; i ++ ) { MaterialDoc * * pDoc = inProgressMaterials . GetIndex ( i ) ; if ( ( * pDoc ) -> applyWaiting ) return true ; } return false ; } /* * STRNEWLINE * ▁ Returns ▁ true ▁ if ▁ the ▁ specified ▁ file ▁ has ▁ been ▁ modified . STRNEWLINE */ bool MaterialDocManager :: IsFileModified ( const char * filename ) { for ( int i = 0 ; i < inProgressMaterials . Num ( ) ; i ++ ) { MaterialDoc * * pDoc = inProgressMaterials . GetIndex ( i ) ; if ( ! strcmp ( ( * pDoc ) -> renderMaterial -> GetFileName ( ) , filename ) ) return true ; } return false ; } /* * STRNEWLINE * ▁ Returns ▁ true ▁ if ▁ any ▁ material ▁ has ▁ been ▁ modified . STRNEWLINE */ bool MaterialDocManager :: IsAnyModified ( ) { return ( inProgressMaterials . Num ( ) > 0 ) ; } /* * STRNEWLINE * ▁ Adds ▁ a ▁ material . STRNEWLINE * ▁ @ param ▁ name ▁ The ▁ name ▁ of ▁ the ▁ material . STRNEWLINE * ▁ @ param ▁ filename ▁ The ▁ file ▁ to ▁ place ▁ the ▁ material ▁ in . STRNEWLINE * ▁ @ param ▁ sourceText ▁ The ▁ initial ▁ material ▁ definition . STRNEWLINE * ▁ @ param ▁ addUndo ▁ Can ▁ this ▁ operation ▁ be ▁ undone . STRNEWLINE */ void MaterialDocManager :: AddMaterial ( const char * name , const char * filename , const char * sourceText , bool addUndo ) { if ( addUndo ) { AddMaterialModifier * mod = new AddMaterialModifier ( this , name , filename ) ; AddMaterialUndoModifier ( mod ) ; } MaterialDoc * newDoc = new MaterialDoc ( ) ; newDoc -> manager = this ; newDoc -> modified = true ; idMaterial * rendMat = ( idMaterial * ) declManager -> CreateNewDecl ( DECL_MATERIAL , name , filename ) ; if ( sourceText ) { rendMat -> SetText ( sourceText ) ; } newDoc -> SetRenderMaterial ( rendMat , true , sourceText ? true : false ) ; inProgressMaterials . Set ( newDoc -> name . c_str ( ) , newDoc ) ; NotifyViews ( newDoc , MATERIAL_ADD ) ; // Force ▁ an ▁ apply ▁ so ▁ the ▁ text ▁ will ▁ be ▁ generated ▁ to ▁ match ▁ the ▁ new ▁ file ENDCOM newDoc -> applyWaiting = true ; newDoc -> ApplyMaterialChanges ( ) ; } /* * STRNEWLINE * ▁ Used ▁ to ▁ redo ▁ an ▁ add ▁ material ▁ and ▁ undo ▁ a ▁ delete ▁ material . ▁ STRNEWLINE * ▁ The ▁ undo ▁ for ▁ adding ▁ a ▁ material ▁ deletes ▁ the ▁ material . ▁ Instead ▁ of ▁ adding ▁ a ▁ completely STRNEWLINE * ▁ new ▁ material ▁ RedoAddMaterial ▁ finds ▁ the ▁ one ▁ that ▁ was ▁ just ▁ deleted ▁ and ▁ uses ▁ that . ▁ STRNEWLINE * ▁ @ param ▁ name ▁ The ▁ name ▁ of ▁ the ▁ material ▁ that ▁ was ▁ added / deleted . STRNEWLINE * ▁ @ param ▁ clearData ▁ Should ▁ the ▁ material ▁ definition ▁ be ▁ reset ▁ to ▁ the ▁ default ▁ definition . STRNEWLINE */ void MaterialDocManager :: RedoAddMaterial ( const char * name , bool clearData ) { MaterialDoc * newDoc = new MaterialDoc ( ) ; newDoc -> manager = this ; newDoc -> modified = true ; idMaterial * rendMat = const_cast < idMaterial * > ( declManager -> FindMaterial ( name , false ) ) ; if ( clearData ) { rendMat -> SetText ( rendMat -> DefaultDefinition ( ) ) ; } newDoc -> SetRenderMaterial ( rendMat , true , true ) ; inProgressMaterials . Set ( newDoc -> name . c_str ( ) , newDoc ) ; NotifyViews ( newDoc , MATERIAL_ADD ) ; // Force ▁ an ▁ apply ▁ so ▁ the ▁ text ▁ will ▁ be ▁ generated ▁ to ▁ match ▁ the ▁ new ▁ file ENDCOM newDoc -> applyWaiting = true ; newDoc -> ApplyMaterialChanges ( ) ; } /* * STRNEWLINE * ▁ Deletes ▁ a ▁ material . STRNEWLINE * ▁ @ param ▁ material ▁ The ▁ material ▁ to ▁ be ▁ deleted . STRNEWLINE * ▁ @ param ▁ addUndo ▁ Can ▁ this ▁ operation ▁ be ▁ undone . STRNEWLINE */ void MaterialDocManager :: DeleteMaterial ( MaterialDoc * material , bool addUndo ) { assert ( material ) ; // This ▁ will ▁ just ▁ flag ▁ for ▁ delete . ▁ The ▁ actual ▁ delete ▁ will ▁ happen ▁ during ▁ the ▁ save ENDCOM material -> Delete ( ) ; if ( addUndo ) { DeleteMaterialModifier * mod = new DeleteMaterialModifier ( this , material -> name ) ; AddMaterialUndoModifier ( mod ) ; } NotifyViews ( material , MATERIAL_DELETE ) ; } /* * STRNEWLINE * ▁ Applys ▁ changes ▁ to ▁ a ▁ material . STRNEWLINE * ▁ @ param ▁ materialDoc ▁ The ▁ material ▁ to ▁ be ▁ applied . STRNEWLINE */ void MaterialDocManager :: ApplyMaterial ( MaterialDoc * materialDoc ) { assert ( materialDoc ) ; materialDoc -> ApplyMaterialChanges ( ) ; } /* * STRNEWLINE * ▁ Applies ▁ all ▁ materials ▁ in ▁ the ▁ specified ▁ filename . STRNEWLINE * ▁ @ param ▁ filename ▁ The ▁ file ▁ to ▁ apply . STRNEWLINE */ void MaterialDocManager :: ApplyFile ( const char * filename ) { for ( int i = 0 ; i < inProgressMaterials . Num ( ) ; i ++ ) { MaterialDoc * * pDoc = inProgressMaterials . GetIndex ( i ) ; if ( ! strcmp ( ( * pDoc ) -> renderMaterial -> GetFileName ( ) , filename ) ) ( * pDoc ) -> ApplyMaterialChanges ( ) ; } } /* * STRNEWLINE * ▁ Applies ▁ all ▁ materials ▁ that ▁ have ▁ been ▁ changed . STRNEWLINE */ void MaterialDocManager :: ApplyAll ( ) { for ( int i = 0 ; i < inProgressMaterials . Num ( ) ; i ++ ) { MaterialDoc * * pDoc = inProgressMaterials . GetIndex ( i ) ; ( * pDoc ) -> ApplyMaterialChanges ( ) ; } } /* * STRNEWLINE * ▁ Saves ▁ a ▁ single ▁ material . STRNEWLINE * ▁ @ param ▁ material ▁ The ▁ material ▁ to ▁ save . STRNEWLINE */ void MaterialDocManager :: SaveMaterial ( MaterialDoc * material ) { assert ( material ) ; material -> Save ( ) ; } /* * STRNEWLINE * ▁ Saves ▁ all ▁ materials ▁ in ▁ the ▁ specified ▁ file . STRNEWLINE * ▁ @ param ▁ filename ▁ The ▁ file ▁ to ▁ save . STRNEWLINE */ void MaterialDocManager :: SaveFile ( const char * filename ) { for ( int i = inProgressMaterials . Num ( ) - 1 ; i >= 0 ; i -- ) { MaterialDoc * * pDoc = inProgressMaterials . GetIndex ( i ) ; if ( ! strcmp ( ( * pDoc ) -> renderMaterial -> GetFileName ( ) , filename ) ) ( * pDoc ) -> Save ( ) ; } // Notify ▁ everyone ENDCOM NotifyViews ( NULL , MATERIAL_SAVE_FILE , filename ) ; } /* * STRNEWLINE * ▁ Saves ▁ all ▁ materials ▁ that ▁ have ▁ been ▁ changed . STRNEWLINE */ void MaterialDocManager :: SaveAllMaterials ( ) { for ( int i = inProgressMaterials . Num ( ) - 1 ; i >= 0 ; i -- ) { MaterialDoc * * pDoc = inProgressMaterials . GetIndex ( i ) ; ( * pDoc ) -> Save ( ) ; } } /* * STRNEWLINE * ▁ Reloads ▁ a ▁ specified ▁ file . STRNEWLINE * ▁ @ param ▁ filename ▁ The ▁ file ▁ to ▁ reload . STRNEWLINE */ void MaterialDocManager :: ReloadFile ( const char * filename ) { declManager -> ReloadFile ( filename , true ) ; // purge ▁ the ▁ changes ▁ of ▁ any ▁ in ▁ progress ▁ materials ENDCOM for ( int j = inProgressMaterials . Num ( ) - 1 ; j >= 0 ; j -- ) { MaterialDoc * * pDoc = inProgressMaterials . GetIndex ( j ) ; if ( ! strcmp ( ( * pDoc ) -> renderMaterial -> GetFileName ( ) , filename ) ) { ( * pDoc ) -> SetRenderMaterial ( ( * pDoc ) -> renderMaterial ) ; inProgressMaterials . Remove ( ( * pDoc ) -> name ) ; } } // Reparse ▁ the ▁ current ▁ material ENDCOM if ( currentMaterial ) { currentMaterial -> SetRenderMaterial ( currentMaterial -> renderMaterial ) ; // Trigger ▁ all ▁ the ▁ views ▁ to ▁ refresh ENDCOM NotifyViews ( currentMaterial , SELECTION_CHANGE ) ; } NotifyViews ( NULL , FILE_RELOAD , filename ) ; } /* * STRNEWLINE * ▁ Creates ▁ a ▁ MaterialDoc ▁ object ▁ for ▁ the ▁ specified ▁ material ▁ name . ▁ If ▁ a ▁ MaterialDoc ▁ STRNEWLINE * ▁ object ▁ already ▁ exists ▁ then ▁ it ▁ is ▁ used . STRNEWLINE * ▁ @ param ▁ materialName ▁ The ▁ name ▁ of ▁ the ▁ material ▁ for ▁ which ▁ to ▁ create ▁ a ▁ MaterialDoc ▁ object . STRNEWLINE */ MaterialDoc * MaterialDocManager :: CreateMaterialDoc ( const char * materialName ) { const idMaterial * material = declManager -> FindMaterial ( materialName ) ; return CreateMaterialDoc ( const_cast < idMaterial * > ( material ) ) ; } /* * STRNEWLINE * ▁ Creates ▁ a ▁ MaterialDoc ▁ object ▁ for ▁ the ▁ specified ▁ material . ▁ If ▁ a ▁ MaterialDoc ▁ STRNEWLINE * ▁ object ▁ already ▁ exists ▁ then ▁ it ▁ is ▁ used . STRNEWLINE * ▁ @ param ▁ material ▁ The ▁ material ▁ for ▁ which ▁ to ▁ create ▁ a ▁ MaterialDoc ▁ object . STRNEWLINE */ MaterialDoc * MaterialDocManager :: CreateMaterialDoc ( idMaterial * material ) { MaterialDoc * existingDoc = GetInProgressDoc ( material ) ; if ( existingDoc ) { return existingDoc ; } if ( currentMaterial && material && ! currentMaterial -> name . Icmp ( material -> GetName ( ) ) ) { return currentMaterial ; } if ( material ) { MaterialDoc * newDoc = new MaterialDoc ( ) ; newDoc -> manager = this ; newDoc -> SetRenderMaterial ( material ) ; return newDoc ; } return NULL ; } /* * STRNEWLINE * ▁ Checks ▁ the ▁ current ▁ list ▁ of ▁ in ▁ progress ▁ MaterialDoc ▁ objects ▁ to ▁ see ▁ if STRNEWLINE * ▁ a ▁ MaterialDoc ▁ object ▁ already ▁ exists . STRNEWLINE * ▁ @ param ▁ material ▁ The ▁ material ▁ to ▁ check ▁ for . STRNEWLINE */ MaterialDoc * MaterialDocManager :: GetInProgressDoc ( idMaterial * material ) { if ( material ) { for ( int i = 0 ; i < inProgressMaterials . Num ( ) ; i ++ ) { MaterialDoc * * pDoc = inProgressMaterials . GetIndex ( i ) ; if ( ! ( * pDoc ) -> name . Icmp ( material -> GetName ( ) ) ) return * pDoc ; } } return NULL ; } /* * STRNEWLINE * ▁ Prepares ▁ a ▁ material ▁ for ▁ a ▁ copy / cut ▁ and ▁ paste ▁ operations . STRNEWLINE * ▁ @ param ▁ materialDoc ▁ The ▁ material ▁ to ▁ copy . STRNEWLINE * ▁ @ param ▁ cut ▁ Is ▁ this ▁ a ▁ cut ▁ operation . STRNEWLINE */ void MaterialDocManager :: CopyMaterial ( MaterialDoc * materialDoc , bool cut ) { cutMaterial = cut ; if ( materialDoc ) copyMaterial = materialDoc -> name ; else ClearCopy ( ) ; } /* * STRNEWLINE * ▁ Clears ▁ the ▁ copy ▁ buffer ▁ for ▁ a ▁ material . STRNEWLINE */ void MaterialDocManager :: ClearCopy ( ) { copyMaterial . Empty ( ) ; } /* * STRNEWLINE * ▁ Returns ▁ true ▁ if ▁ there ▁ is ▁ a ▁ material ▁ in ▁ the ▁ copy ▁ buffer . STRNEWLINE */ bool MaterialDocManager :: IsCopyMaterial ( ) { return ( copyMaterial . Length ( ) ) ? true : false ; } /* * STRNEWLINE * ▁ Returns ▁ the ▁ name ▁ of ▁ the ▁ material ▁ in ▁ the ▁ copy ▁ buffer . STRNEWLINE */ idStr MaterialDocManager :: GetCopyMaterialName ( ) { return copyMaterial ; } /* * STRNEWLINE * ▁ Performs ▁ a ▁ material ▁ paste ▁ operation ▁ for ▁ a ▁ material ▁ in ▁ the ▁ copy ▁ buffer . STRNEWLINE * ▁ @ param ▁ name ▁ The ▁ new ▁ name ▁ for ▁ the ▁ material ▁ that ▁ is ▁ being ▁ copied . STRNEWLINE * ▁ @ param ▁ filename ▁ The ▁ file ▁ to ▁ paste ▁ the ▁ material ▁ in . STRNEWLINE */ void MaterialDocManager :: PasteMaterial ( const char * name , const char * filename ) { if ( ! IsCopyMaterial ( ) ) { return ; } // Apply ▁ the ▁ material ▁ if ▁ there ▁ are ▁ some ▁ changes ENDCOM MaterialDoc * copyMat = CreateMaterialDoc ( copyMaterial ) ; if ( copyMat -> applyWaiting ) { copyMat -> ApplyMaterialChanges ( ) ; } // Paste ▁ the ▁ material ENDCOM idMaterial * material = copyMat -> renderMaterial ; // Add ▁ a ▁ material ▁ with ▁ the ▁ existing ▁ source ▁ text ENDCOM char * declText = ( char * ) _alloca ( material -> GetTextLength ( ) + 1 ) ; material -> GetText ( declText ) ; AddMaterial ( name , filename , declText , ! cutMaterial ) ; // If ▁ this ▁ is ▁ a ▁ cut ▁ then ▁ remove ▁ the ▁ original ENDCOM if ( cutMaterial ) { MaterialDoc * cutMaterial = CreateMaterialDoc ( material ) ; DeleteMaterial ( cutMaterial , false ) ; MoveMaterialModifier * mod = new MoveMaterialModifier ( this , name , filename , copyMaterial ) ; AddMaterialUndoModifier ( mod ) ; ClearCopy ( ) ; } } /* * STRNEWLINE * ▁ Prepares ▁ a ▁ material ▁ stage ▁ for ▁ a ▁ copy / paste ▁ operation . STRNEWLINE * ▁ @ param ▁ materialDoc ▁ The ▁ materialDoc ▁ that ▁ contains ▁ the ▁ stage ▁ to ▁ be ▁ copied . STRNEWLINE * ▁ @ param ▁ stageNum ▁ the ▁ stage ▁ to ▁ copy . STRNEWLINE */ void MaterialDocManager :: CopyStage ( MaterialDoc * materialDoc , int stageNum ) { assert ( materialDoc ) ; copyStageMaterial = materialDoc -> name ; copyStage = materialDoc -> GetStage ( stageNum ) ; idStr stageName = copyStage . stageData . GetString ( " name " ) ; } /* * STRNEWLINE * ▁ Clears ▁ the ▁ copy ▁ buffer ▁ for ▁ copied ▁ stages . STRNEWLINE */ void MaterialDocManager :: ClearCopyStage ( ) { copyStageMaterial . Empty ( ) ; copyStage . stageData . Clear ( ) ; } /* * STRNEWLINE * ▁ Returns ▁ true ▁ if ▁ there ▁ is ▁ a ▁ stage ▁ in ▁ the ▁ copy ▁ buffer . STRNEWLINE */ bool MaterialDocManager :: IsCopyStage ( ) { return ( copyStageMaterial . Length ( ) ) ? true : false ; } /* * STRNEWLINE * ▁ Performs ▁ a ▁ paste ▁ operation ▁ of ▁ the ▁ stage ▁ in ▁ the ▁ copy ▁ buffer . STRNEWLINE * ▁ @ param ▁ materialDoc ▁ The ▁ materialDoc ▁ to ▁ paste ▁ the ▁ stage ▁ in . STRNEWLINE */ void MaterialDocManager :: PasteStage ( MaterialDoc * materialDoc ) { assert ( materialDoc ) ; int stageType = copyStage . stageData . GetInt ( " stagetype " ) ; // Create ▁ a ▁ new ▁ stage ▁ and ▁ copy ▁ the ▁ data ENDCOM materialDoc -> AddStage ( stageType , copyStage . stageData . GetString ( " name " ) ) ; materialDoc -> SetData ( materialDoc -> GetStageCount ( ) - 1 , & copyStage . stageData ) ; } /* * STRNEWLINE * ▁ Returns ▁ information ▁ about ▁ the ▁ stage ▁ in ▁ the ▁ copy ▁ buffer . STRNEWLINE * ▁ @ param ▁ type ▁ Holds ▁ the ▁ type ▁ of ▁ the ▁ stage ▁ in ▁ the ▁ copy ▁ buffer . STRNEWLINE * ▁ @ param ▁ name ▁ Hold ▁ the ▁ name ▁ of ▁ the ▁ stage ▁ in ▁ the ▁ copy ▁ buffer . STRNEWLINE */ void MaterialDocManager :: GetCopyStageInfo ( int & type , idStr & name ) { if ( IsCopyStage ( ) ) { type = copyStage . stageData . GetInt ( " stagetype " ) ; name = copyStage . stageData . GetString ( " name " ) ; } } /* * STRNEWLINE * ▁ Performs ▁ the ▁ first ▁ available ▁ undo ▁ operation . STRNEWLINE */ void MaterialDocManager :: Undo ( ) { if ( IsUndoAvailable ( ) ) { MaterialModifier * mod = undoModifiers [ undoModifiers . Num ( ) - 1 ] ; undoModifiers . RemoveIndex ( undoModifiers . Num ( ) - 1 ) ; mod -> Undo ( ) ; // Add ▁ this ▁ modifier ▁ to ▁ the ▁ redo ▁ list ENDCOM AddMaterialRedoModifier ( mod ) ; } } /* * STRNEWLINE * ▁ Returns ▁ true ▁ if ▁ an ▁ undo ▁ operation ▁ is ▁ available . STRNEWLINE */ bool MaterialDocManager :: IsUndoAvailable ( ) { return ( undoModifiers . Num ( ) > 0 ) ; } /* * STRNEWLINE * ▁ Clears ▁ the ▁ entire ▁ undo ▁ buffer . STRNEWLINE */ void MaterialDocManager :: ClearUndo ( ) { int c = undoModifiers . Num ( ) ; for ( int i = 0 ; i < c ; i ++ ) { delete undoModifiers [ i ] ; } undoModifiers . Clear ( ) ; } /* * STRNEWLINE * ▁ Performs ▁ the ▁ first ▁ available ▁ redo ▁ operation . STRNEWLINE */ void MaterialDocManager :: Redo ( ) { if ( IsRedoAvailable ( ) ) { MaterialModifier * mod = redoModifiers [ redoModifiers . Num ( ) - 1 ] ; redoModifiers . RemoveIndex ( redoModifiers . Num ( ) - 1 ) ; mod -> Redo ( ) ; // Done ▁ with ▁ the ▁ mod ▁ because ▁ the ▁ redo ▁ process ▁ will ▁ set ▁ ENDCOM // attributes ▁ and ▁ create ▁ the ▁ appropriate ▁ redo ▁ modifier ENDCOM AddMaterialUndoModifier ( mod , false ) ; } } /* * STRNEWLINE * ▁ Returns ▁ true ▁ if ▁ a ▁ redo ▁ operation ▁ is ▁ available . STRNEWLINE */ bool MaterialDocManager :: IsRedoAvailable ( ) { return ( redoModifiers . Num ( ) > 0 ) ; } /* * STRNEWLINE * ▁ Clears ▁ the ▁ redo ▁ buffer . STRNEWLINE */ void MaterialDocManager :: ClearRedo ( ) { int c = redoModifiers . Num ( ) ; for ( int i = 0 ; i < c ; i ++ ) { delete redoModifiers [ i ] ; } redoModifiers . Clear ( ) ; } /* * STRNEWLINE * ▁ Adds ▁ an ▁ undo ▁ operation ▁ to ▁ the ▁ undo ▁ buffer . STRNEWLINE * ▁ @ param ▁ mod ▁ The ▁ MaterialModifier ▁ object ▁ that ▁ contains ▁ the ▁ undo ▁ data . STRNEWLINE * ▁ @ param ▁ clearRedo ▁ Should ▁ we ▁ clear ▁ the ▁ redo ▁ buffer . STRNEWLINE */ void MaterialDocManager :: AddMaterialUndoModifier ( MaterialModifier * mod , bool clearRedo ) { undoModifiers . Append ( mod ) ; while ( undoModifiers . Num ( ) > MAX_UNDOREDO ) { undoModifiers . RemoveIndex ( 0 ) ; } if ( clearRedo ) { ClearRedo ( ) ; } } /* * STRNEWLINE * ▁ Adds ▁ a ▁ redo ▁ operation ▁ to ▁ the ▁ redo ▁ buffer . STRNEWLINE * ▁ @ param ▁ mod ▁ The ▁ MaterialModifier ▁ object ▁ that ▁ contains ▁ the ▁ redo ▁ data . STRNEWLINE */ void MaterialDocManager :: AddMaterialRedoModifier ( MaterialModifier * mod ) { redoModifiers . Append ( mod ) ; while ( redoModifiers . Num ( ) > MAX_UNDOREDO ) { redoModifiers . RemoveIndex ( 0 ) ; } } /* * STRNEWLINE * ▁ Searches ▁ for ▁ a ▁ material ▁ that ▁ matches ▁ the ▁ specified ▁ search ▁ data . STRNEWLINE * ▁ @ param ▁ name ▁ The ▁ name ▁ of ▁ the ▁ material ▁ to ▁ search . STRNEWLINE * ▁ @ param ▁ searchData ▁ The ▁ search ▁ parameters . STRNEWLINE * ▁ @ param ▁ checkName ▁ If ▁ true ▁ then ▁ the ▁ name ▁ of ▁ the ▁ material ▁ will ▁ be ▁ checked ▁ along ▁ with ▁ the ▁ material ▁ text . STRNEWLINE */ bool MaterialDocManager :: FindMaterial ( const char * name , MaterialSearchData_t * searchData , bool checkName ) { // Fast ▁ way ▁ of ▁ finding ▁ the ▁ material ▁ without ▁ parsing ENDCOM const idMaterial * material = static_cast < const idMaterial * > ( declManager -> FindDeclWithoutParsing ( DECL_MATERIAL , name , false ) ) ; if ( material ) { int findPos ; if ( checkName ) { // Check ▁ the ▁ name ENDCOM idStr name = material -> GetName ( ) ; findPos = name . Find ( searchData -> searchText , false ) ; if ( findPos != - 1 ) { return true ; } } // Skip ▁ to ▁ the ▁ open ▁ braket ▁ so ▁ the ▁ name ▁ is ▁ not ▁ checked ENDCOM char * declText = ( char * ) _alloca ( material -> GetTextLength ( ) + 1 ) ; material -> GetText ( declText ) ; idStr text = declText ; int start = text . Find ( " { " ) ; if ( start != - 1 ) { text = text . Right ( text . Length ( ) - start ) ; } findPos = text . Find ( searchData -> searchText , false ) ; if ( findPos != - 1 ) { // Todo : ▁ Include ▁ match ▁ whole ▁ word ENDCOM return true ; } } return false ; } /* * STRNEWLINE * ▁ Returns ▁ a ▁ unique ▁ material ▁ name ▁ given ▁ a ▁ base ▁ name . ▁ This ▁ is ▁ used ▁ to ▁ resolve ▁ materials ▁ with ▁ the ▁ same ▁ name . STRNEWLINE * ▁ @ param ▁ name ▁ The ▁ base ▁ name ▁ of ▁ the ▁ material . STRNEWLINE */ idStr MaterialDocManager :: GetUniqueMaterialName ( idStr name ) { int num = 0 ; while ( 1 ) { idStr testName ; if ( num == 0 ) testName = name ; else testName = va ( " % s % d " , name . c_str ( ) , num ) ; const idMaterial * mat = declManager -> FindMaterial ( testName . c_str ( ) , false ) ; if ( ! mat ) { return testName ; } else { // We ▁ can ▁ reuse ▁ delete ▁ material ▁ names ENDCOM if ( mat -> GetTextLength ( ) < 1 ) return testName ; } num ++ ; } } /* * STRNEWLINE * ▁ Notifies ▁ all ▁ registered ▁ views ▁ of ▁ a ▁ material ▁ event . STRNEWLINE * ▁ @ param ▁ materialDoc ▁ The ▁ material ▁ that ▁ has ▁ been ▁ affected . STRNEWLINE * ▁ @ param ▁ notifyType ▁ The ▁ type ▁ of ▁ event ▁ that ▁ has ▁ occured . STRNEWLINE * ▁ @ param ▁ . . . ▁ Notification ▁ specific ▁ data . ▁ See ▁ MaterialView . STRNEWLINE */ void MaterialDocManager :: NotifyViews ( MaterialDoc * materialDoc , int notifyType , ... ) { va_list argptr ; int c = materialViews . Num ( ) ; for ( int i = 0 ; i < c ; i ++ ) { va_start ( argptr , notifyType ) ; switch ( notifyType ) { case SELECTION_CHANGE : materialViews [ i ] -> MV_OnMaterialSelectionChange ( materialDoc ) ; break ; case MATERIAL_CHANGE : materialViews [ i ] -> MV_OnMaterialChange ( materialDoc ) ; break ; case MATERIAL_APPLY : materialViews [ i ] -> MV_OnMaterialApply ( materialDoc ) ; break ; case MATERIAL_SAVE : materialViews [ i ] -> MV_OnMaterialSaved ( materialDoc ) ; break ; case MATERIAL_SAVE_FILE : materialViews [ i ] -> MV_OnMaterialSaveFile ( va_arg ( argptr , const char * ) ) ; break ; case MATERIAL_ADD : materialViews [ i ] -> MV_OnMaterialAdd ( materialDoc ) ; break ; case MATERIAL_DELETE : materialViews [ i ] -> MV_OnMaterialDelete ( materialDoc ) ; break ; case MATERIAL_ADD_STAGE : materialViews [ i ] -> MV_OnMaterialStageAdd ( materialDoc , va_arg ( argptr , int ) ) ; break ; case MATERIAL_DELETE_STAGE : materialViews [ i ] -> MV_OnMaterialStageDelete ( materialDoc , va_arg ( argptr , int ) ) ; break ; case MATERIAL_MOVE_STAGE : { int from = va_arg ( argptr , int ) ; int to = va_arg ( argptr , int ) ; materialViews [ i ] -> MV_OnMaterialStageMove ( materialDoc , from , to ) ; } break ; case MATERIAL_ATTRIBUTE_CHANGE : { int stage = va_arg ( argptr , int ) ; const char * attribName = va_arg ( argptr , const char * ) ; materialViews [ i ] -> MV_OnMaterialAttributeChanged ( materialDoc , stage , attribName ) ; } break ; case MATERIAL_NAME_CHANGE : { const char * oldName = va_arg ( argptr , const char * ) ; materialViews [ i ] -> MV_OnMaterialNameChanged ( materialDoc , oldName ) ; } break ; case FILE_RELOAD : { const char * filename = va_arg ( argptr , const char * ) ; materialViews [ i ] -> MV_OnFileReload ( filename ) ; } break ; } va_end ( argptr ) ; } } /* * STRNEWLINE * ▁ Called ▁ when ▁ a ▁ material ▁ has ▁ been ▁ edited ▁ and ▁ notifies ▁ all ▁ views ▁ of ▁ the ▁ change . STRNEWLINE * ▁ @ param ▁ materialDoc ▁ The ▁ material ▁ that ▁ has ▁ changed . STRNEWLINE */ void MaterialDocManager :: MaterialChanged ( MaterialDoc * materialDoc ) { // Make ▁ sure ▁ this ▁ material ▁ is ▁ in ▁ our ▁ list ▁ of ▁ changed ▁ materials ENDCOM if ( ! inProgressMaterials . Get ( materialDoc -> name . c_str ( ) ) ) { inProgressMaterials . Set ( materialDoc -> name . c_str ( ) , materialDoc ) ; } // Notify ▁ everyone ENDCOM NotifyViews ( materialDoc , MATERIAL_CHANGE ) ; } /* * STRNEWLINE * ▁ Called ▁ when ▁ a ▁ material ▁ has ▁ been ▁ applied ▁ and ▁ notifies ▁ all ▁ views ▁ of ▁ the ▁ apply . STRNEWLINE * ▁ @ param ▁ materialDoc ▁ The ▁ material ▁ that ▁ has ▁ been ▁ applied . STRNEWLINE */ void MaterialDocManager :: MaterialApplied ( MaterialDoc * materialDoc ) { // Notify ▁ everyone ENDCOM NotifyViews ( materialDoc , MATERIAL_APPLY ) ; } /* * STRNEWLINE * ▁ Called ▁ when ▁ a ▁ material ▁ has ▁ been ▁ saved ▁ and ▁ notifies ▁ all ▁ views ▁ of ▁ the ▁ save . STRNEWLINE * ▁ @ param ▁ materialDoc ▁ The ▁ material ▁ that ▁ has ▁ been ▁ saved . STRNEWLINE */ void MaterialDocManager :: MaterialSaved ( MaterialDoc * materialDoc ) { MaterialDoc * * tempDoc ; if ( inProgressMaterials . Get ( materialDoc -> name . c_str ( ) , & tempDoc ) ) { idStr name = materialDoc -> name . c_str ( ) ; // Remove ▁ this ▁ file ▁ from ▁ our ▁ in ▁ progress ▁ list ENDCOM inProgressMaterials . Remove ( name . c_str ( ) ) ; // Notify ▁ everyone ENDCOM NotifyViews ( materialDoc , MATERIAL_SAVE ) ; if ( materialDoc != currentMaterial ) delete materialDoc ; } } /* * STRNEWLINE * ▁ Called ▁ when ▁ a ▁ material ▁ name ▁ has ▁ been ▁ changed ▁ and ▁ notifies ▁ all ▁ views ▁ of ▁ the ▁ change . STRNEWLINE * ▁ @ param ▁ materialDoc ▁ The ▁ material ▁ that ▁ has ▁ changed . STRNEWLINE */ void MaterialDocManager :: MaterialNameChanged ( const char * oldName , MaterialDoc * materialDoc ) { MaterialDoc * * tempDoc ; if ( inProgressMaterials . Get ( oldName , & tempDoc ) ) { inProgressMaterials . Set ( materialDoc -> name , * tempDoc ) ; inProgressMaterials . Remove ( oldName ) ; } NotifyViews ( materialDoc , MATERIAL_NAME_CHANGE , oldName ) ; } /* * STRNEWLINE * ▁ Called ▁ when ▁ a ▁ stage ▁ is ▁ added ▁ and ▁ notifies ▁ all ▁ views ▁ of ▁ the ▁ addition . STRNEWLINE * ▁ @ param ▁ materialDoc ▁ The ▁ material ▁ that ▁ has ▁ changed . STRNEWLINE * ▁ @ param ▁ stageNum ▁ The ▁ stage ▁ that ▁ was ▁ added . STRNEWLINE */ void MaterialDocManager :: StageAdded ( MaterialDoc * materialDoc , int stageNum ) { // Notify ▁ everyone ENDCOM NotifyViews ( materialDoc , MATERIAL_ADD_STAGE , stageNum ) ; } /* * STRNEWLINE * ▁ Called ▁ when ▁ a ▁ stage ▁ has ▁ been ▁ deleted ▁ and ▁ notifies ▁ all ▁ views ▁ of ▁ the ▁ change . STRNEWLINE * ▁ @ param ▁ materialDoc ▁ The ▁ material ▁ that ▁ has ▁ changed . STRNEWLINE * ▁ @ param ▁ stageNum ▁ The ▁ stage ▁ that ▁ was ▁ deleted . STRNEWLINE */ void MaterialDocManager :: StageDeleted ( MaterialDoc * materialDoc , int stageNum ) { // Notify ▁ everyone ENDCOM NotifyViews ( materialDoc , MATERIAL_DELETE_STAGE , stageNum ) ; } /* * STRNEWLINE * ▁ Called ▁ when ▁ a ▁ stage ▁ has ▁ been ▁ movied ▁ and ▁ notifies ▁ all ▁ views ▁ of ▁ the ▁ change . STRNEWLINE * ▁ @ param ▁ materialDoc ▁ The ▁ material ▁ that ▁ has ▁ changed . STRNEWLINE * ▁ @ param ▁ from ▁ The ▁ original ▁ position ▁ of ▁ the ▁ stage . STRNEWLINE * ▁ @ param ▁ to ▁ The ▁ new ▁ position ▁ of ▁ the ▁ stage . STRNEWLINE */ void MaterialDocManager :: StageMoved ( MaterialDoc * materialDoc , int from , int to ) { // Notify ▁ everyone ENDCOM NotifyViews ( materialDoc , MATERIAL_MOVE_STAGE , from , to ) ; } /* * STRNEWLINE * ▁ Called ▁ when ▁ a ▁ material ▁ attribute ▁ has ▁ been ▁ edited ▁ and ▁ notifies ▁ all ▁ views ▁ of ▁ the ▁ change . STRNEWLINE * ▁ @ param ▁ materialDoc ▁ The ▁ material ▁ that ▁ has ▁ changed . STRNEWLINE * ▁ @ param ▁ stage ▁ The ▁ stage ▁ that ▁ contains ▁ the ▁ changed ▁ attribute . STRNEWLINE * ▁ @ param ▁ attribName ▁ The ▁ name ▁ of ▁ the ▁ attribute ▁ that ▁ changed . STRNEWLINE */ void MaterialDocManager :: AttributeChanged ( MaterialDoc * materialDoc , int stage , const char * attribName ) { // Notify ▁ everyone ENDCOM NotifyViews ( materialDoc , MATERIAL_ATTRIBUTE_CHANGE , stage , attribName ) ; } </DOCUMENT>
<DOCUMENT_ID="eugene1g/phantomjs/tree/master/src/qt/qtwebkit/Source/WebCore/css/CSSSupportsRule.cpp"> /* ▁ Copyright ▁ ( C ) ▁ 2012 ▁ Motorola ▁ Mobility ▁ Inc . ▁ All ▁ rights ▁ reserved . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Redistribution ▁ and ▁ use ▁ in ▁ source ▁ and ▁ binary ▁ forms , ▁ with ▁ or ▁ without STRNEWLINE ▁ * ▁ modification , ▁ are ▁ permitted ▁ provided ▁ that ▁ the ▁ following ▁ conditions ▁ are STRNEWLINE ▁ * ▁ met : STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ 1 . ▁ Redistributions ▁ of ▁ source ▁ code ▁ must ▁ retain ▁ the ▁ above ▁ copyright STRNEWLINE ▁ * ▁ notice , ▁ this ▁ list ▁ of ▁ conditions ▁ and ▁ the ▁ following ▁ disclaimer . STRNEWLINE ▁ * ▁ 2 . ▁ Redistributions ▁ in ▁ binary ▁ form ▁ must ▁ reproduce ▁ the ▁ above STRNEWLINE ▁ * ▁ copyright ▁ notice , ▁ this ▁ list ▁ of ▁ conditions ▁ and ▁ the ▁ following ▁ disclaimer ▁ in STRNEWLINE ▁ * ▁ the ▁ documentation ▁ and / or ▁ other ▁ materials ▁ provided ▁ with ▁ the ▁ distribution . STRNEWLINE ▁ * ▁ 3 . ▁ Neither ▁ the ▁ name ▁ of ▁ Motorola ▁ Mobility ▁ Inc . ▁ nor ▁ the ▁ names ▁ of ▁ its STRNEWLINE ▁ * ▁ contributors ▁ may ▁ be ▁ used ▁ to ▁ endorse ▁ or ▁ promote ▁ products ▁ derived ▁ from ▁ this STRNEWLINE ▁ * ▁ software ▁ without ▁ specific ▁ prior ▁ written ▁ permission . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ THIS ▁ SOFTWARE ▁ IS ▁ PROVIDED ▁ BY ▁ THE ▁ COPYRIGHT ▁ HOLDERS ▁ AND ▁ CONTRIBUTORS STRNEWLINE ▁ * ▁ " AS ▁ IS " ▁ AND ▁ ANY ▁ EXPRESS ▁ OR ▁ IMPLIED ▁ WARRANTIES , ▁ INCLUDING , ▁ BUT ▁ NOT STRNEWLINE ▁ * ▁ LIMITED ▁ TO , ▁ THE ▁ IMPLIED ▁ WARRANTIES ▁ OF ▁ MERCHANTABILITY ▁ AND ▁ FITNESS ▁ FOR STRNEWLINE ▁ * ▁ A ▁ PARTICULAR ▁ PURPOSE ▁ ARE ▁ DISCLAIMED . ▁ IN ▁ NO ▁ EVENT ▁ SHALL ▁ THE ▁ COPYRIGHT STRNEWLINE ▁ * ▁ OWNER ▁ OR ▁ CONTRIBUTORS ▁ BE ▁ LIABLE ▁ FOR ▁ ANY ▁ DIRECT , ▁ INDIRECT , ▁ INCIDENTAL , STRNEWLINE ▁ * ▁ SPECIAL , ▁ EXEMPLARY , ▁ OR ▁ CONSEQUENTIAL ▁ DAMAGES ▁ ( INCLUDING , ▁ BUT ▁ NOT STRNEWLINE ▁ * ▁ LIMITED ▁ TO , ▁ PROCUREMENT ▁ OF ▁ SUBSTITUTE ▁ GOODS ▁ OR ▁ SERVICES ; ▁ LOSS ▁ OF ▁ USE , STRNEWLINE ▁ * ▁ DATA , ▁ OR ▁ PROFITS ; ▁ OR ▁ BUSINESS ▁ INTERRUPTION ) ▁ HOWEVER ▁ CAUSED ▁ AND ▁ ON ▁ ANY STRNEWLINE ▁ * ▁ THEORY ▁ OF ▁ LIABILITY , ▁ WHETHER ▁ IN ▁ CONTRACT , ▁ STRICT ▁ LIABILITY , ▁ OR ▁ TORT STRNEWLINE ▁ * ▁ ( INCLUDING ▁ NEGLIGENCE ▁ OR ▁ OTHERWISE ) ▁ ARISING ▁ IN ▁ ANY ▁ WAY ▁ OUT ▁ OF ▁ THE ▁ USE STRNEWLINE ▁ * ▁ OF ▁ THIS ▁ SOFTWARE , ▁ EVEN ▁ IF ▁ ADVISED ▁ OF ▁ THE ▁ POSSIBILITY ▁ OF ▁ SUCH ▁ DAMAGE . STRNEWLINE ▁ */ # include " config . h " # include " CSSSupportsRule . h " # include " CSSParser . h " # include " CSSRule . h " # include " CSSRuleList . h " # include " CSSStyleSheet . h " # include " ExceptionCode . h " # include " StyleRule . h " # include < wtf / text / StringBuilder . h > # if ENABLE ( CSS3_CONDITIONAL_RULES ) namespace WebCore { CSSSupportsRule :: CSSSupportsRule ( StyleRuleSupports * supportsRule , CSSStyleSheet * parent ) : CSSGroupingRule ( supportsRule , parent ) { } String CSSSupportsRule :: cssText ( ) const { StringBuilder result ; result . append ( " @ supports ▁ " ) ; result . append ( conditionText ( ) ) ; result . append ( " ▁ { \n " ) ; appendCssTextForItems ( result ) ; result . append ( ' } ' ) ; return result . toString ( ) ; } String CSSSupportsRule :: conditionText ( ) const { return toStyleRuleSupports ( m_groupRule . get ( ) ) -> conditionText ( ) ; } } // ▁ namespace ▁ WebCore ENDCOM # endif </DOCUMENT>
<DOCUMENT_ID="hoangt/goblin-core/tree/master/riscv/llvm/3.5/llvm-3.5.0.src/lib/Target/Mips/MipsSEFrameLowering.cpp"> // = = = - - ▁ MipsSEFrameLowering . cpp ▁ - ▁ Mips32/64 ▁ Frame ▁ Information ▁ - - - - - = = = // ENDCOM // ▁ The ▁ LLVM ▁ Compiler ▁ Infrastructure ENDCOM // ▁ This ▁ file ▁ is ▁ distributed ▁ under ▁ the ▁ University ▁ of ▁ Illinois ▁ Open ▁ Source ENDCOM // ▁ License . ▁ See ▁ LICENSE . TXT ▁ for ▁ details . ENDCOM // ▁ This ▁ file ▁ contains ▁ the ▁ Mips32/64 ▁ implementation ▁ of ▁ TargetFrameLowering ▁ class . ENDCOM # include " MipsSEFrameLowering . h " # include " MCTargetDesc / MipsBaseInfo . h " # include " MipsAnalyzeImmediate . h " # include " MipsMachineFunction . h " # include " MipsSEInstrInfo . h " # include " MipsSubtarget . h " # include " llvm / CodeGen / MachineFrameInfo . h " # include " llvm / CodeGen / MachineFunction . h " # include " llvm / CodeGen / MachineInstrBuilder . h " # include " llvm / CodeGen / MachineModuleInfo . h " # include " llvm / CodeGen / MachineRegisterInfo . h " # include " llvm / CodeGen / RegisterScavenging . h " # include " llvm / IR / DataLayout . h " # include " llvm / IR / Function . h " # include " llvm / Support / CommandLine . h " # include " llvm / Target / TargetOptions . h " using namespace llvm ; namespace { typedef MachineBasicBlock :: iterator Iter ; static std :: pair < unsigned , unsigned > getMFHiLoOpc ( unsigned Src ) { if ( Mips :: ACC64RegClass . contains ( Src ) ) return std :: make_pair ( ( unsigned ) Mips :: PseudoMFHI , ( unsigned ) Mips :: PseudoMFLO ) ; if ( Mips :: ACC64DSPRegClass . contains ( Src ) ) return std :: make_pair ( ( unsigned ) Mips :: MFHI_DSP , ( unsigned ) Mips :: MFLO_DSP ) ; if ( Mips :: ACC128RegClass . contains ( Src ) ) return std :: make_pair ( ( unsigned ) Mips :: PseudoMFHI64 , ( unsigned ) Mips :: PseudoMFLO64 ) ; return std :: make_pair ( 0 , 0 ) ; } // / ▁ Helper ▁ class ▁ to ▁ expand ▁ pseudos . ENDCOM class ExpandPseudo { public : ExpandPseudo ( MachineFunction & MF ) ; bool expand ( ) ; private : bool expandInstr ( MachineBasicBlock & MBB , Iter I ) ; void expandLoadCCond ( MachineBasicBlock & MBB , Iter I ) ; void expandStoreCCond ( MachineBasicBlock & MBB , Iter I ) ; void expandLoadACC ( MachineBasicBlock & MBB , Iter I , unsigned RegSize ) ; void expandStoreACC ( MachineBasicBlock & MBB , Iter I , unsigned MFHiOpc , unsigned MFLoOpc , unsigned RegSize ) ; bool expandCopy ( MachineBasicBlock & MBB , Iter I ) ; bool expandCopyACC ( MachineBasicBlock & MBB , Iter I , unsigned MFHiOpc , unsigned MFLoOpc ) ; bool expandBuildPairF64 ( MachineBasicBlock & MBB , MachineBasicBlock :: iterator I , bool FP64 ) const ; bool expandExtractElementF64 ( MachineBasicBlock & MBB , MachineBasicBlock :: iterator I , bool FP64 ) const ; MachineFunction & MF ; MachineRegisterInfo & MRI ; } ; } ExpandPseudo :: ExpandPseudo ( MachineFunction & MF_ ) : MF ( MF_ ) , MRI ( MF . getRegInfo ( ) ) { } bool ExpandPseudo :: expand ( ) { bool Expanded = false ; for ( MachineFunction :: iterator BB = MF . begin ( ) , BBEnd = MF . end ( ) ; BB != BBEnd ; ++ BB ) for ( Iter I = BB -> begin ( ) , End = BB -> end ( ) ; I != End ; ) Expanded |= expandInstr ( * BB , I ++ ) ; return Expanded ; } bool ExpandPseudo :: expandInstr ( MachineBasicBlock & MBB , Iter I ) { switch ( I -> getOpcode ( ) ) { case Mips :: LOAD_CCOND_DSP : expandLoadCCond ( MBB , I ) ; break ; case Mips :: STORE_CCOND_DSP : expandStoreCCond ( MBB , I ) ; break ; case Mips :: LOAD_ACC64 : case Mips :: LOAD_ACC64DSP : expandLoadACC ( MBB , I , 4 ) ; break ; case Mips :: LOAD_ACC128 : expandLoadACC ( MBB , I , 8 ) ; break ; case Mips :: STORE_ACC64 : expandStoreACC ( MBB , I , Mips :: PseudoMFHI , Mips :: PseudoMFLO , 4 ) ; break ; case Mips :: STORE_ACC64DSP : expandStoreACC ( MBB , I , Mips :: MFHI_DSP , Mips :: MFLO_DSP , 4 ) ; break ; case Mips :: STORE_ACC128 : expandStoreACC ( MBB , I , Mips :: PseudoMFHI64 , Mips :: PseudoMFLO64 , 8 ) ; break ; case Mips :: BuildPairF64 : if ( expandBuildPairF64 ( MBB , I , false ) ) MBB . erase ( I ) ; return false ; case Mips :: BuildPairF64_64 : if ( expandBuildPairF64 ( MBB , I , true ) ) MBB . erase ( I ) ; return false ; case Mips :: ExtractElementF64 : if ( expandExtractElementF64 ( MBB , I , false ) ) MBB . erase ( I ) ; return false ; case Mips :: ExtractElementF64_64 : if ( expandExtractElementF64 ( MBB , I , true ) ) MBB . erase ( I ) ; return false ; case TargetOpcode :: COPY : if ( ! expandCopy ( MBB , I ) ) return false ; break ; default : return false ; } MBB . erase ( I ) ; return true ; } void ExpandPseudo :: expandLoadCCond ( MachineBasicBlock & MBB , Iter I ) { // ▁ load ▁ $ vr , ▁ FI ENDCOM // ▁ copy ▁ ccond , ▁ $ vr ENDCOM assert ( I -> getOperand ( 0 ) . isReg ( ) && I -> getOperand ( 1 ) . isFI ( ) ) ; const MipsSEInstrInfo & TII = * static_cast < const MipsSEInstrInfo * > ( MF . getTarget ( ) . getInstrInfo ( ) ) ; const MipsRegisterInfo & RegInfo = * static_cast < const MipsRegisterInfo * > ( MF . getTarget ( ) . getRegisterInfo ( ) ) ; const TargetRegisterClass * RC = RegInfo . intRegClass ( 4 ) ; unsigned VR = MRI . createVirtualRegister ( RC ) ; unsigned Dst = I -> getOperand ( 0 ) . getReg ( ) , FI = I -> getOperand ( 1 ) . getIndex ( ) ; TII . loadRegFromStack ( MBB , I , VR , FI , RC , & RegInfo , 0 ) ; BuildMI ( MBB , I , I -> getDebugLoc ( ) , TII . get ( TargetOpcode :: COPY ) , Dst ) . addReg ( VR , RegState :: Kill ) ; } void ExpandPseudo :: expandStoreCCond ( MachineBasicBlock & MBB , Iter I ) { // ▁ copy ▁ $ vr , ▁ ccond ENDCOM // ▁ store ▁ $ vr , ▁ FI ENDCOM assert ( I -> getOperand ( 0 ) . isReg ( ) && I -> getOperand ( 1 ) . isFI ( ) ) ; const MipsSEInstrInfo & TII = * static_cast < const MipsSEInstrInfo * > ( MF . getTarget ( ) . getInstrInfo ( ) ) ; const MipsRegisterInfo & RegInfo = * static_cast < const MipsRegisterInfo * > ( MF . getTarget ( ) . getRegisterInfo ( ) ) ; const TargetRegisterClass * RC = RegInfo . intRegClass ( 4 ) ; unsigned VR = MRI . createVirtualRegister ( RC ) ; unsigned Src = I -> getOperand ( 0 ) . getReg ( ) , FI = I -> getOperand ( 1 ) . getIndex ( ) ; BuildMI ( MBB , I , I -> getDebugLoc ( ) , TII . get ( TargetOpcode :: COPY ) , VR ) . addReg ( Src , getKillRegState ( I -> getOperand ( 0 ) . isKill ( ) ) ) ; TII . storeRegToStack ( MBB , I , VR , true , FI , RC , & RegInfo , 0 ) ; } void ExpandPseudo :: expandLoadACC ( MachineBasicBlock & MBB , Iter I , unsigned RegSize ) { // ▁ load ▁ $ vr0 , ▁ FI ENDCOM // ▁ copy ▁ lo , ▁ $ vr0 ENDCOM // ▁ load ▁ $ vr1 , ▁ FI ▁ + ▁ 4 ENDCOM // ▁ copy ▁ hi , ▁ $ vr1 ENDCOM assert ( I -> getOperand ( 0 ) . isReg ( ) && I -> getOperand ( 1 ) . isFI ( ) ) ; const MipsSEInstrInfo & TII = * static_cast < const MipsSEInstrInfo * > ( MF . getTarget ( ) . getInstrInfo ( ) ) ; const MipsRegisterInfo & RegInfo = * static_cast < const MipsRegisterInfo * > ( MF . getTarget ( ) . getRegisterInfo ( ) ) ; const TargetRegisterClass * RC = RegInfo . intRegClass ( RegSize ) ; unsigned VR0 = MRI . createVirtualRegister ( RC ) ; unsigned VR1 = MRI . createVirtualRegister ( RC ) ; unsigned Dst = I -> getOperand ( 0 ) . getReg ( ) , FI = I -> getOperand ( 1 ) . getIndex ( ) ; unsigned Lo = RegInfo . getSubReg ( Dst , Mips :: sub_lo ) ; unsigned Hi = RegInfo . getSubReg ( Dst , Mips :: sub_hi ) ; DebugLoc DL = I -> getDebugLoc ( ) ; const MCInstrDesc & Desc = TII . get ( TargetOpcode :: COPY ) ; TII . loadRegFromStack ( MBB , I , VR0 , FI , RC , & RegInfo , 0 ) ; BuildMI ( MBB , I , DL , Desc , Lo ) . addReg ( VR0 , RegState :: Kill ) ; TII . loadRegFromStack ( MBB , I , VR1 , FI , RC , & RegInfo , RegSize ) ; BuildMI ( MBB , I , DL , Desc , Hi ) . addReg ( VR1 , RegState :: Kill ) ; } void ExpandPseudo :: expandStoreACC ( MachineBasicBlock & MBB , Iter I , unsigned MFHiOpc , unsigned MFLoOpc , unsigned RegSize ) { // ▁ mflo ▁ $ vr0 , ▁ src ENDCOM // ▁ store ▁ $ vr0 , ▁ FI ENDCOM // ▁ mfhi ▁ $ vr1 , ▁ src ENDCOM // ▁ store ▁ $ vr1 , ▁ FI ▁ + ▁ 4 ENDCOM assert ( I -> getOperand ( 0 ) . isReg ( ) && I -> getOperand ( 1 ) . isFI ( ) ) ; const MipsSEInstrInfo & TII = * static_cast < const MipsSEInstrInfo * > ( MF . getTarget ( ) . getInstrInfo ( ) ) ; const MipsRegisterInfo & RegInfo = * static_cast < const MipsRegisterInfo * > ( MF . getTarget ( ) . getRegisterInfo ( ) ) ; const TargetRegisterClass * RC = RegInfo . intRegClass ( RegSize ) ; unsigned VR0 = MRI . createVirtualRegister ( RC ) ; unsigned VR1 = MRI . createVirtualRegister ( RC ) ; unsigned Src = I -> getOperand ( 0 ) . getReg ( ) , FI = I -> getOperand ( 1 ) . getIndex ( ) ; unsigned SrcKill = getKillRegState ( I -> getOperand ( 0 ) . isKill ( ) ) ; DebugLoc DL = I -> getDebugLoc ( ) ; BuildMI ( MBB , I , DL , TII . get ( MFLoOpc ) , VR0 ) . addReg ( Src ) ; TII . storeRegToStack ( MBB , I , VR0 , true , FI , RC , & RegInfo , 0 ) ; BuildMI ( MBB , I , DL , TII . get ( MFHiOpc ) , VR1 ) . addReg ( Src , SrcKill ) ; TII . storeRegToStack ( MBB , I , VR1 , true , FI , RC , & RegInfo , RegSize ) ; } bool ExpandPseudo :: expandCopy ( MachineBasicBlock & MBB , Iter I ) { unsigned Src = I -> getOperand ( 1 ) . getReg ( ) ; std :: pair < unsigned , unsigned > Opcodes = getMFHiLoOpc ( Src ) ; if ( ! Opcodes . first ) return false ; return expandCopyACC ( MBB , I , Opcodes . first , Opcodes . second ) ; } bool ExpandPseudo :: expandCopyACC ( MachineBasicBlock & MBB , Iter I , unsigned MFHiOpc , unsigned MFLoOpc ) { // ▁ mflo ▁ $ vr0 , ▁ src ENDCOM // ▁ copy ▁ dst _ lo , ▁ $ vr0 ENDCOM // ▁ mfhi ▁ $ vr1 , ▁ src ENDCOM // ▁ copy ▁ dst _ hi , ▁ $ vr1 ENDCOM const MipsSEInstrInfo & TII = * static_cast < const MipsSEInstrInfo * > ( MF . getTarget ( ) . getInstrInfo ( ) ) ; const MipsRegisterInfo & RegInfo = * static_cast < const MipsRegisterInfo * > ( MF . getTarget ( ) . getRegisterInfo ( ) ) ; unsigned Dst = I -> getOperand ( 0 ) . getReg ( ) , Src = I -> getOperand ( 1 ) . getReg ( ) ; unsigned VRegSize = RegInfo . getMinimalPhysRegClass ( Dst ) -> getSize ( ) / 2 ; const TargetRegisterClass * RC = RegInfo . intRegClass ( VRegSize ) ; unsigned VR0 = MRI . createVirtualRegister ( RC ) ; unsigned VR1 = MRI . createVirtualRegister ( RC ) ; unsigned SrcKill = getKillRegState ( I -> getOperand ( 1 ) . isKill ( ) ) ; unsigned DstLo = RegInfo . getSubReg ( Dst , Mips :: sub_lo ) ; unsigned DstHi = RegInfo . getSubReg ( Dst , Mips :: sub_hi ) ; DebugLoc DL = I -> getDebugLoc ( ) ; BuildMI ( MBB , I , DL , TII . get ( MFLoOpc ) , VR0 ) . addReg ( Src ) ; BuildMI ( MBB , I , DL , TII . get ( TargetOpcode :: COPY ) , DstLo ) . addReg ( VR0 , RegState :: Kill ) ; BuildMI ( MBB , I , DL , TII . get ( MFHiOpc ) , VR1 ) . addReg ( Src , SrcKill ) ; BuildMI ( MBB , I , DL , TII . get ( TargetOpcode :: COPY ) , DstHi ) . addReg ( VR1 , RegState :: Kill ) ; return true ; } // / ▁ This ▁ method ▁ expands ▁ the ▁ same ▁ instruction ▁ that ▁ MipsSEInstrInfo : : ENDCOM // / ▁ expandBuildPairF64 ▁ does , ▁ for ▁ the ▁ case ▁ when ▁ ABI ▁ is ▁ fpxx ▁ and ▁ mthc1 ▁ is ▁ not ENDCOM // / ▁ available ▁ and ▁ the ▁ case ▁ where ▁ the ▁ ABI ▁ is ▁ FP64A . ▁ It ▁ is ▁ implemented ▁ here ENDCOM // / ▁ because ▁ frame ▁ indexes ▁ are ▁ eliminated ▁ before ▁ MipsSEInstrInfo : : ENDCOM // / ▁ expandBuildPairF64 ▁ is ▁ called . ENDCOM bool ExpandPseudo :: expandBuildPairF64 ( MachineBasicBlock & MBB , MachineBasicBlock :: iterator I , bool FP64 ) const { // ▁ For ▁ fpxx ▁ and ▁ when ▁ mthc1 ▁ is ▁ not ▁ available , ▁ use : ENDCOM // ▁ spill ▁ + ▁ reload ▁ via ▁ ldc1 ENDCOM // ▁ The ▁ case ▁ where ▁ dmtc1 ▁ is ▁ available ▁ doesn ' t ▁ need ▁ to ▁ be ▁ handled ▁ here ENDCOM // ▁ because ▁ it ▁ never ▁ creates ▁ a ▁ BuildPairF64 ▁ node . ENDCOM // ▁ The ▁ FP64A ▁ ABI ▁ ( fp64 ▁ with ▁ nooddspreg ) ▁ must ▁ also ▁ use ▁ a ▁ spill / reload ▁ sequence ENDCOM // ▁ for ▁ odd - numbered ▁ double ▁ precision ▁ values ▁ ( because ▁ the ▁ lower ▁ 32 - bits ▁ is ENDCOM // ▁ transferred ▁ with ▁ mtc1 ▁ which ▁ is ▁ redirected ▁ to ▁ the ▁ upper ▁ half ▁ of ▁ the ▁ even ENDCOM // ▁ register ) . ▁ Unfortunately , ▁ we ▁ have ▁ to ▁ make ▁ this ▁ decision ▁ before ▁ register ENDCOM // ▁ allocation ▁ so ▁ for ▁ now ▁ we ▁ use ▁ a ▁ spill / reload ▁ sequence ▁ for ▁ all ENDCOM // ▁ double - precision ▁ values ▁ in ▁ regardless ▁ of ▁ being ▁ an ▁ odd / even ▁ register . ENDCOM const TargetMachine & TM = MF . getTarget ( ) ; const MipsSubtarget & Subtarget = TM . getSubtarget < MipsSubtarget > ( ) ; if ( ( Subtarget . isABI_FPXX ( ) && ! Subtarget . hasMTHC1 ( ) ) || ( FP64 && ! Subtarget . useOddSPReg ( ) ) ) { const MipsSEInstrInfo & TII = * static_cast < const MipsSEInstrInfo * > ( TM . getInstrInfo ( ) ) ; const MipsRegisterInfo & TRI = * static_cast < const MipsRegisterInfo * > ( TM . getRegisterInfo ( ) ) ; unsigned DstReg = I -> getOperand ( 0 ) . getReg ( ) ; unsigned LoReg = I -> getOperand ( 1 ) . getReg ( ) ; unsigned HiReg = I -> getOperand ( 2 ) . getReg ( ) ; // ▁ It ▁ should ▁ be ▁ impossible ▁ to ▁ have ▁ FGR64 ▁ on ▁ MIPS - II ▁ or ▁ MIPS32r1 ▁ ( which ▁ are ENDCOM // ▁ the ▁ cases ▁ where ▁ mthc1 ▁ is ▁ not ▁ available ) . ▁ 64 - bit ▁ architectures ▁ and ENDCOM // ▁ MIPS32r2 ▁ or ▁ later ▁ can ▁ use ▁ FGR64 ▁ though . ENDCOM assert ( Subtarget . isGP64bit ( ) || Subtarget . hasMTHC1 ( ) || ! Subtarget . isFP64bit ( ) ) ; const TargetRegisterClass * RC = & Mips :: GPR32RegClass ; const TargetRegisterClass * RC2 = FP64 ? & Mips :: FGR64RegClass : & Mips :: AFGR64RegClass ; // ▁ We ▁ re - use ▁ the ▁ same ▁ spill ▁ slot ▁ each ▁ time ▁ so ▁ that ▁ the ▁ stack ▁ frame ▁ doesn ' t ENDCOM // ▁ grow ▁ too ▁ much ▁ in ▁ functions ▁ with ▁ a ▁ large ▁ number ▁ of ▁ moves . ENDCOM int FI = MF . getInfo < MipsFunctionInfo > ( ) -> getMoveF64ViaSpillFI ( RC2 ) ; TII . storeRegToStack ( MBB , I , LoReg , I -> getOperand ( 1 ) . isKill ( ) , FI , RC , & TRI , 0 ) ; TII . storeRegToStack ( MBB , I , HiReg , I -> getOperand ( 2 ) . isKill ( ) , FI , RC , & TRI , 4 ) ; TII . loadRegFromStack ( MBB , I , DstReg , FI , RC2 , & TRI , 0 ) ; return true ; } return false ; } // / ▁ This ▁ method ▁ expands ▁ the ▁ same ▁ instruction ▁ that ▁ MipsSEInstrInfo : : ENDCOM // / ▁ expandExtractElementF64 ▁ does , ▁ for ▁ the ▁ case ▁ when ▁ ABI ▁ is ▁ fpxx ▁ and ▁ mfhc1 ▁ is ▁ not ENDCOM // / ▁ available ▁ and ▁ the ▁ case ▁ where ▁ the ▁ ABI ▁ is ▁ FP64A . ▁ It ▁ is ▁ implemented ▁ here ENDCOM // / ▁ because ▁ frame ▁ indexes ▁ are ▁ eliminated ▁ before ▁ MipsSEInstrInfo : : ENDCOM // / ▁ expandExtractElementF64 ▁ is ▁ called . ENDCOM bool ExpandPseudo :: expandExtractElementF64 ( MachineBasicBlock & MBB , MachineBasicBlock :: iterator I , bool FP64 ) const { // ▁ For ▁ fpxx ▁ and ▁ when ▁ mfhc1 ▁ is ▁ not ▁ available , ▁ use : ENDCOM // ▁ spill ▁ + ▁ reload ▁ via ▁ ldc1 ENDCOM // ▁ The ▁ case ▁ where ▁ dmfc1 ▁ is ▁ available ▁ doesn ' t ▁ need ▁ to ▁ be ▁ handled ▁ here ENDCOM // ▁ because ▁ it ▁ never ▁ creates ▁ a ▁ ExtractElementF64 ▁ node . ENDCOM // ▁ The ▁ FP64A ▁ ABI ▁ ( fp64 ▁ with ▁ nooddspreg ) ▁ must ▁ also ▁ use ▁ a ▁ spill / reload ▁ sequence ENDCOM // ▁ for ▁ odd - numbered ▁ double ▁ precision ▁ values ▁ ( because ▁ the ▁ lower ▁ 32 - bits ▁ is ENDCOM // ▁ transferred ▁ with ▁ mfc1 ▁ which ▁ is ▁ redirected ▁ to ▁ the ▁ upper ▁ half ▁ of ▁ the ▁ even ENDCOM // ▁ register ) . ▁ Unfortunately , ▁ we ▁ have ▁ to ▁ make ▁ this ▁ decision ▁ before ▁ register ENDCOM // ▁ allocation ▁ so ▁ for ▁ now ▁ we ▁ use ▁ a ▁ spill / reload ▁ sequence ▁ for ▁ all ENDCOM // ▁ double - precision ▁ values ▁ in ▁ regardless ▁ of ▁ being ▁ an ▁ odd / even ▁ register . ENDCOM const TargetMachine & TM = MF . getTarget ( ) ; const MipsSubtarget & Subtarget = TM . getSubtarget < MipsSubtarget > ( ) ; if ( ( Subtarget . isABI_FPXX ( ) && ! Subtarget . hasMTHC1 ( ) ) || ( FP64 && ! Subtarget . useOddSPReg ( ) ) ) { const MipsSEInstrInfo & TII = * static_cast < const MipsSEInstrInfo * > ( TM . getInstrInfo ( ) ) ; const MipsRegisterInfo & TRI = * static_cast < const MipsRegisterInfo * > ( TM . getRegisterInfo ( ) ) ; unsigned DstReg = I -> getOperand ( 0 ) . getReg ( ) ; unsigned SrcReg = I -> getOperand ( 1 ) . getReg ( ) ; unsigned N = I -> getOperand ( 2 ) . getImm ( ) ; // ▁ It ▁ should ▁ be ▁ impossible ▁ to ▁ have ▁ FGR64 ▁ on ▁ MIPS - II ▁ or ▁ MIPS32r1 ▁ ( which ▁ are ENDCOM // ▁ the ▁ cases ▁ where ▁ mfhc1 ▁ is ▁ not ▁ available ) . ▁ 64 - bit ▁ architectures ▁ and ENDCOM // ▁ MIPS32r2 ▁ or ▁ later ▁ can ▁ use ▁ FGR64 ▁ though . ENDCOM assert ( Subtarget . isGP64bit ( ) || Subtarget . hasMTHC1 ( ) || ! Subtarget . isFP64bit ( ) ) ; const TargetRegisterClass * RC = FP64 ? & Mips :: FGR64RegClass : & Mips :: AFGR64RegClass ; const TargetRegisterClass * RC2 = & Mips :: GPR32RegClass ; // ▁ We ▁ re - use ▁ the ▁ same ▁ spill ▁ slot ▁ each ▁ time ▁ so ▁ that ▁ the ▁ stack ▁ frame ▁ doesn ' t ENDCOM // ▁ grow ▁ too ▁ much ▁ in ▁ functions ▁ with ▁ a ▁ large ▁ number ▁ of ▁ moves . ENDCOM int FI = MF . getInfo < MipsFunctionInfo > ( ) -> getMoveF64ViaSpillFI ( RC ) ; TII . storeRegToStack ( MBB , I , SrcReg , I -> getOperand ( 1 ) . isKill ( ) , FI , RC , & TRI , 0 ) ; TII . loadRegFromStack ( MBB , I , DstReg , FI , RC2 , & TRI , N * 4 ) ; return true ; } return false ; } MipsSEFrameLowering :: MipsSEFrameLowering ( const MipsSubtarget & STI ) : MipsFrameLowering ( STI , STI . stackAlignment ( ) ) { } unsigned MipsSEFrameLowering :: ehDataReg ( unsigned I ) const { static const unsigned EhDataReg [ ] = { Mips :: A0 , Mips :: A1 , Mips :: A2 , Mips :: A3 } ; static const unsigned EhDataReg64 [ ] = { Mips :: A0_64 , Mips :: A1_64 , Mips :: A2_64 , Mips :: A3_64 } ; return STI . isABI_N64 ( ) ? EhDataReg64 [ I ] : EhDataReg [ I ] ; } void MipsSEFrameLowering :: emitPrologue ( MachineFunction & MF ) const { MachineBasicBlock & MBB = MF . front ( ) ; MachineFrameInfo * MFI = MF . getFrameInfo ( ) ; MipsFunctionInfo * MipsFI = MF . getInfo < MipsFunctionInfo > ( ) ; const MipsSEInstrInfo & TII = * static_cast < const MipsSEInstrInfo * > ( MF . getTarget ( ) . getInstrInfo ( ) ) ; const MipsRegisterInfo & RegInfo = * static_cast < const MipsRegisterInfo * > ( MF . getTarget ( ) . getRegisterInfo ( ) ) ; MachineBasicBlock :: iterator MBBI = MBB . begin ( ) ; DebugLoc dl = MBBI != MBB . end ( ) ? MBBI -> getDebugLoc ( ) : DebugLoc ( ) ; unsigned SP = STI . isABI_N64 ( ) ? Mips :: SP_64 : Mips :: SP ; unsigned FP = STI . isABI_N64 ( ) ? Mips :: FP_64 : Mips :: FP ; unsigned ZERO = STI . isABI_N64 ( ) ? Mips :: ZERO_64 : Mips :: ZERO ; unsigned ADDu = STI . isABI_N64 ( ) ? Mips :: DADDu : Mips :: ADDu ; // ▁ First , ▁ compute ▁ final ▁ stack ▁ size . ENDCOM uint64_t StackSize = MFI -> getStackSize ( ) ; // ▁ No ▁ need ▁ to ▁ allocate ▁ space ▁ on ▁ the ▁ stack . ENDCOM if ( StackSize == 0 && ! MFI -> adjustsStack ( ) ) return ; MachineModuleInfo & MMI = MF . getMMI ( ) ; const MCRegisterInfo * MRI = MMI . getContext ( ) . getRegisterInfo ( ) ; MachineLocation DstML , SrcML ; // ▁ Adjust ▁ stack . ENDCOM TII . adjustStackPtr ( SP , - StackSize , MBB , MBBI ) ; // ▁ emit ▁ " . cfi _ def _ cfa _ offset ▁ StackSize " ENDCOM unsigned CFIIndex = MMI . addFrameInst ( MCCFIInstruction :: createDefCfaOffset ( nullptr , - StackSize ) ) ; BuildMI ( MBB , MBBI , dl , TII . get ( TargetOpcode :: CFI_INSTRUCTION ) ) . addCFIIndex ( CFIIndex ) ; const std :: vector < CalleeSavedInfo > & CSI = MFI -> getCalleeSavedInfo ( ) ; if ( CSI . size ( ) ) { // ▁ Find ▁ the ▁ instruction ▁ past ▁ the ▁ last ▁ instruction ▁ that ▁ saves ▁ a ▁ callee - saved ENDCOM // ▁ register ▁ to ▁ the ▁ stack . ENDCOM for ( unsigned i = 0 ; i < CSI . size ( ) ; ++ i ) ++ MBBI ; // ▁ Iterate ▁ over ▁ list ▁ of ▁ callee - saved ▁ registers ▁ and ▁ emit ▁ . cfi _ offset ENDCOM // ▁ directives . ENDCOM for ( std :: vector < CalleeSavedInfo > :: const_iterator I = CSI . begin ( ) , E = CSI . end ( ) ; I != E ; ++ I ) { int64_t Offset = MFI -> getObjectOffset ( I -> getFrameIdx ( ) ) ; unsigned Reg = I -> getReg ( ) ; // ▁ If ▁ Reg ▁ is ▁ a ▁ double ▁ precision ▁ register , ▁ emit ▁ two ▁ cfa _ offsets , ENDCOM // ▁ one ▁ for ▁ each ▁ of ▁ the ▁ paired ▁ single ▁ precision ▁ registers . ENDCOM if ( Mips :: AFGR64RegClass . contains ( Reg ) ) { unsigned Reg0 = MRI -> getDwarfRegNum ( RegInfo . getSubReg ( Reg , Mips :: sub_lo ) , true ) ; unsigned Reg1 = MRI -> getDwarfRegNum ( RegInfo . getSubReg ( Reg , Mips :: sub_hi ) , true ) ; if ( ! STI . isLittle ( ) ) std :: swap ( Reg0 , Reg1 ) ; unsigned CFIIndex = MMI . addFrameInst ( MCCFIInstruction :: createOffset ( nullptr , Reg0 , Offset ) ) ; BuildMI ( MBB , MBBI , dl , TII . get ( TargetOpcode :: CFI_INSTRUCTION ) ) . addCFIIndex ( CFIIndex ) ; CFIIndex = MMI . addFrameInst ( MCCFIInstruction :: createOffset ( nullptr , Reg1 , Offset + 4 ) ) ; BuildMI ( MBB , MBBI , dl , TII . get ( TargetOpcode :: CFI_INSTRUCTION ) ) . addCFIIndex ( CFIIndex ) ; } else if ( Mips :: FGR64RegClass . contains ( Reg ) ) { unsigned Reg0 = MRI -> getDwarfRegNum ( Reg , true ) ; unsigned Reg1 = MRI -> getDwarfRegNum ( Reg , true ) + 1 ; if ( ! STI . isLittle ( ) ) std :: swap ( Reg0 , Reg1 ) ; unsigned CFIIndex = MMI . addFrameInst ( MCCFIInstruction :: createOffset ( nullptr , Reg0 , Offset ) ) ; BuildMI ( MBB , MBBI , dl , TII . get ( TargetOpcode :: CFI_INSTRUCTION ) ) . addCFIIndex ( CFIIndex ) ; CFIIndex = MMI . addFrameInst ( MCCFIInstruction :: createOffset ( nullptr , Reg1 , Offset + 4 ) ) ; BuildMI ( MBB , MBBI , dl , TII . get ( TargetOpcode :: CFI_INSTRUCTION ) ) . addCFIIndex ( CFIIndex ) ; } else { // ▁ Reg ▁ is ▁ either ▁ in ▁ GPR32 ▁ or ▁ FGR32 . ENDCOM unsigned CFIIndex = MMI . addFrameInst ( MCCFIInstruction :: createOffset ( nullptr , MRI -> getDwarfRegNum ( Reg , 1 ) , Offset ) ) ; BuildMI ( MBB , MBBI , dl , TII . get ( TargetOpcode :: CFI_INSTRUCTION ) ) . addCFIIndex ( CFIIndex ) ; } } } if ( MipsFI -> callsEhReturn ( ) ) { const TargetRegisterClass * RC = STI . isABI_N64 ( ) ? & Mips :: GPR64RegClass : & Mips :: GPR32RegClass ; // ▁ Insert ▁ instructions ▁ that ▁ spill ▁ eh ▁ data ▁ registers . ENDCOM for ( int I = 0 ; I < 4 ; ++ I ) { if ( ! MBB . isLiveIn ( ehDataReg ( I ) ) ) MBB . addLiveIn ( ehDataReg ( I ) ) ; TII . storeRegToStackSlot ( MBB , MBBI , ehDataReg ( I ) , false , MipsFI -> getEhDataRegFI ( I ) , RC , & RegInfo ) ; } // ▁ Emit ▁ . cfi _ offset ▁ directives ▁ for ▁ eh ▁ data ▁ registers . ENDCOM for ( int I = 0 ; I < 4 ; ++ I ) { int64_t Offset = MFI -> getObjectOffset ( MipsFI -> getEhDataRegFI ( I ) ) ; unsigned Reg = MRI -> getDwarfRegNum ( ehDataReg ( I ) , true ) ; unsigned CFIIndex = MMI . addFrameInst ( MCCFIInstruction :: createOffset ( nullptr , Reg , Offset ) ) ; BuildMI ( MBB , MBBI , dl , TII . get ( TargetOpcode :: CFI_INSTRUCTION ) ) . addCFIIndex ( CFIIndex ) ; } } // ▁ if ▁ framepointer ▁ enabled , ▁ set ▁ it ▁ to ▁ point ▁ to ▁ the ▁ stack ▁ pointer . ENDCOM if ( hasFP ( MF ) ) { // ▁ Insert ▁ instruction ▁ " move ▁ $ fp , ▁ $ sp " ▁ at ▁ this ▁ location . ENDCOM BuildMI ( MBB , MBBI , dl , TII . get ( ADDu ) , FP ) . addReg ( SP ) . addReg ( ZERO ) . setMIFlag ( MachineInstr :: FrameSetup ) ; // ▁ emit ▁ " . cfi _ def _ cfa _ register ▁ $ fp " ENDCOM unsigned CFIIndex = MMI . addFrameInst ( MCCFIInstruction :: createDefCfaRegister ( nullptr , MRI -> getDwarfRegNum ( FP , true ) ) ) ; BuildMI ( MBB , MBBI , dl , TII . get ( TargetOpcode :: CFI_INSTRUCTION ) ) . addCFIIndex ( CFIIndex ) ; } } void MipsSEFrameLowering :: emitEpilogue ( MachineFunction & MF , MachineBasicBlock & MBB ) const { MachineBasicBlock :: iterator MBBI = MBB . getLastNonDebugInstr ( ) ; MachineFrameInfo * MFI = MF . getFrameInfo ( ) ; MipsFunctionInfo * MipsFI = MF . getInfo < MipsFunctionInfo > ( ) ; const MipsSEInstrInfo & TII = * static_cast < const MipsSEInstrInfo * > ( MF . getTarget ( ) . getInstrInfo ( ) ) ; const MipsRegisterInfo & RegInfo = * static_cast < const MipsRegisterInfo * > ( MF . getTarget ( ) . getRegisterInfo ( ) ) ; DebugLoc dl = MBBI -> getDebugLoc ( ) ; unsigned SP = STI . isABI_N64 ( ) ? Mips :: SP_64 : Mips :: SP ; unsigned FP = STI . isABI_N64 ( ) ? Mips :: FP_64 : Mips :: FP ; unsigned ZERO = STI . isABI_N64 ( ) ? Mips :: ZERO_64 : Mips :: ZERO ; unsigned ADDu = STI . isABI_N64 ( ) ? Mips :: DADDu : Mips :: ADDu ; // ▁ if ▁ framepointer ▁ enabled , ▁ restore ▁ the ▁ stack ▁ pointer . ENDCOM if ( hasFP ( MF ) ) { // ▁ Find ▁ the ▁ first ▁ instruction ▁ that ▁ restores ▁ a ▁ callee - saved ▁ register . ENDCOM MachineBasicBlock :: iterator I = MBBI ; for ( unsigned i = 0 ; i < MFI -> getCalleeSavedInfo ( ) . size ( ) ; ++ i ) -- I ; // ▁ Insert ▁ instruction ▁ " move ▁ $ sp , ▁ $ fp " ▁ at ▁ this ▁ location . ENDCOM BuildMI ( MBB , I , dl , TII . get ( ADDu ) , SP ) . addReg ( FP ) . addReg ( ZERO ) ; } if ( MipsFI -> callsEhReturn ( ) ) { const TargetRegisterClass * RC = STI . isABI_N64 ( ) ? & Mips :: GPR64RegClass : & Mips :: GPR32RegClass ; // ▁ Find ▁ first ▁ instruction ▁ that ▁ restores ▁ a ▁ callee - saved ▁ register . ENDCOM MachineBasicBlock :: iterator I = MBBI ; for ( unsigned i = 0 ; i < MFI -> getCalleeSavedInfo ( ) . size ( ) ; ++ i ) -- I ; // ▁ Insert ▁ instructions ▁ that ▁ restore ▁ eh ▁ data ▁ registers . ENDCOM for ( int J = 0 ; J < 4 ; ++ J ) { TII . loadRegFromStackSlot ( MBB , I , ehDataReg ( J ) , MipsFI -> getEhDataRegFI ( J ) , RC , & RegInfo ) ; } } // ▁ Get ▁ the ▁ number ▁ of ▁ bytes ▁ from ▁ FrameInfo ENDCOM uint64_t StackSize = MFI -> getStackSize ( ) ; if ( ! StackSize ) return ; // ▁ Adjust ▁ stack . ENDCOM TII . adjustStackPtr ( SP , StackSize , MBB , MBBI ) ; } bool MipsSEFrameLowering :: spillCalleeSavedRegisters ( MachineBasicBlock & MBB , MachineBasicBlock :: iterator MI , const std :: vector < CalleeSavedInfo > & CSI , const TargetRegisterInfo * TRI ) const { MachineFunction * MF = MBB . getParent ( ) ; MachineBasicBlock * EntryBlock = MF -> begin ( ) ; const TargetInstrInfo & TII = * MF -> getTarget ( ) . getInstrInfo ( ) ; for ( unsigned i = 0 , e = CSI . size ( ) ; i != e ; ++ i ) { // ▁ Add ▁ the ▁ callee - saved ▁ register ▁ as ▁ live - in . ▁ Do ▁ not ▁ add ▁ if ▁ the ▁ register ▁ is ENDCOM // ▁ RA ▁ and ▁ return ▁ address ▁ is ▁ taken , ▁ because ▁ it ▁ has ▁ already ▁ been ▁ added ▁ in ENDCOM // ▁ method ▁ MipsTargetLowering : : LowerRETURNADDR . ENDCOM // ▁ It ' s ▁ killed ▁ at ▁ the ▁ spill , ▁ unless ▁ the ▁ register ▁ is ▁ RA ▁ and ▁ return ▁ address ENDCOM // ▁ is ▁ taken . ENDCOM unsigned Reg = CSI [ i ] . getReg ( ) ; bool IsRAAndRetAddrIsTaken = ( Reg == Mips :: RA || Reg == Mips :: RA_64 ) && MF -> getFrameInfo ( ) -> isReturnAddressTaken ( ) ; if ( ! IsRAAndRetAddrIsTaken ) EntryBlock -> addLiveIn ( Reg ) ; // ▁ Insert ▁ the ▁ spill ▁ to ▁ the ▁ stack ▁ frame . ENDCOM bool IsKill = ! IsRAAndRetAddrIsTaken ; const TargetRegisterClass * RC = TRI -> getMinimalPhysRegClass ( Reg ) ; TII . storeRegToStackSlot ( * EntryBlock , MI , Reg , IsKill , CSI [ i ] . getFrameIdx ( ) , RC , TRI ) ; } return true ; } bool MipsSEFrameLowering :: hasReservedCallFrame ( const MachineFunction & MF ) const { const MachineFrameInfo * MFI = MF . getFrameInfo ( ) ; // ▁ Reserve ▁ call ▁ frame ▁ if ▁ the ▁ size ▁ of ▁ the ▁ maximum ▁ call ▁ frame ▁ fits ▁ into ▁ 16 - bit ENDCOM // ▁ immediate ▁ field ▁ and ▁ there ▁ are ▁ no ▁ variable ▁ sized ▁ objects ▁ on ▁ the ▁ stack . ENDCOM // ▁ Make ▁ sure ▁ the ▁ second ▁ register ▁ scavenger ▁ spill ▁ slot ▁ can ▁ be ▁ accessed ▁ with ▁ one ENDCOM // ▁ instruction . ENDCOM return isInt < 16 > ( MFI -> getMaxCallFrameSize ( ) + getStackAlignment ( ) ) && ! MFI -> hasVarSizedObjects ( ) ; } // ▁ Eliminate ▁ ADJCALLSTACKDOWN , ▁ ADJCALLSTACKUP ▁ pseudo ▁ instructions ENDCOM void MipsSEFrameLowering :: eliminateCallFramePseudoInstr ( MachineFunction & MF , MachineBasicBlock & MBB , MachineBasicBlock :: iterator I ) const { const MipsSEInstrInfo & TII = * static_cast < const MipsSEInstrInfo * > ( MF . getTarget ( ) . getInstrInfo ( ) ) ; if ( ! hasReservedCallFrame ( MF ) ) { int64_t Amount = I -> getOperand ( 0 ) . getImm ( ) ; if ( I -> getOpcode ( ) == Mips :: ADJCALLSTACKDOWN ) Amount = - Amount ; unsigned SP = STI . isABI_N64 ( ) ? Mips :: SP_64 : Mips :: SP ; TII . adjustStackPtr ( SP , Amount , MBB , I ) ; } MBB . erase ( I ) ; } void MipsSEFrameLowering :: processFunctionBeforeCalleeSavedScan ( MachineFunction & MF , RegScavenger * RS ) const { MachineRegisterInfo & MRI = MF . getRegInfo ( ) ; MipsFunctionInfo * MipsFI = MF . getInfo < MipsFunctionInfo > ( ) ; unsigned FP = STI . isABI_N64 ( ) ? Mips :: FP_64 : Mips :: FP ; // ▁ Mark ▁ $ fp ▁ as ▁ used ▁ if ▁ function ▁ has ▁ dedicated ▁ frame ▁ pointer . ENDCOM if ( hasFP ( MF ) ) MRI . setPhysRegUsed ( FP ) ; // ▁ Create ▁ spill ▁ slots ▁ for ▁ eh ▁ data ▁ registers ▁ if ▁ function ▁ calls ▁ eh _ return . ENDCOM if ( MipsFI -> callsEhReturn ( ) ) MipsFI -> createEhDataRegsFI ( ) ; // ▁ Expand ▁ pseudo ▁ instructions ▁ which ▁ load , ▁ store ▁ or ▁ copy ▁ accumulators . ENDCOM // ▁ Add ▁ an ▁ emergency ▁ spill ▁ slot ▁ if ▁ a ▁ pseudo ▁ was ▁ expanded . ENDCOM if ( ExpandPseudo ( MF ) . expand ( ) ) { // ▁ The ▁ spill ▁ slot ▁ should ▁ be ▁ half ▁ the ▁ size ▁ of ▁ the ▁ accumulator . ▁ If ▁ target ▁ is ENDCOM // ▁ mips64 , ▁ it ▁ should ▁ be ▁ 64 - bit , ▁ otherwise ▁ it ▁ should ▁ be ▁ 32 - bt . ENDCOM const TargetRegisterClass * RC = STI . hasMips64 ( ) ? & Mips :: GPR64RegClass : & Mips :: GPR32RegClass ; int FI = MF . getFrameInfo ( ) -> CreateStackObject ( RC -> getSize ( ) , RC -> getAlignment ( ) , false ) ; RS -> addScavengingFrameIndex ( FI ) ; } // ▁ Set ▁ scavenging ▁ frame ▁ index ▁ if ▁ necessary . ENDCOM uint64_t MaxSPOffset = MF . getInfo < MipsFunctionInfo > ( ) -> getIncomingArgSize ( ) + estimateStackSize ( MF ) ; if ( isInt < 16 > ( MaxSPOffset ) ) return ; const TargetRegisterClass * RC = STI . isABI_N64 ( ) ? & Mips :: GPR64RegClass : & Mips :: GPR32RegClass ; int FI = MF . getFrameInfo ( ) -> CreateStackObject ( RC -> getSize ( ) , RC -> getAlignment ( ) , false ) ; RS -> addScavengingFrameIndex ( FI ) ; } const MipsFrameLowering * llvm :: createMipsSEFrameLowering ( const MipsSubtarget & ST ) { return new MipsSEFrameLowering ( ST ) ; } </DOCUMENT>
<DOCUMENT_ID="uwafsl/ardupilot/tree/master/libraries/AP_HAL_Linux/Util.cpp"> # include < AP_HAL / AP_HAL . h > # if CONFIG_HAL_BOARD == HAL_BOARD_LINUX # include < stdio . h > # include < stdarg . h > # include < sys / stat . h > # include < unistd . h > # include < stdlib . h > # include < errno . h > # include < time . h > # include < fcntl . h > extern const AP_HAL :: HAL & hal ; # include " ToneAlarm _ Raspilot . h " # include " Util . h " # include " Heat _ Pwm . h " using namespace Linux ; static int state ; # if CONFIG_HAL_BOARD_SUBTYPE == HAL_BOARD_SUBTYPE_LINUX_RASPILOT ToneAlarm_Raspilot Util :: _toneAlarm ; # else ToneAlarm Util :: _toneAlarm ; # endif void Util :: init ( int argc , char * const * argv ) { saved_argc = argc ; saved_argv = argv ; # ifdef HAL_UTILS_HEAT # if HAL_UTILS_HEAT == HAL_LINUX_HEAT_PWM _heat = new Linux :: HeatPwm ( HAL_LINUX_HEAT_PWM_NUM , HAL_LINUX_HEAT_KP , HAL_LINUX_HEAT_KI , HAL_LINUX_HEAT_PERIOD_NS , HAL_LINUX_HEAT_TARGET_TEMP ) ; # else # error Unrecognized Heat # endif // ▁ # if ENDCOM # else _heat = new Linux :: Heat ( ) ; # endif // ▁ # ifdef ENDCOM } void Util :: set_imu_temp ( float current ) { _heat -> set_imu_temp ( current ) ; } /* * STRNEWLINE ▁ return ▁ commandline ▁ arguments , ▁ if ▁ available STRNEWLINE */ void Util :: commandline_arguments ( uint8_t & argc , char * const * & argv ) { argc = saved_argc ; argv = saved_argv ; } bool Util :: toneAlarm_init ( ) { return _toneAlarm . init ( ) ; } void Util :: toneAlarm_set_tune ( uint8_t tone ) { _toneAlarm . set_tune ( tone ) ; } void Util :: _toneAlarm_timer_tick ( ) { if ( state == 0 ) { state = state + _toneAlarm . init_tune ( ) ; } else if ( state == 1 ) { state = state + _toneAlarm . set_note ( ) ; } if ( state == 2 ) { state = state + _toneAlarm . play ( ) ; } else if ( state == 3 ) { state = 1 ; } if ( _toneAlarm . is_tune_comp ( ) ) { state = 0 ; } } void Util :: set_system_clock ( uint64_t time_utc_usec ) { # if CONFIG_HAL_BOARD_SUBTYPE != HAL_BOARD_SUBTYPE_LINUX_NONE timespec ts ; ts . tv_sec = time_utc_usec / 1.0e6 ; ts . tv_nsec = ( time_utc_usec % 1000000 ) * 1000 ; clock_settime ( CLOCK_REALTIME , & ts ) ; # endif } bool Util :: is_chardev_node ( const char * path ) { struct stat st ; if ( ! path || lstat ( path , & st ) < 0 ) return false ; return S_ISCHR ( st . st_mode ) ; } /* STRNEWLINE ▁ always ▁ report ▁ 256k ▁ of ▁ free ▁ memory . ▁ Using ▁ mallinfo ( ) ▁ isn ' t ▁ useful ▁ as STRNEWLINE ▁ it ▁ only ▁ reported ▁ the ▁ current ▁ heap , ▁ which ▁ auto - expands . ▁ What ▁ we ' re STRNEWLINE ▁ trying ▁ to ▁ do ▁ here ▁ is ▁ ensure ▁ that ▁ code ▁ which ▁ checks ▁ for ▁ free ▁ memory STRNEWLINE ▁ before ▁ allocating ▁ objects ▁ does ▁ allow ▁ the ▁ allocation STRNEWLINE ▁ */ uint32_t Util :: available_memory ( void ) { return 256 * 1024 ; } int Util :: write_file ( const char * path , const char * fmt , ... ) { errno = 0 ; int fd = :: open ( path , O_WRONLY | O_CLOEXEC ) ; if ( fd == - 1 ) { return - errno ; } va_list args ; va_start ( args , fmt ) ; int ret = :: vdprintf ( fd , fmt , args ) ; int errno_bkp = errno ; :: close ( fd ) ; va_end ( args ) ; if ( ret < 1 ) { return - errno_bkp ; } return ret ; } int Util :: read_file ( const char * path , const char * fmt , ... ) { errno = 0 ; FILE * file = :: fopen ( path , " re " ) ; if ( ! file ) return - errno ; va_list args ; va_start ( args , fmt ) ; int ret = :: vfscanf ( file , fmt , args ) ; int errno_bkp = errno ; :: fclose ( file ) ; va_end ( args ) ; if ( ret < 1 ) return - errno_bkp ; return ret ; } const char * Linux :: Util :: _hw_names [ UTIL_NUM_HARDWARES ] = { [ UTIL_HARDWARE_RPI1 ] = " BCM2708" , [ UTIL_HARDWARE_RPI2 ] = " BCM2709" , [ UTIL_HARDWARE_BEBOP ] = " Mykonos3 ▁ board " , [ UTIL_HARDWARE_BEBOP2 ] = " Milos ▁ board " , } ; # define MAX_SIZE_LINE 50 int Util :: get_hw_arm32 ( ) { int ret = - ENOENT ; char buffer [ MAX_SIZE_LINE ] ; const char * hardware_description_entry = " Hardware " ; char * flag ; FILE * f ; f = fopen ( " / proc / cpuinfo " , " r " ) ; if ( f == NULL ) { ret = - errno ; goto end ; } while ( fgets ( buffer , MAX_SIZE_LINE , f ) != NULL ) { flag = strstr ( buffer , hardware_description_entry ) ; if ( flag != NULL ) { for ( uint8_t i = 0 ; i < UTIL_NUM_HARDWARES ; i ++ ) { if ( strstr ( buffer , _hw_names [ i ] ) != 0 ) { ret = i ; goto close_end ; } } } } close_end : fclose ( f ) ; end : return ret ; } # endif // ▁ CONFIG _ HAL _ BOARD ▁ = = ▁ HAL _ BOARD _ LINUX ENDCOM </DOCUMENT>
<DOCUMENT_ID="KonceptGeek/mosesdecoder/tree/master/mert/TER/infosHasher.cpp"> /* * * * * STRNEWLINE tercpp : ▁ an ▁ open - source ▁ Translation ▁ Edit ▁ Rate ▁ ( TER ) ▁ scorer ▁ tool ▁ for ▁ Machine ▁ Translation . STRNEWLINE STRNEWLINE Copyright ▁ 2010-2013 , ▁ Christophe ▁ Servan , ▁ LIUM , ▁ University ▁ of ▁ Le ▁ Mans , ▁ France STRNEWLINE Contact : ▁ christophe . servan @ lium . univ - lemans . fr STRNEWLINE STRNEWLINE The ▁ tercpp ▁ tool ▁ and ▁ library ▁ are ▁ free ▁ software : ▁ you ▁ can ▁ redistribute ▁ it ▁ and / or ▁ modify ▁ it STRNEWLINE under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ Lesser ▁ General ▁ Public ▁ License ▁ as ▁ published ▁ by STRNEWLINE the ▁ Free ▁ Software ▁ Foundation , ▁ either ▁ version ▁ 2.1 ▁ of ▁ the ▁ licence , ▁ or STRNEWLINE ( at ▁ your ▁ option ) ▁ any ▁ later ▁ version . STRNEWLINE STRNEWLINE This ▁ program ▁ and ▁ library ▁ are ▁ distributed ▁ in ▁ the ▁ hope ▁ that ▁ it ▁ will ▁ be ▁ useful , ▁ but ▁ WITHOUT STRNEWLINE ANY ▁ WARRANTY ; ▁ without ▁ even ▁ the ▁ implied ▁ warranty ▁ of ▁ MERCHANTABILITY ▁ or STRNEWLINE FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE . ▁ See ▁ the ▁ GNU ▁ General ▁ Public ▁ License STRNEWLINE for ▁ more ▁ details . STRNEWLINE STRNEWLINE You ▁ should ▁ have ▁ received ▁ a ▁ copy ▁ of ▁ the ▁ GNU ▁ Lesser ▁ General ▁ Public ▁ License STRNEWLINE along ▁ with ▁ this ▁ library ; ▁ if ▁ not , ▁ write ▁ to ▁ the ▁ Free ▁ Software ▁ Foundation , STRNEWLINE Inc . , ▁ 59 ▁ Temple ▁ Place , ▁ Suite ▁ 330 , ▁ Boston , ▁ MA ▁ 02111-1307 ▁ USA STRNEWLINE * * * * */ # include " infosHasher . h " // ▁ The ▁ following ▁ class ▁ defines ▁ a ▁ hash ▁ function ▁ for ▁ strings ENDCOM using namespace std ; using namespace TERCPPNS_Tools ; namespace TERCPPNS_HashMapSpace { infosHasher :: infosHasher ( long cle , string cleTxt , vector < int > valueVecInt ) { m_hashKey = cle ; m_key = cleTxt ; m_value = valueVecInt ; } // ▁ infosHasher : : ~ infosHasher ( ) { } ; */ ENDCOM long infosHasher :: getHashKey ( ) { return m_hashKey ; } string infosHasher :: getKey ( ) { return m_key ; } vector < int > infosHasher :: getValue ( ) { return m_value ; } void infosHasher :: setValue ( vector < int > value ) { m_value = value ; } string infosHasher :: toString ( ) { stringstream to_return ; to_return << m_hashKey << " \t " << m_key << " \t " << vectorToString ( m_value , " \t " ) << endl ; return to_return . str ( ) ; } // ▁ typedef ▁ stdext : : hash _ map < std : : string , string , ▁ stringhasher > ▁ HASH _ S _ S ; ENDCOM } </DOCUMENT>
<DOCUMENT_ID="cryptometh/cryptometh_1/tree/master/src/cryptopp/vmac.cpp"> // ▁ vmac . cpp ▁ - ▁ written ▁ and ▁ placed ▁ in ▁ the ▁ public ▁ domain ▁ by ▁ Wei ▁ Dai ENDCOM // ▁ based ▁ on ▁ Ted ▁ Krovetz ' s ▁ public ▁ domain ▁ vmac . c ▁ and ▁ draft - krovetz - vmac - 01 . txt ENDCOM # include " pch . h " # include " vmac . h " # include " argnames . h " # include " cpu . h " NAMESPACE_BEGIN ( CryptoPP ) # if defined ( _MSC_VER ) && ! CRYPTOPP_BOOL_SLOW_WORD64 # include < intrin . h > # endif # define VMAC_BOOL_WORD128 ( defined ( CRYPTOPP_WORD128_AVAILABLE ) && ! defined ( CRYPTOPP_X64_ASM_AVAILABLE ) ) # ifdef __BORLANDC__ # define const // ▁ Turbo ▁ C + + ▁ 2006 ▁ workaround ENDCOM # endif static const word64 p64 = W64LIT ( 0xfffffffffffffeff ) ; /* ▁ 2 ^ 64 ▁ - ▁ 257 ▁ prime ▁ */ static const word64 m62 = W64LIT ( 0x3fffffffffffffff ) ; /* ▁ 62 - bit ▁ mask ▁ */ static const word64 m63 = W64LIT ( 0x7fffffffffffffff ) ; /* ▁ 63 - bit ▁ mask ▁ */ static const word64 m64 = W64LIT ( 0xffffffffffffffff ) ; /* ▁ 64 - bit ▁ mask ▁ */ static const word64 mpoly = W64LIT ( 0x1fffffff1fffffff ) ; /* ▁ Poly ▁ key ▁ mask ▁ */ # ifdef __BORLANDC__ # undef const # endif # if VMAC_BOOL_WORD128 # ifdef __powerpc__ // ▁ workaround ▁ GCC ▁ Bug ▁ 31690 : ▁ ICE ▁ with ▁ const ▁ _ _ uint128 _ t ▁ and ▁ C + + ▁ front - end ENDCOM # define m126 ( ( word128 ( m62 ) << 64 ) | m64 ) # else static const word128 m126 = ( word128 ( m62 ) << 64 ) | m64 ; /* ▁ 126 - bit ▁ mask ▁ */ # endif # endif void VMAC_Base :: UncheckedSetKey ( const byte * userKey , unsigned int keylength , const NameValuePairs & params ) { int digestLength = params . GetIntValueWithDefault ( Name :: DigestSize ( ) , DefaultDigestSize ( ) ) ; if ( digestLength != 8 && digestLength != 16 ) throw InvalidArgument ( " VMAC : ▁ DigestSize ▁ must ▁ be ▁ 8 ▁ or ▁ 16" ) ; m_is128 = digestLength == 16 ; m_L1KeyLength = params . GetIntValueWithDefault ( Name :: L1KeyLength ( ) , 128 ) ; if ( m_L1KeyLength <= 0 || m_L1KeyLength % 128 != 0 ) throw InvalidArgument ( " VMAC : ▁ L1KeyLength ▁ must ▁ be ▁ a ▁ positive ▁ multiple ▁ of ▁ 128" ) ; AllocateBlocks ( ) ; BlockCipher & cipher = AccessCipher ( ) ; cipher . SetKey ( userKey , keylength , params ) ; unsigned int blockSize = cipher . BlockSize ( ) ; unsigned int blockSizeInWords = blockSize / sizeof ( word64 ) ; SecBlock < word64 > out ( blockSizeInWords ) ; SecByteBlock in ; in . CleanNew ( blockSize ) ; size_t i ; /* ▁ Fill ▁ nh ▁ key ▁ */ in [ 0 ] = 0x80 ; cipher . AdvancedProcessBlocks ( in , NULL , ( byte * ) m_nhKey ( ) , m_nhKeySize ( ) * sizeof ( word64 ) , cipher . BT_InBlockIsCounter ) ; ConditionalByteReverse < word64 > ( BIG_ENDIAN_ORDER , m_nhKey ( ) , m_nhKey ( ) , m_nhKeySize ( ) * sizeof ( word64 ) ) ; /* ▁ Fill ▁ poly ▁ key ▁ */ in [ 0 ] = 0xC0 ; in [ 15 ] = 0 ; for ( i = 0 ; i <= ( size_t ) m_is128 ; i ++ ) { cipher . ProcessBlock ( in , out . BytePtr ( ) ) ; m_polyState ( ) [ i * 4 + 2 ] = GetWord < word64 > ( true , BIG_ENDIAN_ORDER , out . BytePtr ( ) ) & mpoly ; m_polyState ( ) [ i * 4 + 3 ] = GetWord < word64 > ( true , BIG_ENDIAN_ORDER , out . BytePtr ( ) + 8 ) & mpoly ; in [ 15 ] ++ ; } /* ▁ Fill ▁ ip ▁ key ▁ */ in [ 0 ] = 0xE0 ; in [ 15 ] = 0 ; word64 * l3Key = m_l3Key ( ) ; for ( i = 0 ; i <= ( size_t ) m_is128 ; i ++ ) do { cipher . ProcessBlock ( in , out . BytePtr ( ) ) ; l3Key [ i * 2 + 0 ] = GetWord < word64 > ( true , BIG_ENDIAN_ORDER , out . BytePtr ( ) ) ; l3Key [ i * 2 + 1 ] = GetWord < word64 > ( true , BIG_ENDIAN_ORDER , out . BytePtr ( ) + 8 ) ; in [ 15 ] ++ ; } while ( ( l3Key [ i * 2 + 0 ] >= p64 ) || ( l3Key [ i * 2 + 1 ] >= p64 ) ) ; m_padCached = false ; size_t nonceLength ; const byte * nonce = GetIVAndThrowIfInvalid ( params , nonceLength ) ; Resynchronize ( nonce , ( int ) nonceLength ) ; } void VMAC_Base :: GetNextIV ( RandomNumberGenerator & rng , byte * IV ) { SimpleKeyingInterface :: GetNextIV ( rng , IV ) ; IV [ 0 ] &= 0x7f ; } void VMAC_Base :: Resynchronize ( const byte * nonce , int len ) { size_t length = ThrowIfInvalidIVLength ( len ) ; size_t s = IVSize ( ) ; byte * storedNonce = m_nonce ( ) ; if ( m_is128 ) { memset ( storedNonce , 0 , s - length ) ; memcpy ( storedNonce + s - length , nonce , length ) ; AccessCipher ( ) . ProcessBlock ( storedNonce , m_pad ( ) ) ; } else { if ( m_padCached && ( storedNonce [ s - 1 ] | 1 ) == ( nonce [ length - 1 ] | 1 ) ) { m_padCached = VerifyBufsEqual ( storedNonce + s - length , nonce , length - 1 ) ; for ( size_t i = 0 ; m_padCached && i < s - length ; i ++ ) m_padCached = ( storedNonce [ i ] == 0 ) ; } if ( ! m_padCached ) { memset ( storedNonce , 0 , s - length ) ; memcpy ( storedNonce + s - length , nonce , length - 1 ) ; storedNonce [ s - 1 ] = nonce [ length - 1 ] & 0xfe ; AccessCipher ( ) . ProcessBlock ( storedNonce , m_pad ( ) ) ; m_padCached = true ; } storedNonce [ s - 1 ] = nonce [ length - 1 ] ; } m_isFirstBlock = true ; Restart ( ) ; } void VMAC_Base :: HashEndianCorrectedBlock ( const word64 * data ) { assert ( false ) ; throw 0 ; } # if CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE && CRYPTOPP_BOOL_X86 # pragma warning ( disable : 4731 ) // ▁ frame ▁ pointer ▁ register ▁ ' ebp ' ▁ modified ▁ by ▁ inline ▁ assembly ▁ code ENDCOM void # ifdef __GNUC__ __attribute__ ( ( noinline ) ) // ▁ Intel ▁ Compiler ▁ 9.1 ▁ workaround ENDCOM # endif VMAC_Base :: VHASH_Update_SSE2 ( const word64 * data , size_t blocksRemainingInWord64 , int tagPart ) { const word64 * nhK = m_nhKey ( ) ; word64 * polyS = m_polyState ( ) ; word32 L1KeyLength = m_L1KeyLength ; # ifdef __GNUC__ word32 temp ; __asm__ __volatile__ ( AS2 ( mov % % ebx , % 0 ) AS2 ( mov % 1 , % % ebx ) " . intel _ syntax ▁ noprefix ; " # else # if _MSC_VER < 1300 || defined ( __INTEL_COMPILER ) char isFirstBlock = m_isFirstBlock ; AS2 ( mov ebx , [ L1KeyLength ] ) AS2 ( mov dl , [ isFirstBlock ] ) # else AS2 ( mov ecx , this ) AS2 ( mov ebx , [ ecx + m_L1KeyLength ] ) AS2 ( mov dl , [ ecx + m_isFirstBlock ] ) # endif AS2 ( mov eax , tagPart ) AS2 ( shl eax , 4 ) AS2 ( mov edi , nhK ) AS2 ( add edi , eax ) AS2 ( add eax , eax ) AS2 ( add eax , polyS ) AS2 ( mov esi , data ) AS2 ( mov ecx , blocksRemainingInWord64 ) # endif AS2 ( shr ebx , 3 ) AS1 ( push ebp ) AS2 ( sub esp , 12 ) ASL ( 4 ) AS2 ( mov ebp , ebx ) AS2 ( cmp ecx , ebx ) AS2 ( cmovl ebp , ecx ) AS2 ( sub ecx , ebp ) AS2 ( lea ebp , [ edi + 8 * ebp ] ) // ▁ end ▁ of ▁ nhK ENDCOM AS2 ( movq mm6 , [ esi ] ) AS2 ( paddq mm6 , [ edi ] ) AS2 ( movq mm5 , [ esi + 8 ] ) AS2 ( paddq mm5 , [ edi + 8 ] ) AS2 ( add esi , 16 ) AS2 ( add edi , 16 ) AS2 ( movq mm4 , mm6 ) ASS ( pshufw mm2 , mm6 , 1 , 0 , 3 , 2 ) AS2 ( pmuludq mm6 , mm5 ) ASS ( pshufw mm3 , mm5 , 1 , 0 , 3 , 2 ) AS2 ( pmuludq mm5 , mm2 ) AS2 ( pmuludq mm2 , mm3 ) AS2 ( pmuludq mm3 , mm4 ) AS2 ( pxor mm7 , mm7 ) AS2 ( movd [ esp ] , mm6 ) AS2 ( psrlq mm6 , 32 ) AS2 ( movd [ esp + 4 ] , mm5 ) AS2 ( psrlq mm5 , 32 ) AS2 ( cmp edi , ebp ) ASJ ( je , 1 , f ) ASL ( 0 ) AS2 ( movq mm0 , [ esi ] ) AS2 ( paddq mm0 , [ edi ] ) AS2 ( movq mm1 , [ esi + 8 ] ) AS2 ( paddq mm1 , [ edi + 8 ] ) AS2 ( add esi , 16 ) AS2 ( add edi , 16 ) AS2 ( movq mm4 , mm0 ) AS2 ( paddq mm5 , mm2 ) ASS ( pshufw mm2 , mm0 , 1 , 0 , 3 , 2 ) AS2 ( pmuludq mm0 , mm1 ) AS2 ( movd [ esp + 8 ] , mm3 ) AS2 ( psrlq mm3 , 32 ) AS2 ( paddq mm5 , mm3 ) ASS ( pshufw mm3 , mm1 , 1 , 0 , 3 , 2 ) AS2 ( pmuludq mm1 , mm2 ) AS2 ( pmuludq mm2 , mm3 ) AS2 ( pmuludq mm3 , mm4 ) AS2 ( movd mm4 , [ esp ] ) AS2 ( paddq mm7 , mm4 ) AS2 ( movd mm4 , [ esp + 4 ] ) AS2 ( paddq mm6 , mm4 ) AS2 ( movd mm4 , [ esp + 8 ] ) AS2 ( paddq mm6 , mm4 ) AS2 ( movd [ esp ] , mm0 ) AS2 ( psrlq mm0 , 32 ) AS2 ( paddq mm6 , mm0 ) AS2 ( movd [ esp + 4 ] , mm1 ) AS2 ( psrlq mm1 , 32 ) AS2 ( paddq mm5 , mm1 ) AS2 ( cmp edi , ebp ) ASJ ( jne , 0 , b ) ASL ( 1 ) AS2 ( paddq mm5 , mm2 ) AS2 ( movd [ esp + 8 ] , mm3 ) AS2 ( psrlq mm3 , 32 ) AS2 ( paddq mm5 , mm3 ) AS2 ( movd mm4 , [ esp ] ) AS2 ( paddq mm7 , mm4 ) AS2 ( movd mm4 , [ esp + 4 ] ) AS2 ( paddq mm6 , mm4 ) AS2 ( movd mm4 , [ esp + 8 ] ) AS2 ( paddq mm6 , mm4 ) AS2 ( lea ebp , [ 8 * ebx ] ) AS2 ( sub edi , ebp ) // ▁ reset ▁ edi ▁ to ▁ start ▁ of ▁ nhK ENDCOM AS2 ( movd [ esp ] , mm7 ) AS2 ( psrlq mm7 , 32 ) AS2 ( paddq mm6 , mm7 ) AS2 ( movd [ esp + 4 ] , mm6 ) AS2 ( psrlq mm6 , 32 ) AS2 ( paddq mm5 , mm6 ) AS2 ( psllq mm5 , 2 ) AS2 ( psrlq mm5 , 2 ) # define a0 [ eax + 2 * 4 ] # define a1 [ eax + 3 * 4 ] # define a2 [ eax + 0 * 4 ] # define a3 [ eax + 1 * 4 ] # define k0 [ eax + 2 * 8 + 2 * 4 ] # define k1 [ eax + 2 * 8 + 3 * 4 ] # define k2 [ eax + 2 * 8 + 0 * 4 ] # define k3 [ eax + 2 * 8 + 1 * 4 ] AS2 ( test dl , dl ) ASJ ( jz , 2 , f ) AS2 ( movd mm1 , k0 ) AS2 ( movd mm0 , [ esp ] ) AS2 ( paddq mm0 , mm1 ) AS2 ( movd a0 , mm0 ) AS2 ( psrlq mm0 , 32 ) AS2 ( movd mm1 , k1 ) AS2 ( movd mm2 , [ esp + 4 ] ) AS2 ( paddq mm1 , mm2 ) AS2 ( paddq mm0 , mm1 ) AS2 ( movd a1 , mm0 ) AS2 ( psrlq mm0 , 32 ) AS2 ( paddq mm5 , k2 ) AS2 ( paddq mm0 , mm5 ) AS2 ( movq a2 , mm0 ) AS2 ( xor edx , edx ) ASJ ( jmp , 3 , f ) ASL ( 2 ) AS2 ( movd mm0 , a3 ) AS2 ( movq mm4 , mm0 ) AS2 ( pmuludq mm0 , k3 ) // ▁ a3 * k3 ENDCOM AS2 ( movd mm1 , a0 ) AS2 ( pmuludq mm1 , k2 ) // ▁ a0 * k2 ENDCOM AS2 ( movd mm2 , a1 ) AS2 ( movd mm6 , k1 ) AS2 ( pmuludq mm2 , mm6 ) // ▁ a1 * k1 ENDCOM AS2 ( movd mm3 , a2 ) AS2 ( psllq mm0 , 1 ) AS2 ( paddq mm0 , mm5 ) AS2 ( movq mm5 , mm3 ) AS2 ( movd mm7 , k0 ) AS2 ( pmuludq mm3 , mm7 ) // ▁ a2 * k0 ENDCOM AS2 ( pmuludq mm4 , mm7 ) // ▁ a3 * k0 ENDCOM AS2 ( pmuludq mm5 , mm6 ) // ▁ a2 * k1 ENDCOM AS2 ( paddq mm0 , mm1 ) AS2 ( movd mm1 , a1 ) AS2 ( paddq mm4 , mm5 ) AS2 ( movq mm5 , mm1 ) AS2 ( pmuludq mm1 , k2 ) // ▁ a1 * k2 ENDCOM AS2 ( paddq mm0 , mm2 ) AS2 ( movd mm2 , a0 ) AS2 ( paddq mm0 , mm3 ) AS2 ( movq mm3 , mm2 ) AS2 ( pmuludq mm2 , k3 ) // ▁ a0 * k3 ENDCOM AS2 ( pmuludq mm3 , mm7 ) // ▁ a0 * k0 ENDCOM AS2 ( movd [ esp + 8 ] , mm0 ) AS2 ( psrlq mm0 , 32 ) AS2 ( pmuludq mm7 , mm5 ) // ▁ a1 * k0 ENDCOM AS2 ( pmuludq mm5 , k3 ) // ▁ a1 * k3 ENDCOM AS2 ( paddq mm0 , mm1 ) AS2 ( movd mm1 , a2 ) AS2 ( pmuludq mm1 , k2 ) // ▁ a2 * k2 ENDCOM AS2 ( paddq mm0 , mm2 ) AS2 ( paddq mm0 , mm4 ) AS2 ( movq mm4 , mm0 ) AS2 ( movd mm2 , a3 ) AS2 ( pmuludq mm2 , mm6 ) // ▁ a3 * k1 ENDCOM AS2 ( pmuludq mm6 , a0 ) // ▁ a0 * k1 ENDCOM AS2 ( psrlq mm0 , 31 ) AS2 ( paddq mm0 , mm3 ) AS2 ( movd mm3 , [ esp ] ) AS2 ( paddq mm0 , mm3 ) AS2 ( movd mm3 , a2 ) AS2 ( pmuludq mm3 , k3 ) // ▁ a2 * k3 ENDCOM AS2 ( paddq mm5 , mm1 ) AS2 ( movd mm1 , a3 ) AS2 ( pmuludq mm1 , k2 ) // ▁ a3 * k2 ENDCOM AS2 ( paddq mm5 , mm2 ) AS2 ( movd mm2 , [ esp + 4 ] ) AS2 ( psllq mm5 , 1 ) AS2 ( paddq mm0 , mm5 ) AS2 ( psllq mm4 , 33 ) AS2 ( movd a0 , mm0 ) AS2 ( psrlq mm0 , 32 ) AS2 ( paddq mm6 , mm7 ) AS2 ( movd mm7 , [ esp + 8 ] ) AS2 ( paddq mm0 , mm6 ) AS2 ( paddq mm0 , mm2 ) AS2 ( paddq mm3 , mm1 ) AS2 ( psllq mm3 , 1 ) AS2 ( paddq mm0 , mm3 ) AS2 ( psrlq mm4 , 1 ) AS2 ( movd a1 , mm0 ) AS2 ( psrlq mm0 , 32 ) AS2 ( por mm4 , mm7 ) AS2 ( paddq mm0 , mm4 ) AS2 ( movq a2 , mm0 ) # undef a0 # undef a1 # undef a2 # undef a3 # undef k0 # undef k1 # undef k2 # undef k3 ASL ( 3 ) AS2 ( test ecx , ecx ) ASJ ( jnz , 4 , b ) AS2 ( add esp , 12 ) AS1 ( pop ebp ) AS1 ( emms ) # ifdef __GNUC__ " . att _ syntax ▁ prefix ; " AS2 ( mov % 0 , % % ebx ) : " = m " ( temp ) : " m " ( L1KeyLength ) , " c " ( blocksRemainingInWord64 ) , " S " ( data ) , " D " ( nhK + tagPart * 2 ) , " d " ( m_isFirstBlock ) , " a " ( polyS + tagPart * 4 ) : " memory " , " cc " ) ; # endif } # endif # if VMAC_BOOL_WORD128 # define DeclareNH ( a ) word128 a = 0 # define MUL64 ( rh , rl , i1 , i2 ) { word128 p = word128 ( i1 ) * ( i2 ) ; rh = word64 ( p >> 64 ) ; rl = word64 ( p ) ; } # define AccumulateNH ( a , b , c ) a += word128 ( b ) * ( c ) # define Multiply128 ( r , i1 , i2 ) r = word128 ( word64 ( i1 ) ) * word64 ( i2 ) # else # if _MSC_VER >= 1400 && ! defined ( __INTEL_COMPILER ) # define MUL32 ( a , b ) __emulu ( word32 ( a ) , word32 ( b ) ) # else # define MUL32 ( a , b ) ( ( word64 ) ( ( word32 ) ( a ) ) * ( word32 ) ( b ) ) # endif # if defined ( CRYPTOPP_X64_ASM_AVAILABLE ) # define DeclareNH ( a ) word64 a ## 0 = 0 , a ## 1 = 0 # define MUL64 ( rh , rl , i1 , i2 ) asm ( " mulq ▁ % 3" : " = a " ( rl ) , " = d " ( rh ) : " a " ( i1 ) , " g " ( i2 ) : " cc " ) ; # define AccumulateNH ( a , b , c ) asm ( " mulq ▁ % 3 ; ▁ addq ▁ % % rax , ▁ % 0 ; ▁ adcq ▁ % % rdx , ▁ % 1" : " + r " ( a ## 0 ) , " + r " ( a ## 1 ) : " a " ( b ) , " g " ( c ) : " % rdx " , " cc " ) ; # define ADD128 ( rh , rl , ih , il ) asm ( " addq ▁ % 3 , ▁ % 1 ; ▁ adcq ▁ % 2 , ▁ % 0" : " + r " ( rh ) , " + r " ( rl ) : " r " ( ih ) , " r " ( il ) : " cc " ) ; # elif defined ( _MSC_VER ) && ! CRYPTOPP_BOOL_SLOW_WORD64 # define DeclareNH ( a ) word64 a ## 0 = 0 , a ## 1 = 0 # define MUL64 ( rh , rl , i1 , i2 ) ( rl ) = _umul128 ( i1 , i2 , & ( rh ) ) ; # define AccumulateNH ( a , b , c ) { word64 ph , pl ; pl = _umul128 ( b , c , & ph ) ; a ## 0 += pl ; a ## 1 += ph + ( a ## 0 < pl ) ; } # else # define VMAC_BOOL_32BIT 1 # define DeclareNH ( a ) word64 a ## 0 = 0 , a ## 1 = 0 , a ## 2 = 0 # define MUL64 ( rh , rl , i1 , i2 ) { word64 _i1 = ( i1 ) , _i2 = ( i2 ) ; word64 m1 = MUL32 ( _i1 , _i2 >> 32 ) ; word64 m2 = MUL32 ( _i1 >> 32 , _i2 ) ; rh = MUL32 ( _i1 >> 32 , _i2 >> 32 ) ; rl = MUL32 ( _i1 , _i2 ) ; ADD128 ( rh , rl , ( m1 >> 32 ) , ( m1 << 32 ) ) ; ADD128 ( rh , rl , ( m2 >> 32 ) , ( m2 << 32 ) ) ; } # define AccumulateNH ( a , b , c ) { word64 p = MUL32 ( b , c ) ; a ## 1 += word32 ( ( p ) >> 32 ) ; a ## 0 += word32 ( p ) ; p = MUL32 ( ( b ) >> 32 , c ) ; a ## 2 += word32 ( ( p ) >> 32 ) ; a ## 1 += word32 ( p ) ; p = MUL32 ( ( b ) >> 32 , ( c ) >> 32 ) ; a ## 2 += p ; p = MUL32 ( b , ( c ) >> 32 ) ; a ## 1 += word32 ( p ) ; a ## 2 += word32 ( p >> 32 ) ; } # endif # endif # ifndef VMAC_BOOL_32BIT # define VMAC_BOOL_32BIT 0 # endif # ifndef ADD128 # define ADD128 ( rh , rl , ih , il ) { word64 _il = ( il ) ; ( rl ) += ( _il ) ; ( rh ) += ( ih ) + ( ( rl ) < ( _il ) ) ; } # endif # if ! ( defined ( _MSC_VER ) && _MSC_VER < 1300 ) template < bool T_128BitTag > # endif void VMAC_Base :: VHASH_Update_Template ( const word64 * data , size_t blocksRemainingInWord64 ) { # define INNER_LOOP_ITERATION ( j ) { word64 d0 = ConditionalByteReverse ( LITTLE_ENDIAN_ORDER , data [ i + 2 * j + 0 ] ) ; word64 d1 = ConditionalByteReverse ( LITTLE_ENDIAN_ORDER , data [ i + 2 * j + 1 ] ) ; AccumulateNH ( nhA , d0 + nhK [ i + 2 * j + 0 ] , d1 + nhK [ i + 2 * j + 1 ] ) ; if ( T_128BitTag ) AccumulateNH ( nhB , d0 + nhK [ i + 2 * j + 2 ] , d1 + nhK [ i + 2 * j + 3 ] ) ; } # if ( defined ( _MSC_VER ) && _MSC_VER < 1300 ) bool T_128BitTag = m_is128 ; # endif size_t L1KeyLengthInWord64 = m_L1KeyLength / 8 ; size_t innerLoopEnd = L1KeyLengthInWord64 ; const word64 * nhK = m_nhKey ( ) ; word64 * polyS = m_polyState ( ) ; bool isFirstBlock = true ; size_t i ; # if ! VMAC_BOOL_32BIT # if VMAC_BOOL_WORD128 word128 a1 , a2 ; # else word64 ah1 , al1 , ah2 , al2 ; # endif word64 kh1 , kl1 , kh2 , kl2 ; kh1 = ( polyS + 0 * 4 + 2 ) [ 0 ] ; kl1 = ( polyS + 0 * 4 + 2 ) [ 1 ] ; if ( T_128BitTag ) { kh2 = ( polyS + 1 * 4 + 2 ) [ 0 ] ; kl2 = ( polyS + 1 * 4 + 2 ) [ 1 ] ; } # endif do { DeclareNH ( nhA ) ; DeclareNH ( nhB ) ; i = 0 ; if ( blocksRemainingInWord64 < L1KeyLengthInWord64 ) { if ( blocksRemainingInWord64 % 8 ) { innerLoopEnd = blocksRemainingInWord64 % 8 ; for ( ; i < innerLoopEnd ; i += 2 ) INNER_LOOP_ITERATION ( 0 ) ; } innerLoopEnd = blocksRemainingInWord64 ; } for ( ; i < innerLoopEnd ; i += 8 ) { INNER_LOOP_ITERATION ( 0 ) ; INNER_LOOP_ITERATION ( 1 ) ; INNER_LOOP_ITERATION ( 2 ) ; INNER_LOOP_ITERATION ( 3 ) ; } blocksRemainingInWord64 -= innerLoopEnd ; data += innerLoopEnd ; # if VMAC_BOOL_32BIT word32 nh0 [ 2 ] , nh1 [ 2 ] ; word64 nh2 [ 2 ] ; nh0 [ 0 ] = word32 ( nhA0 ) ; nhA1 += ( nhA0 >> 32 ) ; nh1 [ 0 ] = word32 ( nhA1 ) ; nh2 [ 0 ] = ( nhA2 + ( nhA1 >> 32 ) ) & m62 ; if ( T_128BitTag ) { nh0 [ 1 ] = word32 ( nhB0 ) ; nhB1 += ( nhB0 >> 32 ) ; nh1 [ 1 ] = word32 ( nhB1 ) ; nh2 [ 1 ] = ( nhB2 + ( nhB1 >> 32 ) ) & m62 ; } # define a0 ( ( ( word32 * ) ( polyS + i * 4 ) ) [ 2 + NativeByteOrder :: ToEnum ( ) ] ) # define a1 ( * ( ( ( word32 * ) ( polyS + i * 4 ) ) + 3 - NativeByteOrder :: ToEnum ( ) ) ) // ▁ workaround ▁ for ▁ GCC ▁ 3.2 ENDCOM # define a2 ( ( ( word32 * ) ( polyS + i * 4 ) ) [ 0 + NativeByteOrder :: ToEnum ( ) ] ) # define a3 ( * ( ( ( word32 * ) ( polyS + i * 4 ) ) + 1 - NativeByteOrder :: ToEnum ( ) ) ) # define aHi ( ( polyS + i * 4 ) [ 0 ] ) # define k0 ( ( ( word32 * ) ( polyS + i * 4 + 2 ) ) [ 2 + NativeByteOrder :: ToEnum ( ) ] ) # define k1 ( * ( ( ( word32 * ) ( polyS + i * 4 + 2 ) ) + 3 - NativeByteOrder :: ToEnum ( ) ) ) # define k2 ( ( ( word32 * ) ( polyS + i * 4 + 2 ) ) [ 0 + NativeByteOrder :: ToEnum ( ) ] ) # define k3 ( * ( ( ( word32 * ) ( polyS + i * 4 + 2 ) ) + 1 - NativeByteOrder :: ToEnum ( ) ) ) # define kHi ( ( polyS + i * 4 + 2 ) [ 0 ] ) if ( isFirstBlock ) { isFirstBlock = false ; if ( m_isFirstBlock ) { m_isFirstBlock = false ; for ( i = 0 ; i <= ( size_t ) T_128BitTag ; i ++ ) { word64 t = ( word64 ) nh0 [ i ] + k0 ; a0 = ( word32 ) t ; t = ( t >> 32 ) + nh1 [ i ] + k1 ; a1 = ( word32 ) t ; aHi = ( t >> 32 ) + nh2 [ i ] + kHi ; } continue ; } } for ( i = 0 ; i <= ( size_t ) T_128BitTag ; i ++ ) { word64 p , t ; word32 t2 ; p = MUL32 ( a3 , 2 * k3 ) ; p += nh2 [ i ] ; p += MUL32 ( a0 , k2 ) ; p += MUL32 ( a1 , k1 ) ; p += MUL32 ( a2 , k0 ) ; t2 = ( word32 ) p ; p >>= 32 ; p += MUL32 ( a0 , k3 ) ; p += MUL32 ( a1 , k2 ) ; p += MUL32 ( a2 , k1 ) ; p += MUL32 ( a3 , k0 ) ; t = ( word64 ( word32 ( p ) & 0x7fffffff ) << 32 ) | t2 ; p >>= 31 ; p += nh0 [ i ] ; p += MUL32 ( a0 , k0 ) ; p += MUL32 ( a1 , 2 * k3 ) ; p += MUL32 ( a2 , 2 * k2 ) ; p += MUL32 ( a3 , 2 * k1 ) ; t2 = ( word32 ) p ; p >>= 32 ; p += nh1 [ i ] ; p += MUL32 ( a0 , k1 ) ; p += MUL32 ( a1 , k0 ) ; p += MUL32 ( a2 , 2 * k3 ) ; p += MUL32 ( a3 , 2 * k2 ) ; a0 = t2 ; a1 = ( word32 ) p ; aHi = ( p >> 32 ) + t ; } # undef a0 # undef a1 # undef a2 # undef a3 # undef aHi # undef k0 # undef k1 # undef k2 # undef k3 # undef kHi # else // ▁ # if ▁ VMAC _ BOOL _ 32BIT ENDCOM if ( isFirstBlock ) { isFirstBlock = false ; if ( m_isFirstBlock ) { m_isFirstBlock = false ; # if VMAC_BOOL_WORD128 # define first_poly_step ( a , kh , kl , m ) a = ( m & m126 ) + ( ( word128 ( kh ) << 64 ) | kl ) first_poly_step ( a1 , kh1 , kl1 , nhA ) ; if ( T_128BitTag ) first_poly_step ( a2 , kh2 , kl2 , nhB ) ; # else # define first_poly_step ( ah , al , kh , kl , mh , ml ) { mh &= m62 ; ADD128 ( mh , ml , kh , kl ) ; ah = mh ; al = ml ; } first_poly_step ( ah1 , al1 , kh1 , kl1 , nhA1 , nhA0 ) ; if ( T_128BitTag ) first_poly_step ( ah2 , al2 , kh2 , kl2 , nhB1 , nhB0 ) ; # endif continue ; } else { # if VMAC_BOOL_WORD128 a1 = ( word128 ( ( polyS + 0 * 4 ) [ 0 ] ) << 64 ) | ( polyS + 0 * 4 ) [ 1 ] ; # else ah1 = ( polyS + 0 * 4 ) [ 0 ] ; al1 = ( polyS + 0 * 4 ) [ 1 ] ; # endif if ( T_128BitTag ) { # if VMAC_BOOL_WORD128 a2 = ( word128 ( ( polyS + 1 * 4 ) [ 0 ] ) << 64 ) | ( polyS + 1 * 4 ) [ 1 ] ; # else ah2 = ( polyS + 1 * 4 ) [ 0 ] ; al2 = ( polyS + 1 * 4 ) [ 1 ] ; # endif } } } # if VMAC_BOOL_WORD128 # define poly_step ( a , kh , kl , m ) { word128 t1 , t2 , t3 , t4 ; Multiply128 ( t2 , a >> 64 , kl ) ; Multiply128 ( t3 , a , kh ) ; Multiply128 ( t1 , a , kl ) ; Multiply128 ( t4 , a >> 64 , 2 * kh ) ; t2 += t3 ; t4 += t1 ; t2 += t4 >> 64 ; a = ( word128 ( word64 ( t2 ) & m63 ) << 64 ) | word64 ( t4 ) ; t2 *= 2 ; a += m & m126 ; a += t2 >> 64 ; } poly_step ( a1 , kh1 , kl1 , nhA ) ; if ( T_128BitTag ) poly_step ( a2 , kh2 , kl2 , nhB ) ; # else # define poly_step ( ah , al , kh , kl , mh , ml ) { word64 t1h , t1l , t2h , t2l , t3h , t3l , z = 0 ; /* ▁ compute ▁ ab * cd , ▁ put ▁ bd ▁ into ▁ result ▁ registers ▁ */ MUL64 ( t2h , t2l , ah , kl ) ; MUL64 ( t3h , t3l , al , kh ) ; MUL64 ( t1h , t1l , ah , 2 * kh ) ; MUL64 ( ah , al , al , kl ) ; /* ▁ add ▁ together ▁ ad ▁ + ▁ bc ▁ */ ADD128 ( t2h , t2l , t3h , t3l ) ; /* ▁ add ▁ 2 ▁ * ▁ ac ▁ to ▁ result ▁ */ ADD128 ( ah , al , t1h , t1l ) ; /* ▁ now ▁ ( ah , al ) , ▁ ( t2l , 2 * t2h ) ▁ need ▁ summing ▁ */ /* ▁ first ▁ add ▁ the ▁ high ▁ registers , ▁ carrying ▁ into ▁ t2h ▁ */ ADD128 ( t2h , ah , z , t2l ) ; /* ▁ double ▁ t2h ▁ and ▁ add ▁ top ▁ bit ▁ of ▁ ah ▁ */ t2h += t2h + ( ah >> 63 ) ; ah &= m63 ; /* ▁ now ▁ add ▁ the ▁ low ▁ registers ▁ */ mh &= m62 ; ADD128 ( ah , al , mh , ml ) ; ADD128 ( ah , al , z , t2h ) ; } poly_step ( ah1 , al1 , kh1 , kl1 , nhA1 , nhA0 ) ; if ( T_128BitTag ) poly_step ( ah2 , al2 , kh2 , kl2 , nhB1 , nhB0 ) ; # endif # endif // ▁ # if ▁ VMAC _ BOOL _ 32BIT ENDCOM } while ( blocksRemainingInWord64 ) ; # if VMAC_BOOL_WORD128 ( polyS + 0 * 4 ) [ 0 ] = word64 ( a1 >> 64 ) ; ( polyS + 0 * 4 ) [ 1 ] = word64 ( a1 ) ; if ( T_128BitTag ) { ( polyS + 1 * 4 ) [ 0 ] = word64 ( a2 >> 64 ) ; ( polyS + 1 * 4 ) [ 1 ] = word64 ( a2 ) ; } # elif ! VMAC_BOOL_32BIT ( polyS + 0 * 4 ) [ 0 ] = ah1 ; ( polyS + 0 * 4 ) [ 1 ] = al1 ; if ( T_128BitTag ) { ( polyS + 1 * 4 ) [ 0 ] = ah2 ; ( polyS + 1 * 4 ) [ 1 ] = al2 ; } # endif } inline void VMAC_Base :: VHASH_Update ( const word64 * data , size_t blocksRemainingInWord64 ) { # if CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE && CRYPTOPP_BOOL_X86 if ( HasSSE2 ( ) ) { VHASH_Update_SSE2 ( data , blocksRemainingInWord64 , 0 ) ; if ( m_is128 ) VHASH_Update_SSE2 ( data , blocksRemainingInWord64 , 1 ) ; m_isFirstBlock = false ; } else # endif { # if defined ( _MSC_VER ) && _MSC_VER < 1300 VHASH_Update_Template ( data , blocksRemainingInWord64 ) ; # else if ( m_is128 ) VHASH_Update_Template < true > ( data , blocksRemainingInWord64 ) ; else VHASH_Update_Template < false > ( data , blocksRemainingInWord64 ) ; # endif } } size_t VMAC_Base :: HashMultipleBlocks ( const word64 * data , size_t length ) { size_t remaining = ModPowerOf2 ( length , m_L1KeyLength ) ; VHASH_Update ( data , ( length - remaining ) / 8 ) ; return remaining ; } static word64 L3Hash ( const word64 * input , const word64 * l3Key , size_t len ) { word64 rh , rl , t , z = 0 ; word64 p1 = input [ 0 ] , p2 = input [ 1 ] ; word64 k1 = l3Key [ 0 ] , k2 = l3Key [ 1 ] ; /* ▁ fully ▁ reduce ▁ ( p1 , p2 ) + ( len , 0 ) ▁ mod ▁ p127 ▁ */ t = p1 >> 63 ; p1 &= m63 ; ADD128 ( p1 , p2 , len , t ) ; /* ▁ At ▁ this ▁ point , ▁ ( p1 , p2 ) ▁ is ▁ at ▁ most ▁ 2 ^ 127 + ( len < < 64 ) ▁ */ t = ( p1 > m63 ) + ( ( p1 == m63 ) & ( p2 == m64 ) ) ; ADD128 ( p1 , p2 , z , t ) ; p1 &= m63 ; /* ▁ compute ▁ ( p1 , p2 ) / (2 ^ 64-2 ^ 32 ) ▁ and ▁ ( p1 , p2 ) % (2 ^ 64-2 ^ 32 ) ▁ */ t = p1 + ( p2 >> 32 ) ; t += ( t >> 32 ) ; t += ( word32 ) t > 0xfffffffeU ; p1 += ( t >> 32 ) ; p2 += ( p1 << 32 ) ; /* ▁ compute ▁ ( p1 + k1 ) % p64 ▁ and ▁ ( p2 + k2 ) % p64 ▁ */ p1 += k1 ; p1 += ( 0 - ( p1 < k1 ) ) & 257 ; p2 += k2 ; p2 += ( 0 - ( p2 < k2 ) ) & 257 ; /* ▁ compute ▁ ( p1 + k1 ) * ( p2 + k2 ) % p64 ▁ */ MUL64 ( rh , rl , p1 , p2 ) ; t = rh >> 56 ; ADD128 ( t , rl , z , rh ) ; rh <<= 8 ; ADD128 ( t , rl , z , rh ) ; t += t << 8 ; rl += t ; rl += ( 0 - ( rl < t ) ) & 257 ; rl += ( 0 - ( rl > p64 - 1 ) ) & 257 ; return rl ; } void VMAC_Base :: TruncatedFinal ( byte * mac , size_t size ) { size_t len = ModPowerOf2 ( GetBitCountLo ( ) / 8 , m_L1KeyLength ) ; if ( len ) { memset ( m_data ( ) + len , 0 , ( 0 - len ) % 16 ) ; VHASH_Update ( DataBuf ( ) , ( ( len + 15 ) / 16 ) * 2 ) ; len *= 8 ; // ▁ convert ▁ to ▁ bits ENDCOM } else if ( m_isFirstBlock ) { // ▁ special ▁ case ▁ for ▁ empty ▁ string ENDCOM m_polyState ( ) [ 0 ] = m_polyState ( ) [ 2 ] ; m_polyState ( ) [ 1 ] = m_polyState ( ) [ 3 ] ; if ( m_is128 ) { m_polyState ( ) [ 4 ] = m_polyState ( ) [ 6 ] ; m_polyState ( ) [ 5 ] = m_polyState ( ) [ 7 ] ; } } if ( m_is128 ) { word64 t [ 2 ] ; t [ 0 ] = L3Hash ( m_polyState ( ) , m_l3Key ( ) , len ) + GetWord < word64 > ( true , BIG_ENDIAN_ORDER , m_pad ( ) ) ; t [ 1 ] = L3Hash ( m_polyState ( ) + 4 , m_l3Key ( ) + 2 , len ) + GetWord < word64 > ( true , BIG_ENDIAN_ORDER , m_pad ( ) + 8 ) ; if ( size == 16 ) { PutWord ( false , BIG_ENDIAN_ORDER , mac , t [ 0 ] ) ; PutWord ( false , BIG_ENDIAN_ORDER , mac + 8 , t [ 1 ] ) ; } else { t [ 0 ] = ConditionalByteReverse ( BIG_ENDIAN_ORDER , t [ 0 ] ) ; t [ 1 ] = ConditionalByteReverse ( BIG_ENDIAN_ORDER , t [ 1 ] ) ; memcpy ( mac , t , size ) ; } } else { word64 t = L3Hash ( m_polyState ( ) , m_l3Key ( ) , len ) ; t += GetWord < word64 > ( true , BIG_ENDIAN_ORDER , m_pad ( ) + ( m_nonce ( ) [ IVSize ( ) - 1 ] & 1 ) * 8 ) ; if ( size == 8 ) PutWord ( false , BIG_ENDIAN_ORDER , mac , t ) ; else { t = ConditionalByteReverse ( BIG_ENDIAN_ORDER , t ) ; memcpy ( mac , & t , size ) ; } } } NAMESPACE_END </DOCUMENT>
<DOCUMENT_ID="waddlesplash/DolphinQt/tree/master/Externals/wxWidgets3/src/osx/carbon/textctrl.cpp"> // ▁ Name : ▁ src / osx / carbon / textctrl . cpp ENDCOM // ▁ Purpose : ▁ wxTextCtrl ENDCOM // ▁ Author : ▁ Stefan ▁ Csomor ENDCOM // ▁ Modified ▁ by : ▁ Ryan ▁ Norton ▁ ( MLTE ▁ GetLineLength ▁ and ▁ GetLineText ) ENDCOM // ▁ Created : ▁ 1998-01-01 ENDCOM // ▁ Copyright : ▁ ( c ) ▁ Stefan ▁ Csomor ENDCOM // ▁ Licence : ▁ wxWindows ▁ licence ENDCOM # include " wx / wxprec . h " # if wxUSE_TEXTCTRL # include " wx / textctrl . h " # ifndef WX_PRECOMP # include " wx / intl . h " # include " wx / app . h " # include " wx / utils . h " # include " wx / dc . h " # include " wx / button . h " # include " wx / menu . h " # include " wx / settings . h " # include " wx / msgdlg . h " # include " wx / toplevel . h " # endif # ifdef __DARWIN__ # include < sys / types . h > # include < sys / stat . h > # else # include < stat . h > # endif # if wxUSE_STD_IOSTREAM # if wxUSE_IOSTREAMH # include < fstream . h > # else # include < fstream > # endif # endif # include " wx / filefn . h " # include " wx / sysopt . h " # include " wx / thread . h " # include " wx / osx / private . h " # include " wx / osx / carbon / private / mactext . h " class wxMacFunctor { public : wxMacFunctor ( ) { } virtual ~ wxMacFunctor ( ) { } virtual void * operator ( ) ( ) = 0 ; static void * CallBackProc ( void * param ) { wxMacFunctor * f = ( wxMacFunctor * ) param ; void * result = ( * f ) ( ) ; return result ; } } ; template < typename classtype , typename param1type > class wxMacObjectFunctor1 : public wxMacFunctor { typedef void ( classtype :: * function ) ( param1type p1 ) ; typedef void ( classtype :: * ref_function ) ( const param1type & p1 ) ; public : wxMacObjectFunctor1 ( classtype * obj , function f , param1type p1 ) : wxMacFunctor ( ) { m_object = obj ; m_function = f ; m_param1 = p1 ; } wxMacObjectFunctor1 ( classtype * obj , ref_function f , param1type p1 ) : wxMacFunctor ( ) { m_object = obj ; m_refFunction = f ; m_param1 = p1 ; } virtual ~ wxMacObjectFunctor1 ( ) { } virtual void * operator ( ) ( ) { ( m_object ->* m_function ) ( m_param1 ) ; return NULL ; } private : classtype * m_object ; param1type m_param1 ; union { function m_function ; ref_function m_refFunction ; } ; } ; template < typename classtype , typename param1type > void * wxMacMPRemoteCall ( classtype * object , void ( classtype :: * function ) ( param1type p1 ) , param1type p1 ) { wxMacObjectFunctor1 < classtype , param1type > params ( object , function , p1 ) ; void * result = MPRemoteCall ( wxMacFunctor :: CallBackProc , & params , kMPOwningProcessRemoteContext ) ; return result ; } template < typename classtype , typename param1type > void * wxMacMPRemoteCall ( classtype * object , void ( classtype :: * function ) ( const param1type & p1 ) , param1type p1 ) { wxMacObjectFunctor1 < classtype , param1type > params ( object , function , p1 ) ; void * result = MPRemoteCall ( wxMacFunctor :: CallBackProc , & params , kMPOwningProcessRemoteContext ) ; return result ; } template < typename classtype , typename param1type > void * wxMacMPRemoteGUICall ( classtype * object , void ( classtype :: * function ) ( param1type p1 ) , param1type p1 ) { wxMutexGuiLeave ( ) ; void * result = wxMacMPRemoteCall ( object , function , p1 ) ; wxMutexGuiEnter ( ) ; return result ; } template < typename classtype , typename param1type > void * wxMacMPRemoteGUICall ( classtype * object , void ( classtype :: * function ) ( const param1type & p1 ) , param1type p1 ) { wxMutexGuiLeave ( ) ; void * result = wxMacMPRemoteCall ( object , function , p1 ) ; wxMutexGuiEnter ( ) ; return result ; } class WXDLLEXPORT wxMacPortSaver { wxDECLARE_NO_COPY_CLASS ( wxMacPortSaver ) ; public : wxMacPortSaver ( GrafPtr port ) ; ~ wxMacPortSaver ( ) ; private : GrafPtr m_port ; } ; /* STRNEWLINE ▁ Clips ▁ to ▁ the ▁ visible ▁ region ▁ of ▁ a ▁ control ▁ within ▁ the ▁ current ▁ port STRNEWLINE ▁ */ class WXDLLEXPORT wxMacWindowClipper : public wxMacPortSaver { wxDECLARE_NO_COPY_CLASS ( wxMacWindowClipper ) ; public : wxMacWindowClipper ( const wxWindow * win ) ; ~ wxMacWindowClipper ( ) ; private : GrafPtr m_newPort ; RgnHandle m_formerClip ; RgnHandle m_newClip ; } ; wxMacPortSaver :: wxMacPortSaver ( GrafPtr port ) { :: GetPort ( & m_port ) ; :: SetPort ( port ) ; } wxMacPortSaver :: ~ wxMacPortSaver ( ) { :: SetPort ( m_port ) ; } wxMacWindowClipper :: wxMacWindowClipper ( const wxWindow * win ) : wxMacPortSaver ( ( GrafPtr ) GetWindowPort ( ( WindowRef ) win -> MacGetTopLevelWindowRef ( ) ) ) { m_newPort = ( GrafPtr ) GetWindowPort ( ( WindowRef ) win -> MacGetTopLevelWindowRef ( ) ) ; m_formerClip = NewRgn ( ) ; m_newClip = NewRgn ( ) ; GetClip ( m_formerClip ) ; if ( win ) { // ▁ guard ▁ against ▁ half ▁ constructed ▁ objects , ▁ this ▁ just ▁ leads ▁ to ▁ a ▁ empty ▁ clip ENDCOM if ( win -> GetPeer ( ) ) { int x = 0 , y = 0 ; win -> MacWindowToRootWindow ( & x , & y ) ; // ▁ get ▁ area ▁ including ▁ focus ▁ rect ENDCOM HIShapeGetAsQDRgn ( ( ( wxWindow * ) win ) -> MacGetVisibleRegion ( true ) . GetWXHRGN ( ) , m_newClip ) ; if ( ! EmptyRgn ( m_newClip ) ) OffsetRgn ( m_newClip , x , y ) ; } SetClip ( m_newClip ) ; } } wxMacWindowClipper :: ~ wxMacWindowClipper ( ) { SetPort ( m_newPort ) ; SetClip ( m_formerClip ) ; DisposeRgn ( m_newClip ) ; DisposeRgn ( m_formerClip ) ; } // ▁ common ▁ parts ▁ for ▁ implementations ▁ based ▁ on ▁ MLTE ENDCOM class wxMacMLTEControl : public wxMacControl , public wxTextWidgetImpl { public : wxMacMLTEControl ( wxTextCtrl * peer ) ; ~ wxMacMLTEControl ( ) { } virtual bool CanFocus ( ) const { return true ; } virtual wxString GetStringValue ( ) const ; virtual void SetStringValue ( const wxString & str ) ; static TXNFrameOptions FrameOptionsFromWXStyle ( long wxStyle ) ; void AdjustCreationAttributes ( const wxColour & background , bool visible ) ; virtual void SetFont ( const wxFont & font , const wxColour & foreground , long windowStyle , bool ignoreBlack ) ; virtual void SetBackgroundColour ( const wxColour & col ) ; virtual void SetStyle ( long start , long end , const wxTextAttr & style ) ; virtual void Copy ( ) ; virtual void Cut ( ) ; virtual void Paste ( ) ; virtual bool CanPaste ( ) const ; virtual void SetEditable ( bool editable ) ; virtual long GetLastPosition ( ) const ; virtual void Replace ( long from , long to , const wxString & str ) ; virtual void Remove ( long from , long to ) ; virtual void GetSelection ( long * from , long * to ) const ; virtual void SetSelection ( long from , long to ) ; virtual void WriteText ( const wxString & str ) ; virtual bool HasOwnContextMenu ( ) const { TXNCommandEventSupportOptions options ; TXNGetCommandEventSupport ( m_txn , & options ) ; return options & kTXNSupportEditCommandProcessing ; } virtual void CheckSpelling ( bool check ) { TXNSetSpellCheckAsYouType ( m_txn , ( Boolean ) check ) ; } virtual void Clear ( ) ; virtual bool CanUndo ( ) const ; virtual void Undo ( ) ; virtual bool CanRedo ( ) const ; virtual void Redo ( ) ; virtual int GetNumberOfLines ( ) const ; virtual long XYToPosition ( long x , long y ) const ; virtual bool PositionToXY ( long pos , long * x , long * y ) const ; virtual void ShowPosition ( long pos ) ; virtual int GetLineLength ( long lineNo ) const ; virtual wxString GetLineText ( long lineNo ) const ; void SetTXNData ( const wxString & st , TXNOffset start , TXNOffset end ) ; TXNObject GetTXNObject ( ) { return m_txn ; } protected : void TXNSetAttribute ( const wxTextAttr & style , long from , long to ) ; TXNObject m_txn ; } ; // ▁ implementation ▁ available ▁ under ▁ OSX ENDCOM class wxMacMLTEHIViewControl : public wxMacMLTEControl { public : wxMacMLTEHIViewControl ( wxTextCtrl * wxPeer , const wxString & str , const wxPoint & pos , const wxSize & size , long style ) ; virtual ~ wxMacMLTEHIViewControl ( ) ; virtual bool SetFocus ( ) ; virtual bool HasFocus ( ) const ; virtual void SetBackgroundColour ( const wxColour & col ) ; protected : HIViewRef m_scrollView ; HIViewRef m_textView ; } ; // ▁ ' classic ' ▁ MLTE ▁ implementation ENDCOM class wxMacMLTEClassicControl : public wxMacMLTEControl { public : wxMacMLTEClassicControl ( wxTextCtrl * wxPeer , const wxString & str , const wxPoint & pos , const wxSize & size , long style ) ; virtual ~ wxMacMLTEClassicControl ( ) ; virtual void VisibilityChanged ( bool shown ) ; virtual void SuperChangedPosition ( ) ; virtual void MacControlUserPaneDrawProc ( wxInt16 part ) ; virtual wxInt16 MacControlUserPaneHitTestProc ( wxInt16 x , wxInt16 y ) ; virtual wxInt16 MacControlUserPaneTrackingProc ( wxInt16 x , wxInt16 y , void * actionProc ) ; virtual void MacControlUserPaneIdleProc ( ) ; virtual wxInt16 MacControlUserPaneKeyDownProc ( wxInt16 keyCode , wxInt16 charCode , wxInt16 modifiers ) ; virtual void MacControlUserPaneActivateProc ( bool activating ) ; virtual wxInt16 MacControlUserPaneFocusProc ( wxInt16 action ) ; virtual void MacControlUserPaneBackgroundProc ( void * info ) ; virtual bool SetupCursor ( const wxPoint & WXUNUSED ( pt ) ) { MacControlUserPaneIdleProc ( ) ; return true ; } virtual void Move ( int x , int y , int width , int height ) ; protected : OSStatus DoCreate ( ) ; void MacUpdatePosition ( ) ; void MacActivatePaneText ( bool setActive ) ; void MacFocusPaneText ( bool setFocus ) ; void MacSetObjectVisibility ( bool vis ) ; private : TXNFrameID m_txnFrameID ; GrafPtr m_txnPort ; WindowRef m_txnWindow ; // ▁ bounds ▁ of ▁ the ▁ control ▁ as ▁ we ▁ last ▁ did ▁ set ▁ the ▁ txn ▁ frames ENDCOM Rect m_txnControlBounds ; Rect m_txnVisBounds ; static pascal void TXNScrollActionProc ( ControlRef controlRef , ControlPartCode partCode ) ; static pascal void TXNScrollInfoProc ( SInt32 iValue , SInt32 iMaximumValue , TXNScrollBarOrientation iScrollBarOrientation , SInt32 iRefCon ) ; ControlRef m_sbHorizontal ; SInt32 m_lastHorizontalValue ; ControlRef m_sbVertical ; SInt32 m_lastVerticalValue ; } ; wxWidgetImplType * wxWidgetImpl :: CreateTextControl ( wxTextCtrl * wxpeer , wxWindowMac * WXUNUSED ( parent ) , wxWindowID WXUNUSED ( id ) , const wxString & str , const wxPoint & pos , const wxSize & size , long style , long WXUNUSED ( extraStyle ) ) { return new wxMacMLTEHIViewControl ( wxpeer , str , pos , size , style ) ; } // ▁ standard ▁ unicode ▁ control ▁ implementation ENDCOM // ▁ the ▁ current ▁ unicode ▁ textcontrol ▁ implementation ▁ has ▁ a ▁ bug ▁ : ▁ only ▁ if ▁ the ▁ control ENDCOM // ▁ is ▁ currently ▁ having ▁ the ▁ focus , ▁ the ▁ selection ▁ can ▁ be ▁ retrieved ▁ by ▁ the ▁ corresponding ENDCOM // ▁ data ▁ tag . ▁ So ▁ we ▁ have ▁ a ▁ mirroring ▁ using ▁ a ▁ member ▁ variable ENDCOM // ▁ TODO ▁ : ▁ build ▁ event ▁ table ▁ using ▁ virtual ▁ member ▁ functions ▁ for ▁ wxMacControl ENDCOM static const EventTypeSpec unicodeTextControlEventList [ ] = { { kEventClassControl , kEventControlSetFocusPart } , } ; static pascal OSStatus wxMacUnicodeTextControlControlEventHandler ( EventHandlerCallRef handler , EventRef event , void * data ) { OSStatus result = eventNotHandledErr ; wxMacUnicodeTextControl * focus = ( wxMacUnicodeTextControl * ) data ; wxMacCarbonEvent cEvent ( event ) ; switch ( GetEventKind ( event ) ) { case kEventControlSetFocusPart : { ControlPartCode controlPart = cEvent . GetParameter < ControlPartCode > ( kEventParamControlPart , typeControlPartCode ) ; if ( controlPart == kControlFocusNoPart ) { // ▁ about ▁ to ▁ lose ▁ focus ▁ - > ▁ store ▁ selection ▁ to ▁ field ENDCOM focus -> GetData < ControlEditTextSelectionRec > ( 0 , kControlEditTextSelectionTag , & focus -> m_selection ) ; } result = CallNextEventHandler ( handler , event ) ; if ( controlPart != kControlFocusNoPart ) { // ▁ about ▁ to ▁ gain ▁ focus ▁ - > ▁ set ▁ selection ▁ from ▁ field ENDCOM focus -> SetData < ControlEditTextSelectionRec > ( 0 , kControlEditTextSelectionTag , & focus -> m_selection ) ; } break ; } default : break ; } return result ; } static pascal OSStatus wxMacUnicodeTextControlEventHandler ( EventHandlerCallRef handler , EventRef event , void * data ) { OSStatus result = eventNotHandledErr ; switch ( GetEventClass ( event ) ) { case kEventClassControl : result = wxMacUnicodeTextControlControlEventHandler ( handler , event , data ) ; break ; default : break ; } return result ; } DEFINE_ONE_SHOT_HANDLER_GETTER ( wxMacUnicodeTextControlEventHandler ) wxMacUnicodeTextControl :: wxMacUnicodeTextControl ( wxTextCtrl * wxPeer ) : wxMacControl ( wxPeer ) , wxTextWidgetImpl ( wxPeer ) { } wxMacUnicodeTextControl :: wxMacUnicodeTextControl ( wxTextCtrl * wxPeer , const wxString & str , const wxPoint & pos , const wxSize & size , long style ) : wxMacControl ( wxPeer ) , wxTextWidgetImpl ( wxPeer ) { m_font = wxPeer -> GetFont ( ) ; m_windowStyle = style ; m_selection . selStart = m_selection . selEnd = 0 ; Rect bounds = wxMacGetBoundsForControl ( wxPeer , pos , size ) ; wxString st = str ; wxMacConvertNewlines10To13 ( & st ) ; wxCFStringRef cf ( st , m_font . GetEncoding ( ) ) ; m_valueTag = kControlEditTextCFStringTag ; Boolean isPassword = ( m_windowStyle & wxTE_PASSWORD ) != 0 ; if ( isPassword ) { m_valueTag = kControlEditTextPasswordCFStringTag ; } OSStatus err = CreateEditUnicodeTextControl ( MAC_WXHWND ( wxPeer -> MacGetTopLevelWindowRef ( ) ) , & bounds , cf , isPassword , NULL , & m_controlRef ) ; verify_noerr ( err ) ; if ( ! ( m_windowStyle & wxTE_MULTILINE ) ) SetData < Boolean > ( kControlEditTextPart , kControlEditTextSingleLineTag , true ) ; InstallEventHandlers ( ) ; } void wxMacUnicodeTextControl :: InstallEventHandlers ( ) { :: InstallControlEventHandler ( m_controlRef , GetwxMacUnicodeTextControlEventHandlerUPP ( ) , GetEventTypeCount ( unicodeTextControlEventList ) , unicodeTextControlEventList , this , ( EventHandlerRef * ) & m_macTextCtrlEventHandler ) ; } wxMacUnicodeTextControl :: ~ wxMacUnicodeTextControl ( ) { :: RemoveEventHandler ( ( EventHandlerRef ) m_macTextCtrlEventHandler ) ; } void wxMacUnicodeTextControl :: VisibilityChanged ( bool shown ) { if ( ! ( m_windowStyle & wxTE_MULTILINE ) && shown ) { // ▁ work ▁ around ▁ a ▁ refresh ▁ issue ▁ insofar ▁ as ▁ not ▁ always ▁ the ▁ entire ▁ content ▁ is ▁ shown , ENDCOM // ▁ even ▁ if ▁ this ▁ would ▁ be ▁ possible ENDCOM ControlEditTextSelectionRec sel ; CFStringRef value = NULL ; verify_noerr ( GetData < ControlEditTextSelectionRec > ( 0 , kControlEditTextSelectionTag , & sel ) ) ; verify_noerr ( GetData < CFStringRef > ( 0 , m_valueTag , & value ) ) ; verify_noerr ( SetData < CFStringRef > ( 0 , m_valueTag , & value ) ) ; verify_noerr ( SetData < ControlEditTextSelectionRec > ( 0 , kControlEditTextSelectionTag , & sel ) ) ; CFRelease ( value ) ; } } wxString wxMacUnicodeTextControl :: GetStringValue ( ) const { wxString result ; CFStringRef value = GetData < CFStringRef > ( 0 , m_valueTag ) ; if ( value ) { wxCFStringRef cf ( value ) ; result = cf . AsString ( ) ; } # if ' \n ' == 10 wxMacConvertNewlines13To10 ( & result ) ; # else wxMacConvertNewlines10To13 ( & result ) ; # endif return result ; } void wxMacUnicodeTextControl :: SetStringValue ( const wxString & str ) { wxString st = str ; wxMacConvertNewlines10To13 ( & st ) ; wxCFStringRef cf ( st , m_font . GetEncoding ( ) ) ; verify_noerr ( SetData < CFStringRef > ( 0 , m_valueTag , cf ) ) ; } void wxMacUnicodeTextControl :: Copy ( ) { SendHICommand ( kHICommandCopy ) ; } void wxMacUnicodeTextControl :: Cut ( ) { SendHICommand ( kHICommandCut ) ; } void wxMacUnicodeTextControl :: Paste ( ) { SendHICommand ( kHICommandPaste ) ; } bool wxMacUnicodeTextControl :: CanPaste ( ) const { return true ; } void wxMacUnicodeTextControl :: SetEditable ( bool WXUNUSED ( editable ) ) { # if 0 // ▁ leads ▁ to ▁ problem ▁ because ▁ text ▁ cannot ▁ be ▁ selected ▁ anymore ENDCOM SetData < Boolean > ( kControlEditTextPart , kControlEditTextLockedTag , ( Boolean ) ! editable ) ; # endif } void wxMacUnicodeTextControl :: GetSelection ( long * from , long * to ) const { ControlEditTextSelectionRec sel ; if ( HasFocus ( ) ) verify_noerr ( GetData < ControlEditTextSelectionRec > ( 0 , kControlEditTextSelectionTag , & sel ) ) ; else sel = m_selection ; if ( from ) * from = sel . selStart ; if ( to ) * to = sel . selEnd ; } void wxMacUnicodeTextControl :: SetSelection ( long from , long to ) { ControlEditTextSelectionRec sel ; wxString result ; int textLength = 0 ; CFStringRef value = GetData < CFStringRef > ( 0 , m_valueTag ) ; if ( value ) { wxCFStringRef cf ( value ) ; textLength = cf . AsString ( ) . length ( ) ; } if ( ( from == - 1 ) && ( to == - 1 ) ) { from = 0 ; to = textLength ; } else { from = wxMin ( textLength , wxMax ( from , 0 ) ) ; if ( to == - 1 ) to = textLength ; else to = wxMax ( 0 , wxMin ( textLength , to ) ) ; } sel . selStart = from ; sel . selEnd = to ; if ( HasFocus ( ) ) SetData < ControlEditTextSelectionRec > ( 0 , kControlEditTextSelectionTag , & sel ) ; else m_selection = sel ; } void wxMacUnicodeTextControl :: WriteText ( const wxString & str ) { // ▁ TODO : ▁ this ▁ MPRemoting ▁ will ▁ be ▁ moved ▁ into ▁ a ▁ remoting ▁ peer ▁ proxy ▁ for ▁ any ▁ command ENDCOM if ( ! wxIsMainThread ( ) ) { # if wxOSX_USE_CARBON // ▁ unfortunately ▁ CW ▁ 8 ▁ is ▁ not ▁ able ▁ to ▁ correctly ▁ deduce ▁ the ▁ template ▁ types , ENDCOM // ▁ so ▁ we ▁ have ▁ to ▁ instantiate ▁ explicitly ENDCOM wxMacMPRemoteGUICall < wxTextCtrl , wxString > ( ( wxTextCtrl * ) GetWXPeer ( ) , & wxTextCtrl :: WriteText , str ) ; # endif return ; } wxString st = str ; wxMacConvertNewlines10To13 ( & st ) ; if ( HasFocus ( ) ) { wxCFStringRef cf ( st , m_font . GetEncoding ( ) ) ; CFStringRef value = cf ; SetData < CFStringRef > ( 0 , kControlEditTextInsertCFStringRefTag , & value ) ; } else { wxString val = GetStringValue ( ) ; long start , end ; GetSelection ( & start , & end ) ; val . Remove ( start , end - start ) ; val . insert ( start , str ) ; SetStringValue ( val ) ; SetSelection ( start + str . length ( ) , start + str . length ( ) ) ; } } // ▁ MLTE ▁ control ▁ implementation ▁ ( common ▁ part ) ENDCOM // ▁ if ▁ MTLE ▁ is ▁ read ▁ only , ▁ no ▁ changes ▁ at ▁ all ▁ are ▁ allowed , ▁ not ▁ even ▁ from ENDCOM // ▁ procedural ▁ API , ▁ in ▁ order ▁ to ▁ allow ▁ changes ▁ via ▁ API ▁ all ▁ the ▁ same ▁ we ▁ must ▁ undo ENDCOM // ▁ the ▁ readonly ▁ status ▁ while ▁ we ▁ are ▁ executing , ▁ this ▁ class ▁ helps ▁ to ▁ do ▁ so ENDCOM class wxMacEditHelper { public : wxMacEditHelper ( TXNObject txn ) { TXNControlTag tag [ ] = { kTXNIOPrivilegesTag } ; m_txn = txn ; TXNGetTXNObjectControls ( m_txn , 1 , tag , m_data ) ; if ( m_data [ 0 ] . uValue == kTXNReadOnly ) { TXNControlData data [ ] = { { kTXNReadWrite } } ; TXNSetTXNObjectControls ( m_txn , false , 1 , tag , data ) ; } } ~ wxMacEditHelper ( ) { TXNControlTag tag [ ] = { kTXNIOPrivilegesTag } ; if ( m_data [ 0 ] . uValue == kTXNReadOnly ) TXNSetTXNObjectControls ( m_txn , false , 1 , tag , m_data ) ; } protected : TXNObject m_txn ; TXNControlData m_data [ 1 ] ; } ; wxMacMLTEControl :: wxMacMLTEControl ( wxTextCtrl * peer ) : wxMacControl ( peer ) , wxTextWidgetImpl ( peer ) { SetNeedsFocusRect ( true ) ; } wxString wxMacMLTEControl :: GetStringValue ( ) const { wxString result ; OSStatus err ; Size actualSize = 0 ; { # if wxUSE_UNICODE Handle theText ; err = TXNGetDataEncoded ( m_txn , kTXNStartOffset , kTXNEndOffset , & theText , kTXNUnicodeTextData ) ; // ▁ all ▁ done ENDCOM if ( err != noErr ) { actualSize = 0 ; } else { actualSize = GetHandleSize ( theText ) / sizeof ( UniChar ) ; if ( actualSize > 0 ) { wxChar * ptr = NULL ; SetHandleSize ( theText , ( actualSize + 1 ) * sizeof ( UniChar ) ) ; HLock ( theText ) ; ( ( ( UniChar * ) * theText ) [ actualSize ] ) = 0 ; wxMBConvUTF16 converter ; size_t noChars = converter . MB2WC ( NULL , ( const char * ) * theText , 0 ) ; wxASSERT_MSG ( noChars != wxCONV_FAILED , wxT ( " Unable ▁ to ▁ count ▁ the ▁ number ▁ of ▁ characters ▁ in ▁ this ▁ string ! " ) ) ; ptr = new wxChar [ noChars + 1 ] ; noChars = converter . MB2WC ( ptr , ( const char * ) * theText , noChars + 1 ) ; wxASSERT_MSG ( noChars != wxCONV_FAILED , wxT ( " Conversion ▁ of ▁ string ▁ failed ! " ) ) ; ptr [ noChars ] = 0 ; HUnlock ( theText ) ; ptr [ actualSize ] = 0 ; result = wxString ( ptr ) ; delete [ ] ptr ; } DisposeHandle ( theText ) ; } # else // ▁ ! wxUSE _ UNICODE ENDCOM Handle theText ; err = TXNGetDataEncoded ( m_txn , kTXNStartOffset , kTXNEndOffset , & theText , kTXNTextData ) ; // ▁ all ▁ done ENDCOM if ( err != noErr ) { actualSize = 0 ; } else { actualSize = GetHandleSize ( theText ) ; if ( actualSize > 0 ) { HLock ( theText ) ; result = wxString ( * theText , wxConvLocal , actualSize ) ; HUnlock ( theText ) ; } DisposeHandle ( theText ) ; } # endif // ▁ wxUSE _ UNICODE / ! wxUSE _ UNICODE ENDCOM } # if ' \n ' == 10 wxMacConvertNewlines13To10 ( & result ) ; # else wxMacConvertNewlines10To13 ( & result ) ; # endif return result ; } void wxMacMLTEControl :: SetStringValue ( const wxString & str ) { wxString st = str ; wxMacConvertNewlines10To13 ( & st ) ; { # ifndef __LP64__ wxMacWindowClipper c ( GetWXPeer ( ) ) ; # endif { wxMacEditHelper help ( m_txn ) ; SetTXNData ( st , kTXNStartOffset , kTXNEndOffset ) ; } TXNSetSelection ( m_txn , 0 , 0 ) ; TXNShowSelection ( m_txn , kTXNShowStart ) ; } } TXNFrameOptions wxMacMLTEControl :: FrameOptionsFromWXStyle ( long wxStyle ) { TXNFrameOptions frameOptions = kTXNDontDrawCaretWhenInactiveMask ; frameOptions |= kTXNDoFontSubstitutionMask ; if ( ! ( wxStyle & wxTE_NOHIDESEL ) ) frameOptions |= kTXNDontDrawSelectionWhenInactiveMask ; if ( wxStyle & ( wxHSCROLL | wxTE_DONTWRAP ) ) frameOptions |= kTXNWantHScrollBarMask ; if ( wxStyle & wxTE_MULTILINE ) { if ( ! ( wxStyle & wxTE_DONTWRAP ) ) frameOptions |= kTXNAlwaysWrapAtViewEdgeMask ; if ( ! ( wxStyle & wxTE_NO_VSCROLL ) ) { frameOptions |= kTXNWantVScrollBarMask ; // ▁ The ▁ following ▁ code ▁ causes ▁ drawing ▁ problems ▁ on ▁ 10.4 . ▁ Perhaps ▁ it ▁ can ▁ be ▁ restored ▁ for ENDCOM // ▁ older ▁ versions ▁ of ▁ the ▁ OS , ▁ but ▁ I ' m ▁ not ▁ sure ▁ it ' s ▁ appropriate ▁ to ▁ put ▁ a ▁ grow ▁ icon ▁ here ENDCOM // ▁ anyways , ▁ as ▁ AFAIK ▁ users ▁ can ' t ▁ actually ▁ use ▁ it ▁ to ▁ resize ▁ the ▁ text ▁ ctrl . ENDCOM // ▁ if ▁ ( ▁ frameOptions ▁ & ▁ kTXNWantHScrollBarMask ▁ ) ENDCOM // ▁ frameOptions ▁ | = ▁ kTXNDrawGrowIconMask ▁ ; ENDCOM } } else { frameOptions |= kTXNSingleLineOnlyMask ; } return frameOptions ; } void wxMacMLTEControl :: AdjustCreationAttributes ( const wxColour & background , bool WXUNUSED ( visible ) ) { TXNControlTag iControlTags [ ] = { kTXNDoFontSubstitution , kTXNWordWrapStateTag , } ; TXNControlData iControlData [ ] = { { true } , { kTXNNoAutoWrap } , } ; int toptag = WXSIZEOF ( iControlTags ) ; if ( m_windowStyle & wxTE_MULTILINE ) { iControlData [ 1 ] . uValue = ( m_windowStyle & wxTE_DONTWRAP ) ? kTXNNoAutoWrap : kTXNAutoWrap ; } OSStatus err = TXNSetTXNObjectControls ( m_txn , false , toptag , iControlTags , iControlData ) ; verify_noerr ( err ) ; // ▁ setting ▁ the ▁ default ▁ font : ENDCOM // ▁ under ▁ 10.2 ▁ this ▁ causes ▁ a ▁ visible ▁ caret , ▁ therefore ▁ we ▁ avoid ▁ it ENDCOM Str255 fontName ; SInt16 fontSize ; Style fontStyle ; GetThemeFont ( kThemeSystemFont , GetApplicationScript ( ) , fontName , & fontSize , & fontStyle ) ; TXNTypeAttributes typeAttr [ ] = { { kTXNQDFontNameAttribute , kTXNQDFontNameAttributeSize , { ( void * ) fontName } } , { kTXNQDFontSizeAttribute , kTXNFontSizeAttributeSize , { ( void * ) ( fontSize << 16 ) } } , { kTXNQDFontStyleAttribute , kTXNQDFontStyleAttributeSize , { ( void * ) normal } } , } ; err = TXNSetTypeAttributes ( m_txn , WXSIZEOF ( typeAttr ) , typeAttr , kTXNStartOffset , kTXNEndOffset ) ; verify_noerr ( err ) ; if ( m_windowStyle & wxTE_PASSWORD ) { UniChar c = 0x00A5 ; err = TXNEchoMode ( m_txn , c , 0 , true ) ; verify_noerr ( err ) ; } TXNBackground tback ; tback . bgType = kTXNBackgroundTypeRGB ; background . GetRGBColor ( & tback . bg . color ) ; TXNSetBackground ( m_txn , & tback ) ; TXNCommandEventSupportOptions options ; if ( TXNGetCommandEventSupport ( m_txn , & options ) == noErr ) { options |= kTXNSupportEditCommandProcessing | kTXNSupportEditCommandUpdating | kTXNSupportFontCommandProcessing | kTXNSupportFontCommandUpdating ; // ▁ only ▁ spell ▁ check ▁ when ▁ not ▁ read - only ENDCOM // ▁ use ▁ system ▁ options ▁ for ▁ the ▁ default ENDCOM bool checkSpelling = false ; if ( ! ( m_windowStyle & wxTE_READONLY ) ) { # if wxUSE_SYSTEM_OPTIONS if ( wxSystemOptions :: HasOption ( wxMAC_TEXTCONTROL_USE_SPELL_CHECKER ) && ( wxSystemOptions :: GetOptionInt ( wxMAC_TEXTCONTROL_USE_SPELL_CHECKER ) == 1 ) ) { checkSpelling = true ; } # endif } if ( checkSpelling ) options |= kTXNSupportSpellCheckCommandProcessing | kTXNSupportSpellCheckCommandUpdating ; TXNSetCommandEventSupport ( m_txn , options ) ; } } void wxMacMLTEControl :: SetBackgroundColour ( const wxColour & col ) { TXNBackground tback ; tback . bgType = kTXNBackgroundTypeRGB ; col . GetRGBColor ( & tback . bg . color ) ; TXNSetBackground ( m_txn , & tback ) ; } static inline int wxConvertToTXN ( int x ) { return static_cast < int > ( x / 254.0 * 72 + 0.5 ) ; } void wxMacMLTEControl :: TXNSetAttribute ( const wxTextAttr & style , long from , long to ) { TXNTypeAttributes typeAttr [ 4 ] ; RGBColor color ; size_t typeAttrCount = 0 ; TXNMargins margins ; TXNControlTag controlTags [ 4 ] ; TXNControlData controlData [ 4 ] ; size_t controlAttrCount = 0 ; TXNTab * tabs = NULL ; bool relayout = false ; wxFont font ; if ( style . HasFont ( ) ) { wxASSERT ( typeAttrCount < WXSIZEOF ( typeAttr ) ) ; font = style . GetFont ( ) ; typeAttr [ typeAttrCount ] . tag = kTXNATSUIStyle ; typeAttr [ typeAttrCount ] . size = kTXNATSUIStyleSize ; typeAttr [ typeAttrCount ] . data . dataPtr = font . MacGetATSUStyle ( ) ; typeAttrCount ++ ; } if ( style . HasTextColour ( ) ) { wxASSERT ( typeAttrCount < WXSIZEOF ( typeAttr ) ) ; style . GetTextColour ( ) . GetRGBColor ( & color ) ; typeAttr [ typeAttrCount ] . tag = kTXNQDFontColorAttribute ; typeAttr [ typeAttrCount ] . size = kTXNQDFontColorAttributeSize ; typeAttr [ typeAttrCount ] . data . dataPtr = ( void * ) & color ; typeAttrCount ++ ; } if ( style . HasAlignment ( ) ) { wxASSERT ( controlAttrCount < WXSIZEOF ( controlTags ) ) ; SInt32 align ; switch ( style . GetAlignment ( ) ) { case wxTEXT_ALIGNMENT_LEFT : align = kTXNFlushLeft ; break ; case wxTEXT_ALIGNMENT_CENTRE : align = kTXNCenter ; break ; case wxTEXT_ALIGNMENT_RIGHT : align = kTXNFlushRight ; break ; case wxTEXT_ALIGNMENT_JUSTIFIED : align = kTXNFullJust ; break ; default : case wxTEXT_ALIGNMENT_DEFAULT : align = kTXNFlushDefault ; break ; } controlTags [ controlAttrCount ] = kTXNJustificationTag ; controlData [ controlAttrCount ] . sValue = align ; controlAttrCount ++ ; } if ( style . HasLeftIndent ( ) || style . HasRightIndent ( ) ) { wxASSERT ( controlAttrCount < WXSIZEOF ( controlTags ) ) ; controlTags [ controlAttrCount ] = kTXNMarginsTag ; controlData [ controlAttrCount ] . marginsPtr = & margins ; verify_noerr ( TXNGetTXNObjectControls ( m_txn , 1 , & controlTags [ controlAttrCount ] , & controlData [ controlAttrCount ] ) ) ; if ( style . HasLeftIndent ( ) ) { margins . leftMargin = wxConvertToTXN ( style . GetLeftIndent ( ) ) ; } if ( style . HasRightIndent ( ) ) { margins . rightMargin = wxConvertToTXN ( style . GetRightIndent ( ) ) ; } controlAttrCount ++ ; } if ( style . HasTabs ( ) ) { const wxArrayInt & tabarray = style . GetTabs ( ) ; // ▁ unfortunately ▁ Mac ▁ only ▁ applies ▁ a ▁ tab ▁ distance , ▁ not ▁ individually ▁ different ▁ tabs ENDCOM controlTags [ controlAttrCount ] = kTXNTabSettingsTag ; if ( tabarray . size ( ) > 0 ) controlData [ controlAttrCount ] . tabValue . value = wxConvertToTXN ( tabarray [ 0 ] ) ; else controlData [ controlAttrCount ] . tabValue . value = 72 ; controlData [ controlAttrCount ] . tabValue . tabType = kTXNLeftTab ; controlAttrCount ++ ; } // ▁ unfortunately ▁ the ▁ relayout ▁ is ▁ not ▁ automatic ENDCOM if ( controlAttrCount > 0 ) { verify_noerr ( TXNSetTXNObjectControls ( m_txn , false /* ▁ don ' t ▁ clear ▁ all ▁ */ , controlAttrCount , controlTags , controlData ) ) ; relayout = true ; } if ( typeAttrCount > 0 ) { verify_noerr ( TXNSetTypeAttributes ( m_txn , typeAttrCount , typeAttr , from , to ) ) ; if ( from != to ) relayout = true ; } if ( tabs != NULL ) { delete [ ] tabs ; } if ( relayout ) { TXNRecalcTextLayout ( m_txn ) ; } } void wxMacMLTEControl :: SetFont ( const wxFont & font , const wxColour & foreground , long WXUNUSED ( windowStyle ) , bool WXUNUSED ( ignoreBlack ) ) { wxMacEditHelper help ( m_txn ) ; TXNSetAttribute ( wxTextAttr ( foreground , wxNullColour , font ) , kTXNStartOffset , kTXNEndOffset ) ; } void wxMacMLTEControl :: SetStyle ( long start , long end , const wxTextAttr & style ) { wxMacEditHelper help ( m_txn ) ; TXNSetAttribute ( style , start , end ) ; } void wxMacMLTEControl :: Copy ( ) { TXNCopy ( m_txn ) ; } void wxMacMLTEControl :: Cut ( ) { TXNCut ( m_txn ) ; } void wxMacMLTEControl :: Paste ( ) { TXNPaste ( m_txn ) ; } bool wxMacMLTEControl :: CanPaste ( ) const { return TXNIsScrapPastable ( ) ; } void wxMacMLTEControl :: SetEditable ( bool editable ) { TXNControlTag tag [ ] = { kTXNIOPrivilegesTag } ; TXNControlData data [ ] = { { editable ? kTXNReadWrite : kTXNReadOnly } } ; TXNSetTXNObjectControls ( m_txn , false , WXSIZEOF ( tag ) , tag , data ) ; } long wxMacMLTEControl :: GetLastPosition ( ) const { wxTextPos actualsize = 0 ; Handle theText ; # if wxUSE_UNICODE OSErr err = TXNGetDataEncoded ( m_txn , kTXNStartOffset , kTXNEndOffset , & theText , kTXNUnicodeTextData ) ; // ▁ all ▁ done ENDCOM if ( err == noErr ) { actualsize = GetHandleSize ( theText ) / sizeof ( UniChar ) ; DisposeHandle ( theText ) ; } # else OSErr err = TXNGetDataEncoded ( m_txn , kTXNStartOffset , kTXNEndOffset , & theText , kTXNTextData ) ; // ▁ all ▁ done ENDCOM if ( err == noErr ) { actualsize = GetHandleSize ( theText ) ; DisposeHandle ( theText ) ; } # endif else { actualsize = 0 ; } return actualsize ; } void wxMacMLTEControl :: Replace ( long from , long to , const wxString & str ) { wxString value = str ; wxMacConvertNewlines10To13 ( & value ) ; wxMacEditHelper help ( m_txn ) ; # ifndef __LP64__ wxMacWindowClipper c ( GetWXPeer ( ) ) ; # endif TXNSetSelection ( m_txn , from , to == - 1 ? kTXNEndOffset : to ) ; TXNClear ( m_txn ) ; SetTXNData ( value , kTXNUseCurrentSelection , kTXNUseCurrentSelection ) ; } void wxMacMLTEControl :: Remove ( long from , long to ) { # ifndef __LP64__ wxMacWindowClipper c ( GetWXPeer ( ) ) ; # endif wxMacEditHelper help ( m_txn ) ; TXNSetSelection ( m_txn , from , to ) ; TXNClear ( m_txn ) ; } void wxMacMLTEControl :: GetSelection ( long * from , long * to ) const { TXNOffset f , t ; TXNGetSelection ( m_txn , & f , & t ) ; * from = f ; * to = t ; } void wxMacMLTEControl :: SetSelection ( long from , long to ) { # ifndef __LP64__ wxMacWindowClipper c ( GetWXPeer ( ) ) ; # endif // ▁ change ▁ the ▁ selection ENDCOM if ( ( from == - 1 ) && ( to == - 1 ) ) TXNSelectAll ( m_txn ) ; else TXNSetSelection ( m_txn , from , to == - 1 ? kTXNEndOffset : to ) ; TXNShowSelection ( m_txn , kTXNShowStart ) ; } void wxMacMLTEControl :: WriteText ( const wxString & str ) { // ▁ TODO : ▁ this ▁ MPRemoting ▁ will ▁ be ▁ moved ▁ into ▁ a ▁ remoting ▁ peer ▁ proxy ▁ for ▁ any ▁ command ENDCOM if ( ! wxIsMainThread ( ) ) { # if wxOSX_USE_CARBON // ▁ unfortunately ▁ CW ▁ 8 ▁ is ▁ not ▁ able ▁ to ▁ correctly ▁ deduce ▁ the ▁ template ▁ types , ENDCOM // ▁ so ▁ we ▁ have ▁ to ▁ instantiate ▁ explicitly ENDCOM wxMacMPRemoteGUICall < wxTextCtrl , wxString > ( ( wxTextCtrl * ) GetWXPeer ( ) , & wxTextCtrl :: WriteText , str ) ; # endif return ; } wxString st = str ; wxMacConvertNewlines10To13 ( & st ) ; long start , end , dummy ; GetSelection ( & start , & dummy ) ; # ifndef __LP64__ wxMacWindowClipper c ( GetWXPeer ( ) ) ; # endif { wxMacEditHelper helper ( m_txn ) ; SetTXNData ( st , kTXNUseCurrentSelection , kTXNUseCurrentSelection ) ; } GetSelection ( & dummy , & end ) ; // ▁ TODO : ▁ SetStyle ( ▁ start ▁ , ▁ end ▁ , ▁ GetDefaultStyle ( ) ▁ ) ▁ ; ENDCOM } void wxMacMLTEControl :: Clear ( ) { # ifndef __LP64__ wxMacWindowClipper c ( GetWXPeer ( ) ) ; # endif wxMacEditHelper st ( m_txn ) ; TXNSetSelection ( m_txn , kTXNStartOffset , kTXNEndOffset ) ; TXNClear ( m_txn ) ; } bool wxMacMLTEControl :: CanUndo ( ) const { return TXNCanUndo ( m_txn , NULL ) ; } void wxMacMLTEControl :: Undo ( ) { TXNUndo ( m_txn ) ; } bool wxMacMLTEControl :: CanRedo ( ) const { return TXNCanRedo ( m_txn , NULL ) ; } void wxMacMLTEControl :: Redo ( ) { TXNRedo ( m_txn ) ; } int wxMacMLTEControl :: GetNumberOfLines ( ) const { ItemCount lines = 0 ; TXNGetLineCount ( m_txn , & lines ) ; return lines ; } long wxMacMLTEControl :: XYToPosition ( long x , long y ) const { Point curpt ; wxTextPos lastpos ; // ▁ TODO : ▁ find ▁ a ▁ better ▁ implementation ▁ : ▁ while ▁ we ▁ can ▁ get ▁ the ENDCOM // ▁ line ▁ metrics ▁ of ▁ a ▁ certain ▁ line , ▁ we ▁ don ' t ▁ get ▁ its ▁ starting ENDCOM // ▁ position , ▁ so ▁ it ▁ would ▁ probably ▁ be ▁ rather ▁ a ▁ binary ▁ search ENDCOM // ▁ for ▁ the ▁ start ▁ position ENDCOM long xpos = 0 , ypos = 0 ; int lastHeight = 0 ; ItemCount n ; lastpos = GetLastPosition ( ) ; for ( n = 0 ; n <= ( ItemCount ) lastpos ; ++ n ) { if ( y == ypos && x == xpos ) return n ; TXNOffsetToPoint ( m_txn , n , & curpt ) ; if ( curpt . v > lastHeight ) { xpos = 0 ; if ( n > 0 ) ++ ypos ; lastHeight = curpt . v ; } else ++ xpos ; } return 0 ; } bool wxMacMLTEControl :: PositionToXY ( long pos , long * x , long * y ) const { Point curpt ; wxTextPos lastpos ; if ( y ) * y = 0 ; if ( x ) * x = 0 ; lastpos = GetLastPosition ( ) ; if ( pos <= lastpos ) { // ▁ TODO : ▁ find ▁ a ▁ better ▁ implementation ▁ - ▁ while ▁ we ▁ can ▁ get ▁ the ENDCOM // ▁ line ▁ metrics ▁ of ▁ a ▁ certain ▁ line , ▁ we ▁ don ' t ▁ get ▁ its ▁ starting ENDCOM // ▁ position , ▁ so ▁ it ▁ would ▁ probably ▁ be ▁ rather ▁ a ▁ binary ▁ search ENDCOM // ▁ for ▁ the ▁ start ▁ position ENDCOM long xpos = 0 , ypos = 0 ; int lastHeight = 0 ; ItemCount n ; for ( n = 0 ; n <= ( ItemCount ) pos ; ++ n ) { TXNOffsetToPoint ( m_txn , n , & curpt ) ; if ( curpt . v > lastHeight ) { xpos = 0 ; if ( n > 0 ) ++ ypos ; lastHeight = curpt . v ; } else ++ xpos ; } if ( y ) * y = ypos ; if ( x ) * x = xpos ; } return false ; } void wxMacMLTEControl :: ShowPosition ( long pos ) { Point current , desired ; TXNOffset selstart , selend ; TXNGetSelection ( m_txn , & selstart , & selend ) ; TXNOffsetToPoint ( m_txn , selstart , & current ) ; TXNOffsetToPoint ( m_txn , pos , & desired ) ; // ▁ TODO : ▁ use ▁ HIPoints ▁ for ▁ 10.3 ▁ and ▁ above ENDCOM OSErr theErr = noErr ; long dv = desired . v - current . v ; long dh = desired . h - current . h ; TXNShowSelection ( m_txn , kTXNShowStart ) ; // ▁ NB : ▁ should ▁ this ▁ be ▁ kTXNShowStart ▁ or ▁ kTXNShowEnd ▁ ? ? ENDCOM theErr = TXNScroll ( m_txn , kTXNScrollUnitsInPixels , kTXNScrollUnitsInPixels , & dv , & dh ) ; // ▁ there ▁ will ▁ be ▁ an ▁ error ▁ returned ▁ for ▁ classic ▁ MLTE ▁ implementation ▁ when ▁ the ▁ control ▁ is ENDCOM // ▁ invisible , ▁ but ▁ HITextView ▁ works ▁ correctly , ▁ so ▁ we ▁ don ' t ▁ assert ▁ that ▁ one ENDCOM // ▁ wxASSERT _ MSG ( ▁ theErr ▁ = = ▁ noErr , ▁ wxT ( " TXNScroll ▁ returned ▁ an ▁ error ! " ) ▁ ) ; ENDCOM } void wxMacMLTEControl :: SetTXNData ( const wxString & st , TXNOffset start , TXNOffset end ) { # if wxUSE_UNICODE wxMBConvUTF16 converter ; ByteCount byteBufferLen = converter . WC2MB ( NULL , st . wc_str ( ) , 0 ) ; wxASSERT_MSG ( byteBufferLen != wxCONV_FAILED , wxT ( " Conversion ▁ to ▁ UTF - 16 ▁ unexpectedly ▁ failed " ) ) ; UniChar * unibuf = ( UniChar * ) malloc ( byteBufferLen + 2 ) ; // ▁ 2 ▁ for ▁ NUL ▁ in ▁ UTF - 16 ENDCOM converter . WC2MB ( ( char * ) unibuf , st . wc_str ( ) , byteBufferLen + 2 ) ; TXNSetData ( m_txn , kTXNUnicodeTextData , ( void * ) unibuf , byteBufferLen , start , end ) ; free ( unibuf ) ; # else // ▁ ! wxUSE _ UNICODE ENDCOM wxCharBuffer text = st . mb_str ( wxConvLocal ) ; TXNSetData ( m_txn , kTXNTextData , ( void * ) text . data ( ) , strlen ( text ) , start , end ) ; # endif // ▁ wxUSE _ UNICODE / ! wxUSE _ UNICODE ENDCOM } wxString wxMacMLTEControl :: GetLineText ( long lineNo ) const { wxString line ; if ( lineNo < GetNumberOfLines ( ) ) { Point firstPoint ; Fixed lineWidth , lineHeight , currentHeight ; long ypos ; // ▁ get ▁ the ▁ first ▁ possible ▁ position ▁ in ▁ the ▁ control ENDCOM TXNOffsetToPoint ( m_txn , 0 , & firstPoint ) ; // ▁ Iterate ▁ through ▁ the ▁ lines ▁ until ▁ we ▁ reach ▁ the ▁ one ▁ we ▁ want , ENDCOM // ▁ adding ▁ to ▁ our ▁ current ▁ y ▁ pixel ▁ point ▁ position ENDCOM ypos = 0 ; currentHeight = 0 ; while ( ypos < lineNo ) { TXNGetLineMetrics ( m_txn , ypos ++ , & lineWidth , & lineHeight ) ; currentHeight += lineHeight ; } Point thePoint = { firstPoint . v + ( currentHeight >> 16 ) , firstPoint . h + ( 0 ) } ; TXNOffset theOffset ; TXNPointToOffset ( m_txn , thePoint , & theOffset ) ; wxString content = GetStringValue ( ) ; Point currentPoint = thePoint ; while ( thePoint . v == currentPoint . v && theOffset < content . length ( ) ) { line += content [ theOffset ] ; TXNOffsetToPoint ( m_txn , ++ theOffset , & currentPoint ) ; } } return line ; } int wxMacMLTEControl :: GetLineLength ( long lineNo ) const { int theLength = 0 ; if ( lineNo < GetNumberOfLines ( ) ) { Point firstPoint ; Fixed lineWidth , lineHeight , currentHeight ; long ypos ; // ▁ get ▁ the ▁ first ▁ possible ▁ position ▁ in ▁ the ▁ control ENDCOM TXNOffsetToPoint ( m_txn , 0 , & firstPoint ) ; // ▁ Iterate ▁ through ▁ the ▁ lines ▁ until ▁ we ▁ reach ▁ the ▁ one ▁ we ▁ want , ENDCOM // ▁ adding ▁ to ▁ our ▁ current ▁ y ▁ pixel ▁ point ▁ position ENDCOM ypos = 0 ; currentHeight = 0 ; while ( ypos < lineNo ) { TXNGetLineMetrics ( m_txn , ypos ++ , & lineWidth , & lineHeight ) ; currentHeight += lineHeight ; } Point thePoint = { firstPoint . v + ( currentHeight >> 16 ) , firstPoint . h + ( 0 ) } ; TXNOffset theOffset ; TXNPointToOffset ( m_txn , thePoint , & theOffset ) ; wxString content = GetStringValue ( ) ; Point currentPoint = thePoint ; while ( thePoint . v == currentPoint . v && theOffset < content . length ( ) ) { ++ theLength ; TXNOffsetToPoint ( m_txn , ++ theOffset , & currentPoint ) ; } } return theLength ; } // ▁ MLTE ▁ control ▁ implementation ▁ ( OSX ▁ part ) ENDCOM // ▁ tiger ▁ multi - line ▁ textcontrols ▁ with ▁ no ▁ CR ▁ in ▁ the ▁ entire ▁ content ENDCOM // ▁ don ' t ▁ scroll ▁ automatically , ▁ so ▁ we ▁ need ▁ a ▁ hack . ENDCOM // ▁ This ▁ attempt ▁ only ▁ works ▁ ' before ' ▁ the ▁ key ▁ ( ie ▁ before ▁ CallNextEventHandler ) ENDCOM // ▁ is ▁ processed , ▁ thus ▁ the ▁ scrolling ▁ always ▁ occurs ▁ one ▁ character ▁ too ▁ late , ▁ but ENDCOM // ▁ better ▁ than ▁ nothing ▁ . . . ENDCOM static const EventTypeSpec eventList [ ] = { { kEventClassTextInput , kEventTextInputUnicodeForKeyEvent } , } ; static pascal OSStatus wxMacUnicodeTextEventHandler ( EventHandlerCallRef handler , EventRef event , void * data ) { OSStatus result = eventNotHandledErr ; wxMacMLTEHIViewControl * focus = ( wxMacMLTEHIViewControl * ) data ; switch ( GetEventKind ( event ) ) { case kEventTextInputUnicodeForKeyEvent : { TXNOffset from , to ; TXNGetSelection ( focus -> GetTXNObject ( ) , & from , & to ) ; if ( from == to ) TXNShowSelection ( focus -> GetTXNObject ( ) , kTXNShowStart ) ; result = CallNextEventHandler ( handler , event ) ; break ; } default : break ; } return result ; } static pascal OSStatus wxMacTextControlEventHandler ( EventHandlerCallRef handler , EventRef event , void * data ) { OSStatus result = eventNotHandledErr ; switch ( GetEventClass ( event ) ) { case kEventClassTextInput : result = wxMacUnicodeTextEventHandler ( handler , event , data ) ; break ; default : break ; } return result ; } DEFINE_ONE_SHOT_HANDLER_GETTER ( wxMacTextControlEventHandler ) wxMacMLTEHIViewControl :: wxMacMLTEHIViewControl ( wxTextCtrl * wxPeer , const wxString & str , const wxPoint & pos , const wxSize & size , long style ) : wxMacMLTEControl ( wxPeer ) { m_font = wxPeer -> GetFont ( ) ; m_windowStyle = style ; Rect bounds = wxMacGetBoundsForControl ( wxPeer , pos , size ) ; wxString st = str ; wxMacConvertNewlines10To13 ( & st ) ; HIRect hr = { { bounds . left , bounds . top } , { bounds . right - bounds . left , bounds . bottom - bounds . top } } ; m_scrollView = NULL ; TXNFrameOptions frameOptions = FrameOptionsFromWXStyle ( style ) ; if ( ( frameOptions & ( kTXNWantVScrollBarMask | kTXNWantHScrollBarMask ) ) || ( frameOptions & kTXNSingleLineOnlyMask ) ) { if ( frameOptions & ( kTXNWantVScrollBarMask | kTXNWantHScrollBarMask ) ) { HIScrollViewCreate ( ( frameOptions & kTXNWantHScrollBarMask ? kHIScrollViewOptionsHorizScroll : 0 ) | ( frameOptions & kTXNWantVScrollBarMask ? kHIScrollViewOptionsVertScroll : 0 ) , & m_scrollView ) ; } else { HIScrollViewCreate ( kHIScrollViewOptionsVertScroll , & m_scrollView ) ; HIScrollViewSetScrollBarAutoHide ( m_scrollView , true ) ; } HIViewSetFrame ( m_scrollView , & hr ) ; HIViewSetVisible ( m_scrollView , true ) ; } m_textView = NULL ; HITextViewCreate ( NULL , 0 , frameOptions , & m_textView ) ; m_txn = HITextViewGetTXNObject ( m_textView ) ; HIViewSetVisible ( m_textView , true ) ; if ( m_scrollView ) { HIViewAddSubview ( m_scrollView , m_textView ) ; m_controlRef = m_scrollView ; InstallEventHandler ( ( WXWidget ) m_textView ) ; } else { HIViewSetFrame ( m_textView , & hr ) ; m_controlRef = m_textView ; } AdjustCreationAttributes ( * wxWHITE , true ) ; # ifndef __LP64__ wxMacWindowClipper c ( GetWXPeer ( ) ) ; # endif SetTXNData ( st , kTXNStartOffset , kTXNEndOffset ) ; TXNSetSelection ( m_txn , 0 , 0 ) ; TXNShowSelection ( m_txn , kTXNShowStart ) ; :: InstallControlEventHandler ( m_textView , GetwxMacTextControlEventHandlerUPP ( ) , GetEventTypeCount ( eventList ) , eventList , this , NULL ) ; } wxMacMLTEHIViewControl :: ~ wxMacMLTEHIViewControl ( ) { } bool wxMacMLTEHIViewControl :: SetFocus ( ) { return SetKeyboardFocus ( GetControlOwner ( m_textView ) , m_textView , kControlFocusNextPart ) == noErr ; } bool wxMacMLTEHIViewControl :: HasFocus ( ) const { ControlRef control ; if ( GetUserFocusWindow ( ) == NULL ) return false ; GetKeyboardFocus ( GetUserFocusWindow ( ) , & control ) ; return control == m_textView ; } void wxMacMLTEHIViewControl :: SetBackgroundColour ( const wxColour & col ) { HITextViewSetBackgroundColor ( m_textView , col . GetPixel ( ) ) ; } # endif // ▁ wxUSE _ TEXTCTRL ENDCOM </DOCUMENT>
<DOCUMENT_ID="dodamn/pkg-dosbox/tree/master/src/hardware/mixer.cpp"> /* STRNEWLINE ▁ * ▁ Copyright ▁ ( C ) ▁ 2002-2009 ▁ The ▁ DOSBox ▁ Team STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ This ▁ program ▁ is ▁ free ▁ software ; ▁ you ▁ can ▁ redistribute ▁ it ▁ and / or ▁ modify STRNEWLINE ▁ * ▁ it ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ as ▁ published ▁ by STRNEWLINE ▁ * ▁ the ▁ Free ▁ Software ▁ Foundation ; ▁ either ▁ version ▁ 2 ▁ of ▁ the ▁ License , ▁ or STRNEWLINE ▁ * ▁ ( at ▁ your ▁ option ) ▁ any ▁ later ▁ version . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ This ▁ program ▁ is ▁ distributed ▁ in ▁ the ▁ hope ▁ that ▁ it ▁ will ▁ be ▁ useful , STRNEWLINE ▁ * ▁ but ▁ WITHOUT ▁ ANY ▁ WARRANTY ; ▁ without ▁ even ▁ the ▁ implied ▁ warranty ▁ of STRNEWLINE ▁ * ▁ MERCHANTABILITY ▁ or ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE . ▁ See ▁ the STRNEWLINE ▁ * ▁ GNU ▁ Library ▁ General ▁ Public ▁ License ▁ for ▁ more ▁ details . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ You ▁ should ▁ have ▁ received ▁ a ▁ copy ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License STRNEWLINE ▁ * ▁ along ▁ with ▁ this ▁ program ; ▁ if ▁ not , ▁ write ▁ to ▁ the ▁ Free ▁ Software STRNEWLINE ▁ * ▁ Foundation , ▁ Inc . , ▁ 59 ▁ Temple ▁ Place ▁ - ▁ Suite ▁ 330 , ▁ Boston , ▁ MA ▁ 02111-1307 , ▁ USA . STRNEWLINE ▁ */ /* ▁ $ Id : ▁ mixer . cpp , v ▁ 1.53 ▁ 2009/04/28 ▁ 21:48:24 ▁ harekiet ▁ Exp ▁ $ ▁ */ /* ▁ STRNEWLINE TABSYMBOL Remove ▁ the ▁ sdl ▁ code ▁ from ▁ here ▁ and ▁ have ▁ it ▁ handeld ▁ in ▁ the ▁ sdlmain . STRNEWLINE TABSYMBOL That ▁ should ▁ call ▁ the ▁ mixer ▁ start ▁ from ▁ there ▁ or ▁ something . STRNEWLINE */ # include < string . h > # include < sys / types . h > # include < math . h > # if defined ( WIN32 ) // Midi ▁ listing ENDCOM # ifndef WIN32_LEAN_AND_MEAN # define WIN32_LEAN_AND_MEAN # endif # include < windows . h > # include < mmsystem . h > # endif # include " SDL . h " # include " mem . h " # include " pic . h " # include " dosbox . h " # include " mixer . h " # include " timer . h " # include " setup . h " # include " cross . h " # include " support . h " # include " mapper . h " # include " hardware . h " # include " programs . h " # define MIXER_SSIZE 4 # define MIXER_SHIFT 14 # define MIXER_REMAIN ( ( 1 << MIXER_SHIFT ) - 1 ) # define MIXER_VOLSHIFT 13 static INLINE Bit16s MIXER_CLIP ( Bits SAMP ) { if ( SAMP < MAX_AUDIO ) { if ( SAMP > MIN_AUDIO ) return SAMP ; else return MIN_AUDIO ; } else return MAX_AUDIO ; } static struct { Bit32s work [ MIXER_BUFSIZE ] [ 2 ] ; Bitu pos , done ; Bitu needed , min_needed , max_needed ; Bit32u tick_add , tick_remain ; float mastervol [ 2 ] ; MixerChannel * channels ; bool nosound ; Bit32u freq ; Bit32u blocksize ; } mixer ; Bit8u MixTemp [ MIXER_BUFSIZE ] ; MixerChannel * MIXER_AddChannel ( MIXER_Handler handler , Bitu freq , const char * name ) { MixerChannel * chan = new MixerChannel ( ) ; chan -> scale = 1.0 ; chan -> handler = handler ; chan -> name = name ; chan -> SetFreq ( freq ) ; chan -> next = mixer . channels ; chan -> SetVolume ( 1 , 1 ) ; chan -> enabled = false ; mixer . channels = chan ; return chan ; } MixerChannel * MIXER_FindChannel ( const char * name ) { MixerChannel * chan = mixer . channels ; while ( chan ) { if ( ! strcasecmp ( chan -> name , name ) ) break ; chan = chan -> next ; } return chan ; } void MIXER_DelChannel ( MixerChannel * delchan ) { MixerChannel * chan = mixer . channels ; MixerChannel * * where = & mixer . channels ; while ( chan ) { if ( chan == delchan ) { * where = chan -> next ; delete delchan ; return ; } where = & chan -> next ; chan = chan -> next ; } } void MixerChannel :: UpdateVolume ( void ) { volmul [ 0 ] = ( Bits ) ( ( 1 << MIXER_VOLSHIFT ) * scale * volmain [ 0 ] * mixer . mastervol [ 0 ] ) ; volmul [ 1 ] = ( Bits ) ( ( 1 << MIXER_VOLSHIFT ) * scale * volmain [ 1 ] * mixer . mastervol [ 1 ] ) ; } void MixerChannel :: SetVolume ( float _left , float _right ) { volmain [ 0 ] = _left ; volmain [ 1 ] = _right ; UpdateVolume ( ) ; } void MixerChannel :: SetScale ( float f ) { scale = f ; UpdateVolume ( ) ; } void MixerChannel :: Enable ( bool _yesno ) { if ( _yesno == enabled ) return ; enabled = _yesno ; if ( enabled ) { freq_index = MIXER_REMAIN ; SDL_LockAudio ( ) ; if ( done < mixer . done ) done = mixer . done ; SDL_UnlockAudio ( ) ; } } void MixerChannel :: SetFreq ( Bitu _freq ) { freq_add = ( _freq << MIXER_SHIFT ) / mixer . freq ; } void MixerChannel :: Mix ( Bitu _needed ) { needed = _needed ; while ( enabled && needed > done ) { Bitu todo = needed - done ; todo *= freq_add ; if ( todo & MIXER_REMAIN ) { todo = ( todo >> MIXER_SHIFT ) + 1 ; } else { todo = ( todo >> MIXER_SHIFT ) ; } handler ( todo ) ; } } void MixerChannel :: AddSilence ( void ) { if ( done < needed ) { done = needed ; last [ 0 ] = last [ 1 ] = 0 ; freq_index = MIXER_REMAIN ; } } template < class Type , bool stereo , bool signeddata , bool nativeorder > inline void MixerChannel :: AddSamples ( Bitu len , const Type * data ) { Bits diff [ 2 ] ; Bitu mixpos = mixer . pos + done ; freq_index &= MIXER_REMAIN ; Bitu pos = 0 ; Bitu new_pos ; goto thestart ; for ( ; ; ) { new_pos = freq_index >> MIXER_SHIFT ; if ( pos < new_pos ) { last [ 0 ] += diff [ 0 ] ; if ( stereo ) last [ 1 ] += diff [ 1 ] ; pos = new_pos ; thestart : if ( pos >= len ) return ; if ( sizeof ( Type ) == 1 ) { if ( ! signeddata ) { if ( stereo ) { diff [ 0 ] = ( ( ( Bit8s ) ( data [ pos * 2 + 0 ] ^ 0x80 ) ) << 8 ) - last [ 0 ] ; diff [ 1 ] = ( ( ( Bit8s ) ( data [ pos * 2 + 1 ] ^ 0x80 ) ) << 8 ) - last [ 1 ] ; } else { diff [ 0 ] = ( ( ( Bit8s ) ( data [ pos ] ^ 0x80 ) ) << 8 ) - last [ 0 ] ; } } else { if ( stereo ) { diff [ 0 ] = ( data [ pos * 2 + 0 ] << 8 ) - last [ 0 ] ; diff [ 1 ] = ( data [ pos * 2 + 1 ] << 8 ) - last [ 1 ] ; } else { diff [ 0 ] = ( data [ pos ] << 8 ) - last [ 0 ] ; } } // 16bit ▁ and ▁ 32bit ▁ both ▁ contain ▁ 16bit ▁ data ▁ internally ENDCOM } else { if ( signeddata ) { if ( stereo ) { if ( nativeorder ) { diff [ 0 ] = data [ pos * 2 + 0 ] - last [ 0 ] ; diff [ 1 ] = data [ pos * 2 + 1 ] - last [ 1 ] ; } else { if ( sizeof ( Type ) == 2 ) { diff [ 0 ] = ( Bit16s ) host_readw ( ( HostPt ) & data [ pos * 2 + 0 ] ) - last [ 0 ] ; diff [ 1 ] = ( Bit16s ) host_readw ( ( HostPt ) & data [ pos * 2 + 1 ] ) - last [ 1 ] ; } else { diff [ 0 ] = ( Bit32s ) host_readd ( ( HostPt ) & data [ pos * 2 + 0 ] ) - last [ 0 ] ; diff [ 1 ] = ( Bit32s ) host_readd ( ( HostPt ) & data [ pos * 2 + 1 ] ) - last [ 1 ] ; } } } else { if ( nativeorder ) { diff [ 0 ] = data [ pos ] - last [ 0 ] ; } else { if ( sizeof ( Type ) == 2 ) { diff [ 0 ] = ( Bit16s ) host_readw ( ( HostPt ) & data [ pos ] ) - last [ 0 ] ; } else { diff [ 0 ] = ( Bit32s ) host_readd ( ( HostPt ) & data [ pos ] ) - last [ 0 ] ; } } } } else { if ( stereo ) { if ( nativeorder ) { diff [ 0 ] = ( Bits ) data [ pos * 2 + 0 ] - 32768 - last [ 0 ] ; diff [ 1 ] = ( Bits ) data [ pos * 2 + 1 ] - 32768 - last [ 1 ] ; } else { if ( sizeof ( Type ) == 2 ) { diff [ 0 ] = ( Bits ) host_readw ( ( HostPt ) & data [ pos * 2 + 0 ] ) - 32768 - last [ 0 ] ; diff [ 1 ] = ( Bits ) host_readw ( ( HostPt ) & data [ pos * 2 + 1 ] ) - 32768 - last [ 1 ] ; } else { diff [ 0 ] = ( Bits ) host_readd ( ( HostPt ) & data [ pos * 2 + 0 ] ) - 32768 - last [ 0 ] ; diff [ 1 ] = ( Bits ) host_readd ( ( HostPt ) & data [ pos * 2 + 1 ] ) - 32768 - last [ 1 ] ; } } } else { if ( nativeorder ) { diff [ 0 ] = ( Bits ) data [ pos ] - 32768 - last [ 0 ] ; } else { if ( sizeof ( Type ) == 2 ) { diff [ 0 ] = ( Bits ) host_readw ( ( HostPt ) & data [ pos ] ) - 32768 - last [ 0 ] ; } else { diff [ 0 ] = ( Bits ) host_readd ( ( HostPt ) & data [ pos ] ) - 32768 - last [ 0 ] ; } } } } } } Bits diff_mul = freq_index & MIXER_REMAIN ; freq_index += freq_add ; mixpos &= MIXER_BUFMASK ; Bits sample = last [ 0 ] + ( ( diff [ 0 ] * diff_mul ) >> MIXER_SHIFT ) ; mixer . work [ mixpos ] [ 0 ] += sample * volmul [ 0 ] ; if ( stereo ) sample = last [ 1 ] + ( ( diff [ 1 ] * diff_mul ) >> MIXER_SHIFT ) ; mixer . work [ mixpos ] [ 1 ] += sample * volmul [ 1 ] ; mixpos ++ ; done ++ ; } } void MixerChannel :: AddStretched ( Bitu len , Bit16s * data ) { if ( done >= needed ) { LOG_MSG ( " Can ' t ▁ add , ▁ buffer ▁ full " ) ; return ; } Bitu outlen = needed - done ; Bits diff ; freq_index = 0 ; Bitu temp_add = ( len << MIXER_SHIFT ) / outlen ; Bitu mixpos = mixer . pos + done ; done = needed ; Bitu pos = 0 ; diff = data [ 0 ] - last [ 0 ] ; while ( outlen -- ) { Bitu new_pos = freq_index >> MIXER_SHIFT ; if ( pos < new_pos ) { pos = new_pos ; last [ 0 ] += diff ; diff = data [ pos ] - last [ 0 ] ; } Bits diff_mul = freq_index & MIXER_REMAIN ; freq_index += temp_add ; mixpos &= MIXER_BUFMASK ; Bits sample = last [ 0 ] + ( ( diff * diff_mul ) >> MIXER_SHIFT ) ; mixer . work [ mixpos ] [ 0 ] += sample * volmul [ 0 ] ; mixer . work [ mixpos ] [ 1 ] += sample * volmul [ 1 ] ; mixpos ++ ; } } void MixerChannel :: AddSamples_m8 ( Bitu len , const Bit8u * data ) { AddSamples < Bit8u , false , false , true > ( len , data ) ; } void MixerChannel :: AddSamples_s8 ( Bitu len , const Bit8u * data ) { AddSamples < Bit8u , true , false , true > ( len , data ) ; } void MixerChannel :: AddSamples_m8s ( Bitu len , const Bit8s * data ) { AddSamples < Bit8s , false , true , true > ( len , data ) ; } void MixerChannel :: AddSamples_s8s ( Bitu len , const Bit8s * data ) { AddSamples < Bit8s , true , true , true > ( len , data ) ; } void MixerChannel :: AddSamples_m16 ( Bitu len , const Bit16s * data ) { AddSamples < Bit16s , false , true , true > ( len , data ) ; } void MixerChannel :: AddSamples_s16 ( Bitu len , const Bit16s * data ) { AddSamples < Bit16s , true , true , true > ( len , data ) ; } void MixerChannel :: AddSamples_m16u ( Bitu len , const Bit16u * data ) { AddSamples < Bit16u , false , false , true > ( len , data ) ; } void MixerChannel :: AddSamples_s16u ( Bitu len , const Bit16u * data ) { AddSamples < Bit16u , true , false , true > ( len , data ) ; } void MixerChannel :: AddSamples_m32 ( Bitu len , const Bit32s * data ) { AddSamples < Bit32s , false , true , true > ( len , data ) ; } void MixerChannel :: AddSamples_s32 ( Bitu len , const Bit32s * data ) { AddSamples < Bit32s , true , true , true > ( len , data ) ; } void MixerChannel :: AddSamples_m16_nonnative ( Bitu len , const Bit16s * data ) { AddSamples < Bit16s , false , true , false > ( len , data ) ; } void MixerChannel :: AddSamples_s16_nonnative ( Bitu len , const Bit16s * data ) { AddSamples < Bit16s , true , true , false > ( len , data ) ; } void MixerChannel :: AddSamples_m16u_nonnative ( Bitu len , const Bit16u * data ) { AddSamples < Bit16u , false , false , false > ( len , data ) ; } void MixerChannel :: AddSamples_s16u_nonnative ( Bitu len , const Bit16u * data ) { AddSamples < Bit16u , true , false , false > ( len , data ) ; } void MixerChannel :: AddSamples_m32_nonnative ( Bitu len , const Bit32s * data ) { AddSamples < Bit32s , false , true , false > ( len , data ) ; } void MixerChannel :: AddSamples_s32_nonnative ( Bitu len , const Bit32s * data ) { AddSamples < Bit32s , true , true , false > ( len , data ) ; } void MixerChannel :: FillUp ( void ) { SDL_LockAudio ( ) ; if ( ! enabled || done < mixer . done ) { SDL_UnlockAudio ( ) ; return ; } float index = PIC_TickIndex ( ) ; Mix ( ( Bitu ) ( index * mixer . needed ) ) ; SDL_UnlockAudio ( ) ; } extern bool ticksLocked ; static inline bool Mixer_irq_important ( void ) { /* ▁ In ▁ some ▁ states ▁ correct ▁ timing ▁ of ▁ the ▁ irqs ▁ is ▁ more ▁ important ▁ then ▁ STRNEWLINE TABSYMBOL ▁ * ▁ non ▁ stuttering ▁ audo ▁ */ return ( ticksLocked || ( CaptureState & ( CAPTURE_WAVE | CAPTURE_VIDEO ) ) ) ; } /* ▁ Mix ▁ a ▁ certain ▁ amount ▁ of ▁ new ▁ samples ▁ */ static void MIXER_MixData ( Bitu needed ) { MixerChannel * chan = mixer . channels ; while ( chan ) { chan -> Mix ( needed ) ; chan = chan -> next ; } if ( CaptureState & ( CAPTURE_WAVE | CAPTURE_VIDEO ) ) { Bit16s convert [ 1024 ] [ 2 ] ; Bitu added = needed - mixer . done ; if ( added > 1024 ) added = 1024 ; Bitu readpos = ( mixer . pos + mixer . done ) & MIXER_BUFMASK ; for ( Bitu i = 0 ; i < added ; i ++ ) { Bits sample = mixer . work [ readpos ] [ 0 ] >> MIXER_VOLSHIFT ; convert [ i ] [ 0 ] = MIXER_CLIP ( sample ) ; sample = mixer . work [ readpos ] [ 1 ] >> MIXER_VOLSHIFT ; convert [ i ] [ 1 ] = MIXER_CLIP ( sample ) ; readpos = ( readpos + 1 ) & MIXER_BUFMASK ; } CAPTURE_AddWave ( mixer . freq , added , ( Bit16s * ) convert ) ; } // Reset ▁ the ▁ the ▁ tick _ add ▁ for ▁ constant ▁ speed ENDCOM if ( Mixer_irq_important ( ) ) mixer . tick_add = ( ( mixer . freq ) << MIXER_SHIFT ) / 1000 ; mixer . done = needed ; } static void MIXER_Mix ( void ) { SDL_LockAudio ( ) ; MIXER_MixData ( mixer . needed ) ; mixer . tick_remain += mixer . tick_add ; mixer . needed += ( mixer . tick_remain >> MIXER_SHIFT ) ; mixer . tick_remain &= MIXER_REMAIN ; SDL_UnlockAudio ( ) ; } static void MIXER_Mix_NoSound ( void ) { MIXER_MixData ( mixer . needed ) ; /* ▁ Clear ▁ piece ▁ we ' ve ▁ just ▁ generated ▁ */ for ( Bitu i = 0 ; i < mixer . needed ; i ++ ) { mixer . work [ mixer . pos ] [ 0 ] = 0 ; mixer . work [ mixer . pos ] [ 1 ] = 0 ; mixer . pos = ( mixer . pos + 1 ) & MIXER_BUFMASK ; } /* ▁ Reduce ▁ count ▁ in ▁ channels ▁ */ for ( MixerChannel * chan = mixer . channels ; chan ; chan = chan -> next ) { if ( chan -> done > mixer . needed ) chan -> done -= mixer . needed ; else chan -> done = 0 ; } /* ▁ Set ▁ values ▁ for ▁ next ▁ tick ▁ */ mixer . tick_remain += mixer . tick_add ; mixer . needed = mixer . tick_remain >> MIXER_SHIFT ; mixer . tick_remain &= MIXER_REMAIN ; mixer . done = 0 ; } static void MIXER_CallBack ( void * userdata , Uint8 * stream , int len ) { Bitu need = ( Bitu ) len / MIXER_SSIZE ; Bit16s * output = ( Bit16s * ) stream ; Bitu reduce ; Bitu pos , index , index_add ; Bits sample ; /* ▁ Enough ▁ room ▁ in ▁ the ▁ buffer ▁ ? ▁ */ if ( mixer . done < need ) { // TABSYMBOL TABSYMBOL LOG _ MSG ( " Full ▁ underrun ▁ need ▁ % d , ▁ have ▁ % d , ▁ min ▁ % d " , ▁ need , ▁ mixer . done , ▁ mixer . min _ needed ) ; ENDCOM if ( ( need - mixer . done ) > ( need >> 7 ) ) // Max ▁ 1 ▁ procent ▁ stretch . ENDCOM return ; reduce = mixer . done ; index_add = ( reduce << MIXER_SHIFT ) / need ; mixer . tick_add = ( ( mixer . freq + mixer . min_needed ) << MIXER_SHIFT ) / 1000 ; } else if ( mixer . done < mixer . max_needed ) { Bitu left = mixer . done - need ; if ( left < mixer . min_needed ) { if ( ! Mixer_irq_important ( ) ) { Bitu needed = mixer . needed - need ; Bitu diff = ( mixer . min_needed > needed ? mixer . min_needed : needed ) - left ; mixer . tick_add = ( ( mixer . freq + ( diff * 3 ) ) << MIXER_SHIFT ) / 1000 ; left = 0 ; // No ▁ stretching ▁ as ▁ we ▁ compensate ▁ with ▁ the ▁ tick _ add ▁ value ENDCOM } else { left = ( mixer . min_needed - left ) ; left = 1 + ( 2 * left ) / mixer . min_needed ; // left = 1,2,3 ENDCOM } // TABSYMBOL TABSYMBOL TABSYMBOL LOG _ MSG ( " needed ▁ underrun ▁ need ▁ % d , ▁ have ▁ % d , ▁ min ▁ % d , ▁ left ▁ % d " , ▁ need , ▁ mixer . done , ▁ mixer . min _ needed , ▁ left ) ; ENDCOM reduce = need - left ; index_add = ( reduce << MIXER_SHIFT ) / need ; } else { reduce = need ; index_add = ( 1 << MIXER_SHIFT ) ; // TABSYMBOL TABSYMBOL TABSYMBOL LOG _ MSG ( " regular ▁ run ▁ need ▁ % d , ▁ have ▁ % d , ▁ min ▁ % d , ▁ left ▁ % d " , ▁ need , ▁ mixer . done , ▁ mixer . min _ needed , ▁ left ) ; ENDCOM /* ▁ Mixer ▁ tick ▁ value ▁ being ▁ updated : STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL ▁ * ▁ 3 ▁ cases : STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL ▁ * ▁ 1 ) ▁ A ▁ lot ▁ too ▁ high . ▁ > division ▁ by ▁ 5 . ▁ but ▁ maxed ▁ by ▁ 2 * ▁ min ▁ to ▁ prevent ▁ too ▁ fast ▁ drops . STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL ▁ * ▁ 2 ) ▁ A ▁ little ▁ too ▁ high ▁ > ▁ division ▁ by ▁ 8 STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL ▁ * ▁ 3 ) ▁ A ▁ little ▁ to ▁ nothing ▁ above ▁ the ▁ min _ needed ▁ buffer ▁ > ▁ go ▁ to ▁ default ▁ value STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL ▁ */ Bitu diff = left - mixer . min_needed ; if ( diff > ( mixer . min_needed << 1 ) ) diff = mixer . min_needed << 1 ; if ( diff > ( mixer . min_needed >> 1 ) ) mixer . tick_add = ( ( mixer . freq - ( diff / 5 ) ) << MIXER_SHIFT ) / 1000 ; else if ( diff > ( mixer . min_needed >> 4 ) ) mixer . tick_add = ( ( mixer . freq - ( diff >> 3 ) ) << MIXER_SHIFT ) / 1000 ; else mixer . tick_add = ( mixer . freq << MIXER_SHIFT ) / 1000 ; } } else { /* ▁ There ▁ is ▁ way ▁ too ▁ much ▁ data ▁ in ▁ the ▁ buffer ▁ */ // TABSYMBOL TABSYMBOL LOG _ MSG ( " overflow ▁ run ▁ need ▁ % d , ▁ have ▁ % d , ▁ min ▁ % d " , ▁ need , ▁ mixer . done , ▁ mixer . min _ needed ) ; ENDCOM if ( mixer . done > MIXER_BUFSIZE ) index_add = MIXER_BUFSIZE - 2 * mixer . min_needed ; else index_add = mixer . done - 2 * mixer . min_needed ; index_add = ( index_add << MIXER_SHIFT ) / need ; reduce = mixer . done - 2 * mixer . min_needed ; mixer . tick_add = ( ( mixer . freq - ( mixer . min_needed / 5 ) ) << MIXER_SHIFT ) / 1000 ; } /* ▁ Reduce ▁ done ▁ count ▁ in ▁ all ▁ channels ▁ */ for ( MixerChannel * chan = mixer . channels ; chan ; chan = chan -> next ) { if ( chan -> done > reduce ) chan -> done -= reduce ; else chan -> done = 0 ; } // ▁ Reset ▁ mixer . tick _ add ▁ when ▁ irqs ▁ are ▁ important ENDCOM if ( Mixer_irq_important ( ) ) mixer . tick_add = ( mixer . freq << MIXER_SHIFT ) / 1000 ; mixer . done -= reduce ; mixer . needed -= reduce ; pos = mixer . pos ; mixer . pos = ( mixer . pos + reduce ) & MIXER_BUFMASK ; index = 0 ; if ( need != reduce ) { while ( need -- ) { Bitu i = ( pos + ( index >> MIXER_SHIFT ) ) & MIXER_BUFMASK ; index += index_add ; sample = mixer . work [ i ] [ 0 ] >> MIXER_VOLSHIFT ; * output ++ = MIXER_CLIP ( sample ) ; sample = mixer . work [ i ] [ 1 ] >> MIXER_VOLSHIFT ; * output ++ = MIXER_CLIP ( sample ) ; } /* ▁ Clean ▁ the ▁ used ▁ buffer ▁ */ while ( reduce -- ) { pos &= MIXER_BUFMASK ; mixer . work [ pos ] [ 0 ] = 0 ; mixer . work [ pos ] [ 1 ] = 0 ; pos ++ ; } } else { while ( reduce -- ) { pos &= MIXER_BUFMASK ; sample = mixer . work [ pos ] [ 0 ] >> MIXER_VOLSHIFT ; * output ++ = MIXER_CLIP ( sample ) ; sample = mixer . work [ pos ] [ 1 ] >> MIXER_VOLSHIFT ; * output ++ = MIXER_CLIP ( sample ) ; mixer . work [ pos ] [ 0 ] = 0 ; mixer . work [ pos ] [ 1 ] = 0 ; pos ++ ; } } } static void MIXER_Stop ( Section * sec ) { } class MIXER : public Program { public : void MakeVolume ( char * scan , float & vol0 , float & vol1 ) { Bitu w = 0 ; bool db = ( toupper ( * scan ) == ' D ' ) ; if ( db ) scan ++ ; while ( * scan ) { if ( * scan == ' : ' ) { ++ scan ; w = 1 ; } char * before = scan ; float val = ( float ) strtod ( scan , & scan ) ; if ( before == scan ) { ++ scan ; continue ; } if ( ! db ) val /= 100 ; else val = powf ( 10.0f , ( float ) val / 20.0f ) ; if ( val < 0 ) val = 1.0f ; if ( ! w ) { vol0 = val ; } else { vol1 = val ; } } if ( ! w ) vol1 = vol0 ; } void Run ( void ) { if ( cmd -> FindExist ( " / LISTMIDI " ) ) { ListMidi ( ) ; return ; } if ( cmd -> FindString ( " MASTER " , temp_line , false ) ) { MakeVolume ( ( char * ) temp_line . c_str ( ) , mixer . mastervol [ 0 ] , mixer . mastervol [ 1 ] ) ; } MixerChannel * chan = mixer . channels ; while ( chan ) { if ( cmd -> FindString ( chan -> name , temp_line , false ) ) { MakeVolume ( ( char * ) temp_line . c_str ( ) , chan -> volmain [ 0 ] , chan -> volmain [ 1 ] ) ; } chan -> UpdateVolume ( ) ; chan = chan -> next ; } if ( cmd -> FindExist ( " / NOSHOW " ) ) return ; chan = mixer . channels ; WriteOut ( " Channel ▁ ▁ Main ▁ ▁ ▁ ▁ Main ( dB ) \n " ) ; ShowVolume ( " MASTER " , mixer . mastervol [ 0 ] , mixer . mastervol [ 1 ] ) ; for ( chan = mixer . channels ; chan ; chan = chan -> next ) ShowVolume ( chan -> name , chan -> volmain [ 0 ] , chan -> volmain [ 1 ] ) ; } private : void ShowVolume ( const char * name , float vol0 , float vol1 ) { WriteOut ( " % -8s ▁ % 3.0f : % - 3.0f ▁ ▁ % + 3.2f : % - + 3.2f ▁ \n " , name , vol0 * 100 , vol1 * 100 , 20 * log ( vol0 ) / log ( 10.0f ) , 20 * log ( vol1 ) / log ( 10.0f ) ) ; } void ListMidi ( ) { # if defined ( WIN32 ) unsigned int total = midiOutGetNumDevs ( ) ; for ( unsigned int i = 0 ; i < total ; i ++ ) { MIDIOUTCAPS mididev ; midiOutGetDevCaps ( i , & mididev , sizeof ( MIDIOUTCAPS ) ) ; WriteOut ( " % 2d\t ▁ \ " % s\ " \n " , i , mididev . szPname ) ; } # endif return ; } ; } ; static void MIXER_ProgramStart ( Program * * make ) { * make = new MIXER ; } MixerChannel * MixerObject :: Install ( MIXER_Handler handler , Bitu freq , const char * name ) { if ( ! installed ) { if ( strlen ( name ) > 31 ) E_Exit ( " Too ▁ long ▁ mixer ▁ channel ▁ name " ) ; safe_strncpy ( m_name , name , 32 ) ; installed = true ; return MIXER_AddChannel ( handler , freq , name ) ; } else { E_Exit ( " allready ▁ added ▁ mixer ▁ channel . " ) ; return 0 ; // Compiler ▁ happy ENDCOM } } MixerObject :: ~ MixerObject ( ) { if ( ! installed ) return ; MIXER_DelChannel ( MIXER_FindChannel ( m_name ) ) ; } void MIXER_Init ( Section * sec ) { sec -> AddDestroyFunction ( & MIXER_Stop ) ; Section_prop * section = static_cast < Section_prop * > ( sec ) ; /* ▁ Read ▁ out ▁ config ▁ section ▁ */ mixer . freq = section -> Get_int ( " rate " ) ; mixer . nosound = section -> Get_bool ( " nosound " ) ; mixer . blocksize = section -> Get_int ( " blocksize " ) ; /* ▁ Initialize ▁ the ▁ internal ▁ stuff ▁ */ mixer . channels = 0 ; mixer . pos = 0 ; mixer . done = 0 ; memset ( mixer . work , 0 , sizeof ( mixer . work ) ) ; mixer . mastervol [ 0 ] = 1.0f ; mixer . mastervol [ 1 ] = 1.0f ; /* ▁ Start ▁ the ▁ Mixer ▁ using ▁ SDL ▁ Sound ▁ at ▁ 22 ▁ khz ▁ */ SDL_AudioSpec spec ; SDL_AudioSpec obtained ; spec . freq = mixer . freq ; spec . format = AUDIO_S16SYS ; spec . channels = 2 ; spec . callback = MIXER_CallBack ; spec . userdata = NULL ; spec . samples = ( Uint16 ) mixer . blocksize ; mixer . tick_remain = 0 ; if ( mixer . nosound ) { LOG_MSG ( " MIXER : No ▁ Sound ▁ Mode ▁ Selected . " ) ; mixer . tick_add = ( ( mixer . freq ) << MIXER_SHIFT ) / 1000 ; TIMER_AddTickHandler ( MIXER_Mix_NoSound ) ; } else if ( SDL_OpenAudio ( & spec , & obtained ) < 0 ) { mixer . nosound = true ; LOG_MSG ( " MIXER : Can ' t ▁ open ▁ audio : ▁ % s ▁ , ▁ running ▁ in ▁ nosound ▁ mode . " , SDL_GetError ( ) ) ; mixer . tick_add = ( ( mixer . freq ) << MIXER_SHIFT ) / 1000 ; TIMER_AddTickHandler ( MIXER_Mix_NoSound ) ; } else { mixer . freq = obtained . freq ; mixer . blocksize = obtained . samples ; mixer . tick_add = ( mixer . freq << MIXER_SHIFT ) / 1000 ; TIMER_AddTickHandler ( MIXER_Mix ) ; SDL_PauseAudio ( 0 ) ; } mixer . min_needed = section -> Get_int ( " prebuffer " ) ; if ( mixer . min_needed > 100 ) mixer . min_needed = 100 ; mixer . min_needed = ( mixer . freq * mixer . min_needed ) / 1000 ; mixer . max_needed = mixer . blocksize * 2 + 2 * mixer . min_needed ; mixer . needed = mixer . min_needed + 1 ; PROGRAMS_MakeFile ( " MIXER . COM " , MIXER_ProgramStart ) ; } </DOCUMENT>
<DOCUMENT_ID="tectronics/mysql-parallel-replication/tree/master/extra/yassl/taocrypt/src/hash.cpp"> /* STRNEWLINE ▁ Copyright ▁ ( C ) ▁ 2000-2007 ▁ MySQL ▁ AB STRNEWLINE STRNEWLINE ▁ This ▁ program ▁ is ▁ free ▁ software ; ▁ you ▁ can ▁ redistribute ▁ it ▁ and / or ▁ modify STRNEWLINE ▁ it ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ as ▁ published ▁ by STRNEWLINE ▁ the ▁ Free ▁ Software ▁ Foundation ; ▁ version ▁ 2 ▁ of ▁ the ▁ License . STRNEWLINE STRNEWLINE ▁ This ▁ program ▁ is ▁ distributed ▁ in ▁ the ▁ hope ▁ that ▁ it ▁ will ▁ be ▁ useful , STRNEWLINE ▁ but ▁ WITHOUT ▁ ANY ▁ WARRANTY ; ▁ without ▁ even ▁ the ▁ implied ▁ warranty ▁ of STRNEWLINE ▁ MERCHANTABILITY ▁ or ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE . ▁ See ▁ the STRNEWLINE ▁ GNU ▁ General ▁ Public ▁ License ▁ for ▁ more ▁ details . STRNEWLINE STRNEWLINE ▁ You ▁ should ▁ have ▁ received ▁ a ▁ copy ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License STRNEWLINE ▁ along ▁ with ▁ this ▁ program ; ▁ see ▁ the ▁ file ▁ COPYING . ▁ If ▁ not , ▁ write ▁ to ▁ the STRNEWLINE ▁ Free ▁ Software ▁ Foundation , ▁ Inc . , ▁ 51 ▁ Franklin ▁ St , ▁ Fifth ▁ Floor , ▁ Boston , STRNEWLINE ▁ MA ▁ 02110-1301 ▁ USA . STRNEWLINE */ /* ▁ hash . cpp ▁ implements ▁ a ▁ base ▁ for ▁ digest ▁ types STRNEWLINE */ # include " runtime . hpp " # include < string . h > # include < assert . h > # include " hash . hpp " namespace TaoCrypt { HASHwithTransform :: HASHwithTransform ( word32 digSz , word32 buffSz ) { assert ( digSz <= MaxDigestSz ) ; assert ( buffSz <= MaxBufferSz ) ; } void HASHwithTransform :: AddLength ( word32 len ) { HashLengthType tmp = loLen_ ; if ( ( loLen_ += len ) < tmp ) hiLen_ ++ ; // ▁ carry ▁ low ▁ to ▁ high ENDCOM hiLen_ += SafeRightShift < 8 * sizeof ( HashLengthType ) > ( len ) ; } // ▁ Update ▁ digest ▁ with ▁ data ▁ of ▁ size ▁ len , ▁ do ▁ in ▁ blocks ENDCOM void HASHwithTransform :: Update ( const byte * data , word32 len ) { // ▁ do ▁ block ▁ size ▁ increments ENDCOM word32 blockSz = getBlockSize ( ) ; byte * local = reinterpret_cast < byte * > ( buffer_ ) ; while ( len ) { word32 add = min ( len , blockSz - buffLen_ ) ; memcpy ( & local [ buffLen_ ] , data , add ) ; buffLen_ += add ; data += add ; len -= add ; if ( buffLen_ == blockSz ) { ByteReverseIf ( local , local , blockSz , getByteOrder ( ) ) ; Transform ( ) ; AddLength ( blockSz ) ; buffLen_ = 0 ; } } } // ▁ Final ▁ process , ▁ place ▁ digest ▁ in ▁ hash ENDCOM void HASHwithTransform :: Final ( byte * hash ) { word32 blockSz = getBlockSize ( ) ; word32 digestSz = getDigestSize ( ) ; word32 padSz = getPadSize ( ) ; ByteOrder order = getByteOrder ( ) ; AddLength ( buffLen_ ) ; // ▁ before ▁ adding ▁ pads ENDCOM HashLengthType preLoLen = GetBitCountLo ( ) ; HashLengthType preHiLen = GetBitCountHi ( ) ; byte * local = reinterpret_cast < byte * > ( buffer_ ) ; local [ buffLen_ ++ ] = 0x80 ; // ▁ add ▁ 1 ENDCOM // ▁ pad ▁ with ▁ zeros ENDCOM if ( buffLen_ > padSz ) { memset ( & local [ buffLen_ ] , 0 , blockSz - buffLen_ ) ; buffLen_ += blockSz - buffLen_ ; ByteReverseIf ( local , local , blockSz , order ) ; Transform ( ) ; buffLen_ = 0 ; } memset ( & local [ buffLen_ ] , 0 , padSz - buffLen_ ) ; ByteReverseIf ( local , local , blockSz , order ) ; memcpy ( & local [ padSz ] , order ? & preHiLen : & preLoLen , sizeof ( preLoLen ) ) ; memcpy ( & local [ padSz + 4 ] , order ? & preLoLen : & preHiLen , sizeof ( preLoLen ) ) ; Transform ( ) ; ByteReverseIf ( digest_ , digest_ , digestSz , order ) ; memcpy ( hash , digest_ , digestSz ) ; Init ( ) ; // ▁ reset ▁ state ENDCOM } # ifdef WORD64_AVAILABLE HASH64withTransform :: HASH64withTransform ( word32 digSz , word32 buffSz ) { assert ( digSz <= MaxDigestSz ) ; assert ( buffSz <= MaxBufferSz ) ; } void HASH64withTransform :: AddLength ( word32 len ) { HashLengthType tmp = loLen_ ; if ( ( loLen_ += len ) < tmp ) hiLen_ ++ ; // ▁ carry ▁ low ▁ to ▁ high ENDCOM hiLen_ += SafeRightShift < 8 * sizeof ( HashLengthType ) > ( len ) ; } // ▁ Update ▁ digest ▁ with ▁ data ▁ of ▁ size ▁ len , ▁ do ▁ in ▁ blocks ENDCOM void HASH64withTransform :: Update ( const byte * data , word32 len ) { // ▁ do ▁ block ▁ size ▁ increments ENDCOM word32 blockSz = getBlockSize ( ) ; byte * local = reinterpret_cast < byte * > ( buffer_ ) ; while ( len ) { word32 add = min ( len , blockSz - buffLen_ ) ; memcpy ( & local [ buffLen_ ] , data , add ) ; buffLen_ += add ; data += add ; len -= add ; if ( buffLen_ == blockSz ) { ByteReverseIf ( buffer_ , buffer_ , blockSz , getByteOrder ( ) ) ; Transform ( ) ; AddLength ( blockSz ) ; buffLen_ = 0 ; } } } // ▁ Final ▁ process , ▁ place ▁ digest ▁ in ▁ hash ENDCOM void HASH64withTransform :: Final ( byte * hash ) { word32 blockSz = getBlockSize ( ) ; word32 digestSz = getDigestSize ( ) ; word32 padSz = getPadSize ( ) ; ByteOrder order = getByteOrder ( ) ; AddLength ( buffLen_ ) ; // ▁ before ▁ adding ▁ pads ENDCOM HashLengthType preLoLen = GetBitCountLo ( ) ; HashLengthType preHiLen = GetBitCountHi ( ) ; byte * local = reinterpret_cast < byte * > ( buffer_ ) ; local [ buffLen_ ++ ] = 0x80 ; // ▁ add ▁ 1 ENDCOM // ▁ pad ▁ with ▁ zeros ENDCOM if ( buffLen_ > padSz ) { memset ( & local [ buffLen_ ] , 0 , blockSz - buffLen_ ) ; buffLen_ += blockSz - buffLen_ ; ByteReverseIf ( buffer_ , buffer_ , blockSz , order ) ; Transform ( ) ; buffLen_ = 0 ; } memset ( & local [ buffLen_ ] , 0 , padSz - buffLen_ ) ; ByteReverseIf ( buffer_ , buffer_ , padSz , order ) ; buffer_ [ blockSz / sizeof ( word64 ) - 2 ] = order ? preHiLen : preLoLen ; buffer_ [ blockSz / sizeof ( word64 ) - 1 ] = order ? preLoLen : preHiLen ; Transform ( ) ; ByteReverseIf ( digest_ , digest_ , digestSz , order ) ; memcpy ( hash , digest_ , digestSz ) ; Init ( ) ; // ▁ reset ▁ state ENDCOM } # endif // ▁ WORD64 _ AVAILABLE ENDCOM } // ▁ namespace ENDCOM </DOCUMENT>
<DOCUMENT_ID="KDE/koffice/tree/master/kcells/dialogs/StyleManagerDialog.cpp"> /* ▁ This ▁ file ▁ is ▁ part ▁ of ▁ the ▁ KDE ▁ project STRNEWLINE ▁ Copyright ▁ 2007 ▁ Stefan ▁ Nikolaus ▁ < stefan . nikolaus @ kdemail . net > STRNEWLINE ▁ Copyright ▁ 2003 ▁ Laurent ▁ Montel ▁ < montel @ kde . org > STRNEWLINE ▁ Copyright ▁ 2003 ▁ Norbert ▁ Andres ▁ < nandres @ web . de > STRNEWLINE STRNEWLINE ▁ This ▁ library ▁ is ▁ free ▁ software ; ▁ you ▁ can ▁ redistribute ▁ it ▁ and / or STRNEWLINE ▁ modify ▁ it ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ Library ▁ General ▁ Public STRNEWLINE ▁ License ▁ as ▁ published ▁ by ▁ the ▁ Free ▁ Software ▁ Foundation ; ▁ either STRNEWLINE ▁ version ▁ 2 ▁ of ▁ the ▁ License , ▁ or ▁ ( at ▁ your ▁ option ) ▁ any ▁ later ▁ version . STRNEWLINE STRNEWLINE ▁ This ▁ library ▁ is ▁ distributed ▁ in ▁ the ▁ hope ▁ that ▁ it ▁ will ▁ be ▁ useful , STRNEWLINE ▁ but ▁ WITHOUT ▁ ANY ▁ WARRANTY ; ▁ without ▁ even ▁ the ▁ implied ▁ warranty ▁ of STRNEWLINE ▁ MERCHANTABILITY ▁ or ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE . ▁ See ▁ the ▁ GNU STRNEWLINE ▁ Library ▁ General ▁ Public ▁ License ▁ for ▁ more ▁ details . STRNEWLINE STRNEWLINE ▁ You ▁ should ▁ have ▁ received ▁ a ▁ copy ▁ of ▁ the ▁ GNU ▁ Library ▁ General ▁ Public ▁ License STRNEWLINE ▁ along ▁ with ▁ this ▁ library ; ▁ see ▁ the ▁ file ▁ COPYING . LIB . ▁ If ▁ not , ▁ write ▁ to STRNEWLINE ▁ the ▁ Free ▁ Software ▁ Foundation , ▁ Inc . , ▁ 51 ▁ Franklin ▁ Street , ▁ Fifth ▁ Floor , STRNEWLINE ▁ Boston , ▁ MA ▁ 02110-1301 , ▁ USA . STRNEWLINE */ # include " StyleManagerDialog . h " # include < QMap > # include < QTreeWidget > # include < QVBoxLayout > # include < kcombobox . h > # include < kdebug . h > # include < klocale . h > # include " KCCell . h " # include " LayoutDialog . h " # include " ui / Selection . h " # include " KCSheet . h " # include " KCStyle . h " # include " KCStyleManager . h " # include " commands / KCStyleCommand . h " StyleManagerDialog :: StyleManagerDialog ( QWidget * parent , Selection * selection , KCStyleManager * manager ) : KDialog ( parent ) , m_selection ( selection ) , m_styleManager ( manager ) { setButtons ( Apply | User1 | User2 | User3 | Close ) ; setButtonText ( User3 , i18n ( " & New . . . " ) ) ; setButtonText ( User2 , i18n ( " & Modify . . . " ) ) ; setButtonText ( User1 , i18n ( " & Delete . . . " ) ) ; setButtonsOrientation ( Qt :: Vertical ) ; setCaption ( i18n ( " Style ▁ Manager " ) ) ; QWidget * widget = new QWidget ( this ) ; setMainWidget ( widget ) ; QVBoxLayout * layout = new QVBoxLayout ( widget ) ; m_styleList = new QTreeWidget ( this ) ; m_styleList -> setHeaderLabel ( i18n ( " Style " ) ) ; layout -> addWidget ( m_styleList ) ; m_displayBox = new KComboBox ( false , this ) ; m_displayBox -> insertItem ( 0 , i18n ( " All ▁ Styles " ) ) ; m_displayBox -> insertItem ( 1 , i18n ( " Custom ▁ Styles " ) ) ; m_displayBox -> insertItem ( 2 , i18n ( " Hierarchical " ) ) ; layout -> addWidget ( m_displayBox ) ; slotDisplayMode ( 0 ) ; enableButton ( KDialog :: User3 , true ) ; enableButton ( KDialog :: User2 , true ) ; enableButton ( KDialog :: User1 , false ) ; connect ( m_displayBox , SIGNAL ( activated ( int ) ) , this , SLOT ( slotDisplayMode ( int ) ) ) ; connect ( this , SIGNAL ( applyClicked ( ) ) , this , SLOT ( slotOk ( ) ) ) ; connect ( this , SIGNAL ( user3Clicked ( ) ) , this , SLOT ( slotNew ( ) ) ) ; connect ( this , SIGNAL ( user2Clicked ( ) ) , this , SLOT ( slotEdit ( ) ) ) ; connect ( this , SIGNAL ( user1Clicked ( ) ) , this , SLOT ( slotRemove ( ) ) ) ; connect ( m_styleList , SIGNAL ( itemDoubleClicked ( QTreeWidgetItem * , int ) ) , this , SLOT ( slotEdit ( ) ) ) ; connect ( m_styleList , SIGNAL ( currentItemChanged ( QTreeWidgetItem * , QTreeWidgetItem * ) ) , this , SLOT ( selectionChanged ( QTreeWidgetItem * ) ) ) ; } StyleManagerDialog :: ~ StyleManagerDialog ( ) { } void StyleManagerDialog :: fillComboBox ( ) { typedef QMap < KCCustomStyle * , QTreeWidgetItem * > KCMap ; KCMap entries ; entries . clear ( ) ; entries [ m_styleManager -> defaultStyle ( ) ] = new QTreeWidgetItem ( m_styleList , QStringList ( i18n ( " Default " ) ) ) ; CustomStyles :: const_iterator iter = m_styleManager -> m_styles . constBegin ( ) ; CustomStyles :: const_iterator end = m_styleManager -> m_styles . constEnd ( ) ; while ( entries . count ( ) != m_styleManager -> m_styles . count ( ) + 1 ) { if ( entries . find ( iter . value ( ) ) == entries . end ( ) ) { if ( iter . value ( ) -> parentName ( ) . isNull ( ) ) entries [ iter . value ( ) ] = new QTreeWidgetItem ( entries [ m_styleManager -> defaultStyle ( ) ] , QStringList ( iter . value ( ) -> name ( ) ) ) ; else { KCCustomStyle * parentStyle = m_styleManager -> style ( iter . value ( ) -> parentName ( ) ) ; if ( parentStyle ) { KCMap :: const_iterator i = entries . constFind ( parentStyle ) ; if ( i != entries . constEnd ( ) ) entries [ iter . value ( ) ] = new QTreeWidgetItem ( i . value ( ) , QStringList ( iter . value ( ) -> name ( ) ) ) ; } } } ++ iter ; if ( iter == end ) iter = m_styleManager -> m_styles . constBegin ( ) ; } entries . clear ( ) ; } void StyleManagerDialog :: slotDisplayMode ( int mode ) { m_styleList -> clear ( ) ; if ( mode != 2 ) // ▁ NOT ▁ " Hierarchical " ENDCOM m_styleList -> setRootIsDecorated ( false ) ; else { // ▁ " Hierarchical " ENDCOM m_styleList -> setRootIsDecorated ( true ) ; fillComboBox ( ) ; return ; } if ( mode != 1 ) // ▁ NOT ▁ " Custom ▁ Styles " ENDCOM new QTreeWidgetItem ( m_styleList , QStringList ( i18n ( " Default " ) ) ) ; CustomStyles :: iterator iter = m_styleManager -> m_styles . begin ( ) ; CustomStyles :: iterator end = m_styleManager -> m_styles . end ( ) ; while ( iter != end ) { KCCustomStyle * styleData = iter . value ( ) ; if ( ! styleData || styleData -> name ( ) . isEmpty ( ) ) { ++ iter ; continue ; } if ( mode == 1 ) { // ▁ " Custom ▁ Styles " ENDCOM if ( styleData -> type ( ) == KCStyle :: CUSTOM ) new QTreeWidgetItem ( m_styleList , QStringList ( styleData -> name ( ) ) ) ; } else new QTreeWidgetItem ( m_styleList , QStringList ( styleData -> name ( ) ) ) ; ++ iter ; } } void StyleManagerDialog :: slotOk ( ) { kDebug ( ) ; QTreeWidgetItem * item = m_styleList -> currentItem ( ) ; if ( ! item ) { accept ( ) ; return ; } QString name ( item -> text ( 0 ) ) ; if ( name == i18n ( " Default " ) ) { KCStyleCommand * command = new KCStyleCommand ( ) ; command -> setSheet ( m_selection -> activeSheet ( ) ) ; command -> setDefault ( ) ; command -> add ( * m_selection ) ; command -> execute ( m_selection -> canvas ( ) ) ; } else { KCStyleCommand * command = new KCStyleCommand ( ) ; command -> setSheet ( m_selection -> activeSheet ( ) ) ; command -> setParentName ( name ) ; command -> add ( * m_selection ) ; command -> execute ( m_selection -> canvas ( ) ) ; } accept ( ) ; } void StyleManagerDialog :: slotNew ( ) { KCCustomStyle * parentStyle = 0 ; QTreeWidgetItem * item = m_styleList -> currentItem ( ) ; if ( item ) { const QString name = item -> text ( 0 ) ; if ( name == i18n ( " Default " ) ) parentStyle = m_styleManager -> defaultStyle ( ) ; else parentStyle = m_styleManager -> style ( name ) ; } else parentStyle = m_styleManager -> defaultStyle ( ) ; int i = 1 ; QString newName ( i18n ( " style % 1" , m_styleManager -> count ( ) + i ) ) ; while ( m_styleManager -> style ( newName ) != 0 ) { ++ i ; newName = i18n ( " style % 1" , m_styleManager -> count ( ) + i ) ; } KCCustomStyle * style = new KCCustomStyle ( newName , parentStyle ) ; style -> setType ( KCStyle :: TENTATIVE ) ; QPointer < CellFormatDialog > dialog = new CellFormatDialog ( this , m_selection , style , m_styleManager ) ; dialog -> exec ( ) ; delete dialog ; if ( style -> type ( ) == KCStyle :: TENTATIVE ) { delete style ; return ; } m_styleManager -> m_styles [ style -> name ( ) ] = style ; slotDisplayMode ( m_displayBox -> currentIndex ( ) ) ; } void StyleManagerDialog :: slotEdit ( ) { QTreeWidgetItem * item = m_styleList -> currentItem ( ) ; if ( ! item ) return ; KCCustomStyle * style = 0 ; QString name ( item -> text ( 0 ) ) ; if ( name == i18n ( " Default " ) ) style = m_styleManager -> defaultStyle ( ) ; else style = m_styleManager -> style ( name ) ; if ( ! style ) return ; QPointer < CellFormatDialog > dialog = new CellFormatDialog ( this , m_selection , style , m_styleManager ) ; dialog -> exec ( ) ; if ( dialog -> result ( ) == Accepted ) m_selection -> emitRefreshSheetViews ( ) ; slotDisplayMode ( m_displayBox -> currentIndex ( ) ) ; delete dialog ; } void StyleManagerDialog :: slotRemove ( ) { QTreeWidgetItem * item = m_styleList -> currentItem ( ) ; if ( ! item ) return ; const QString name = item -> text ( 0 ) ; KCCustomStyle * style = 0 ; if ( name == i18n ( " Default " ) ) style = m_styleManager -> defaultStyle ( ) ; else style = m_styleManager -> style ( name ) ; if ( ! style ) return ; if ( style -> type ( ) != KCStyle :: CUSTOM ) return ; m_styleManager -> takeStyle ( style ) ; slotDisplayMode ( m_displayBox -> currentIndex ( ) ) ; } void StyleManagerDialog :: selectionChanged ( QTreeWidgetItem * item ) { if ( ! item ) return ; const QString name = item -> text ( 0 ) ; KCCustomStyle * style = 0 ; if ( name == i18n ( " Default " ) ) style = m_styleManager -> defaultStyle ( ) ; else style = m_styleManager -> style ( name ) ; if ( ! style ) { enableButton ( KDialog :: User1 , false ) ; return ; } if ( style -> type ( ) == KCStyle :: BUILTIN ) enableButton ( KDialog :: User1 , false ) ; else enableButton ( KDialog :: User1 , true ) ; } # include " StyleManagerDialog . moc " </DOCUMENT>
<DOCUMENT_ID="plexinc/plex-home-theater-public/tree/master/plex/Update-Installer/external/win32cpp/tutorials/Tutorial8/View.cpp"> // ▁ View . cpp ENDCOM // ▁ Definitions ▁ for ▁ the ▁ CView ▁ class ENDCOM # include " view . h " # include " GDI . h " # include " file . h " # include " resource . h " using namespace std ; CView :: CView ( ) : m_PenColor ( RGB ( 0 , 0 , 0 ) ) { m_Brush . CreateSolidBrush ( RGB ( 255 , 255 , 230 ) ) ; } CView :: ~ CView ( ) { } void CView :: ClearPoints ( ) { m_points . clear ( ) ; Invalidate ( ) ; } void CView :: DrawLine ( int x , int y ) { CClientDC dcClient ( this ) ; dcClient . CreatePen ( PS_SOLID , 1 , m_points . back ( ) . color ) ; dcClient . MoveTo ( m_points . back ( ) . x , m_points . back ( ) . y ) ; dcClient . LineTo ( x , y ) ; } void CView :: OnDraw ( CDC * pDC ) { if ( m_points . size ( ) > 0 ) { bool bDraw = false ; // Start ▁ with ▁ the ▁ pen ▁ up ENDCOM for ( unsigned int i = 0 ; i < m_points . size ( ) ; i ++ ) { pDC -> CreatePen ( PS_SOLID , 1 , m_points [ i ] . color ) ; if ( bDraw ) pDC -> LineTo ( m_points [ i ] . x , m_points [ i ] . y ) ; else pDC -> MoveTo ( m_points [ i ] . x , m_points [ i ] . y ) ; bDraw = m_points [ i ] . PenDown ; } } } void CView :: PreCreate ( CREATESTRUCT & cs ) { // ▁ Set ▁ the ▁ extra ▁ style ▁ to ▁ provide ▁ a ▁ sunken ▁ effect ENDCOM cs . dwExStyle = WS_EX_CLIENTEDGE ; } void CView :: PreRegisterClass ( WNDCLASS & wc ) { // ▁ Set ▁ the ▁ background ▁ brush , ▁ class ▁ name ▁ and ▁ cursor ENDCOM wc . hbrBackground = m_Brush ; wc . lpszClassName = _T ( " Scribble ▁ Window " ) ; wc . hCursor = :: LoadCursor ( GetApp ( ) -> GetInstanceHandle ( ) , MAKEINTRESOURCE ( IDC_CURSOR1 ) ) ; } BOOL CView :: FileOpen ( LPCTSTR szFilename ) { // ▁ empty ▁ the ▁ PlotPoint ▁ vector ENDCOM m_points . clear ( ) ; DWORD nBytesRead ; BOOL bResult = FALSE ; // ▁ Create ▁ a ▁ handle ▁ to ▁ the ▁ file ENDCOM CFile File ; if ( File . Open ( szFilename , OPEN_EXISTING ) ) { do { PlotPoint pp ; nBytesRead = File . Read ( & pp , sizeof ( PlotPoint ) ) ; if ( nBytesRead == sizeof ( PlotPoint ) ) m_points . push_back ( pp ) ; } while ( nBytesRead == sizeof ( PlotPoint ) ) ; if ( ( 0 != nBytesRead ) || ( m_points . empty ( ) ) ) { // ▁ Failed ▁ to ▁ read ▁ all ▁ of ▁ the ▁ file ENDCOM m_points . clear ( ) ; :: MessageBox ( 0 , _T ( " Invalid ▁ data ▁ in ▁ file " ) , _T ( " Error " ) , MB_ICONEXCLAMATION | MB_OK ) ; } else bResult = TRUE ; } else { tString tsErrMsg = _T ( " Failed ▁ to ▁ open ▁ file ▁ " ) ; tsErrMsg += szFilename ; :: MessageBox ( 0 , tsErrMsg . c_str ( ) , _T ( " Error " ) , MB_ICONEXCLAMATION | MB_OK ) ; } Invalidate ( ) ; return bResult ; } BOOL CView :: FileSave ( LPCTSTR szFilename ) { BOOL bResult = TRUE ; CFile hFile ; if ( ! hFile . Open ( szFilename , CREATE_ALWAYS ) ) { :: MessageBox ( 0 , _T ( " Failed ▁ to ▁ open ▁ file ▁ for ▁ writing " ) , _T ( " Error " ) , MB_ICONEXCLAMATION | MB_OK ) ; bResult = FALSE ; } if ( bResult ) { // ▁ Write ▁ the ▁ file ENDCOM for ( size_t i = 0 ; i < m_points . size ( ) ; ++ i ) { if ( ! hFile . Write ( & m_points [ i ] , sizeof ( PlotPoint ) ) ) { :: MessageBox ( 0 , _T ( " Error ▁ while ▁ writing ▁ to ▁ file " ) , _T ( " Error " ) , MB_ICONEXCLAMATION | MB_OK ) ; bResult = FALSE ; break ; } } // ▁ Verify ▁ file ▁ length ENDCOM if ( hFile . GetLength ( ) != m_points . size ( ) * sizeof ( PlotPoint ) ) { :: MessageBox ( 0 , _T ( " Error ▁ while ▁ writing ▁ to ▁ file " ) , _T ( " Error " ) , MB_ICONEXCLAMATION | MB_OK ) ; bResult = FALSE ; } } return bResult ; } void CView :: SetPen ( COLORREF color ) { m_PenColor = color ; } void CView :: StorePoint ( int x , int y , bool PenDown ) { PlotPoint P1 ; P1 . x = x ; P1 . y = y ; P1 . PenDown = PenDown ; P1 . color = m_PenColor ; m_points . push_back ( P1 ) ; // Add ▁ the ▁ point ▁ to ▁ the ▁ vector ENDCOM } void CView :: OnLButtonDown ( LPARAM lParam ) { // ▁ Capture ▁ mouse ▁ input . ENDCOM SetCapture ( ) ; StorePoint ( GET_X_LPARAM ( lParam ) , GET_Y_LPARAM ( lParam ) , true ) ; } void CView :: OnLButtonUp ( LPARAM lParam ) { { // Release ▁ the ▁ capture ▁ on ▁ the ▁ mouse ENDCOM ReleaseCapture ( ) ; StorePoint ( GET_X_LPARAM ( lParam ) , GET_Y_LPARAM ( lParam ) , false ) ; } } void CView :: OnMouseMove ( WPARAM wParam , LPARAM lParam ) { // ▁ hold ▁ down ▁ the ▁ left ▁ mouse ▁ button ▁ and ▁ move ▁ mouse ▁ to ▁ draw ▁ lines . ENDCOM if ( ( wParam & MK_LBUTTON ) && ( GetCapture ( ) == this ) ) { DrawLine ( GET_X_LPARAM ( lParam ) , GET_Y_LPARAM ( lParam ) ) ; StorePoint ( GET_X_LPARAM ( lParam ) , GET_Y_LPARAM ( lParam ) , true ) ; } } LRESULT CView :: WndProc ( UINT uMsg , WPARAM wParam , LPARAM lParam ) { switch ( uMsg ) { case WM_LBUTTONDOWN : OnLButtonDown ( lParam ) ; break ; case WM_MOUSEMOVE : OnMouseMove ( wParam , lParam ) ; break ; case WM_LBUTTONUP : OnLButtonUp ( lParam ) ; break ; } // Use ▁ the ▁ default ▁ message ▁ handling ▁ for ▁ remaining ▁ messages ENDCOM return WndProcDefault ( uMsg , wParam , lParam ) ; } </DOCUMENT>
<DOCUMENT_ID="CodeDJ/qt5-hidpi/tree/master/qt/qtdeclarative/src/quick/util/qquickanimatorcontroller.cpp"> /* * * * * STRNEWLINE * * STRNEWLINE * * ▁ Copyright ▁ ( C ) ▁ 2013 ▁ Digia ▁ Plc ▁ and / or ▁ its ▁ subsidiary ( - ies ) . STRNEWLINE * * ▁ Contact : ▁ http : // www . qt - project . org / legal STRNEWLINE * * STRNEWLINE * * ▁ This ▁ file ▁ is ▁ part ▁ of ▁ the ▁ QtQuick ▁ module ▁ of ▁ the ▁ Qt ▁ Toolkit . STRNEWLINE * * STRNEWLINE * * ▁ $ QT _ BEGIN _ LICENSE : LGPL $ STRNEWLINE * * ▁ Commercial ▁ License ▁ Usage STRNEWLINE * * ▁ Licensees ▁ holding ▁ valid ▁ commercial ▁ Qt ▁ licenses ▁ may ▁ use ▁ this ▁ file ▁ in STRNEWLINE * * ▁ accordance ▁ with ▁ the ▁ commercial ▁ license ▁ agreement ▁ provided ▁ with ▁ the STRNEWLINE * * ▁ Software ▁ or , ▁ alternatively , ▁ in ▁ accordance ▁ with ▁ the ▁ terms ▁ contained ▁ in STRNEWLINE * * ▁ a ▁ written ▁ agreement ▁ between ▁ you ▁ and ▁ Digia . ▁ For ▁ licensing ▁ terms ▁ and STRNEWLINE * * ▁ conditions ▁ see ▁ http : // qt . digia . com / licensing . ▁ For ▁ further ▁ information STRNEWLINE * * ▁ use ▁ the ▁ contact ▁ form ▁ at ▁ http : // qt . digia . com / contact - us . STRNEWLINE * * STRNEWLINE * * ▁ GNU ▁ Lesser ▁ General ▁ Public ▁ License ▁ Usage STRNEWLINE * * ▁ Alternatively , ▁ this ▁ file ▁ may ▁ be ▁ used ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ Lesser STRNEWLINE * * ▁ General ▁ Public ▁ License ▁ version ▁ 2.1 ▁ as ▁ published ▁ by ▁ the ▁ Free ▁ Software STRNEWLINE * * ▁ Foundation ▁ and ▁ appearing ▁ in ▁ the ▁ file ▁ LICENSE . LGPL ▁ included ▁ in ▁ the STRNEWLINE * * ▁ packaging ▁ of ▁ this ▁ file . ▁ Please ▁ review ▁ the ▁ following ▁ information ▁ to STRNEWLINE * * ▁ ensure ▁ the ▁ GNU ▁ Lesser ▁ General ▁ Public ▁ License ▁ version ▁ 2.1 ▁ requirements STRNEWLINE * * ▁ will ▁ be ▁ met : ▁ http : // www . gnu . org / licenses / old - licenses / lgpl - 2.1 . html . STRNEWLINE * * STRNEWLINE * * ▁ In ▁ addition , ▁ as ▁ a ▁ special ▁ exception , ▁ Digia ▁ gives ▁ you ▁ certain ▁ additional STRNEWLINE * * ▁ rights . ▁ These ▁ rights ▁ are ▁ described ▁ in ▁ the ▁ Digia ▁ Qt ▁ LGPL ▁ Exception STRNEWLINE * * ▁ version ▁ 1.1 , ▁ included ▁ in ▁ the ▁ file ▁ LGPL _ EXCEPTION . txt ▁ in ▁ this ▁ package . STRNEWLINE * * STRNEWLINE * * ▁ GNU ▁ General ▁ Public ▁ License ▁ Usage STRNEWLINE * * ▁ Alternatively , ▁ this ▁ file ▁ may ▁ be ▁ used ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU STRNEWLINE * * ▁ General ▁ Public ▁ License ▁ version ▁ 3.0 ▁ as ▁ published ▁ by ▁ the ▁ Free ▁ Software STRNEWLINE * * ▁ Foundation ▁ and ▁ appearing ▁ in ▁ the ▁ file ▁ LICENSE . GPL ▁ included ▁ in ▁ the STRNEWLINE * * ▁ packaging ▁ of ▁ this ▁ file . ▁ Please ▁ review ▁ the ▁ following ▁ information ▁ to STRNEWLINE * * ▁ ensure ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ version ▁ 3.0 ▁ requirements ▁ will ▁ be STRNEWLINE * * ▁ met : ▁ http : // www . gnu . org / copyleft / gpl . html . STRNEWLINE * * STRNEWLINE * * STRNEWLINE * * ▁ $ QT _ END _ LICENSE $ STRNEWLINE * * STRNEWLINE * * * * */ # include " qquickanimatorcontroller _ p . h " # include < private / qquickwindow_p . h > # include < private / qsgrenderloop_p . h > # include < private / qanimationgroupjob_p . h > # include < QtGui / qscreen . h > # include < QtCore / qcoreapplication . h > QT_BEGIN_NAMESPACE QQuickAnimatorController :: QQuickAnimatorController ( ) : m_window ( 0 ) { } QQuickAnimatorController :: ~ QQuickAnimatorController ( ) { // ▁ The ▁ proxy ▁ job ▁ might ▁ already ▁ have ▁ been ▁ deleted , ▁ in ▁ which ▁ case ▁ we ENDCOM // ▁ need ▁ to ▁ avoid ▁ calling ▁ functions ▁ on ▁ them . ▁ Then ▁ delete ▁ the ▁ job . ENDCOM foreach ( QAbstractAnimationJob * job , m_deleting ) { m_starting . take ( job ) ; m_stopping . take ( job ) ; m_animatorRoots . take ( job ) ; delete job ; } foreach ( QQuickAnimatorProxyJob * proxy , m_animatorRoots ) proxy -> controllerWasDeleted ( ) ; qDeleteAll ( m_animatorRoots . keys ( ) ) ; // ▁ Delete ▁ those ▁ who ▁ have ▁ been ▁ started , ▁ stopped ▁ and ▁ are ▁ now ▁ still ENDCOM // ▁ pending ▁ for ▁ restart . ENDCOM foreach ( QAbstractAnimationJob * job , m_starting . keys ( ) ) { if ( ! m_animatorRoots . contains ( job ) ) delete job ; } } void QQuickAnimatorController :: itemDestroyed ( QObject * o ) { m_deletedSinceLastFrame << ( QQuickItem * ) o ; } void QQuickAnimatorController :: advance ( ) { bool running = false ; for ( QHash < QAbstractAnimationJob * , QQuickAnimatorProxyJob * > :: const_iterator it = m_animatorRoots . constBegin ( ) ; ! running && it != m_animatorRoots . constEnd ( ) ; ++ it ) { if ( it . key ( ) -> isRunning ( ) ) running = true ; } // ▁ It ▁ was ▁ tempting ▁ to ▁ only ▁ run ▁ over ▁ the ▁ active ▁ animations , ▁ but ▁ we ▁ need ▁ to ▁ push ENDCOM // ▁ the ▁ values ▁ for ▁ the ▁ transforms ▁ that ▁ finished ▁ in ▁ the ▁ last ▁ frame ▁ and ▁ those ▁ will ENDCOM // ▁ have ▁ been ▁ removed ▁ already . . . ENDCOM lock ( ) ; for ( QHash < QQuickItem * , QQuickTransformAnimatorJob :: Helper * > :: const_iterator it = m_transforms . constBegin ( ) ; it != m_transforms . constEnd ( ) ; ++ it ) { QQuickTransformAnimatorJob :: Helper * xform = * it ; // ▁ Set ▁ to ▁ zero ▁ when ▁ the ▁ item ▁ was ▁ deleted ▁ in ▁ beforeNodeSync ( ) . ENDCOM if ( ! xform -> item ) continue ; ( * it ) -> apply ( ) ; } unlock ( ) ; if ( running ) m_window -> update ( ) ; } static void qquick_initialize_helper ( QAbstractAnimationJob * job , QQuickAnimatorController * c ) { if ( job -> isRenderThreadJob ( ) ) { QQuickAnimatorJob * j = static_cast < QQuickAnimatorJob * > ( job ) ; if ( ! j -> target ( ) ) { return ; } else if ( c -> m_deletedSinceLastFrame . contains ( j -> target ( ) ) ) { j -> targetWasDeleted ( ) ; } else { j -> addAnimationChangeListener ( c , QAbstractAnimationJob :: StateChange ) ; j -> initialize ( c ) ; } } else if ( job -> isGroup ( ) ) { QAnimationGroupJob * g = static_cast < QAnimationGroupJob * > ( job ) ; for ( QAbstractAnimationJob * a = g -> firstChild ( ) ; a ; a = a -> nextSibling ( ) ) qquick_initialize_helper ( a , c ) ; } } void QQuickAnimatorController :: beforeNodeSync ( ) { foreach ( QAbstractAnimationJob * job , m_deleting ) { m_starting . take ( job ) ; m_stopping . take ( job ) ; m_animatorRoots . take ( job ) ; job -> stop ( ) ; delete job ; } m_deleting . clear ( ) ; if ( m_starting . size ( ) ) m_window -> update ( ) ; foreach ( QQuickAnimatorProxyJob * proxy , m_starting ) { QAbstractAnimationJob * job = proxy -> job ( ) ; job -> addAnimationChangeListener ( this , QAbstractAnimationJob :: Completion ) ; qquick_initialize_helper ( job , this ) ; m_animatorRoots [ job ] = proxy ; job -> start ( ) ; proxy -> startedByController ( ) ; } m_starting . clear ( ) ; foreach ( QQuickAnimatorProxyJob * proxy , m_stopping ) { QAbstractAnimationJob * job = proxy -> job ( ) ; job -> stop ( ) ; } m_stopping . clear ( ) ; foreach ( QQuickAnimatorJob * job , m_activeLeafAnimations ) { if ( ! job -> target ( ) ) continue ; else if ( m_deletedSinceLastFrame . contains ( job -> target ( ) ) ) job -> targetWasDeleted ( ) ; else if ( job -> isTransform ( ) ) { QQuickTransformAnimatorJob * xform = static_cast < QQuickTransformAnimatorJob * > ( job ) ; xform -> transformHelper ( ) -> sync ( ) ; } } foreach ( QQuickItem * wiped , m_deletedSinceLastFrame ) { QQuickTransformAnimatorJob :: Helper * helper = m_transforms . value ( wiped ) ; if ( helper ) helper -> item = 0 ; } m_deletedSinceLastFrame . clear ( ) ; } void QQuickAnimatorController :: afterNodeSync ( ) { foreach ( QQuickAnimatorJob * job , m_activeLeafAnimations ) { if ( job -> isUniform ( ) && job -> target ( ) ) static_cast < QQuickUniformAnimatorJob * > ( job ) -> afterNodeSync ( ) ; } } void QQuickAnimatorController :: animationFinished ( QAbstractAnimationJob * job ) { /* ▁ We ▁ are ▁ currently ▁ on ▁ the ▁ render ▁ thread ▁ and ▁ m _ deleting ▁ is ▁ primarily STRNEWLINE ▁ * ▁ being ▁ written ▁ on ▁ the ▁ GUI ▁ Thread ▁ and ▁ read ▁ during ▁ sync . ▁ However , ▁ we ▁ don ' t STRNEWLINE ▁ * ▁ need ▁ to ▁ lock ▁ here ▁ as ▁ this ▁ is ▁ a ▁ direct ▁ result ▁ of ▁ animationDriver - > advance ( ) STRNEWLINE ▁ * ▁ which ▁ is ▁ already ▁ locked . ▁ For ▁ non - threaded ▁ render ▁ loops ▁ no ▁ locking ▁ is STRNEWLINE ▁ * ▁ needed ▁ in ▁ any ▁ case . STRNEWLINE ▁ */ if ( ! m_deleting . contains ( job ) ) { QQuickAnimatorProxyJob * proxy = m_animatorRoots [ job ] ; if ( proxy ) QCoreApplication :: postEvent ( proxy , new QEvent ( QEvent :: User ) ) ; // ▁ else ▁ already ▁ gone . . . ENDCOM } } void QQuickAnimatorController :: animationStateChanged ( QAbstractAnimationJob * job , QAbstractAnimationJob :: State newState , QAbstractAnimationJob :: State oldState ) { Q_ASSERT ( job -> isRenderThreadJob ( ) ) ; QQuickAnimatorJob * animator = static_cast < QQuickAnimatorJob * > ( job ) ; if ( newState == QAbstractAnimationJob :: Running ) { m_activeLeafAnimations << animator ; animator -> setHasBeenRunning ( true ) ; } else if ( oldState == QAbstractAnimationJob :: Running ) { m_activeLeafAnimations . remove ( animator ) ; } } void QQuickAnimatorController :: requestSync ( ) { // ▁ Force ▁ a ▁ " sync " ▁ pass ▁ as ▁ the ▁ newly ▁ started ▁ animation ▁ needs ▁ to ▁ sync ▁ properties ▁ from ▁ GUI . ENDCOM m_window -> maybeUpdate ( ) ; } // ▁ These ▁ functions ▁ are ▁ called ▁ on ▁ the ▁ GUI ▁ thread . ENDCOM void QQuickAnimatorController :: startJob ( QQuickAnimatorProxyJob * proxy , QAbstractAnimationJob * job ) { m_starting [ job ] = proxy ; requestSync ( ) ; } void QQuickAnimatorController :: stopJob ( QQuickAnimatorProxyJob * proxy , QAbstractAnimationJob * job ) { m_stopping [ job ] = proxy ; requestSync ( ) ; } void QQuickAnimatorController :: deleteJob ( QAbstractAnimationJob * job ) { lock ( ) ; m_deleting << job ; requestSync ( ) ; unlock ( ) ; } QT_END_NAMESPACE </DOCUMENT>
<DOCUMENT_ID="patmarion/PCL/tree/master/sample_consensus/src/ransac.cpp"> /* STRNEWLINE ▁ * ▁ Software ▁ License ▁ Agreement ▁ ( BSD ▁ License ) STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Point ▁ Cloud ▁ Library ▁ ( PCL ) ▁ - ▁ www . pointclouds . org STRNEWLINE ▁ * ▁ Copyright ▁ ( c ) ▁ 2009-2012 , ▁ Willow ▁ Garage , ▁ Inc . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ All ▁ rights ▁ reserved . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Redistribution ▁ and ▁ use ▁ in ▁ source ▁ and ▁ binary ▁ forms , ▁ with ▁ or ▁ without STRNEWLINE ▁ * ▁ modification , ▁ are ▁ permitted ▁ provided ▁ that ▁ the ▁ following ▁ conditions STRNEWLINE ▁ * ▁ are ▁ met : STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ * ▁ Redistributions ▁ of ▁ source ▁ code ▁ must ▁ retain ▁ the ▁ above ▁ copyright STRNEWLINE ▁ * ▁ notice , ▁ this ▁ list ▁ of ▁ conditions ▁ and ▁ the ▁ following ▁ disclaimer . STRNEWLINE ▁ * ▁ * ▁ Redistributions ▁ in ▁ binary ▁ form ▁ must ▁ reproduce ▁ the ▁ above STRNEWLINE ▁ * ▁ copyright ▁ notice , ▁ this ▁ list ▁ of ▁ conditions ▁ and ▁ the ▁ following STRNEWLINE ▁ * ▁ disclaimer ▁ in ▁ the ▁ documentation ▁ and / or ▁ other ▁ materials ▁ provided STRNEWLINE ▁ * ▁ with ▁ the ▁ distribution . STRNEWLINE ▁ * ▁ * ▁ Neither ▁ the ▁ name ▁ of ▁ Willow ▁ Garage , ▁ Inc . ▁ nor ▁ the ▁ names ▁ of ▁ its STRNEWLINE ▁ * ▁ contributors ▁ may ▁ be ▁ used ▁ to ▁ endorse ▁ or ▁ promote ▁ products ▁ derived STRNEWLINE ▁ * ▁ from ▁ this ▁ software ▁ without ▁ specific ▁ prior ▁ written ▁ permission . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ THIS ▁ SOFTWARE ▁ IS ▁ PROVIDED ▁ BY ▁ THE ▁ COPYRIGHT ▁ HOLDERS ▁ AND ▁ CONTRIBUTORS STRNEWLINE ▁ * ▁ " AS ▁ IS " ▁ AND ▁ ANY ▁ EXPRESS ▁ OR ▁ IMPLIED ▁ WARRANTIES , ▁ INCLUDING , ▁ BUT ▁ NOT STRNEWLINE ▁ * ▁ LIMITED ▁ TO , ▁ THE ▁ IMPLIED ▁ WARRANTIES ▁ OF ▁ MERCHANTABILITY ▁ AND ▁ FITNESS STRNEWLINE ▁ * ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE ▁ ARE ▁ DISCLAIMED . ▁ IN ▁ NO ▁ EVENT ▁ SHALL ▁ THE STRNEWLINE ▁ * ▁ COPYRIGHT ▁ OWNER ▁ OR ▁ CONTRIBUTORS ▁ BE ▁ LIABLE ▁ FOR ▁ ANY ▁ DIRECT , ▁ INDIRECT , STRNEWLINE ▁ * ▁ INCIDENTAL , ▁ SPECIAL , ▁ EXEMPLARY , ▁ OR ▁ CONSEQUENTIAL ▁ DAMAGES ▁ ( INCLUDING , STRNEWLINE ▁ * ▁ BUT ▁ NOT ▁ LIMITED ▁ TO , ▁ PROCUREMENT ▁ OF ▁ SUBSTITUTE ▁ GOODS ▁ OR ▁ SERVICES ; STRNEWLINE ▁ * ▁ LOSS ▁ OF ▁ USE , ▁ DATA , ▁ OR ▁ PROFITS ; ▁ OR ▁ BUSINESS ▁ INTERRUPTION ) ▁ HOWEVER STRNEWLINE ▁ * ▁ CAUSED ▁ AND ▁ ON ▁ ANY ▁ THEORY ▁ OF ▁ LIABILITY , ▁ WHETHER ▁ IN ▁ CONTRACT , ▁ STRICT STRNEWLINE ▁ * ▁ LIABILITY , ▁ OR ▁ TORT ▁ ( INCLUDING ▁ NEGLIGENCE ▁ OR ▁ OTHERWISE ) ▁ ARISING ▁ IN STRNEWLINE ▁ * ▁ ANY ▁ WAY ▁ OUT ▁ OF ▁ THE ▁ USE ▁ OF ▁ THIS ▁ SOFTWARE , ▁ EVEN ▁ IF ▁ ADVISED ▁ OF ▁ THE STRNEWLINE ▁ * ▁ POSSIBILITY ▁ OF ▁ SUCH ▁ DAMAGE . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ $ Id $ STRNEWLINE ▁ * STRNEWLINE ▁ */ # include < pcl / impl / instantiate . hpp > # include < pcl / point_types . h > # include < pcl / sample_consensus / ransac . h > # include < pcl / sample_consensus / impl / ransac . hpp > // ▁ Instantiations ▁ of ▁ specific ▁ point ▁ types ENDCOM # ifdef PCL_ONLY_CORE_POINT_TYPES PCL_INSTANTIATE ( RandomSampleConsensus , ( pcl :: PointXYZ ) ( pcl :: PointXYZI ) ( pcl :: PointXYZRGBA ) ( pcl :: PointXYZRGB ) ) # else PCL_INSTANTIATE ( RandomSampleConsensus , PCL_XYZ_POINT_TYPES ) # endif </DOCUMENT>
<DOCUMENT_ID="attilahorvath/phantomjs/tree/master/src/qt/qtwebkit/Source/JavaScriptCore/llint/LLIntEntrypoints.cpp"> /* STRNEWLINE ▁ * ▁ Copyright ▁ ( C ) ▁ 2012 ▁ Apple ▁ Inc . ▁ All ▁ rights ▁ reserved . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Redistribution ▁ and ▁ use ▁ in ▁ source ▁ and ▁ binary ▁ forms , ▁ with ▁ or ▁ without STRNEWLINE ▁ * ▁ modification , ▁ are ▁ permitted ▁ provided ▁ that ▁ the ▁ following ▁ conditions STRNEWLINE ▁ * ▁ are ▁ met : STRNEWLINE ▁ * ▁ 1 . ▁ Redistributions ▁ of ▁ source ▁ code ▁ must ▁ retain ▁ the ▁ above ▁ copyright STRNEWLINE ▁ * ▁ notice , ▁ this ▁ list ▁ of ▁ conditions ▁ and ▁ the ▁ following ▁ disclaimer . STRNEWLINE ▁ * ▁ 2 . ▁ Redistributions ▁ in ▁ binary ▁ form ▁ must ▁ reproduce ▁ the ▁ above ▁ copyright STRNEWLINE ▁ * ▁ notice , ▁ this ▁ list ▁ of ▁ conditions ▁ and ▁ the ▁ following ▁ disclaimer ▁ in ▁ the STRNEWLINE ▁ * ▁ documentation ▁ and / or ▁ other ▁ materials ▁ provided ▁ with ▁ the ▁ distribution . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ THIS ▁ SOFTWARE ▁ IS ▁ PROVIDED ▁ BY ▁ APPLE ▁ INC . ▁ ` ` AS ▁ IS ' ' ▁ AND ▁ ANY STRNEWLINE ▁ * ▁ EXPRESS ▁ OR ▁ IMPLIED ▁ WARRANTIES , ▁ INCLUDING , ▁ BUT ▁ NOT ▁ LIMITED ▁ TO , ▁ THE STRNEWLINE ▁ * ▁ IMPLIED ▁ WARRANTIES ▁ OF ▁ MERCHANTABILITY ▁ AND ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR STRNEWLINE ▁ * ▁ PURPOSE ▁ ARE ▁ DISCLAIMED . ▁ IN ▁ NO ▁ EVENT ▁ SHALL ▁ APPLE ▁ INC . ▁ OR STRNEWLINE ▁ * ▁ CONTRIBUTORS ▁ BE ▁ LIABLE ▁ FOR ▁ ANY ▁ DIRECT , ▁ INDIRECT , ▁ INCIDENTAL , ▁ SPECIAL , STRNEWLINE ▁ * ▁ EXEMPLARY , ▁ OR ▁ CONSEQUENTIAL ▁ DAMAGES ▁ ( INCLUDING , ▁ BUT ▁ NOT ▁ LIMITED ▁ TO , STRNEWLINE ▁ * ▁ PROCUREMENT ▁ OF ▁ SUBSTITUTE ▁ GOODS ▁ OR ▁ SERVICES ; ▁ LOSS ▁ OF ▁ USE , ▁ DATA , ▁ OR STRNEWLINE ▁ * ▁ PROFITS ; ▁ OR ▁ BUSINESS ▁ INTERRUPTION ) ▁ HOWEVER ▁ CAUSED ▁ AND ▁ ON ▁ ANY ▁ THEORY STRNEWLINE ▁ * ▁ OF ▁ LIABILITY , ▁ WHETHER ▁ IN ▁ CONTRACT , ▁ STRICT ▁ LIABILITY , ▁ OR ▁ TORT STRNEWLINE ▁ * ▁ ( INCLUDING ▁ NEGLIGENCE ▁ OR ▁ OTHERWISE ) ▁ ARISING ▁ IN ▁ ANY ▁ WAY ▁ OUT ▁ OF ▁ THE ▁ USE STRNEWLINE ▁ * ▁ OF ▁ THIS ▁ SOFTWARE , ▁ EVEN ▁ IF ▁ ADVISED ▁ OF ▁ THE ▁ POSSIBILITY ▁ OF ▁ SUCH ▁ DAMAGE . ▁ STRNEWLINE ▁ */ # include " config . h " # include " LLIntEntrypoints . h " # if ENABLE ( LLINT ) # include " JITCode . h " # include " VM . h " # include " JSObject . h " # include " LLIntThunks . h " # include " LowLevelInterpreter . h " namespace JSC { namespace LLInt { void getFunctionEntrypoint ( VM & vm , CodeSpecializationKind kind , JITCode & jitCode , MacroAssemblerCodePtr & arityCheck ) { if ( ! vm . canUseJIT ( ) ) { if ( kind == CodeForCall ) { jitCode = JITCode ( MacroAssemblerCodeRef :: createLLIntCodeRef ( llint_function_for_call_prologue ) , JITCode :: InterpreterThunk ) ; arityCheck = MacroAssemblerCodePtr :: createLLIntCodePtr ( llint_function_for_call_arity_check ) ; return ; } ASSERT ( kind == CodeForConstruct ) ; jitCode = JITCode ( MacroAssemblerCodeRef :: createLLIntCodeRef ( llint_function_for_construct_prologue ) , JITCode :: InterpreterThunk ) ; arityCheck = MacroAssemblerCodePtr :: createLLIntCodePtr ( llint_function_for_construct_arity_check ) ; return ; } # if ENABLE ( JIT ) if ( kind == CodeForCall ) { jitCode = JITCode ( vm . getCTIStub ( functionForCallEntryThunkGenerator ) , JITCode :: InterpreterThunk ) ; arityCheck = vm . getCTIStub ( functionForCallArityCheckThunkGenerator ) . code ( ) ; return ; } ASSERT ( kind == CodeForConstruct ) ; jitCode = JITCode ( vm . getCTIStub ( functionForConstructEntryThunkGenerator ) , JITCode :: InterpreterThunk ) ; arityCheck = vm . getCTIStub ( functionForConstructArityCheckThunkGenerator ) . code ( ) ; # endif // ▁ ENABLE ( JIT ) ENDCOM } void getEvalEntrypoint ( VM & vm , JITCode & jitCode ) { if ( ! vm . canUseJIT ( ) ) { jitCode = JITCode ( MacroAssemblerCodeRef :: createLLIntCodeRef ( llint_eval_prologue ) , JITCode :: InterpreterThunk ) ; return ; } # if ENABLE ( JIT ) jitCode = JITCode ( vm . getCTIStub ( evalEntryThunkGenerator ) , JITCode :: InterpreterThunk ) ; # endif } void getProgramEntrypoint ( VM & vm , JITCode & jitCode ) { if ( ! vm . canUseJIT ( ) ) { jitCode = JITCode ( MacroAssemblerCodeRef :: createLLIntCodeRef ( llint_program_prologue ) , JITCode :: InterpreterThunk ) ; return ; } # if ENABLE ( JIT ) jitCode = JITCode ( vm . getCTIStub ( programEntryThunkGenerator ) , JITCode :: InterpreterThunk ) ; # endif } } } // ▁ namespace ▁ JSC : : LLInt ENDCOM # endif // ▁ ENABLE ( LLINT ) ENDCOM </DOCUMENT>
<DOCUMENT_ID="sacarlson/MultiCoin-exp/tree/master/src/db.cpp"> // ▁ Copyright ▁ ( c ) ▁ 2009-2010 ▁ Satoshi ▁ Nakamoto ENDCOM // ▁ Distributed ▁ under ▁ the ▁ MIT / X11 ▁ software ▁ license , ▁ see ▁ the ▁ accompanying ENDCOM // ▁ file ▁ license . txt ▁ or ▁ http : // www . opensource . org / licenses / mit - license . php . ENDCOM # include " headers . h " # include " db . h " # include " net . h " # include " auxpow . h " # include < boost / filesystem . hpp > # include < boost / filesystem / fstream . hpp > using namespace std ; using namespace boost ; unsigned int nWalletDBUpdated ; uint64 nAccountingEntryNumber = 0 ; // ▁ CDB ENDCOM static CCriticalSection cs_db ; static bool fDbEnvInit = false ; DbEnv dbenv ( 0 ) ; static map < string , int > mapFileUseCount ; static map < string , Db * > mapDb ; class CDBInit { public : CDBInit ( ) { } ~ CDBInit ( ) { if ( fDbEnvInit ) { dbenv . close ( 0 ) ; fDbEnvInit = false ; } } } instance_of_cdbinit ; CDB :: CDB ( const char * pszFile , const char * pszMode ) : pdb ( NULL ) { int ret ; if ( pszFile == NULL ) return ; fReadOnly = ( ! strchr ( pszMode , ' + ' ) && ! strchr ( pszMode , ' w ' ) ) ; bool fCreate = strchr ( pszMode , ' c ' ) ; unsigned int nFlags = DB_THREAD ; if ( fCreate ) nFlags |= DB_CREATE ; CRITICAL_BLOCK ( cs_db ) { if ( ! fDbEnvInit ) { if ( fShutdown ) return ; string strDataDir = GetDataDir ( ) ; string strLogDir = strDataDir + " / database " ; filesystem :: create_directory ( strLogDir . c_str ( ) ) ; string strErrorFile = strDataDir + " / db . log " ; printf ( " dbenv . open ▁ strLogDir = % s ▁ strErrorFile = % s \n " , strLogDir . c_str ( ) , strErrorFile . c_str ( ) ) ; dbenv . set_lg_dir ( strLogDir . c_str ( ) ) ; dbenv . set_lg_max ( 10000000 ) ; dbenv . set_lk_max_locks ( 10000 ) ; dbenv . set_lk_max_objects ( 10000 ) ; dbenv . set_errfile ( fopen ( strErrorFile . c_str ( ) , " a " ) ) ; // / ▁ debug ENDCOM dbenv . set_flags ( DB_AUTO_COMMIT , 1 ) ; ret = dbenv . open ( strDataDir . c_str ( ) , DB_CREATE | DB_INIT_LOCK | DB_INIT_LOG | DB_INIT_MPOOL | DB_INIT_TXN | DB_THREAD | DB_RECOVER , S_IRUSR | S_IWUSR ) ; if ( ret > 0 ) throw runtime_error ( strprintf ( " CDB ( ) ▁ : ▁ error ▁ % d ▁ opening ▁ database ▁ environment " , ret ) ) ; fDbEnvInit = true ; } strFile = pszFile ; ++ mapFileUseCount [ strFile ] ; pdb = mapDb [ strFile ] ; if ( pdb == NULL ) { pdb = new Db ( & dbenv , 0 ) ; ret = pdb -> open ( NULL , // ▁ Txn ▁ pointer ENDCOM pszFile , // ▁ Filename ENDCOM " main " , // ▁ Logical ▁ db ▁ name ENDCOM DB_BTREE , // ▁ Database ▁ type ENDCOM nFlags , // ▁ Flags ENDCOM 0 ) ; if ( ret > 0 ) { delete pdb ; pdb = NULL ; CRITICAL_BLOCK ( cs_db ) -- mapFileUseCount [ strFile ] ; strFile = " " ; throw runtime_error ( strprintf ( " CDB ( ) ▁ : ▁ can ' t ▁ open ▁ database ▁ file ▁ % s , ▁ error ▁ % d " , pszFile , ret ) ) ; } if ( fCreate && ! Exists ( string ( " version " ) ) ) { bool fTmp = fReadOnly ; fReadOnly = false ; WriteVersion ( VERSION ) ; fReadOnly = fTmp ; } mapDb [ strFile ] = pdb ; } } } void CDB :: Close ( ) { if ( ! pdb ) return ; if ( ! vTxn . empty ( ) ) vTxn . front ( ) -> abort ( ) ; vTxn . clear ( ) ; pdb = NULL ; // ▁ Flush ▁ database ▁ activity ▁ from ▁ memory ▁ pool ▁ to ▁ disk ▁ log ENDCOM unsigned int nMinutes = 0 ; if ( fReadOnly ) nMinutes = 1 ; if ( strFile == " addr . dat " ) nMinutes = 2 ; if ( strFile == " blkindex . dat " && IsInitialBlockDownload ( ) && nBestHeight % 500 != 0 ) nMinutes = 1 ; dbenv . txn_checkpoint ( 0 , nMinutes , 0 ) ; CRITICAL_BLOCK ( cs_db ) -- mapFileUseCount [ strFile ] ; } void static CloseDb ( const string & strFile ) { CRITICAL_BLOCK ( cs_db ) { if ( mapDb [ strFile ] != NULL ) { // ▁ Close ▁ the ▁ database ▁ handle ENDCOM Db * pdb = mapDb [ strFile ] ; pdb -> close ( 0 ) ; delete pdb ; mapDb [ strFile ] = NULL ; } } } void DBFlush ( bool fShutdown ) { // ▁ Flush ▁ log ▁ data ▁ to ▁ the ▁ actual ▁ data ▁ file ENDCOM // ▁ on ▁ all ▁ files ▁ that ▁ are ▁ not ▁ in ▁ use ENDCOM printf ( " DBFlush ( % s ) % s \n " , fShutdown ? " true " : " false " , fDbEnvInit ? " " : " ▁ db ▁ not ▁ started " ) ; if ( ! fDbEnvInit ) return ; CRITICAL_BLOCK ( cs_db ) { map < string , int > :: iterator mi = mapFileUseCount . begin ( ) ; while ( mi != mapFileUseCount . end ( ) ) { string strFile = ( * mi ) . first ; int nRefCount = ( * mi ) . second ; printf ( " % s ▁ refcount = % d \n " , strFile . c_str ( ) , nRefCount ) ; if ( nRefCount == 0 ) { // ▁ Move ▁ log ▁ data ▁ to ▁ the ▁ dat ▁ file ENDCOM CloseDb ( strFile ) ; dbenv . txn_checkpoint ( 0 , 0 , 0 ) ; printf ( " % s ▁ flush \n " , strFile . c_str ( ) ) ; dbenv . lsn_reset ( strFile . c_str ( ) , 0 ) ; mapFileUseCount . erase ( mi ++ ) ; } else mi ++ ; } if ( fShutdown ) { char * * listp ; if ( mapFileUseCount . empty ( ) ) dbenv . log_archive ( & listp , DB_ARCH_REMOVE ) ; dbenv . close ( 0 ) ; fDbEnvInit = false ; } } } // ▁ CTxDB ENDCOM bool CTxDB :: ReadTxIndex ( uint256 hash , CTxIndex & txindex ) { assert ( ! fClient ) ; txindex . SetNull ( ) ; return Read ( make_pair ( string ( " tx " ) , hash ) , txindex ) ; } bool CTxDB :: UpdateTxIndex ( uint256 hash , const CTxIndex & txindex ) { assert ( ! fClient ) ; return Write ( make_pair ( string ( " tx " ) , hash ) , txindex ) ; } bool CTxDB :: AddTxIndex ( const CTransaction & tx , const CDiskTxPos & pos , int nHeight ) { assert ( ! fClient ) ; // ▁ Add ▁ to ▁ tx ▁ index ENDCOM uint256 hash = tx . GetHash ( ) ; CTxIndex txindex ( pos , tx . vout . size ( ) ) ; return Write ( make_pair ( string ( " tx " ) , hash ) , txindex ) ; } bool CTxDB :: EraseTxIndex ( const CTransaction & tx ) { assert ( ! fClient ) ; uint256 hash = tx . GetHash ( ) ; return Erase ( make_pair ( string ( " tx " ) , hash ) ) ; } bool CTxDB :: ContainsTx ( uint256 hash ) { assert ( ! fClient ) ; return Exists ( make_pair ( string ( " tx " ) , hash ) ) ; } bool CTxDB :: ReadOwnerTxes ( uint160 hash160 , int nMinHeight , vector < CTransaction > & vtx ) { assert ( ! fClient ) ; vtx . clear ( ) ; // ▁ Get ▁ cursor ENDCOM Dbc * pcursor = GetCursor ( ) ; if ( ! pcursor ) return false ; unsigned int fFlags = DB_SET_RANGE ; loop { // ▁ Read ▁ next ▁ record ENDCOM CDataStream ssKey ; if ( fFlags == DB_SET_RANGE ) ssKey << string ( " owner " ) << hash160 << CDiskTxPos ( 0 , 0 , 0 ) ; CDataStream ssValue ; int ret = ReadAtCursor ( pcursor , ssKey , ssValue , fFlags ) ; fFlags = DB_NEXT ; if ( ret == DB_NOTFOUND ) break ; else if ( ret != 0 ) { pcursor -> close ( ) ; return false ; } // ▁ Unserialize ENDCOM string strType ; uint160 hashItem ; CDiskTxPos pos ; ssKey >> strType >> hashItem >> pos ; int nItemHeight ; ssValue >> nItemHeight ; // ▁ Read ▁ transaction ENDCOM if ( strType != " owner " || hashItem != hash160 ) break ; if ( nItemHeight >= nMinHeight ) { vtx . resize ( vtx . size ( ) + 1 ) ; if ( ! vtx . back ( ) . ReadFromDisk ( pos ) ) { pcursor -> close ( ) ; return false ; } } } pcursor -> close ( ) ; return true ; } bool CTxDB :: ReadDiskTx ( uint256 hash , CTransaction & tx , CTxIndex & txindex ) { assert ( ! fClient ) ; tx . SetNull ( ) ; if ( ! ReadTxIndex ( hash , txindex ) ) return false ; return ( tx . ReadFromDisk ( txindex . pos ) ) ; } bool CTxDB :: ReadDiskTx ( uint256 hash , CTransaction & tx ) { CTxIndex txindex ; return ReadDiskTx ( hash , tx , txindex ) ; } bool CTxDB :: ReadDiskTx ( COutPoint outpoint , CTransaction & tx , CTxIndex & txindex ) { return ReadDiskTx ( outpoint . hash , tx , txindex ) ; } bool CTxDB :: ReadDiskTx ( COutPoint outpoint , CTransaction & tx ) { CTxIndex txindex ; return ReadDiskTx ( outpoint . hash , tx , txindex ) ; } bool CTxDB :: WriteBlockIndex ( const CDiskBlockIndex & blockindex ) { return Write ( make_pair ( string ( " blockindex " ) , blockindex . GetBlockHash ( ) ) , blockindex ) ; } bool CTxDB :: EraseBlockIndex ( uint256 hash ) { return Erase ( make_pair ( string ( " blockindex " ) , hash ) ) ; } bool CTxDB :: ReadHashBestChain ( uint256 & hashBestChain ) { return Read ( string ( " hashBestChain " ) , hashBestChain ) ; } bool CTxDB :: WriteHashBestChain ( uint256 hashBestChain ) { return Write ( string ( " hashBestChain " ) , hashBestChain ) ; } bool CTxDB :: ReadBestInvalidWork ( CBigNum & bnBestInvalidWork ) { return Read ( string ( " bnBestInvalidWork " ) , bnBestInvalidWork ) ; } bool CTxDB :: WriteBestInvalidWork ( CBigNum bnBestInvalidWork ) { return Write ( string ( " bnBestInvalidWork " ) , bnBestInvalidWork ) ; } CBlockIndex static * InsertBlockIndex ( uint256 hash ) { if ( hash == 0 ) return NULL ; // ▁ Return ▁ existing ENDCOM map < uint256 , CBlockIndex * > :: iterator mi = mapBlockIndex . find ( hash ) ; if ( mi != mapBlockIndex . end ( ) ) return ( * mi ) . second ; // ▁ Create ▁ new ENDCOM CBlockIndex * pindexNew = new CBlockIndex ( ) ; if ( ! pindexNew ) throw runtime_error ( " LoadBlockIndex ( ) ▁ : ▁ new ▁ CBlockIndex ▁ failed " ) ; mi = mapBlockIndex . insert ( make_pair ( hash , pindexNew ) ) . first ; pindexNew -> phashBlock = & ( ( * mi ) . first ) ; return pindexNew ; } bool CTxDB :: LoadBlockIndex ( ) { // ▁ Get ▁ database ▁ cursor ENDCOM Dbc * pcursor = GetCursor ( ) ; if ( ! pcursor ) return false ; // ▁ Load ▁ mapBlockIndex ENDCOM unsigned int fFlags = DB_SET_RANGE ; loop { // ▁ Read ▁ next ▁ record ENDCOM CDataStream ssKey ; if ( fFlags == DB_SET_RANGE ) ssKey << make_pair ( string ( " blockindex " ) , uint256 ( 0 ) ) ; CDataStream ssValue ; int ret = ReadAtCursor ( pcursor , ssKey , ssValue , fFlags ) ; fFlags = DB_NEXT ; if ( ret == DB_NOTFOUND ) break ; else if ( ret != 0 ) return false ; // ▁ Unserialize ENDCOM string strType ; ssKey >> strType ; if ( strType == " blockindex " ) { CDiskBlockIndex diskindex ; ssValue >> diskindex ; // ▁ Construct ▁ block ▁ index ▁ object ENDCOM CBlockIndex * pindexNew = InsertBlockIndex ( diskindex . GetBlockHash ( ) ) ; pindexNew -> pprev = InsertBlockIndex ( diskindex . hashPrev ) ; pindexNew -> pnext = InsertBlockIndex ( diskindex . hashNext ) ; pindexNew -> nFile = diskindex . nFile ; pindexNew -> nBlockPos = diskindex . nBlockPos ; pindexNew -> nHeight = diskindex . nHeight ; pindexNew -> nVersion = diskindex . nVersion ; pindexNew -> hashMerkleRoot = diskindex . hashMerkleRoot ; pindexNew -> nTime = diskindex . nTime ; pindexNew -> nBits = diskindex . nBits ; pindexNew -> nNonce = diskindex . nNonce ; pindexNew -> auxpow = diskindex . auxpow ; // ▁ Watch ▁ for ▁ genesis ▁ block ENDCOM if ( pindexGenesisBlock == NULL && diskindex . GetBlockHash ( ) == hashGenesisBlock ) pindexGenesisBlock = pindexNew ; if ( ! pindexNew -> CheckIndex ( ) ) return error ( " LoadBlockIndex ( ) ▁ : ▁ CheckIndex ▁ failed ▁ at ▁ % d " , pindexNew -> nHeight ) ; } else { break ; } } pcursor -> close ( ) ; // ▁ Calculate ▁ bnChainWork ENDCOM vector < pair < int , CBlockIndex * > > vSortedByHeight ; vSortedByHeight . reserve ( mapBlockIndex . size ( ) ) ; BOOST_FOREACH ( const PAIRTYPE ( uint256 , CBlockIndex * ) & item , mapBlockIndex ) { CBlockIndex * pindex = item . second ; vSortedByHeight . push_back ( make_pair ( pindex -> nHeight , pindex ) ) ; } sort ( vSortedByHeight . begin ( ) , vSortedByHeight . end ( ) ) ; BOOST_FOREACH ( const PAIRTYPE ( int , CBlockIndex * ) & item , vSortedByHeight ) { CBlockIndex * pindex = item . second ; pindex -> bnChainWork = ( pindex -> pprev ? pindex -> pprev -> bnChainWork : 0 ) + pindex -> GetBlockWork ( ) ; } // ▁ Load ▁ hashBestChain ▁ pointer ▁ to ▁ end ▁ of ▁ best ▁ chain ENDCOM if ( ! ReadHashBestChain ( hashBestChain ) ) { if ( pindexGenesisBlock == NULL ) return true ; return error ( " CTxDB : : LoadBlockIndex ( ) ▁ : ▁ hashBestChain ▁ not ▁ loaded " ) ; } if ( ! mapBlockIndex . count ( hashBestChain ) ) return error ( " CTxDB : : LoadBlockIndex ( ) ▁ : ▁ hashBestChain ▁ not ▁ found ▁ in ▁ the ▁ block ▁ index " ) ; pindexBest = mapBlockIndex [ hashBestChain ] ; nBestHeight = pindexBest -> nHeight ; bnBestChainWork = pindexBest -> bnChainWork ; printf ( " LoadBlockIndex ( ) : ▁ hashBestChain = % s ▁ ▁ height = % d \n " , hashBestChain . ToString ( ) . substr ( 0 , 20 ) . c_str ( ) , nBestHeight ) ; // ▁ Load ▁ bnBestInvalidWork , ▁ OK ▁ if ▁ it ▁ doesn ' t ▁ exist ENDCOM ReadBestInvalidWork ( bnBestInvalidWork ) ; // ▁ Verify ▁ blocks ▁ in ▁ the ▁ best ▁ chain ENDCOM CBlockIndex * pindexFork = NULL ; for ( CBlockIndex * pindex = pindexBest ; pindex && pindex -> pprev ; pindex = pindex -> pprev ) { if ( pindex -> nHeight < nBestHeight - 2500 && ! mapArgs . count ( " - checkblocks " ) ) break ; CBlock block ; if ( ! block . ReadFromDisk ( pindex ) ) return error ( " LoadBlockIndex ( ) ▁ : ▁ block . ReadFromDisk ▁ failed " ) ; if ( ! block . CheckBlock ( pindex -> nHeight ) ) { printf ( " LoadBlockIndex ( ) ▁ : ▁ * * * ▁ found ▁ bad ▁ block ▁ at ▁ % d , ▁ hash = % s \n " , pindex -> nHeight , pindex -> GetBlockHash ( ) . ToString ( ) . c_str ( ) ) ; pindexFork = pindex -> pprev ; } } if ( pindexFork ) { // ▁ Reorg ▁ back ▁ to ▁ the ▁ fork ENDCOM printf ( " LoadBlockIndex ( ) ▁ : ▁ * * * ▁ moving ▁ best ▁ chain ▁ pointer ▁ back ▁ to ▁ block ▁ % d \n " , pindexFork -> nHeight ) ; CBlock block ; if ( ! block . ReadFromDisk ( pindexFork ) ) return error ( " LoadBlockIndex ( ) ▁ : ▁ block . ReadFromDisk ▁ failed " ) ; CTxDB txdb ; block . SetBestChain ( txdb , pindexFork ) ; } return true ; } // ▁ CAddrDB ENDCOM bool CAddrDB :: WriteAddress ( const CAddress & addr ) { return Write ( make_pair ( string ( " addr " ) , addr . GetKey ( ) ) , addr ) ; } bool CAddrDB :: EraseAddress ( const CAddress & addr ) { return Erase ( make_pair ( string ( " addr " ) , addr . GetKey ( ) ) ) ; } bool CAddrDB :: LoadAddresses ( ) { CRITICAL_BLOCK ( cs_mapAddresses ) { // ▁ Load ▁ user ▁ provided ▁ addresses ENDCOM CAutoFile filein = fopen ( ( GetDataDir ( ) + " / addr . txt " ) . c_str ( ) , " rt " ) ; if ( filein ) { try { char psz [ 1000 ] ; while ( fgets ( psz , sizeof ( psz ) , filein ) ) { CAddress addr ( psz , NODE_NETWORK ) ; addr . nTime = 0 ; // ▁ so ▁ it ▁ won ' t ▁ relay ▁ unless ▁ successfully ▁ connected ENDCOM if ( addr . IsValid ( ) ) AddAddress ( addr ) ; } } catch ( ... ) { } } // ▁ Get ▁ cursor ENDCOM Dbc * pcursor = GetCursor ( ) ; if ( ! pcursor ) return false ; loop { // ▁ Read ▁ next ▁ record ENDCOM CDataStream ssKey ; CDataStream ssValue ; int ret = ReadAtCursor ( pcursor , ssKey , ssValue ) ; if ( ret == DB_NOTFOUND ) break ; else if ( ret != 0 ) return false ; // ▁ Unserialize ENDCOM string strType ; ssKey >> strType ; if ( strType == " addr " ) { CAddress addr ; ssValue >> addr ; mapAddresses . insert ( make_pair ( addr . GetKey ( ) , addr ) ) ; } } pcursor -> close ( ) ; printf ( " Loaded ▁ % d ▁ addresses \n " , mapAddresses . size ( ) ) ; } return true ; } bool LoadAddresses ( ) { return CAddrDB ( " cr + " ) . LoadAddresses ( ) ; } // ▁ CWalletDB ENDCOM bool CWalletDB :: WriteName ( const string & strAddress , const string & strName ) { nWalletDBUpdated ++ ; return Write ( make_pair ( string ( " name " ) , strAddress ) , strName ) ; } bool CWalletDB :: EraseName ( const string & strAddress ) { // ▁ This ▁ should ▁ only ▁ be ▁ used ▁ for ▁ sending ▁ addresses , ▁ never ▁ for ▁ receiving ▁ addresses , ENDCOM // ▁ receiving ▁ addresses ▁ must ▁ always ▁ have ▁ an ▁ address ▁ book ▁ entry ▁ if ▁ they ' re ▁ not ▁ change ▁ return . ENDCOM nWalletDBUpdated ++ ; return Erase ( make_pair ( string ( " name " ) , strAddress ) ) ; } bool CWalletDB :: ReadAccount ( const string & strAccount , CAccount & account ) { account . SetNull ( ) ; return Read ( make_pair ( string ( " acc " ) , strAccount ) , account ) ; } bool CWalletDB :: WriteAccount ( const string & strAccount , const CAccount & account ) { return Write ( make_pair ( string ( " acc " ) , strAccount ) , account ) ; } bool CWalletDB :: WriteAccountingEntry ( const CAccountingEntry & acentry ) { return Write ( make_tuple ( string ( " acentry " ) , acentry . strAccount , ++ nAccountingEntryNumber ) , acentry ) ; } int64 CWalletDB :: GetAccountCreditDebit ( const string & strAccount ) { list < CAccountingEntry > entries ; ListAccountCreditDebit ( strAccount , entries ) ; int64 nCreditDebit = 0 ; BOOST_FOREACH ( const CAccountingEntry & entry , entries ) nCreditDebit += entry . nCreditDebit ; return nCreditDebit ; } void CWalletDB :: ListAccountCreditDebit ( const string & strAccount , list < CAccountingEntry > & entries ) { int64 nCreditDebit = 0 ; bool fAllAccounts = ( strAccount == " * " ) ; Dbc * pcursor = GetCursor ( ) ; if ( ! pcursor ) throw runtime_error ( " CWalletDB : : ListAccountCreditDebit ( ) ▁ : ▁ cannot ▁ create ▁ DB ▁ cursor " ) ; unsigned int fFlags = DB_SET_RANGE ; loop { // ▁ Read ▁ next ▁ record ENDCOM CDataStream ssKey ; if ( fFlags == DB_SET_RANGE ) ssKey << make_tuple ( string ( " acentry " ) , ( fAllAccounts ? string ( " " ) : strAccount ) , uint64 ( 0 ) ) ; CDataStream ssValue ; int ret = ReadAtCursor ( pcursor , ssKey , ssValue , fFlags ) ; fFlags = DB_NEXT ; if ( ret == DB_NOTFOUND ) break ; else if ( ret != 0 ) { pcursor -> close ( ) ; throw runtime_error ( " CWalletDB : : ListAccountCreditDebit ( ) ▁ : ▁ error ▁ scanning ▁ DB " ) ; } // ▁ Unserialize ENDCOM string strType ; ssKey >> strType ; if ( strType != " acentry " ) break ; CAccountingEntry acentry ; ssKey >> acentry . strAccount ; if ( ! fAllAccounts && acentry . strAccount != strAccount ) break ; ssValue >> acentry ; entries . push_back ( acentry ) ; } pcursor -> close ( ) ; } bool CWalletDB :: LoadWallet ( CWallet * pwallet ) { pwallet -> vchDefaultKey . clear ( ) ; int nFileVersion = 0 ; vector < uint256 > vWalletUpgrade ; // ▁ Modify ▁ defaults ENDCOM # ifndef __WXMSW__ // ▁ Tray ▁ icon ▁ sometimes ▁ disappears ▁ on ▁ 9.10 ▁ karmic ▁ koala ▁ 64 - bit , ▁ leaving ▁ no ▁ way ▁ to ▁ access ▁ the ▁ program ENDCOM fMinimizeToTray = false ; fMinimizeOnClose = false ; # endif // // ▁ todo : ▁ shouldn ' t ▁ we ▁ catch ▁ exceptions ▁ and ▁ try ▁ to ▁ recover ▁ and ▁ continue ? ENDCOM CRITICAL_BLOCK ( pwallet -> cs_mapWallet ) CRITICAL_BLOCK ( pwallet -> cs_mapKeys ) { // ▁ Get ▁ cursor ENDCOM Dbc * pcursor = GetCursor ( ) ; if ( ! pcursor ) return false ; loop { // ▁ Read ▁ next ▁ record ENDCOM CDataStream ssKey ; CDataStream ssValue ; int ret = ReadAtCursor ( pcursor , ssKey , ssValue ) ; if ( ret == DB_NOTFOUND ) break ; else if ( ret != 0 ) return false ; // ▁ Unserialize ENDCOM // ▁ Taking ▁ advantage ▁ of ▁ the ▁ fact ▁ that ▁ pair ▁ serialization ENDCOM // ▁ is ▁ just ▁ the ▁ two ▁ items ▁ serialized ▁ one ▁ after ▁ the ▁ other ENDCOM string strType ; ssKey >> strType ; if ( strType == " name " ) { string strAddress ; ssKey >> strAddress ; ssValue >> pwallet -> mapAddressBook [ strAddress ] ; } else if ( strType == " tx " ) { uint256 hash ; ssKey >> hash ; CWalletTx & wtx = pwallet -> mapWallet [ hash ] ; ssValue >> wtx ; wtx . pwallet = pwallet ; if ( wtx . GetHash ( ) != hash ) printf ( " Error ▁ in ▁ wallet . dat , ▁ hash ▁ mismatch \n " ) ; // ▁ Undo ▁ serialize ▁ changes ▁ in ▁ 31600 ENDCOM if ( 31404 <= wtx . fTimeReceivedIsTxTime && wtx . fTimeReceivedIsTxTime <= 31703 ) { if ( ! ssValue . empty ( ) ) { char fTmp ; char fUnused ; ssValue >> fTmp >> fUnused >> wtx . strFromAccount ; printf ( " LoadWallet ( ) ▁ upgrading ▁ tx ▁ ver = % d ▁ % d ▁ ' % s ' ▁ % s \n " , wtx . fTimeReceivedIsTxTime , fTmp , wtx . strFromAccount . c_str ( ) , hash . ToString ( ) . c_str ( ) ) ; wtx . fTimeReceivedIsTxTime = fTmp ; } else { printf ( " LoadWallet ( ) ▁ repairing ▁ tx ▁ ver = % d ▁ % s \n " , wtx . fTimeReceivedIsTxTime , hash . ToString ( ) . c_str ( ) ) ; wtx . fTimeReceivedIsTxTime = 0 ; } vWalletUpgrade . push_back ( hash ) ; } // // ▁ debug ▁ print ENDCOM // printf ( " LoadWallet ▁ % s \n " , ▁ wtx . GetHash ( ) . ToString ( ) . c _ str ( ) ) ; ENDCOM // printf ( " ▁ % 12I64d ▁ % s ▁ % s ▁ % s \n " , ENDCOM // ▁ wtx . vout [ 0 ] . nValue , ENDCOM // ▁ DateTimeStrFormat ( " % x ▁ % H : % M : % S " , ▁ wtx . GetBlockTime ( ) ) . c _ str ( ) , ENDCOM // ▁ wtx . hashBlock . ToString ( ) . substr ( 0,20 ) . c _ str ( ) , ENDCOM // ▁ wtx . mapValue [ " message " ] . c _ str ( ) ) ; ENDCOM } else if ( strType == " acentry " ) { string strAccount ; ssKey >> strAccount ; uint64 nNumber ; ssKey >> nNumber ; if ( nNumber > nAccountingEntryNumber ) nAccountingEntryNumber = nNumber ; } else if ( strType == " key " || strType == " wkey " ) { vector < unsigned char > vchPubKey ; ssKey >> vchPubKey ; CWalletKey wkey ; if ( strType == " key " ) ssValue >> wkey . vchPrivKey ; else ssValue >> wkey ; pwallet -> mapKeys [ vchPubKey ] = wkey . vchPrivKey ; mapPubKeys [ Hash160 ( vchPubKey ) ] = vchPubKey ; } else if ( strType == " defaultkey " ) { ssValue >> pwallet -> vchDefaultKey ; } else if ( strType == " pool " ) { int64 nIndex ; ssKey >> nIndex ; pwallet -> setKeyPool . insert ( nIndex ) ; } else if ( strType == " version " ) { ssValue >> nFileVersion ; if ( nFileVersion == 10300 ) nFileVersion = 300 ; } else if ( strType == " setting " ) { string strKey ; ssKey >> strKey ; // ▁ Options ENDCOM # ifndef GUI if ( strKey == " fGenerateBitcoins " ) ssValue >> fGenerateBitcoins ; # endif if ( strKey == " nTransactionFee " ) ssValue >> nTransactionFee ; if ( strKey == " addrIncoming " ) ssValue >> addrIncoming ; if ( strKey == " fLimitProcessors " ) ssValue >> fLimitProcessors ; if ( strKey == " nLimitProcessors " ) ssValue >> nLimitProcessors ; if ( strKey == " fMinimizeToTray " ) ssValue >> fMinimizeToTray ; if ( strKey == " fMinimizeOnClose " ) ssValue >> fMinimizeOnClose ; if ( strKey == " fUseProxy " ) ssValue >> fUseProxy ; if ( strKey == " addrProxy " ) ssValue >> addrProxy ; if ( fHaveUPnP && strKey == " fUseUPnP " ) ssValue >> fUseUPnP ; } } pcursor -> close ( ) ; } BOOST_FOREACH ( uint256 hash , vWalletUpgrade ) WriteTx ( hash , pwallet -> mapWallet [ hash ] ) ; printf ( " nFileVersion ▁ = ▁ % d \n " , nFileVersion ) ; printf ( " fGenerateBitcoins ▁ = ▁ % d \n " , fGenerateBitcoins ) ; printf ( " nTransactionFee ▁ = ▁ % " PRI64d " \n " , nTransactionFee ) ; printf ( " addrIncoming ▁ = ▁ % s \n " , addrIncoming . ToString ( ) . c_str ( ) ) ; printf ( " fMinimizeToTray ▁ = ▁ % d \n " , fMinimizeToTray ) ; printf ( " fMinimizeOnClose ▁ = ▁ % d \n " , fMinimizeOnClose ) ; printf ( " fUseProxy ▁ = ▁ % d \n " , fUseProxy ) ; printf ( " addrProxy ▁ = ▁ % s \n " , addrProxy . ToString ( ) . c_str ( ) ) ; if ( fHaveUPnP ) printf ( " fUseUPnP ▁ = ▁ % d \n " , fUseUPnP ) ; // ▁ Upgrade ENDCOM if ( nFileVersion < VERSION ) { // ▁ Get ▁ rid ▁ of ▁ old ▁ debug . log ▁ file ▁ in ▁ current ▁ directory ENDCOM if ( nFileVersion <= 105 && ! pszSetDataDir [ 0 ] ) unlink ( " debug . log " ) ; WriteVersion ( VERSION ) ; } return true ; } void ThreadFlushWalletDB ( void * parg ) { const string & strFile = ( ( const string * ) parg ) [ 0 ] ; static bool fOneThread ; if ( fOneThread ) return ; fOneThread = true ; if ( mapArgs . count ( " - noflushwallet " ) ) return ; unsigned int nLastSeen = nWalletDBUpdated ; unsigned int nLastFlushed = nWalletDBUpdated ; int64 nLastWalletUpdate = GetTime ( ) ; while ( ! fShutdown ) { Sleep ( 500 ) ; if ( nLastSeen != nWalletDBUpdated ) { nLastSeen = nWalletDBUpdated ; nLastWalletUpdate = GetTime ( ) ; } if ( nLastFlushed != nWalletDBUpdated && GetTime ( ) - nLastWalletUpdate >= 2 ) { TRY_CRITICAL_BLOCK ( cs_db ) { // ▁ Don ' t ▁ do ▁ this ▁ if ▁ any ▁ databases ▁ are ▁ in ▁ use ENDCOM int nRefCount = 0 ; map < string , int > :: iterator mi = mapFileUseCount . begin ( ) ; while ( mi != mapFileUseCount . end ( ) ) { nRefCount += ( * mi ) . second ; mi ++ ; } if ( nRefCount == 0 && ! fShutdown ) { map < string , int > :: iterator mi = mapFileUseCount . find ( strFile ) ; if ( mi != mapFileUseCount . end ( ) ) { printf ( " % s ▁ " , DateTimeStrFormat ( " % x ▁ % H : % M : % S " , GetTime ( ) ) . c_str ( ) ) ; printf ( " Flushing ▁ wallet . dat \n " ) ; nLastFlushed = nWalletDBUpdated ; int64 nStart = GetTimeMillis ( ) ; // ▁ Flush ▁ wallet . dat ▁ so ▁ it ' s ▁ self ▁ contained ENDCOM CloseDb ( strFile ) ; dbenv . txn_checkpoint ( 0 , 0 , 0 ) ; dbenv . lsn_reset ( strFile . c_str ( ) , 0 ) ; mapFileUseCount . erase ( mi ++ ) ; printf ( " Flushed ▁ wallet . dat ▁ % " PRI64d " ms \n " , GetTimeMillis ( ) - nStart ) ; } } } } } } bool BackupWallet ( const CWallet & wallet , const string & strDest ) { if ( ! wallet . fFileBacked ) return false ; while ( ! fShutdown ) { CRITICAL_BLOCK ( cs_db ) { if ( ! mapFileUseCount . count ( wallet . strWalletFile ) || mapFileUseCount [ wallet . strWalletFile ] == 0 ) { // ▁ Flush ▁ log ▁ data ▁ to ▁ the ▁ dat ▁ file ENDCOM CloseDb ( wallet . strWalletFile ) ; dbenv . txn_checkpoint ( 0 , 0 , 0 ) ; dbenv . lsn_reset ( wallet . strWalletFile . c_str ( ) , 0 ) ; mapFileUseCount . erase ( wallet . strWalletFile ) ; // ▁ Copy ▁ wallet . dat ENDCOM filesystem :: path pathSrc ( GetDataDir ( ) + " / " + wallet . strWalletFile ) ; filesystem :: path pathDest ( strDest ) ; if ( filesystem :: is_directory ( pathDest ) ) pathDest = pathDest / wallet . strWalletFile ; # if BOOST_VERSION >= 104000 filesystem :: copy_file ( pathSrc , pathDest , filesystem :: copy_option :: overwrite_if_exists ) ; # else filesystem :: copy_file ( pathSrc , pathDest ) ; # endif printf ( " copied ▁ wallet . dat ▁ to ▁ % s \n " , pathDest . string ( ) . c_str ( ) ) ; return true ; } } Sleep ( 100 ) ; } return false ; } </DOCUMENT>
<DOCUMENT_ID="nawawi/wkhtmltopdf/tree/master/webkit/Source/WebCore/bindings/js/JSDocumentCustom.cpp"> /* STRNEWLINE ▁ * ▁ Copyright ▁ ( C ) ▁ 2007 , ▁ 2008 , ▁ 2009 , ▁ 2011 ▁ Apple ▁ Inc . ▁ All ▁ rights ▁ reserved . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ This ▁ library ▁ is ▁ free ▁ software ; ▁ you ▁ can ▁ redistribute ▁ it ▁ and / or STRNEWLINE ▁ * ▁ modify ▁ it ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ Library ▁ General ▁ Public STRNEWLINE ▁ * ▁ License ▁ as ▁ published ▁ by ▁ the ▁ Free ▁ Software ▁ Foundation ; ▁ either STRNEWLINE ▁ * ▁ version ▁ 2 ▁ of ▁ the ▁ License , ▁ or ▁ ( at ▁ your ▁ option ) ▁ any ▁ later ▁ version . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ This ▁ library ▁ is ▁ distributed ▁ in ▁ the ▁ hope ▁ that ▁ it ▁ will ▁ be ▁ useful , STRNEWLINE ▁ * ▁ but ▁ WITHOUT ▁ ANY ▁ WARRANTY ; ▁ without ▁ even ▁ the ▁ implied ▁ warranty ▁ of STRNEWLINE ▁ * ▁ MERCHANTABILITY ▁ or ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE . ▁ See ▁ the ▁ GNU STRNEWLINE ▁ * ▁ Library ▁ General ▁ Public ▁ License ▁ for ▁ more ▁ details . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ You ▁ should ▁ have ▁ received ▁ a ▁ copy ▁ of ▁ the ▁ GNU ▁ Library ▁ General ▁ Public ▁ License STRNEWLINE ▁ * ▁ along ▁ with ▁ this ▁ library ; ▁ see ▁ the ▁ file ▁ COPYING . LIB . ▁ If ▁ not , ▁ write ▁ to STRNEWLINE ▁ * ▁ the ▁ Free ▁ Software ▁ Foundation , ▁ Inc . , ▁ 51 ▁ Franklin ▁ Street , ▁ Fifth ▁ Floor , STRNEWLINE ▁ * ▁ Boston , ▁ MA ▁ 02110-1301 , ▁ USA . STRNEWLINE ▁ */ # include " config . h " # include " JSDocument . h " # include " ExceptionCode . h " # include " Frame . h " # include " FrameLoader . h " # include " HTMLDocument . h " # include " JSCanvasRenderingContext2D . h " # if ENABLE ( WEBGL ) # include " JSWebGLRenderingContext . h " # endif # include " JSDOMWindowCustom . h " # include " JSHTMLDocument . h " # include " JSLocation . h " # include " JSTouch . h " # include " JSTouchList . h " # include " Location . h " # include " ScriptController . h " # include " TouchList . h " # if ENABLE ( SVG ) # include " JSSVGDocument . h " # include " SVGDocument . h " # endif # include < wtf / GetPtr . h > using namespace JSC ; namespace WebCore { JSValue JSDocument :: location ( ExecState * exec ) const { Frame * frame = static_cast < Document * > ( impl ( ) ) -> frame ( ) ; if ( ! frame ) return jsNull ( ) ; Location * location = frame -> document ( ) -> domWindow ( ) -> location ( ) ; if ( JSDOMWrapper * wrapper = getCachedWrapper ( currentWorld ( exec ) , location ) ) return wrapper ; JSLocation * jsLocation = JSLocation :: create ( getDOMStructure < JSLocation > ( exec , globalObject ( ) ) , globalObject ( ) , location ) ; cacheWrapper ( currentWorld ( exec ) , location , jsLocation ) ; return jsLocation ; } void JSDocument :: setLocation ( ExecState * exec , JSValue value ) { Frame * frame = static_cast < Document * > ( impl ( ) ) -> frame ( ) ; if ( ! frame ) return ; String locationString = value . toString ( exec ) -> value ( exec ) ; if ( exec -> hadException ( ) ) return ; if ( Location * location = frame -> document ( ) -> domWindow ( ) -> location ( ) ) location -> setHref ( locationString , activeDOMWindow ( exec ) , firstDOMWindow ( exec ) ) ; } JSValue toJS ( ExecState * exec , JSDOMGlobalObject * globalObject , Document * document ) { if ( ! document ) return jsNull ( ) ; JSDOMWrapper * wrapper = getCachedWrapper ( currentWorld ( exec ) , document ) ; if ( wrapper ) return wrapper ; if ( DOMWindow * domWindow = document -> domWindow ( ) ) { globalObject = toJSDOMWindow ( toJS ( exec , domWindow ) ) ; // ▁ Creating ▁ a ▁ wrapper ▁ for ▁ domWindow ▁ might ▁ have ▁ created ▁ a ▁ wrapper ▁ for ▁ document ▁ as ▁ well . ENDCOM wrapper = getCachedWrapper ( currentWorld ( exec ) , document ) ; if ( wrapper ) return wrapper ; } if ( document -> isHTMLDocument ( ) ) wrapper = CREATE_DOM_WRAPPER ( exec , globalObject , HTMLDocument , document ) ; # if ENABLE ( SVG ) else if ( document -> isSVGDocument ( ) ) wrapper = CREATE_DOM_WRAPPER ( exec , globalObject , SVGDocument , document ) ; # endif else wrapper = CREATE_DOM_WRAPPER ( exec , globalObject , Document , document ) ; // ▁ Make ▁ sure ▁ the ▁ document ▁ is ▁ kept ▁ around ▁ by ▁ the ▁ window ▁ object , ▁ and ▁ works ▁ right ▁ with ▁ the ENDCOM // ▁ back / forward ▁ cache . ENDCOM if ( ! document -> frame ( ) ) { size_t nodeCount = 0 ; for ( Node * n = document ; n ; n = n -> traverseNextNode ( ) ) nodeCount ++ ; exec -> heap ( ) -> reportExtraMemoryCost ( nodeCount * sizeof ( Node ) ) ; } return wrapper ; } # if ENABLE ( TOUCH_EVENTS ) JSValue JSDocument :: createTouchList ( ExecState * exec ) { RefPtr < TouchList > touchList = TouchList :: create ( ) ; for ( size_t i = 0 ; i < exec -> argumentCount ( ) ; i ++ ) touchList -> append ( toTouch ( exec -> argument ( i ) ) ) ; return toJS ( exec , globalObject ( ) , touchList . release ( ) ) ; } # endif } // ▁ namespace ▁ WebCore ENDCOM </DOCUMENT>
<DOCUMENT_ID="carvalhomb/tsmells/tree/master/sample/poco/poco/Net/src/ICMPPacket.cpp"> // ▁ ICMPPacket . cpp ENDCOM // ▁ $ Id : ▁ // poco / svn / Net / src / ICMPPacket . cpp # 2 ▁ $ ENDCOM // ▁ Library : ▁ Net ENDCOM // ▁ Package : ▁ ICMP ENDCOM // ▁ Module : ▁ ICMPPacket ENDCOM // ▁ Copyright ▁ ( c ) ▁ 2006 , ▁ Applied ▁ Informatics ▁ Software ▁ Engineering ▁ GmbH . ENDCOM // ▁ and ▁ Contributors . ENDCOM // ▁ Permission ▁ is ▁ hereby ▁ granted , ▁ free ▁ of ▁ charge , ▁ to ▁ any ▁ person ▁ or ▁ organization ENDCOM // ▁ obtaining ▁ a ▁ copy ▁ of ▁ the ▁ software ▁ and ▁ accompanying ▁ documentation ▁ covered ▁ by ENDCOM // ▁ this ▁ license ▁ ( the ▁ " Software " ) ▁ to ▁ use , ▁ reproduce , ▁ display , ▁ distribute , ENDCOM // ▁ execute , ▁ and ▁ transmit ▁ the ▁ Software , ▁ and ▁ to ▁ prepare ▁ derivative ▁ works ▁ of ▁ the ENDCOM // ▁ Software , ▁ and ▁ to ▁ permit ▁ third - parties ▁ to ▁ whom ▁ the ▁ Software ▁ is ▁ furnished ▁ to ENDCOM // ▁ do ▁ so , ▁ all ▁ subject ▁ to ▁ the ▁ following : ENDCOM // ▁ The ▁ copyright ▁ notices ▁ in ▁ the ▁ Software ▁ and ▁ this ▁ entire ▁ statement , ▁ including ENDCOM // ▁ the ▁ above ▁ license ▁ grant , ▁ this ▁ restriction ▁ and ▁ the ▁ following ▁ disclaimer , ENDCOM // ▁ must ▁ be ▁ included ▁ in ▁ all ▁ copies ▁ of ▁ the ▁ Software , ▁ in ▁ whole ▁ or ▁ in ▁ part , ▁ and ENDCOM // ▁ all ▁ derivative ▁ works ▁ of ▁ the ▁ Software , ▁ unless ▁ such ▁ copies ▁ or ▁ derivative ENDCOM // ▁ works ▁ are ▁ solely ▁ in ▁ the ▁ form ▁ of ▁ machine - executable ▁ object ▁ code ▁ generated ▁ by ENDCOM // ▁ a ▁ source ▁ language ▁ processor . ENDCOM // ▁ THE ▁ SOFTWARE ▁ IS ▁ PROVIDED ▁ " AS ▁ IS " , ▁ WITHOUT ▁ WARRANTY ▁ OF ▁ ANY ▁ KIND , ▁ EXPRESS ▁ OR ENDCOM // ▁ IMPLIED , ▁ INCLUDING ▁ BUT ▁ NOT ▁ LIMITED ▁ TO ▁ THE ▁ WARRANTIES ▁ OF ▁ MERCHANTABILITY , ENDCOM // ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE , ▁ TITLE ▁ AND ▁ NON - INFRINGEMENT . ▁ IN ▁ NO ▁ EVENT ENDCOM // ▁ SHALL ▁ THE ▁ COPYRIGHT ▁ HOLDERS ▁ OR ▁ ANYONE ▁ DISTRIBUTING ▁ THE ▁ SOFTWARE ▁ BE ▁ LIABLE ENDCOM // ▁ FOR ▁ ANY ▁ DAMAGES ▁ OR ▁ OTHER ▁ LIABILITY , ▁ WHETHER ▁ IN ▁ CONTRACT , ▁ TORT ▁ OR ▁ OTHERWISE , ENDCOM // ▁ ARISING ▁ FROM , ▁ OUT ▁ OF ▁ OR ▁ IN ▁ CONNECTION ▁ WITH ▁ THE ▁ SOFTWARE ▁ OR ▁ THE ▁ USE ▁ OR ▁ OTHER ENDCOM // ▁ DEALINGS ▁ IN ▁ THE ▁ SOFTWARE . ENDCOM # include " Poco / Net / ICMPPacket . h " # include " Poco / Net / ICMPv4PacketImpl . h " # include " Poco / Net / NetException . h " # include " Poco / Timestamp . h " # include " Poco / Timespan . h " # include " Poco / Process . h " # include " Poco / NumberFormatter . h " # include < sstream > using Poco :: InvalidArgumentException ; using Poco :: NotImplementedException ; using Poco :: Timestamp ; using Poco :: Timespan ; using Poco :: Process ; using Poco :: NumberFormatter ; using Poco :: UInt8 ; using Poco :: UInt16 ; using Poco :: Int32 ; namespace Poco { namespace Net { ICMPPacket :: ICMPPacket ( IPAddress :: Family family , int dataSize ) : _pImpl ( 0 ) { if ( family == IPAddress :: IPv4 ) _pImpl = new ICMPv4PacketImpl ( dataSize ) ; # if POCO_HAVE_IPv6 else if ( family == IPAddress :: IPv6 ) throw NotImplementedException ( " ICMPv6 ▁ packets ▁ not ▁ implemented . " ) ; # endif else throw InvalidArgumentException ( " Invalid ▁ or ▁ unsupported ▁ address ▁ family ▁ passed ▁ to ▁ ICMPPacket " ) ; } ICMPPacket :: ~ ICMPPacket ( ) { delete _pImpl ; } void ICMPPacket :: setDataSize ( int dataSize ) { _pImpl -> setDataSize ( dataSize ) ; } int ICMPPacket :: getDataSize ( ) const { return _pImpl -> getDataSize ( ) ; } int ICMPPacket :: packetSize ( ) const { return _pImpl -> packetSize ( ) ; } int ICMPPacket :: maxPacketSize ( ) const { return _pImpl -> maxPacketSize ( ) ; } const Poco :: UInt8 * ICMPPacket :: packet ( ) { return _pImpl -> packet ( ) ; } struct timeval ICMPPacket :: time ( Poco :: UInt8 * buffer , int length ) const { return _pImpl -> time ( buffer , length ) ; } bool ICMPPacket :: validReplyID ( Poco :: UInt8 * buffer , int length ) const { return _pImpl -> validReplyID ( buffer , length ) ; } std :: string ICMPPacket :: errorDescription ( Poco :: UInt8 * buffer , int length ) { return _pImpl -> errorDescription ( buffer , length ) ; } std :: string ICMPPacket :: typeDescription ( int typeId ) { return _pImpl -> typeDescription ( typeId ) ; } } } // ▁ namespace ▁ Poco : : Net ENDCOM </DOCUMENT>
<DOCUMENT_ID="ondra-novak/blink/tree/master/Source/core/svg/SVGFontFaceUriElement.cpp"> /* STRNEWLINE ▁ * ▁ Copyright ▁ ( C ) ▁ 2007 ▁ Eric ▁ Seidel ▁ < eric @ webkit . org > STRNEWLINE ▁ * ▁ Copyright ▁ ( C ) ▁ 2009 ▁ Apple ▁ Inc . ▁ All ▁ rights ▁ reserved . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ This ▁ library ▁ is ▁ free ▁ software ; ▁ you ▁ can ▁ redistribute ▁ it ▁ and / or STRNEWLINE ▁ * ▁ modify ▁ it ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ Library ▁ General ▁ Public STRNEWLINE ▁ * ▁ License ▁ as ▁ published ▁ by ▁ the ▁ Free ▁ Software ▁ Foundation ; ▁ either STRNEWLINE ▁ * ▁ version ▁ 2 ▁ of ▁ the ▁ License , ▁ or ▁ ( at ▁ your ▁ option ) ▁ any ▁ later ▁ version . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ This ▁ library ▁ is ▁ distributed ▁ in ▁ the ▁ hope ▁ that ▁ it ▁ will ▁ be ▁ useful , STRNEWLINE ▁ * ▁ but ▁ WITHOUT ▁ ANY ▁ WARRANTY ; ▁ without ▁ even ▁ the ▁ implied ▁ warranty ▁ of STRNEWLINE ▁ * ▁ MERCHANTABILITY ▁ or ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE . ▁ See ▁ the ▁ GNU STRNEWLINE ▁ * ▁ Library ▁ General ▁ Public ▁ License ▁ for ▁ more ▁ details . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ You ▁ should ▁ have ▁ received ▁ a ▁ copy ▁ of ▁ the ▁ GNU ▁ Library ▁ General ▁ Public ▁ License STRNEWLINE ▁ * ▁ along ▁ with ▁ this ▁ library ; ▁ see ▁ the ▁ file ▁ COPYING . LIB . ▁ If ▁ not , ▁ write ▁ to STRNEWLINE ▁ * ▁ the ▁ Free ▁ Software ▁ Foundation , ▁ Inc . , ▁ 51 ▁ Franklin ▁ Street , ▁ Fifth ▁ Floor , STRNEWLINE ▁ * ▁ Boston , ▁ MA ▁ 02110-1301 , ▁ USA . STRNEWLINE ▁ */ # include " config . h " # if ENABLE ( SVG_FONTS ) # include " core / svg / SVGFontFaceUriElement . h " # include " core / XLinkNames . h " # include " core / css / CSSFontFaceSrcValue . h " # include " core / dom / Document . h " # include " core / fetch / FetchRequest . h " # include " core / fetch / ResourceFetcher . h " # include " core / svg / SVGFontFaceElement . h " namespace blink { using namespace SVGNames ; inline SVGFontFaceUriElement :: SVGFontFaceUriElement ( Document & document ) : SVGElement ( font_face_uriTag , document ) { ScriptWrappable :: init ( this ) ; } DEFINE_NODE_FACTORY ( SVGFontFaceUriElement ) SVGFontFaceUriElement :: ~ SVGFontFaceUriElement ( ) { if ( m_resource ) m_resource -> removeClient ( this ) ; } PassRefPtrWillBeRawPtr < CSSFontFaceSrcValue > SVGFontFaceUriElement :: srcValue ( ) const { RefPtrWillBeRawPtr < CSSFontFaceSrcValue > src = CSSFontFaceSrcValue :: create ( getAttribute ( XLinkNames :: hrefAttr ) ) ; AtomicString value ( fastGetAttribute ( formatAttr ) ) ; src -> setFormat ( value . isEmpty ( ) ? " svg " : value ) ; // ▁ Default ▁ format ENDCOM return src . release ( ) ; } void SVGFontFaceUriElement :: parseAttribute ( const QualifiedName & name , const AtomicString & value ) { if ( name . matches ( XLinkNames :: hrefAttr ) ) loadFont ( ) ; else SVGElement :: parseAttribute ( name , value ) ; } void SVGFontFaceUriElement :: childrenChanged ( const ChildrenChange & change ) { SVGElement :: childrenChanged ( change ) ; if ( ! isSVGFontFaceSrcElement ( parentNode ( ) ) ) return ; ContainerNode * grandparent = parentNode ( ) -> parentNode ( ) ; if ( isSVGFontFaceElement ( grandparent ) ) toSVGFontFaceElement ( * grandparent ) . rebuildFontFace ( ) ; } Node :: InsertionNotificationRequest SVGFontFaceUriElement :: insertedInto ( ContainerNode * rootParent ) { loadFont ( ) ; return SVGElement :: insertedInto ( rootParent ) ; } void SVGFontFaceUriElement :: loadFont ( ) { if ( m_resource ) m_resource -> removeClient ( this ) ; const AtomicString & href = getAttribute ( XLinkNames :: hrefAttr ) ; if ( ! href . isNull ( ) ) { ResourceFetcher * fetcher = document ( ) . fetcher ( ) ; FetchRequest request ( ResourceRequest ( document ( ) . completeURL ( href ) ) , localName ( ) ) ; m_resource = fetcher -> fetchFont ( request ) ; if ( m_resource ) { m_resource -> addClient ( this ) ; m_resource -> beginLoadIfNeeded ( fetcher ) ; } } else { m_resource = 0 ; } } } # endif // ▁ ENABLE ( SVG _ FONTS ) ENDCOM </DOCUMENT>
<DOCUMENT_ID="weolar/miniblink49/tree/master/gen/blink/bindings/core/v8/V8VideoTrackList.cpp"> // ▁ Copyright ▁ 2014 ▁ The ▁ Chromium ▁ Authors . ▁ All ▁ rights ▁ reserved . ENDCOM // ▁ Use ▁ of ▁ this ▁ source ▁ code ▁ is ▁ governed ▁ by ▁ a ▁ BSD - style ▁ license ▁ that ▁ can ▁ be ENDCOM // ▁ found ▁ in ▁ the ▁ LICENSE ▁ file . ENDCOM // ▁ This ▁ file ▁ has ▁ been ▁ auto - generated ▁ by ▁ code _ generator _ v8 . py . ▁ DO ▁ NOT ▁ MODIFY ! ENDCOM # include " config . h " # include " V8VideoTrackList . h " # include " bindings / core / v8 / ExceptionState . h " # include " bindings / core / v8 / V8AbstractEventListener . h " # include " bindings / core / v8 / V8DOMConfiguration . h " # include " bindings / core / v8 / V8EventListenerList . h " # include " bindings / core / v8 / V8GCController . h " # include " bindings / core / v8 / V8ObjectConstructor . h " # include " bindings / core / v8 / V8VideoTrack . h " # include " core / dom / ContextFeatures . h " # include " core / dom / Document . h " # include " core / dom / Element . h " # include " platform / RuntimeEnabledFeatures . h " # include " platform / TraceEvent . h " # include " wtf / GetPtr . h " # include " wtf / RefPtr . h " namespace blink { // ▁ Suppress ▁ warning : ▁ global ▁ constructors , ▁ because ▁ struct ▁ WrapperTypeInfo ▁ is ▁ trivial ENDCOM // ▁ and ▁ does ▁ not ▁ depend ▁ on ▁ another ▁ global ▁ objects . ENDCOM # if defined ( COMPONENT_BUILD ) && defined ( WIN32 ) && COMPILER ( CLANG ) # pragma clang diagnostic push # pragma clang diagnostic ignored " - Wglobal - constructors " # endif const WrapperTypeInfo V8VideoTrackList :: wrapperTypeInfo = { gin :: kEmbedderBlink , V8VideoTrackList :: domTemplate , V8VideoTrackList :: refObject , V8VideoTrackList :: derefObject , V8VideoTrackList :: trace , 0 , V8VideoTrackList :: visitDOMWrapper , V8VideoTrackList :: preparePrototypeObject , V8VideoTrackList :: installConditionallyEnabledProperties , " VideoTrackList " , & V8EventTarget :: wrapperTypeInfo , WrapperTypeInfo :: WrapperTypeObjectPrototype , WrapperTypeInfo :: ObjectClassId , WrapperTypeInfo :: InheritFromEventTarget , WrapperTypeInfo :: Dependent , WrapperTypeInfo :: WillBeGarbageCollectedObject } ; # if defined ( COMPONENT_BUILD ) && defined ( WIN32 ) && COMPILER ( CLANG ) # pragma clang diagnostic pop # endif // ▁ This ▁ static ▁ member ▁ must ▁ be ▁ declared ▁ by ▁ DEFINE _ WRAPPERTYPEINFO ▁ in ▁ VideoTrackList . h . ENDCOM // ▁ For ▁ details , ▁ see ▁ the ▁ comment ▁ of ▁ DEFINE _ WRAPPERTYPEINFO ▁ in ENDCOM // ▁ bindings / core / v8 / ScriptWrappable . h . ENDCOM const WrapperTypeInfo & VideoTrackList :: s_wrapperTypeInfo = V8VideoTrackList :: wrapperTypeInfo ; namespace VideoTrackListV8Internal { static void lengthAttributeGetter ( const v8 :: FunctionCallbackInfo < v8 :: Value > & info ) { v8 :: Local < v8 :: Object > holder = info . Holder ( ) ; VideoTrackList * impl = V8VideoTrackList :: toImpl ( holder ) ; v8SetReturnValueUnsigned ( info , impl -> length ( ) ) ; } static void lengthAttributeGetterCallback ( const v8 :: FunctionCallbackInfo < v8 :: Value > & info ) { TRACE_EVENT_SET_SAMPLING_STATE ( " blink " , " DOMGetter " ) ; VideoTrackListV8Internal :: lengthAttributeGetter ( info ) ; TRACE_EVENT_SET_SAMPLING_STATE ( " v8" , " V8Execution " ) ; } static void selectedIndexAttributeGetter ( const v8 :: FunctionCallbackInfo < v8 :: Value > & info ) { v8 :: Local < v8 :: Object > holder = info . Holder ( ) ; VideoTrackList * impl = V8VideoTrackList :: toImpl ( holder ) ; v8SetReturnValueInt ( info , impl -> selectedIndex ( ) ) ; } static void selectedIndexAttributeGetterCallback ( const v8 :: FunctionCallbackInfo < v8 :: Value > & info ) { TRACE_EVENT_SET_SAMPLING_STATE ( " blink " , " DOMGetter " ) ; VideoTrackListV8Internal :: selectedIndexAttributeGetter ( info ) ; TRACE_EVENT_SET_SAMPLING_STATE ( " v8" , " V8Execution " ) ; } static void onchangeAttributeGetter ( const v8 :: FunctionCallbackInfo < v8 :: Value > & info ) { v8 :: Local < v8 :: Object > holder = info . Holder ( ) ; VideoTrackList * impl = V8VideoTrackList :: toImpl ( holder ) ; EventListener * cppValue ( impl -> onchange ( ) ) ; v8SetReturnValue ( info , cppValue ? v8 :: Local < v8 :: Value > ( V8AbstractEventListener :: cast ( cppValue ) -> getListenerObject ( impl -> executionContext ( ) ) ) : v8 :: Local < v8 :: Value > ( v8 :: Null ( info . GetIsolate ( ) ) ) ) ; } static void onchangeAttributeGetterCallback ( const v8 :: FunctionCallbackInfo < v8 :: Value > & info ) { TRACE_EVENT_SET_SAMPLING_STATE ( " blink " , " DOMGetter " ) ; VideoTrackListV8Internal :: onchangeAttributeGetter ( info ) ; TRACE_EVENT_SET_SAMPLING_STATE ( " v8" , " V8Execution " ) ; } static void onchangeAttributeSetter ( v8 :: Local < v8 :: Value > v8Value , const v8 :: FunctionCallbackInfo < v8 :: Value > & info ) { v8 :: Local < v8 :: Object > holder = info . Holder ( ) ; VideoTrackList * impl = V8VideoTrackList :: toImpl ( holder ) ; moveEventListenerToNewWrapper ( info . GetIsolate ( ) , holder , impl -> onchange ( ) , v8Value , V8VideoTrackList :: eventListenerCacheIndex ) ; impl -> setOnchange ( V8EventListenerList :: getEventListener ( ScriptState :: current ( info . GetIsolate ( ) ) , v8Value , true , ListenerFindOrCreate ) ) ; } static void onchangeAttributeSetterCallback ( const v8 :: FunctionCallbackInfo < v8 :: Value > & info ) { v8 :: Local < v8 :: Value > v8Value = info [ 0 ] ; TRACE_EVENT_SET_SAMPLING_STATE ( " blink " , " DOMSetter " ) ; VideoTrackListV8Internal :: onchangeAttributeSetter ( v8Value , info ) ; TRACE_EVENT_SET_SAMPLING_STATE ( " v8" , " V8Execution " ) ; } static void onaddtrackAttributeGetter ( const v8 :: FunctionCallbackInfo < v8 :: Value > & info ) { v8 :: Local < v8 :: Object > holder = info . Holder ( ) ; VideoTrackList * impl = V8VideoTrackList :: toImpl ( holder ) ; EventListener * cppValue ( impl -> onaddtrack ( ) ) ; v8SetReturnValue ( info , cppValue ? v8 :: Local < v8 :: Value > ( V8AbstractEventListener :: cast ( cppValue ) -> getListenerObject ( impl -> executionContext ( ) ) ) : v8 :: Local < v8 :: Value > ( v8 :: Null ( info . GetIsolate ( ) ) ) ) ; } static void onaddtrackAttributeGetterCallback ( const v8 :: FunctionCallbackInfo < v8 :: Value > & info ) { TRACE_EVENT_SET_SAMPLING_STATE ( " blink " , " DOMGetter " ) ; VideoTrackListV8Internal :: onaddtrackAttributeGetter ( info ) ; TRACE_EVENT_SET_SAMPLING_STATE ( " v8" , " V8Execution " ) ; } static void onaddtrackAttributeSetter ( v8 :: Local < v8 :: Value > v8Value , const v8 :: FunctionCallbackInfo < v8 :: Value > & info ) { v8 :: Local < v8 :: Object > holder = info . Holder ( ) ; VideoTrackList * impl = V8VideoTrackList :: toImpl ( holder ) ; moveEventListenerToNewWrapper ( info . GetIsolate ( ) , holder , impl -> onaddtrack ( ) , v8Value , V8VideoTrackList :: eventListenerCacheIndex ) ; impl -> setOnaddtrack ( V8EventListenerList :: getEventListener ( ScriptState :: current ( info . GetIsolate ( ) ) , v8Value , true , ListenerFindOrCreate ) ) ; } static void onaddtrackAttributeSetterCallback ( const v8 :: FunctionCallbackInfo < v8 :: Value > & info ) { v8 :: Local < v8 :: Value > v8Value = info [ 0 ] ; TRACE_EVENT_SET_SAMPLING_STATE ( " blink " , " DOMSetter " ) ; VideoTrackListV8Internal :: onaddtrackAttributeSetter ( v8Value , info ) ; TRACE_EVENT_SET_SAMPLING_STATE ( " v8" , " V8Execution " ) ; } static void onremovetrackAttributeGetter ( const v8 :: FunctionCallbackInfo < v8 :: Value > & info ) { v8 :: Local < v8 :: Object > holder = info . Holder ( ) ; VideoTrackList * impl = V8VideoTrackList :: toImpl ( holder ) ; EventListener * cppValue ( impl -> onremovetrack ( ) ) ; v8SetReturnValue ( info , cppValue ? v8 :: Local < v8 :: Value > ( V8AbstractEventListener :: cast ( cppValue ) -> getListenerObject ( impl -> executionContext ( ) ) ) : v8 :: Local < v8 :: Value > ( v8 :: Null ( info . GetIsolate ( ) ) ) ) ; } static void onremovetrackAttributeGetterCallback ( const v8 :: FunctionCallbackInfo < v8 :: Value > & info ) { TRACE_EVENT_SET_SAMPLING_STATE ( " blink " , " DOMGetter " ) ; VideoTrackListV8Internal :: onremovetrackAttributeGetter ( info ) ; TRACE_EVENT_SET_SAMPLING_STATE ( " v8" , " V8Execution " ) ; } static void onremovetrackAttributeSetter ( v8 :: Local < v8 :: Value > v8Value , const v8 :: FunctionCallbackInfo < v8 :: Value > & info ) { v8 :: Local < v8 :: Object > holder = info . Holder ( ) ; VideoTrackList * impl = V8VideoTrackList :: toImpl ( holder ) ; moveEventListenerToNewWrapper ( info . GetIsolate ( ) , holder , impl -> onremovetrack ( ) , v8Value , V8VideoTrackList :: eventListenerCacheIndex ) ; impl -> setOnremovetrack ( V8EventListenerList :: getEventListener ( ScriptState :: current ( info . GetIsolate ( ) ) , v8Value , true , ListenerFindOrCreate ) ) ; } static void onremovetrackAttributeSetterCallback ( const v8 :: FunctionCallbackInfo < v8 :: Value > & info ) { v8 :: Local < v8 :: Value > v8Value = info [ 0 ] ; TRACE_EVENT_SET_SAMPLING_STATE ( " blink " , " DOMSetter " ) ; VideoTrackListV8Internal :: onremovetrackAttributeSetter ( v8Value , info ) ; TRACE_EVENT_SET_SAMPLING_STATE ( " v8" , " V8Execution " ) ; } static void getTrackByIdMethod ( const v8 :: FunctionCallbackInfo < v8 :: Value > & info ) { if ( UNLIKELY ( info . Length ( ) < 1 ) ) { V8ThrowException :: throwException ( createMinimumArityTypeErrorForMethod ( info . GetIsolate ( ) , " getTrackById " , " VideoTrackList " , 1 , info . Length ( ) ) , info . GetIsolate ( ) ) ; return ; } VideoTrackList * impl = V8VideoTrackList :: toImpl ( info . Holder ( ) ) ; V8StringResource < > id ; { id = info [ 0 ] ; if ( ! id . prepare ( ) ) return ; } v8SetReturnValue ( info , impl -> getTrackById ( id ) ) ; } static void getTrackByIdMethodCallback ( const v8 :: FunctionCallbackInfo < v8 :: Value > & info ) { TRACE_EVENT_SET_SAMPLING_STATE ( " blink " , " DOMMethod " ) ; VideoTrackListV8Internal :: getTrackByIdMethod ( info ) ; TRACE_EVENT_SET_SAMPLING_STATE ( " v8" , " V8Execution " ) ; } static void indexedPropertyGetter ( uint32_t index , const v8 :: PropertyCallbackInfo < v8 :: Value > & info ) { VideoTrackList * impl = V8VideoTrackList :: toImpl ( info . Holder ( ) ) ; RefPtrWillBeRawPtr < VideoTrack > result = impl -> anonymousIndexedGetter ( index ) ; if ( ! result ) return ; v8SetReturnValueFast ( info , WTF :: getPtr ( result . release ( ) ) , impl ) ; } static void indexedPropertyGetterCallback ( uint32_t index , const v8 :: PropertyCallbackInfo < v8 :: Value > & info ) { TRACE_EVENT_SET_SAMPLING_STATE ( " blink " , " DOMIndexedProperty " ) ; VideoTrackListV8Internal :: indexedPropertyGetter ( index , info ) ; TRACE_EVENT_SET_SAMPLING_STATE ( " v8" , " V8Execution " ) ; } } // ▁ namespace ▁ VideoTrackListV8Internal ENDCOM void V8VideoTrackList :: visitDOMWrapper ( v8 :: Isolate * isolate , ScriptWrappable * scriptWrappable , const v8 :: Persistent < v8 :: Object > & wrapper ) { VideoTrackList * impl = scriptWrappable -> toImpl < VideoTrackList > ( ) ; // ▁ The ▁ owner ( ) ▁ method ▁ may ▁ return ▁ a ▁ reference ▁ or ▁ a ▁ pointer . ENDCOM if ( Node * owner = WTF :: getPtr ( impl -> owner ( ) ) ) { Node * root = V8GCController :: opaqueRootForGC ( isolate , owner ) ; isolate -> SetReferenceFromGroup ( v8 :: UniqueId ( reinterpret_cast < intptr_t > ( root ) ) , wrapper ) ; return ; } } static const V8DOMConfiguration :: AccessorConfiguration V8VideoTrackListAccessors [ ] = { { " length " , VideoTrackListV8Internal :: lengthAttributeGetterCallback , 0 , 0 , 0 , 0 , static_cast < v8 :: AccessControl > ( v8 :: DEFAULT ) , static_cast < v8 :: PropertyAttribute > ( v8 :: None ) , V8DOMConfiguration :: ExposedToAllScripts , V8DOMConfiguration :: OnPrototype , V8DOMConfiguration :: CheckHolder } , { " selectedIndex " , VideoTrackListV8Internal :: selectedIndexAttributeGetterCallback , 0 , 0 , 0 , 0 , static_cast < v8 :: AccessControl > ( v8 :: DEFAULT ) , static_cast < v8 :: PropertyAttribute > ( v8 :: None ) , V8DOMConfiguration :: ExposedToAllScripts , V8DOMConfiguration :: OnPrototype , V8DOMConfiguration :: CheckHolder } , { " onchange " , VideoTrackListV8Internal :: onchangeAttributeGetterCallback , VideoTrackListV8Internal :: onchangeAttributeSetterCallback , 0 , 0 , 0 , static_cast < v8 :: AccessControl > ( v8 :: DEFAULT ) , static_cast < v8 :: PropertyAttribute > ( v8 :: None ) , V8DOMConfiguration :: ExposedToAllScripts , V8DOMConfiguration :: OnPrototype , V8DOMConfiguration :: CheckHolder } , { " onaddtrack " , VideoTrackListV8Internal :: onaddtrackAttributeGetterCallback , VideoTrackListV8Internal :: onaddtrackAttributeSetterCallback , 0 , 0 , 0 , static_cast < v8 :: AccessControl > ( v8 :: DEFAULT ) , static_cast < v8 :: PropertyAttribute > ( v8 :: None ) , V8DOMConfiguration :: ExposedToAllScripts , V8DOMConfiguration :: OnPrototype , V8DOMConfiguration :: CheckHolder } , { " onremovetrack " , VideoTrackListV8Internal :: onremovetrackAttributeGetterCallback , VideoTrackListV8Internal :: onremovetrackAttributeSetterCallback , 0 , 0 , 0 , static_cast < v8 :: AccessControl > ( v8 :: DEFAULT ) , static_cast < v8 :: PropertyAttribute > ( v8 :: None ) , V8DOMConfiguration :: ExposedToAllScripts , V8DOMConfiguration :: OnPrototype , V8DOMConfiguration :: CheckHolder } , } ; static const V8DOMConfiguration :: MethodConfiguration V8VideoTrackListMethods [ ] = { { " getTrackById " , VideoTrackListV8Internal :: getTrackByIdMethodCallback , 0 , 1 , V8DOMConfiguration :: ExposedToAllScripts } , } ; static void installV8VideoTrackListTemplate ( v8 :: Local < v8 :: FunctionTemplate > functionTemplate , v8 :: Isolate * isolate ) { functionTemplate -> ReadOnlyPrototype ( ) ; v8 :: Local < v8 :: Signature > defaultSignature ; if ( ! RuntimeEnabledFeatures :: audioVideoTracksEnabled ( ) ) defaultSignature = V8DOMConfiguration :: installDOMClassTemplate ( isolate , functionTemplate , " VideoTrackList " , V8EventTarget :: domTemplate ( isolate ) , V8VideoTrackList :: internalFieldCount , 0 , 0 , 0 , 0 , 0 , 0 ) ; else defaultSignature = V8DOMConfiguration :: installDOMClassTemplate ( isolate , functionTemplate , " VideoTrackList " , V8EventTarget :: domTemplate ( isolate ) , V8VideoTrackList :: internalFieldCount , 0 , 0 , V8VideoTrackListAccessors , WTF_ARRAY_LENGTH ( V8VideoTrackListAccessors ) , V8VideoTrackListMethods , WTF_ARRAY_LENGTH ( V8VideoTrackListMethods ) ) ; v8 :: Local < v8 :: ObjectTemplate > instanceTemplate = functionTemplate -> InstanceTemplate ( ) ; ALLOW_UNUSED_LOCAL ( instanceTemplate ) ; v8 :: Local < v8 :: ObjectTemplate > prototypeTemplate = functionTemplate -> PrototypeTemplate ( ) ; ALLOW_UNUSED_LOCAL ( prototypeTemplate ) ; { v8 :: IndexedPropertyHandlerConfiguration config ( VideoTrackListV8Internal :: indexedPropertyGetterCallback , 0 , 0 , 0 , indexedPropertyEnumerator < VideoTrackList > ) ; functionTemplate -> InstanceTemplate ( ) -> SetHandler ( config ) ; } // ▁ Custom ▁ toString ▁ template ENDCOM functionTemplate -> Set ( v8AtomicString ( isolate , " toString " ) , V8PerIsolateData :: from ( isolate ) -> toStringTemplate ( ) ) ; } v8 :: Local < v8 :: FunctionTemplate > V8VideoTrackList :: domTemplate ( v8 :: Isolate * isolate ) { return V8DOMConfiguration :: domClassTemplate ( isolate , const_cast < WrapperTypeInfo * > ( & wrapperTypeInfo ) , installV8VideoTrackListTemplate ) ; } bool V8VideoTrackList :: hasInstance ( v8 :: Local < v8 :: Value > v8Value , v8 :: Isolate * isolate ) { return V8PerIsolateData :: from ( isolate ) -> hasInstance ( & wrapperTypeInfo , v8Value ) ; } v8 :: Local < v8 :: Object > V8VideoTrackList :: findInstanceInPrototypeChain ( v8 :: Local < v8 :: Value > v8Value , v8 :: Isolate * isolate ) { return V8PerIsolateData :: from ( isolate ) -> findInstanceInPrototypeChain ( & wrapperTypeInfo , v8Value ) ; } VideoTrackList * V8VideoTrackList :: toImplWithTypeCheck ( v8 :: Isolate * isolate , v8 :: Local < v8 :: Value > value ) { return hasInstance ( value , isolate ) ? toImpl ( v8 :: Local < v8 :: Object > :: Cast ( value ) ) : 0 ; } void V8VideoTrackList :: refObject ( ScriptWrappable * scriptWrappable ) { # if ! ENABLE ( OILPAN ) scriptWrappable -> toImpl < VideoTrackList > ( ) -> ref ( ) ; # endif } void V8VideoTrackList :: derefObject ( ScriptWrappable * scriptWrappable ) { # if ! ENABLE ( OILPAN ) scriptWrappable -> toImpl < VideoTrackList > ( ) -> deref ( ) ; # endif } } // ▁ namespace ▁ blink ENDCOM </DOCUMENT>
<DOCUMENT_ID="afoksha/OpenGL/tree/master/demos/100_Player/player_5.cpp"> # include < iostream > # include < string > # include < thread > # include < mutex > # include < condition_variable > std :: mutex m ; std :: condition_variable cv ; std :: string data ; bool ready = false ; bool processed = false ; void worker_thread ( ) { // ▁ Wait ▁ until ▁ main ( ) ▁ sends ▁ data ENDCOM std :: unique_lock < std :: mutex > lk ( m ) ; cv . wait ( lk , [ ] { return ready ; } ) ; // ▁ after ▁ the ▁ wait , ▁ we ▁ own ▁ the ▁ lock . ENDCOM std :: cout << " Worker ▁ thread ▁ is ▁ processing ▁ data \n " ; data += " ▁ after ▁ processing " ; // ▁ Send ▁ data ▁ back ▁ to ▁ main ( ) ENDCOM processed = true ; std :: cout << " Worker ▁ thread ▁ signals ▁ data ▁ processing ▁ completed \n " ; // ▁ Manual ▁ unlocking ▁ is ▁ done ▁ before ▁ notifying , ▁ to ▁ avoid ▁ waking ▁ up ENDCOM // ▁ the ▁ waiting ▁ thread ▁ only ▁ to ▁ block ▁ again ▁ ( see ▁ notify _ one ▁ for ▁ details ) ENDCOM lk . unlock ( ) ; cv . notify_one ( ) ; } int main ( int argc , char * argv [ ] ) { std :: thread worker ( worker_thread ) ; data = " Example ▁ data " ; // ▁ send ▁ data ▁ to ▁ the ▁ worker ▁ thread ENDCOM { std :: lock_guard < std :: mutex > lk ( m ) ; ready = true ; std :: cout << " main ( ) ▁ signals ▁ data ▁ ready ▁ for ▁ processing \n " ; } cv . notify_one ( ) ; // ▁ wait ▁ for ▁ the ▁ worker ENDCOM { std :: unique_lock < std :: mutex > lk ( m ) ; cv . wait ( lk , [ ] { return processed ; } ) ; } std :: cout << " Back ▁ in ▁ main ( ) , ▁ data ▁ = ▁ " << data << ' \n ' ; worker . join ( ) ; } </DOCUMENT>
<DOCUMENT_ID="JoseBarrales/mlnc/tree/master/src/test/rpc_tests.cpp"> # include < boost / test / unit_test . hpp > # include < boost / foreach . hpp > # include " base58 . h " # include " util . h " # include " bitcoinrpc . h " using namespace std ; using namespace json_spirit ; BOOST_AUTO_TEST_SUITE ( rpc_tests ) static Array createArgs ( int nRequired , const char * address1 = NULL , const char * address2 = NULL ) { Array result ; result . push_back ( nRequired ) ; Array addresses ; if ( address1 ) addresses . push_back ( address1 ) ; if ( address2 ) addresses . push_back ( address1 ) ; result . push_back ( addresses ) ; return result ; } // ▁ This ▁ can ▁ be ▁ removed ▁ this ▁ when ▁ addmultisigaddress ▁ is ▁ enabled ▁ on ▁ main ▁ net : ENDCOM struct TestNetFixture { TestNetFixture ( ) { fTestNet = true ; } ~ TestNetFixture ( ) { fTestNet = false ; } } ; BOOST_FIXTURE_TEST_CASE ( rpc_addmultisig , TestNetFixture ) { rpcfn_type addmultisig = tableRPC [ " addmultisigaddress " ] -> actor ; // ▁ old , ▁ 65 - byte - long : ENDCOM const char * address1Hex = "0434e3e09f49ea168c5bbf53f877ff4206923858aab7c7e1df25bc263978107c95e35065a27ef6f1b27222db0ec97e0e895eaca603d3ee0d4c060ce3d8a00286c8" ; // ▁ new , ▁ compressed : ENDCOM const char * address2Hex = "0388c2037017c62240b6b72ac1a2a5f94da790596ebd06177c8572752922165cb4" ; Value v ; CBitcoinAddress address ; BOOST_CHECK_NO_THROW ( v = addmultisig ( createArgs ( 1 , address1Hex ) , false ) ) ; address . SetString ( v . get_str ( ) ) ; BOOST_CHECK ( address . IsValid ( ) && address . IsScript ( ) ) ; BOOST_CHECK_NO_THROW ( v = addmultisig ( createArgs ( 1 , address1Hex , address2Hex ) , false ) ) ; address . SetString ( v . get_str ( ) ) ; BOOST_CHECK ( address . IsValid ( ) && address . IsScript ( ) ) ; BOOST_CHECK_NO_THROW ( v = addmultisig ( createArgs ( 2 , address1Hex , address2Hex ) , false ) ) ; address . SetString ( v . get_str ( ) ) ; BOOST_CHECK ( address . IsValid ( ) && address . IsScript ( ) ) ; BOOST_CHECK_THROW ( addmultisig ( createArgs ( 0 ) , false ) , runtime_error ) ; BOOST_CHECK_THROW ( addmultisig ( createArgs ( 1 ) , false ) , runtime_error ) ; BOOST_CHECK_THROW ( addmultisig ( createArgs ( 2 , address1Hex ) , false ) , runtime_error ) ; BOOST_CHECK_THROW ( addmultisig ( createArgs ( 1 , " " ) , false ) , runtime_error ) ; BOOST_CHECK_THROW ( addmultisig ( createArgs ( 1 , " NotAValidPubkey " ) , false ) , runtime_error ) ; string short1 ( address1Hex , address1Hex + sizeof ( address1Hex ) - 2 ) ; // ▁ last ▁ byte ▁ missing ENDCOM BOOST_CHECK_THROW ( addmultisig ( createArgs ( 2 , short1 . c_str ( ) ) , false ) , runtime_error ) ; string short2 ( address1Hex + 2 , address1Hex + sizeof ( address1Hex ) ) ; // ▁ first ▁ byte ▁ missing ENDCOM BOOST_CHECK_THROW ( addmultisig ( createArgs ( 2 , short2 . c_str ( ) ) , false ) , runtime_error ) ; } BOOST_AUTO_TEST_SUITE_END ( ) </DOCUMENT>
<DOCUMENT_ID="kyoungchinseo/aws-sdk-cpp/tree/master/aws-cpp-sdk-s3/source/model/Delete.cpp"> /* STRNEWLINE * ▁ Copyright ▁ 2010-2015 ▁ Amazon . com , ▁ Inc . ▁ or ▁ its ▁ affiliates . ▁ All ▁ Rights ▁ Reserved . STRNEWLINE * STRNEWLINE * ▁ Licensed ▁ under ▁ the ▁ Apache ▁ License , ▁ Version ▁ 2.0 ▁ ( the ▁ " License " ) . STRNEWLINE * ▁ You ▁ may ▁ not ▁ use ▁ this ▁ file ▁ except ▁ in ▁ compliance ▁ with ▁ the ▁ License . STRNEWLINE * ▁ A ▁ copy ▁ of ▁ the ▁ License ▁ is ▁ located ▁ at STRNEWLINE * STRNEWLINE * ▁ http : // aws . amazon . com / apache2.0 STRNEWLINE * STRNEWLINE * ▁ or ▁ in ▁ the ▁ " license " ▁ file ▁ accompanying ▁ this ▁ file . ▁ This ▁ file ▁ is ▁ distributed STRNEWLINE * ▁ on ▁ an ▁ " AS ▁ IS " ▁ BASIS , ▁ WITHOUT ▁ WARRANTIES ▁ OR ▁ CONDITIONS ▁ OF ▁ ANY ▁ KIND , ▁ either STRNEWLINE * ▁ express ▁ or ▁ implied . ▁ See ▁ the ▁ License ▁ for ▁ the ▁ specific ▁ language ▁ governing STRNEWLINE * ▁ permissions ▁ and ▁ limitations ▁ under ▁ the ▁ License . STRNEWLINE */ # include < aws / s3 / model / Delete . h > # include < aws / core / utils / xml / XmlSerializer . h > # include < aws / core / utils / StringUtils . h > # include < aws / core / utils / memory / stl / AWSStringStream . h > # include < utility > using namespace Aws :: S3 :: Model ; using namespace Aws :: Utils :: Xml ; using namespace Aws :: Utils ; Delete :: Delete ( ) : m_objectsHasBeenSet ( false ) , m_quiet ( false ) , m_quietHasBeenSet ( false ) { } Delete :: Delete ( const XmlNode & xmlNode ) : m_objectsHasBeenSet ( false ) , m_quiet ( false ) , m_quietHasBeenSet ( false ) { * this = xmlNode ; } Delete & Delete :: operator = ( const XmlNode & xmlNode ) { XmlNode resultNode = xmlNode ; if ( ! resultNode . IsNull ( ) ) { XmlNode objectsNode = resultNode . FirstChild ( " Objects " ) ; if ( ! objectsNode . IsNull ( ) ) { XmlNode objectsMember = objectsNode ; while ( ! objectsMember . IsNull ( ) ) { m_objects . push_back ( objectsMember ) ; objectsMember = objectsMember . NextNode ( " Object " ) ; } m_objectsHasBeenSet = true ; } XmlNode quietNode = resultNode . FirstChild ( " Quiet " ) ; if ( quietNode . IsNull ( ) ) { quietNode = resultNode ; } if ( ! quietNode . IsNull ( ) ) { m_quiet = StringUtils :: ConvertToBool ( StringUtils :: Trim ( quietNode . GetText ( ) . c_str ( ) ) . c_str ( ) ) ; m_quietHasBeenSet = true ; } } return * this ; } void Delete :: AddToNode ( XmlNode & parentNode ) const { Aws :: StringStream ss ; if ( m_objectsHasBeenSet ) { for ( const auto & item : m_objects ) { XmlNode objectsNode = parentNode . CreateChildElement ( " Object " ) ; item . AddToNode ( objectsNode ) ; } } if ( m_quietHasBeenSet ) { XmlNode quietNode = parentNode . CreateChildElement ( " Object " ) ; ss << m_quiet ; quietNode . SetText ( ss . str ( ) ) ; ss . str ( " " ) ; } } </DOCUMENT>
<DOCUMENT_ID="punker76/Windows-universal-samples/tree/master/Samples/XamlCloudFontIntegration/cpp/Scenario_Document1.xaml.cpp"> // ▁ Copyright ▁ ( c ) ▁ Microsoft . ▁ All ▁ rights ▁ reserved . ENDCOM // ▁ This ▁ code ▁ is ▁ licensed ▁ under ▁ the ▁ MIT ▁ License ▁ ( MIT ) . ENDCOM // ▁ THIS ▁ CODE ▁ IS ▁ PROVIDED ▁ * AS ▁ IS * ▁ WITHOUT ▁ WARRANTY ▁ OF ENDCOM // ▁ ANY ▁ KIND , ▁ EITHER ▁ EXPRESS ▁ OR ▁ IMPLIED , ▁ INCLUDING ▁ ANY ENDCOM // ▁ IMPLIED ▁ WARRANTIES ▁ OF ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ENDCOM // ▁ PURPOSE , ▁ MERCHANTABILITY , ▁ OR ▁ NON - INFRINGEMENT . ENDCOM # include " pch . h " # include " Scenario _ Document1 . xaml . h " using namespace SDKTemplate ; using namespace Platform ; using namespace Windows :: Foundation ; using namespace Windows :: Foundation :: Collections ; using namespace Windows :: UI :: Xaml ; using namespace Windows :: UI :: Xaml :: Controls ; using namespace Windows :: UI :: Xaml :: Controls :: Primitives ; using namespace Windows :: UI :: Xaml :: Data ; using namespace Windows :: UI :: Xaml :: Input ; using namespace Windows :: UI :: Xaml :: Media ; using namespace Windows :: UI :: Xaml :: Navigation ; Scenario_Document1 :: Scenario_Document1 ( ) { InitializeComponent ( ) ; } void Scenario_Document1 :: Page_Loaded ( Platform :: Object ^ sender , Windows :: UI :: Xaml :: RoutedEventArgs ^ e ) { // ▁ Font ▁ formatting ▁ is ▁ being ▁ applied ▁ on ▁ page ▁ load ▁ rather ▁ than ▁ in ▁ XAML ▁ markup ENDCOM // ▁ so ▁ that ▁ the ▁ on - demand ▁ cloud ▁ font ▁ behavior ▁ can ▁ be ▁ experienced ▁ when ▁ the ENDCOM // ▁ app ▁ runs ▁ rather ▁ than ▁ when ▁ the ▁ XAML ▁ file ▁ is ▁ viewed ▁ in ▁ Visual ▁ Studio . ENDCOM // ▁ Formatting ▁ will ▁ be ▁ applied ▁ to ▁ all ▁ content ▁ elements ▁ in ▁ the ▁ page ▁ that ▁ don ' t ▁ ENDCOM // ▁ already ▁ have ▁ FontFamily ▁ set . ENDCOM this -> FontFamily = ref new Windows :: UI :: Xaml :: Media :: FontFamily ( " Neue ▁ Haas ▁ Grotesk ▁ Text ▁ Pro " ) ; } </DOCUMENT>
<DOCUMENT_ID="jobermayr/pcsx2/tree/master/3rdparty/wxwidgets3.0/src/common/filectrlcmn.cpp"> // ▁ Name : ▁ src / common / filectrlcmn . cpp ENDCOM // ▁ Purpose : ▁ Implementation ▁ for ▁ wxFileCtrlBase ▁ and ▁ other ▁ common ▁ functions ▁ used ▁ by ENDCOM // ▁ platform - specific ▁ wxFileCtrl ' s ENDCOM // ▁ Author : ▁ Diaa ▁ M . ▁ Sami ENDCOM // ▁ Created : ▁ 2007-07-07 ENDCOM // ▁ Copyright : ▁ ( c ) ▁ Diaa ▁ M . ▁ Sami ENDCOM // ▁ Licence : ▁ wxWindows ▁ licence ENDCOM # include " wx / wxprec . h " # ifdef __BORLANDC__ # pragma hdrstop # endif # if wxUSE_FILECTRL # include " wx / filectrl . h " # ifndef WX_PRECOMP # include " wx / debug . h " # endif const char wxFileCtrlNameStr [ ] = " wxfilectrl " ; wxDEFINE_EVENT ( wxEVT_FILECTRL_SELECTIONCHANGED , wxFileCtrlEvent ) ; wxDEFINE_EVENT ( wxEVT_FILECTRL_FILEACTIVATED , wxFileCtrlEvent ) ; wxDEFINE_EVENT ( wxEVT_FILECTRL_FOLDERCHANGED , wxFileCtrlEvent ) ; wxDEFINE_EVENT ( wxEVT_FILECTRL_FILTERCHANGED , wxFileCtrlEvent ) ; IMPLEMENT_DYNAMIC_CLASS ( wxFileCtrlEvent , wxCommandEvent ) // ▁ some ▁ helper ▁ functions ENDCOM void GenerateFilterChangedEvent ( wxFileCtrlBase * fileCtrl , wxWindow * wnd ) { wxFileCtrlEvent event ( wxEVT_FILECTRL_FILTERCHANGED , wnd , wnd -> GetId ( ) ) ; event . SetFilterIndex ( fileCtrl -> GetFilterIndex ( ) ) ; wnd -> GetEventHandler ( ) -> ProcessEvent ( event ) ; } void GenerateFolderChangedEvent ( wxFileCtrlBase * fileCtrl , wxWindow * wnd ) { wxFileCtrlEvent event ( wxEVT_FILECTRL_FOLDERCHANGED , wnd , wnd -> GetId ( ) ) ; event . SetDirectory ( fileCtrl -> GetDirectory ( ) ) ; wnd -> GetEventHandler ( ) -> ProcessEvent ( event ) ; } void GenerateSelectionChangedEvent ( wxFileCtrlBase * fileCtrl , wxWindow * wnd ) { wxFileCtrlEvent event ( wxEVT_FILECTRL_SELECTIONCHANGED , wnd , wnd -> GetId ( ) ) ; event . SetDirectory ( fileCtrl -> GetDirectory ( ) ) ; wxArrayString filenames ; fileCtrl -> GetFilenames ( filenames ) ; event . SetFiles ( filenames ) ; wnd -> GetEventHandler ( ) -> ProcessEvent ( event ) ; } void GenerateFileActivatedEvent ( wxFileCtrlBase * fileCtrl , wxWindow * wnd , const wxString filename ) { wxFileCtrlEvent event ( wxEVT_FILECTRL_FILEACTIVATED , wnd , wnd -> GetId ( ) ) ; event . SetDirectory ( fileCtrl -> GetDirectory ( ) ) ; wxArrayString filenames ; if ( filename . empty ( ) ) { fileCtrl -> GetFilenames ( filenames ) ; } else { filenames . Add ( filename ) ; } event . SetFiles ( filenames ) ; wnd -> GetEventHandler ( ) -> ProcessEvent ( event ) ; } // ▁ wxFileCtrlEvent ▁ implementation ENDCOM wxString wxFileCtrlEvent :: GetFile ( ) const { wxASSERT_MSG ( ! wxDynamicCast ( GetEventObject ( ) , wxFileCtrl ) -> HasMultipleFileSelection ( ) , wxT ( " Please ▁ use ▁ GetFiles ( ) ▁ to ▁ get ▁ all ▁ files ▁ instead ▁ of ▁ this ▁ function " ) ) ; wxString string ; if ( m_files . Count ( ) != 0 ) string = m_files [ 0 ] ; return string ; } # endif // ▁ wxUSE _ FILECTRL ENDCOM </DOCUMENT>
<DOCUMENT_ID="einon/affymetrix-power-tools/tree/master/sdk/calvin_files/parameter/test/ParameterFileDataTest.cpp"> // ▁ Copyright ▁ ( C ) ▁ 2005 ▁ Affymetrix , ▁ Inc . ENDCOM // ▁ This ▁ library ▁ is ▁ free ▁ software ; ▁ you ▁ can ▁ redistribute ▁ it ▁ and / or ▁ modify ENDCOM // ▁ it ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ Lesser ▁ General ▁ Public ▁ License ▁ ENDCOM // ▁ ( version ▁ 2.1 ) ▁ as ▁ published ▁ by ▁ the ▁ Free ▁ Software ▁ Foundation . ENDCOM // ▁ This ▁ library ▁ is ▁ distributed ▁ in ▁ the ▁ hope ▁ that ▁ it ▁ will ▁ be ▁ useful , ▁ but ENDCOM // ▁ WITHOUT ▁ ANY ▁ WARRANTY ; ▁ without ▁ even ▁ the ▁ implied ▁ warranty ▁ of ▁ MERCHANTABILITY ENDCOM // ▁ or ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE . ▁ See ▁ the ▁ GNU ▁ Lesser ▁ General ▁ Public ▁ License ENDCOM // ▁ for ▁ more ▁ details . ENDCOM // ▁ You ▁ should ▁ have ▁ received ▁ a ▁ copy ▁ of ▁ the ▁ GNU ▁ Lesser ▁ General ▁ Public ▁ License ENDCOM // ▁ along ▁ with ▁ this ▁ library ; ▁ if ▁ not , ▁ write ▁ to ▁ the ▁ Free ▁ Software ▁ Foundation , ▁ Inc . , ENDCOM // ▁ 59 ▁ Temple ▁ Place , ▁ Suite ▁ 330 , ▁ Boston , ▁ MA ▁ 02111-1307 ▁ USA ▁ ENDCOM # include " calvin _ files / parameter / src / ParameterFileData . h " # include < cppunit / extensions / HelperMacros . h > using namespace affymetrix_calvin_parameter ; class ParameterFileDataTest : public CPPUNIT_NS :: TestFixture { CPPUNIT_TEST_SUITE ( ParameterFileDataTest ) ; CPPUNIT_TEST ( testAccess ) ; CPPUNIT_TEST_SUITE_END ( ) ; public : void setUp ( ) ; void tearDown ( ) ; void testAccess ( ) ; } ; CPPUNIT_TEST_SUITE_REGISTRATION ( ParameterFileDataTest ) ; void ParameterFileDataTest :: setUp ( ) { } void ParameterFileDataTest :: tearDown ( ) { } void ParameterFileDataTest :: testAccess ( ) { ParameterFileData d ; d . ImplementationAttributes ( ) . description = L " d " ; d . ImplementationAttributes ( ) . executableFileName = L " e " ; d . ImplementationAttributes ( ) . name = L " n " ; d . ImplementationAttributes ( ) . version = L " v " ; CPPUNIT_ASSERT ( d . ImplementationAttributes ( ) . description == L " d " ) ; CPPUNIT_ASSERT ( d . ImplementationAttributes ( ) . executableFileName == L " e " ) ; CPPUNIT_ASSERT ( d . ImplementationAttributes ( ) . name == L " n " ) ; CPPUNIT_ASSERT ( d . ImplementationAttributes ( ) . version == L " v " ) ; d . ParameterFileAttributes ( ) . company = L " c " ; d . ParameterFileAttributes ( ) . userName = L " u " ; d . ParameterFileAttributes ( ) . contentVersion = L " cv " ; CPPUNIT_ASSERT ( d . ParameterFileAttributes ( ) . company == L " c " ) ; CPPUNIT_ASSERT ( d . ParameterFileAttributes ( ) . userName == L " u " ) ; CPPUNIT_ASSERT ( d . ParameterFileAttributes ( ) . contentVersion == L " cv " ) ; ParameterType p ; p . name = L " n " ; p . index = L " i " ; p . displayName = L " d " ; p . category = L " c " ; p . isEditable = L " is " ; p . type = L " t " ; p . currentValue = L " cv " ; p . minValue = L " mv " ; p . maxValue = L " xv " ; p . defaultValue = L " dv " ; p . precision = L " p " ; p . maxLength = L " l " ; p . description = L " de " ; CPPUNIT_ASSERT ( p . name == L " n " ) ; CPPUNIT_ASSERT ( p . index == L " i " ) ; CPPUNIT_ASSERT ( p . displayName == L " d " ) ; CPPUNIT_ASSERT ( p . category == L " c " ) ; CPPUNIT_ASSERT ( p . isEditable == L " is " ) ; CPPUNIT_ASSERT ( p . type == L " t " ) ; CPPUNIT_ASSERT ( p . currentValue == L " cv " ) ; CPPUNIT_ASSERT ( p . minValue == L " mv " ) ; CPPUNIT_ASSERT ( p . maxValue == L " xv " ) ; CPPUNIT_ASSERT ( p . defaultValue == L " dv " ) ; CPPUNIT_ASSERT ( p . precision == L " p " ) ; CPPUNIT_ASSERT ( p . maxLength == L " l " ) ; CPPUNIT_ASSERT ( p . description == L " de " ) ; d . Parameters ( ) . push_back ( p ) ; p . name . clear ( ) ; p . index . clear ( ) ; CPPUNIT_ASSERT ( d . Parameters ( ) . size ( ) == 1 ) ; d . Clear ( ) ; CPPUNIT_ASSERT ( d . ImplementationAttributes ( ) . description == L " " ) ; CPPUNIT_ASSERT ( d . ImplementationAttributes ( ) . executableFileName == L " " ) ; CPPUNIT_ASSERT ( d . ImplementationAttributes ( ) . name == L " " ) ; CPPUNIT_ASSERT ( d . ImplementationAttributes ( ) . version == L " " ) ; CPPUNIT_ASSERT ( d . ParameterFileAttributes ( ) . company == L " " ) ; CPPUNIT_ASSERT ( d . ParameterFileAttributes ( ) . userName == L " " ) ; CPPUNIT_ASSERT ( d . ParameterFileAttributes ( ) . contentVersion == L " " ) ; CPPUNIT_ASSERT ( d . Parameters ( ) . size ( ) == 0 ) ; } </DOCUMENT>
<DOCUMENT_ID="doorxp/ccjson/tree/master/cocos2d/cocos/audio/android/AudioResampler.cpp"> /* STRNEWLINE ▁ * ▁ Copyright ▁ ( C ) ▁ 2007 ▁ The ▁ Android ▁ Open ▁ Source ▁ Project STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Licensed ▁ under ▁ the ▁ Apache ▁ License , ▁ Version ▁ 2.0 ▁ ( the ▁ " License " ) ; STRNEWLINE ▁ * ▁ you ▁ may ▁ not ▁ use ▁ this ▁ file ▁ except ▁ in ▁ compliance ▁ with ▁ the ▁ License . STRNEWLINE ▁ * ▁ You ▁ may ▁ obtain ▁ a ▁ copy ▁ of ▁ the ▁ License ▁ at STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ http : // www . apache . org / licenses / LICENSE - 2.0 STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Unless ▁ required ▁ by ▁ applicable ▁ law ▁ or ▁ agreed ▁ to ▁ in ▁ writing , ▁ software STRNEWLINE ▁ * ▁ distributed ▁ under ▁ the ▁ License ▁ is ▁ distributed ▁ on ▁ an ▁ " AS ▁ IS " ▁ BASIS , STRNEWLINE ▁ * ▁ WITHOUT ▁ WARRANTIES ▁ OR ▁ CONDITIONS ▁ OF ▁ ANY ▁ KIND , ▁ either ▁ express ▁ or ▁ implied . STRNEWLINE ▁ * ▁ See ▁ the ▁ License ▁ for ▁ the ▁ specific ▁ language ▁ governing ▁ permissions ▁ and STRNEWLINE ▁ * ▁ limitations ▁ under ▁ the ▁ License . STRNEWLINE ▁ */ # define LOG_TAG " AudioResampler " // # define ▁ LOG _ NDEBUG ▁ 0 ENDCOM # include < stdint . h > # include < stdlib . h > # include < sys / types . h > # include < pthread . h > # include < new > # include " audio / android / cutils / log . h " # include " audio / android / utils / Utils . h " // # include ▁ < cutils / properties . h > ENDCOM # include " audio / android / audio _ utils / include / audio _ utils / primitives . h " # include " audio / android / AudioResampler . h " // # include ▁ " audio / android / AudioResamplerSinc . h " ENDCOM # include " audio / android / AudioResamplerCubic . h " // # include ▁ " AudioResamplerDyn . h " ENDCOM // cjh ▁ # ifdef ▁ _ _ arm _ _ ENDCOM // ▁ # define ▁ ASM _ ARM _ RESAMP1 ▁ // ▁ enable ▁ asm ▁ optimisation ▁ for ▁ ResamplerOrder1 ENDCOM // # endif ENDCOM namespace cocos2d { namespace experimental { class AudioResamplerOrder1 : public AudioResampler { public : AudioResamplerOrder1 ( int inChannelCount , int32_t sampleRate ) : AudioResampler ( inChannelCount , sampleRate , LOW_QUALITY ) , mX0L ( 0 ) , mX0R ( 0 ) { } virtual size_t resample ( int32_t * out , size_t outFrameCount , AudioBufferProvider * provider ) ; private : // ▁ number ▁ of ▁ bits ▁ used ▁ in ▁ interpolation ▁ multiply ▁ - ▁ 15 ▁ bits ▁ avoids ▁ overflow ENDCOM static const int kNumInterpBits = 15 ; // ▁ bits ▁ to ▁ shift ▁ the ▁ phase ▁ fraction ▁ down ▁ to ▁ avoid ▁ overflow ENDCOM static const int kPreInterpShift = kNumPhaseBits - kNumInterpBits ; void init ( ) { } size_t resampleMono16 ( int32_t * out , size_t outFrameCount , AudioBufferProvider * provider ) ; size_t resampleStereo16 ( int32_t * out , size_t outFrameCount , AudioBufferProvider * provider ) ; # ifdef ASM_ARM_RESAMP1 // ▁ asm ▁ optimisation ▁ for ▁ ResamplerOrder1 ENDCOM void AsmMono16Loop ( int16_t * in , int32_t * maxOutPt , int32_t maxInIdx , size_t & outputIndex , int32_t * out , size_t & inputIndex , int32_t vl , int32_t vr , uint32_t & phaseFraction , uint32_t phaseIncrement ) ; void AsmStereo16Loop ( int16_t * in , int32_t * maxOutPt , int32_t maxInIdx , size_t & outputIndex , int32_t * out , size_t & inputIndex , int32_t vl , int32_t vr , uint32_t & phaseFraction , uint32_t phaseIncrement ) ; # endif // ▁ ASM _ ARM _ RESAMP1 ENDCOM static inline int32_t Interp ( int32_t x0 , int32_t x1 , uint32_t f ) { return x0 + ( ( ( x1 - x0 ) * ( int32_t ) ( f >> kPreInterpShift ) ) >> kNumInterpBits ) ; } static inline void Advance ( size_t * index , uint32_t * frac , uint32_t inc ) { * frac += inc ; * index += ( size_t ) ( * frac >> kNumPhaseBits ) ; * frac &= kPhaseMask ; } int mX0L ; int mX0R ; } ; /* static */ const double AudioResampler :: kPhaseMultiplier = 1L << AudioResampler :: kNumPhaseBits ; bool AudioResampler :: qualityIsSupported ( src_quality quality ) { switch ( quality ) { case DEFAULT_QUALITY : case LOW_QUALITY : case MED_QUALITY : case HIGH_QUALITY : case VERY_HIGH_QUALITY : return true ; default : return false ; } } static pthread_once_t once_control = PTHREAD_ONCE_INIT ; static AudioResampler :: src_quality defaultQuality = AudioResampler :: DEFAULT_QUALITY ; void AudioResampler :: init_routine ( ) { // ▁ int ▁ resamplerQuality ▁ = ▁ getSystemProperty ( " af . resampler . quality " ) ; ENDCOM // ▁ if ▁ ( resamplerQuality ▁ > ▁ 0 ) ▁ { ENDCOM // ▁ defaultQuality ▁ = ▁ ( src _ quality ) ▁ resamplerQuality ; ENDCOM // ▁ ALOGD ( " forcing ▁ AudioResampler ▁ quality ▁ to ▁ % d " , ▁ defaultQuality ) ; ENDCOM // ▁ if ▁ ( defaultQuality ▁ < ▁ DEFAULT _ QUALITY ▁ | | ▁ defaultQuality ▁ > ▁ VERY _ HIGH _ QUALITY ) ▁ { ENDCOM // ▁ defaultQuality ▁ = ▁ DEFAULT _ QUALITY ; ENDCOM } uint32_t AudioResampler :: qualityMHz ( src_quality quality ) { switch ( quality ) { default : case DEFAULT_QUALITY : case LOW_QUALITY : return 3 ; case MED_QUALITY : return 6 ; case HIGH_QUALITY : return 20 ; case VERY_HIGH_QUALITY : return 34 ; // ▁ case ▁ DYN _ LOW _ QUALITY : ENDCOM // ▁ return ▁ 4 ; ENDCOM // ▁ case ▁ DYN _ MED _ QUALITY : ENDCOM // ▁ return ▁ 6 ; ENDCOM // ▁ case ▁ DYN _ HIGH _ QUALITY : ENDCOM // ▁ return ▁ 12 ; ENDCOM } } static const uint32_t maxMHz = 130 ; // ▁ an ▁ arbitrary ▁ number ▁ that ▁ permits ▁ 3 ▁ VHQ , ▁ should ▁ be ▁ tunable ENDCOM static pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER ; static uint32_t currentMHz = 0 ; AudioResampler * AudioResampler :: create ( audio_format_t format , int inChannelCount , int32_t sampleRate , src_quality quality ) { bool atFinalQuality ; if ( quality == DEFAULT_QUALITY ) { // ▁ read ▁ the ▁ resampler ▁ default ▁ quality ▁ property ▁ the ▁ first ▁ time ▁ it ▁ is ▁ needed ENDCOM int ok = pthread_once ( & once_control , init_routine ) ; if ( ok != 0 ) { ALOGE ( " % s ▁ pthread _ once ▁ failed : ▁ % d " , __func__ , ok ) ; } quality = defaultQuality ; atFinalQuality = false ; } else { atFinalQuality = true ; } /* ▁ if ▁ the ▁ caller ▁ requests ▁ DEFAULT _ QUALITY ▁ and ▁ af . resampler . property STRNEWLINE ▁ * ▁ has ▁ not ▁ been ▁ set , ▁ the ▁ target ▁ resampler ▁ quality ▁ is ▁ set ▁ to ▁ DYN _ MED _ QUALITY , STRNEWLINE ▁ * ▁ and ▁ allowed ▁ to ▁ " throttle " ▁ down ▁ to ▁ DYN _ LOW _ QUALITY ▁ if ▁ necessary STRNEWLINE ▁ * ▁ due ▁ to ▁ estimated ▁ CPU ▁ load ▁ of ▁ having ▁ too ▁ many ▁ active ▁ resamplers STRNEWLINE ▁ * ▁ ( the ▁ code ▁ below ▁ the ▁ if ) . STRNEWLINE ▁ */ if ( quality == DEFAULT_QUALITY ) { // cjh ▁ quality ▁ = ▁ DYN _ MED _ QUALITY ; ENDCOM } // ▁ naive ▁ implementation ▁ of ▁ CPU ▁ load ▁ throttling ▁ doesn ' t ▁ account ▁ for ▁ whether ▁ resampler ▁ is ▁ active ENDCOM pthread_mutex_lock ( & mutex ) ; for ( ; ; ) { uint32_t deltaMHz = qualityMHz ( quality ) ; uint32_t newMHz = currentMHz + deltaMHz ; if ( ( qualityIsSupported ( quality ) && newMHz <= maxMHz ) || atFinalQuality ) { ALOGV ( " resampler ▁ load ▁ % u ▁ - > ▁ % u ▁ MHz ▁ due ▁ to ▁ delta ▁ + % u ▁ MHz ▁ from ▁ quality ▁ % d " , currentMHz , newMHz , deltaMHz , quality ) ; currentMHz = newMHz ; break ; } // ▁ not ▁ enough ▁ CPU ▁ available ▁ for ▁ proposed ▁ quality ▁ level , ▁ so ▁ try ▁ next ▁ lowest ▁ level ENDCOM switch ( quality ) { default : case LOW_QUALITY : atFinalQuality = true ; break ; case MED_QUALITY : quality = LOW_QUALITY ; break ; case HIGH_QUALITY : quality = MED_QUALITY ; break ; case VERY_HIGH_QUALITY : quality = HIGH_QUALITY ; break ; // ▁ case ▁ DYN _ LOW _ QUALITY : ENDCOM // ▁ atFinalQuality ▁ = ▁ true ; ENDCOM // ▁ break ; ENDCOM // ▁ case ▁ DYN _ MED _ QUALITY : ENDCOM // ▁ quality ▁ = ▁ DYN _ LOW _ QUALITY ; ENDCOM // ▁ break ; ENDCOM // ▁ case ▁ DYN _ HIGH _ QUALITY : ENDCOM // ▁ quality ▁ = ▁ DYN _ MED _ QUALITY ; ENDCOM // ▁ break ; ENDCOM } } pthread_mutex_unlock ( & mutex ) ; AudioResampler * resampler ; switch ( quality ) { default : case LOW_QUALITY : ALOGV ( " Create ▁ linear ▁ Resampler " ) ; LOG_ALWAYS_FATAL_IF ( format != AUDIO_FORMAT_PCM_16_BIT , " invalid ▁ pcm ▁ format " ) ; resampler = new ( std :: nothrow ) AudioResamplerOrder1 ( inChannelCount , sampleRate ) ; break ; case MED_QUALITY : ALOGV ( " Create ▁ cubic ▁ Resampler " ) ; LOG_ALWAYS_FATAL_IF ( format != AUDIO_FORMAT_PCM_16_BIT , " invalid ▁ pcm ▁ format " ) ; resampler = new ( std :: nothrow ) AudioResamplerCubic ( inChannelCount , sampleRate ) ; break ; case HIGH_QUALITY : ALOGV ( " Create ▁ HIGH _ QUALITY ▁ sinc ▁ Resampler " ) ; LOG_ALWAYS_FATAL_IF ( format != AUDIO_FORMAT_PCM_16_BIT , " invalid ▁ pcm ▁ format " ) ; ALOG_ASSERT ( false , " HIGH _ QUALITY ▁ isn ' t ▁ supported " ) ; // ▁ Cocos2d - x ▁ only ▁ uses ▁ MED _ QUALITY , ▁ so ▁ we ▁ could ▁ remove ▁ Sinc ▁ relative ▁ files ENDCOM // ▁ resampler ▁ = ▁ new ▁ ( std : : nothrow ) ▁ AudioResamplerSinc ( inChannelCount , ▁ sampleRate ) ; ENDCOM break ; case VERY_HIGH_QUALITY : ALOGV ( " Create ▁ VERY _ HIGH _ QUALITY ▁ sinc ▁ Resampler ▁ = ▁ % d " , quality ) ; LOG_ALWAYS_FATAL_IF ( format != AUDIO_FORMAT_PCM_16_BIT , " invalid ▁ pcm ▁ format " ) ; // ▁ Cocos2d - x ▁ only ▁ uses ▁ MED _ QUALITY , ▁ so ▁ we ▁ could ▁ remove ▁ Sinc ▁ relative ▁ files ENDCOM // ▁ resampler ▁ = ▁ new ▁ ( std : : nothrow ) ▁ AudioResamplerSinc ( inChannelCount , ▁ sampleRate , ▁ quality ) ; ENDCOM ALOG_ASSERT ( false , " VERY _ HIGH _ QUALITY ▁ isn ' t ▁ supported " ) ; break ; } // ▁ initialize ▁ resampler ENDCOM resampler -> init ( ) ; return resampler ; } AudioResampler :: AudioResampler ( int inChannelCount , int32_t sampleRate , src_quality quality ) : mChannelCount ( inChannelCount ) , mSampleRate ( sampleRate ) , mInSampleRate ( sampleRate ) , mInputIndex ( 0 ) , mPhaseFraction ( 0 ) , mLocalTimeFreq ( 0 ) , mPTS ( AudioBufferProvider :: kInvalidPTS ) , mQuality ( quality ) { const int maxChannels = 2 ; // cjh ▁ quality ▁ < ▁ DYN _ LOW _ QUALITY ▁ ? ▁ 2 ▁ : ▁ 8 ; ENDCOM if ( inChannelCount < 1 || inChannelCount > maxChannels ) { LOG_ALWAYS_FATAL ( " Unsupported ▁ sample ▁ format ▁ % d ▁ quality ▁ % d ▁ channels " , quality , inChannelCount ) ; } if ( sampleRate <= 0 ) { LOG_ALWAYS_FATAL ( " Unsupported ▁ sample ▁ rate ▁ % d ▁ Hz " , sampleRate ) ; } // ▁ initialize ▁ common ▁ members ENDCOM mVolume [ 0 ] = mVolume [ 1 ] = 0 ; mBuffer . frameCount = 0 ; } AudioResampler :: ~ AudioResampler ( ) { pthread_mutex_lock ( & mutex ) ; src_quality quality = getQuality ( ) ; uint32_t deltaMHz = qualityMHz ( quality ) ; int32_t newMHz = currentMHz - deltaMHz ; ALOGV ( " resampler ▁ load ▁ % u ▁ - > ▁ % d ▁ MHz ▁ due ▁ to ▁ delta ▁ - % u ▁ MHz ▁ from ▁ quality ▁ % d " , currentMHz , newMHz , deltaMHz , quality ) ; LOG_ALWAYS_FATAL_IF ( newMHz < 0 , " negative ▁ resampler ▁ load ▁ % d ▁ MHz " , newMHz ) ; currentMHz = newMHz ; pthread_mutex_unlock ( & mutex ) ; } void AudioResampler :: setSampleRate ( int32_t inSampleRate ) { mInSampleRate = inSampleRate ; mPhaseIncrement = ( uint32_t ) ( ( kPhaseMultiplier * inSampleRate ) / mSampleRate ) ; } void AudioResampler :: setVolume ( float left , float right ) { // ▁ TODO : ▁ Implement ▁ anti - zipper ▁ filter ENDCOM // ▁ convert ▁ to ▁ U4.12 ▁ for ▁ internal ▁ integer ▁ use ▁ ( round ▁ down ) ENDCOM // ▁ integer ▁ volume ▁ values ▁ are ▁ clamped ▁ to ▁ 0 ▁ to ▁ UNITY _ GAIN . ENDCOM mVolume [ 0 ] = u4_12_from_float ( clampFloatVol ( left ) ) ; mVolume [ 1 ] = u4_12_from_float ( clampFloatVol ( right ) ) ; } void AudioResampler :: setLocalTimeFreq ( uint64_t freq ) { mLocalTimeFreq = freq ; } void AudioResampler :: setPTS ( int64_t pts ) { mPTS = pts ; } int64_t AudioResampler :: calculateOutputPTS ( int outputFrameIndex ) { if ( mPTS == AudioBufferProvider :: kInvalidPTS ) { return AudioBufferProvider :: kInvalidPTS ; } else { return mPTS + ( ( outputFrameIndex * mLocalTimeFreq ) / mSampleRate ) ; } } void AudioResampler :: reset ( ) { mInputIndex = 0 ; mPhaseFraction = 0 ; mBuffer . frameCount = 0 ; } size_t AudioResamplerOrder1 :: resample ( int32_t * out , size_t outFrameCount , AudioBufferProvider * provider ) { // ▁ should ▁ never ▁ happen , ▁ but ▁ we ▁ overflow ▁ if ▁ it ▁ does ENDCOM // ▁ ALOG _ ASSERT ( outFrameCount ▁ < ▁ 32767 ) ; ENDCOM // ▁ select ▁ the ▁ appropriate ▁ resampler ENDCOM switch ( mChannelCount ) { case 1 : return resampleMono16 ( out , outFrameCount , provider ) ; case 2 : return resampleStereo16 ( out , outFrameCount , provider ) ; default : LOG_ALWAYS_FATAL ( " invalid ▁ channel ▁ count : ▁ % d " , mChannelCount ) ; return 0 ; } } size_t AudioResamplerOrder1 :: resampleStereo16 ( int32_t * out , size_t outFrameCount , AudioBufferProvider * provider ) { int32_t vl = mVolume [ 0 ] ; int32_t vr = mVolume [ 1 ] ; size_t inputIndex = mInputIndex ; uint32_t phaseFraction = mPhaseFraction ; uint32_t phaseIncrement = mPhaseIncrement ; size_t outputIndex = 0 ; size_t outputSampleCount = outFrameCount * 2 ; size_t inFrameCount = getInFrameCountRequired ( outFrameCount ) ; // ▁ ALOGE ( " starting ▁ resample ▁ % d ▁ frames , ▁ inputIndex = % d , ▁ phaseFraction = % d , ▁ phaseIncrement = % d " , ENDCOM // ▁ outFrameCount , ▁ inputIndex , ▁ phaseFraction , ▁ phaseIncrement ) ; ENDCOM while ( outputIndex < outputSampleCount ) { // ▁ buffer ▁ is ▁ empty , ▁ fetch ▁ a ▁ new ▁ one ENDCOM while ( mBuffer . frameCount == 0 ) { mBuffer . frameCount = inFrameCount ; provider -> getNextBuffer ( & mBuffer , calculateOutputPTS ( outputIndex / 2 ) ) ; if ( mBuffer . raw == NULL ) { goto resampleStereo16_exit ; } // ▁ ALOGE ( " New ▁ buffer ▁ fetched : ▁ % d ▁ frames " , ▁ mBuffer . frameCount ) ; ENDCOM if ( mBuffer . frameCount > inputIndex ) break ; inputIndex -= mBuffer . frameCount ; mX0L = mBuffer . i16 [ mBuffer . frameCount * 2 - 2 ] ; mX0R = mBuffer . i16 [ mBuffer . frameCount * 2 - 1 ] ; provider -> releaseBuffer ( & mBuffer ) ; // ▁ mBuffer . frameCount ▁ = = ▁ 0 ▁ now ▁ so ▁ we ▁ reload ▁ a ▁ new ▁ buffer ENDCOM } int16_t * in = mBuffer . i16 ; // ▁ handle ▁ boundary ▁ case ENDCOM while ( inputIndex == 0 ) { // ▁ ALOGE ( " boundary ▁ case " ) ; ENDCOM out [ outputIndex ++ ] += vl * Interp ( mX0L , in [ 0 ] , phaseFraction ) ; out [ outputIndex ++ ] += vr * Interp ( mX0R , in [ 1 ] , phaseFraction ) ; Advance ( & inputIndex , & phaseFraction , phaseIncrement ) ; if ( outputIndex == outputSampleCount ) { break ; } } // ▁ process ▁ input ▁ samples ENDCOM // ▁ ALOGE ( " general ▁ case " ) ; ENDCOM # ifdef ASM_ARM_RESAMP1 // ▁ asm ▁ optimisation ▁ for ▁ ResamplerOrder1 ENDCOM if ( inputIndex + 2 < mBuffer . frameCount ) { int32_t * maxOutPt ; int32_t maxInIdx ; maxOutPt = out + ( outputSampleCount - 2 ) ; // ▁ 2 ▁ because ▁ 2 ▁ frames ▁ per ▁ loop ENDCOM maxInIdx = mBuffer . frameCount - 2 ; AsmStereo16Loop ( in , maxOutPt , maxInIdx , outputIndex , out , inputIndex , vl , vr , phaseFraction , phaseIncrement ) ; } # endif // ▁ ASM _ ARM _ RESAMP1 ENDCOM while ( outputIndex < outputSampleCount && inputIndex < mBuffer . frameCount ) { out [ outputIndex ++ ] += vl * Interp ( in [ inputIndex * 2 - 2 ] , in [ inputIndex * 2 ] , phaseFraction ) ; out [ outputIndex ++ ] += vr * Interp ( in [ inputIndex * 2 - 1 ] , in [ inputIndex * 2 + 1 ] , phaseFraction ) ; Advance ( & inputIndex , & phaseFraction , phaseIncrement ) ; } // ▁ ALOGE ( " loop ▁ done ▁ - ▁ outputIndex = % d , ▁ inputIndex = % d " , ▁ outputIndex , ▁ inputIndex ) ; ENDCOM // ▁ if ▁ done ▁ with ▁ buffer , ▁ save ▁ samples ENDCOM if ( inputIndex >= mBuffer . frameCount ) { inputIndex -= mBuffer . frameCount ; // ▁ ALOGE ( " buffer ▁ done , ▁ new ▁ input ▁ index ▁ % d " , ▁ inputIndex ) ; ENDCOM mX0L = mBuffer . i16 [ mBuffer . frameCount * 2 - 2 ] ; mX0R = mBuffer . i16 [ mBuffer . frameCount * 2 - 1 ] ; provider -> releaseBuffer ( & mBuffer ) ; // ▁ verify ▁ that ▁ the ▁ releaseBuffer ▁ resets ▁ the ▁ buffer ▁ frameCount ENDCOM // ▁ ALOG _ ASSERT ( mBuffer . frameCount ▁ = = ▁ 0 ) ; ENDCOM } } // ▁ ALOGE ( " output ▁ buffer ▁ full ▁ - ▁ outputIndex = % d , ▁ inputIndex = % d " , ▁ outputIndex , ▁ inputIndex ) ; ENDCOM resampleStereo16_exit : // ▁ save ▁ state ENDCOM mInputIndex = inputIndex ; mPhaseFraction = phaseFraction ; return outputIndex / 2 /* ▁ channels ▁ for ▁ stereo ▁ */ ; } size_t AudioResamplerOrder1 :: resampleMono16 ( int32_t * out , size_t outFrameCount , AudioBufferProvider * provider ) { int32_t vl = mVolume [ 0 ] ; int32_t vr = mVolume [ 1 ] ; size_t inputIndex = mInputIndex ; uint32_t phaseFraction = mPhaseFraction ; uint32_t phaseIncrement = mPhaseIncrement ; size_t outputIndex = 0 ; size_t outputSampleCount = outFrameCount * 2 ; size_t inFrameCount = getInFrameCountRequired ( outFrameCount ) ; // ▁ ALOGE ( " starting ▁ resample ▁ % d ▁ frames , ▁ inputIndex = % d , ▁ phaseFraction = % d , ▁ phaseIncrement = % d " , ENDCOM // ▁ outFrameCount , ▁ inputIndex , ▁ phaseFraction , ▁ phaseIncrement ) ; ENDCOM while ( outputIndex < outputSampleCount ) { // ▁ buffer ▁ is ▁ empty , ▁ fetch ▁ a ▁ new ▁ one ENDCOM while ( mBuffer . frameCount == 0 ) { mBuffer . frameCount = inFrameCount ; provider -> getNextBuffer ( & mBuffer , calculateOutputPTS ( outputIndex / 2 ) ) ; if ( mBuffer . raw == NULL ) { mInputIndex = inputIndex ; mPhaseFraction = phaseFraction ; goto resampleMono16_exit ; } // ▁ ALOGE ( " New ▁ buffer ▁ fetched : ▁ % d ▁ frames " , ▁ mBuffer . frameCount ) ; ENDCOM if ( mBuffer . frameCount > inputIndex ) break ; inputIndex -= mBuffer . frameCount ; mX0L = mBuffer . i16 [ mBuffer . frameCount - 1 ] ; provider -> releaseBuffer ( & mBuffer ) ; // ▁ mBuffer . frameCount ▁ = = ▁ 0 ▁ now ▁ so ▁ we ▁ reload ▁ a ▁ new ▁ buffer ENDCOM } int16_t * in = mBuffer . i16 ; // ▁ handle ▁ boundary ▁ case ENDCOM while ( inputIndex == 0 ) { // ▁ ALOGE ( " boundary ▁ case " ) ; ENDCOM int32_t sample = Interp ( mX0L , in [ 0 ] , phaseFraction ) ; out [ outputIndex ++ ] += vl * sample ; out [ outputIndex ++ ] += vr * sample ; Advance ( & inputIndex , & phaseFraction , phaseIncrement ) ; if ( outputIndex == outputSampleCount ) { break ; } } // ▁ process ▁ input ▁ samples ENDCOM // ▁ ALOGE ( " general ▁ case " ) ; ENDCOM # ifdef ASM_ARM_RESAMP1 // ▁ asm ▁ optimisation ▁ for ▁ ResamplerOrder1 ENDCOM if ( inputIndex + 2 < mBuffer . frameCount ) { int32_t * maxOutPt ; int32_t maxInIdx ; maxOutPt = out + ( outputSampleCount - 2 ) ; maxInIdx = ( int32_t ) mBuffer . frameCount - 2 ; AsmMono16Loop ( in , maxOutPt , maxInIdx , outputIndex , out , inputIndex , vl , vr , phaseFraction , phaseIncrement ) ; } # endif // ▁ ASM _ ARM _ RESAMP1 ENDCOM while ( outputIndex < outputSampleCount && inputIndex < mBuffer . frameCount ) { int32_t sample = Interp ( in [ inputIndex - 1 ] , in [ inputIndex ] , phaseFraction ) ; out [ outputIndex ++ ] += vl * sample ; out [ outputIndex ++ ] += vr * sample ; Advance ( & inputIndex , & phaseFraction , phaseIncrement ) ; } // ▁ ALOGE ( " loop ▁ done ▁ - ▁ outputIndex = % d , ▁ inputIndex = % d " , ▁ outputIndex , ▁ inputIndex ) ; ENDCOM // ▁ if ▁ done ▁ with ▁ buffer , ▁ save ▁ samples ENDCOM if ( inputIndex >= mBuffer . frameCount ) { inputIndex -= mBuffer . frameCount ; // ▁ ALOGE ( " buffer ▁ done , ▁ new ▁ input ▁ index ▁ % d " , ▁ inputIndex ) ; ENDCOM mX0L = mBuffer . i16 [ mBuffer . frameCount - 1 ] ; provider -> releaseBuffer ( & mBuffer ) ; // ▁ verify ▁ that ▁ the ▁ releaseBuffer ▁ resets ▁ the ▁ buffer ▁ frameCount ENDCOM // ▁ ALOG _ ASSERT ( mBuffer . frameCount ▁ = = ▁ 0 ) ; ENDCOM } } // ▁ ALOGE ( " output ▁ buffer ▁ full ▁ - ▁ outputIndex = % d , ▁ inputIndex = % d " , ▁ outputIndex , ▁ inputIndex ) ; ENDCOM resampleMono16_exit : // ▁ save ▁ state ENDCOM mInputIndex = inputIndex ; mPhaseFraction = phaseFraction ; return outputIndex ; } # ifdef ASM_ARM_RESAMP1 // ▁ asm ▁ optimisation ▁ for ▁ ResamplerOrder1 ENDCOM /* * * * * STRNEWLINE * STRNEWLINE * ▁ AsmMono16Loop STRNEWLINE * ▁ asm ▁ optimized ▁ monotonic ▁ loop ▁ version ; ▁ one ▁ loop ▁ is ▁ 2 ▁ frames STRNEWLINE * ▁ Input : STRNEWLINE * ▁ in ▁ : ▁ pointer ▁ on ▁ input ▁ samples STRNEWLINE * ▁ maxOutPt ▁ : ▁ pointer ▁ on ▁ first ▁ not ▁ filled STRNEWLINE * ▁ maxInIdx ▁ : ▁ index ▁ on ▁ first ▁ not ▁ used STRNEWLINE * ▁ outputIndex ▁ : ▁ pointer ▁ on ▁ current ▁ output ▁ index STRNEWLINE * ▁ out ▁ : ▁ pointer ▁ on ▁ output ▁ buffer STRNEWLINE * ▁ inputIndex ▁ : ▁ pointer ▁ on ▁ current ▁ input ▁ index STRNEWLINE * ▁ vl , ▁ vr ▁ : ▁ left ▁ and ▁ right ▁ gain STRNEWLINE * ▁ phaseFraction ▁ : ▁ pointer ▁ on ▁ current ▁ phase ▁ fraction STRNEWLINE * ▁ phaseIncrement STRNEWLINE * ▁ Output : STRNEWLINE * ▁ outputIndex ▁ : STRNEWLINE * ▁ out ▁ : ▁ updated ▁ buffer STRNEWLINE * ▁ inputIndex ▁ : ▁ index ▁ of ▁ next ▁ to ▁ use STRNEWLINE * ▁ phaseFraction ▁ : ▁ phase ▁ fraction ▁ for ▁ next ▁ interpolation STRNEWLINE * STRNEWLINE * * * * */ __attribute__ ( ( noinline ) ) void AudioResamplerOrder1 :: AsmMono16Loop ( int16_t * in , int32_t * maxOutPt , int32_t maxInIdx , size_t & outputIndex , int32_t * out , size_t & inputIndex , int32_t vl , int32_t vr , uint32_t & phaseFraction , uint32_t phaseIncrement ) { ( void ) maxOutPt ; // ▁ remove ▁ unused ▁ parameter ▁ warnings ENDCOM ( void ) maxInIdx ; ( void ) outputIndex ; ( void ) out ; ( void ) inputIndex ; ( void ) vl ; ( void ) vr ; ( void ) phaseFraction ; ( void ) phaseIncrement ; ( void ) in ; # define MO_PARAM5 "36" // ▁ offset ▁ of ▁ parameter ▁ 5 ▁ ( outputIndex ) ENDCOM asm ( " stmfd ▁ ▁ sp ! , ▁ { r4 , ▁ r5 , ▁ r6 , ▁ r7 , ▁ r8 , ▁ r9 , ▁ r10 , ▁ r11 , ▁ lr } \n " // ▁ get ▁ parameters ENDCOM " ▁ ▁ ▁ ldr ▁ r6 , ▁ [ sp , ▁ # " MO_PARAM5 " ▁ + ▁ 20 ] \n " // ▁ & phaseFraction ENDCOM " ▁ ▁ ▁ ldr ▁ r6 , ▁ [ r6 ] \n " // ▁ phaseFraction ENDCOM " ▁ ▁ ▁ ldr ▁ r7 , ▁ [ sp , ▁ # " MO_PARAM5 " ▁ + ▁ 8 ] \n " // ▁ & inputIndex ENDCOM " ▁ ▁ ▁ ldr ▁ r7 , ▁ [ r7 ] \n " // ▁ inputIndex ENDCOM " ▁ ▁ ▁ ldr ▁ r8 , ▁ [ sp , ▁ # " MO_PARAM5 " ▁ + ▁ 4 ] \n " // ▁ out ENDCOM " ▁ ▁ ▁ ldr ▁ r0 , ▁ [ sp , ▁ # " MO_PARAM5 " ▁ + ▁ 0 ] \n " // ▁ & outputIndex ENDCOM " ▁ ▁ ▁ ldr ▁ r0 , ▁ [ r0 ] \n " // ▁ outputIndex ENDCOM " ▁ ▁ ▁ add ▁ r8 , ▁ r8 , ▁ r0 , ▁ asl ▁ # 2 \n " // ▁ curOut ENDCOM " ▁ ▁ ▁ ldr ▁ r9 , ▁ [ sp , ▁ # " MO_PARAM5 " ▁ + ▁ 24 ] \n " // ▁ phaseIncrement ENDCOM " ▁ ▁ ▁ ldr ▁ r10 , ▁ [ sp , ▁ # " MO_PARAM5 " ▁ + ▁ 12 ] \n " // ▁ vl ENDCOM " ▁ ▁ ▁ ldr ▁ r11 , ▁ [ sp , ▁ # " MO_PARAM5 " ▁ + ▁ 16 ] \n " // ▁ vr ENDCOM // ▁ r0 ▁ pin , ▁ x0 , ▁ Samp ENDCOM // ▁ r1 ▁ in ENDCOM // ▁ r2 ▁ maxOutPt ENDCOM // ▁ r3 ▁ maxInIdx ENDCOM // ▁ r4 ▁ x1 , ▁ i1 , ▁ i3 , ▁ Out1 ENDCOM // ▁ r5 ▁ out0 ENDCOM // ▁ r6 ▁ frac ENDCOM // ▁ r7 ▁ inputIndex ENDCOM // ▁ r8 ▁ curOut ENDCOM // ▁ r9 ▁ inc ENDCOM // ▁ r10 ▁ vl ENDCOM // ▁ r11 ▁ vr ENDCOM // ▁ r12 ENDCOM // ▁ r13 ▁ sp ENDCOM // ▁ r14 ENDCOM // ▁ the ▁ following ▁ loop ▁ works ▁ on ▁ 2 ▁ frames ENDCOM "1 : \n " " ▁ ▁ ▁ cmp ▁ r8 , ▁ r2 \n " // ▁ curOut ▁ - ▁ maxCurOut ENDCOM " ▁ ▁ ▁ bcs ▁ 2f \n " # define MO_ONE_FRAME " ▁ ▁ ▁ add ▁ r0 , ▁ r1 , ▁ r7 , ▁ asl ▁ # 1 \n " /* ▁ in ▁ + ▁ inputIndex ▁ */ " ▁ ▁ ▁ ldrsh ▁ r4 , ▁ [ r0 ] \n " /* ▁ in [ inputIndex ] ▁ */ " ▁ ▁ ▁ ldr ▁ r5 , ▁ [ r8 ] \n " /* ▁ out [ outputIndex ] ▁ */ " ▁ ▁ ▁ ldrsh ▁ r0 , ▁ [ r0 , ▁ # -2 ] \n " /* ▁ in [ inputIndex - 1 ] ▁ */ " ▁ ▁ ▁ bic ▁ r6 , ▁ r6 , ▁ # 0xC0000000 \n " /* ▁ phaseFraction ▁ & ▁ . . . ▁ */ " ▁ ▁ ▁ sub ▁ r4 , ▁ r4 , ▁ r0 \n " /* ▁ in [ inputIndex ] ▁ - ▁ in [ inputIndex - 1 ] ▁ */ " ▁ ▁ ▁ mov ▁ r4 , ▁ r4 , ▁ lsl ▁ # 2 \n " " ▁ ▁ ▁ smulwt ▁ r4 , ▁ r4 , ▁ r6 \n " /* ▁ ( x1 - x0 ) * . . ▁ */ " ▁ ▁ ▁ add ▁ r6 , ▁ r6 , ▁ r9 \n " /* ▁ phaseFraction ▁ + ▁ phaseIncrement ▁ */ " ▁ ▁ ▁ add ▁ r0 , ▁ r0 , ▁ r4 \n " /* ▁ x0 ▁ - ▁ ( . . ) ▁ */ " ▁ ▁ ▁ mla ▁ r5 , ▁ r0 , ▁ r10 , ▁ r5 \n " /* ▁ vl * interp ▁ + ▁ out [ ] ▁ */ " ▁ ▁ ▁ ldr ▁ r4 , ▁ [ r8 , ▁ # 4 ] \n " /* ▁ out [ outputIndex + 1 ] ▁ */ " ▁ ▁ ▁ str ▁ r5 , ▁ [ r8 ] , ▁ # 4 \n " /* ▁ out [ outputIndex + + ] ▁ = ▁ . . . ▁ */ " ▁ ▁ ▁ mla ▁ r4 , ▁ r0 , ▁ r11 , ▁ r4 \n " /* ▁ vr * interp ▁ + ▁ out [ ] ▁ */ " ▁ ▁ ▁ add ▁ r7 , ▁ r7 , ▁ r6 , ▁ lsr ▁ # 30 \n " /* ▁ inputIndex ▁ + ▁ phaseFraction > > 30 ▁ */ " ▁ ▁ ▁ str ▁ r4 , ▁ [ r8 ] , ▁ # 4 \n " /* ▁ out [ outputIndex + + ] ▁ = ▁ . . . ▁ */ MO_ONE_FRAME // ▁ frame ▁ 1 ENDCOM MO_ONE_FRAME // ▁ frame ▁ 2 ENDCOM " ▁ ▁ ▁ cmp ▁ r7 , ▁ r3 \n " // ▁ inputIndex ▁ - ▁ maxInIdx ENDCOM " ▁ ▁ ▁ bcc ▁ 1b \n " "2 : \n " " ▁ ▁ ▁ bic ▁ r6 , ▁ r6 , ▁ # 0xC0000000 \n " // ▁ phaseFraction ▁ & ▁ . . . ENDCOM // ▁ save ▁ modified ▁ values ENDCOM " ▁ ▁ ▁ ldr ▁ r0 , ▁ [ sp , ▁ # " MO_PARAM5 " ▁ + ▁ 20 ] \n " // ▁ & phaseFraction ENDCOM " ▁ ▁ ▁ str ▁ r6 , ▁ [ r0 ] \n " // ▁ phaseFraction ENDCOM " ▁ ▁ ▁ ldr ▁ r0 , ▁ [ sp , ▁ # " MO_PARAM5 " ▁ + ▁ 8 ] \n " // ▁ & inputIndex ENDCOM " ▁ ▁ ▁ str ▁ r7 , ▁ [ r0 ] \n " // ▁ inputIndex ENDCOM " ▁ ▁ ▁ ldr ▁ r0 , ▁ [ sp , ▁ # " MO_PARAM5 " ▁ + ▁ 4 ] \n " // ▁ out ENDCOM " ▁ ▁ ▁ sub ▁ r8 , ▁ r0 \n " // ▁ curOut ▁ - ▁ out ENDCOM " ▁ ▁ ▁ asr ▁ r8 , ▁ # 2 \n " // ▁ new ▁ outputIndex ENDCOM " ▁ ▁ ▁ ldr ▁ r0 , ▁ [ sp , ▁ # " MO_PARAM5 " ▁ + ▁ 0 ] \n " // ▁ & outputIndex ENDCOM " ▁ ▁ ▁ str ▁ r8 , ▁ [ r0 ] \n " // ▁ save ▁ outputIndex ENDCOM " ▁ ▁ ▁ ldmfd ▁ ▁ ▁ sp ! , ▁ { r4 , ▁ r5 , ▁ r6 , ▁ r7 , ▁ r8 , ▁ r9 , ▁ r10 , ▁ r11 , ▁ pc } \n " ) ; } /* * * * * STRNEWLINE * STRNEWLINE * ▁ AsmStereo16Loop STRNEWLINE * ▁ asm ▁ optimized ▁ stereo ▁ loop ▁ version ; ▁ one ▁ loop ▁ is ▁ 2 ▁ frames STRNEWLINE * ▁ Input : STRNEWLINE * ▁ in ▁ : ▁ pointer ▁ on ▁ input ▁ samples STRNEWLINE * ▁ maxOutPt ▁ : ▁ pointer ▁ on ▁ first ▁ not ▁ filled STRNEWLINE * ▁ maxInIdx ▁ : ▁ index ▁ on ▁ first ▁ not ▁ used STRNEWLINE * ▁ outputIndex ▁ : ▁ pointer ▁ on ▁ current ▁ output ▁ index STRNEWLINE * ▁ out ▁ : ▁ pointer ▁ on ▁ output ▁ buffer STRNEWLINE * ▁ inputIndex ▁ : ▁ pointer ▁ on ▁ current ▁ input ▁ index STRNEWLINE * ▁ vl , ▁ vr ▁ : ▁ left ▁ and ▁ right ▁ gain STRNEWLINE * ▁ phaseFraction ▁ : ▁ pointer ▁ on ▁ current ▁ phase ▁ fraction STRNEWLINE * ▁ phaseIncrement STRNEWLINE * ▁ Output : STRNEWLINE * ▁ outputIndex ▁ : STRNEWLINE * ▁ out ▁ : ▁ updated ▁ buffer STRNEWLINE * ▁ inputIndex ▁ : ▁ index ▁ of ▁ next ▁ to ▁ use STRNEWLINE * ▁ phaseFraction ▁ : ▁ phase ▁ fraction ▁ for ▁ next ▁ interpolation STRNEWLINE * STRNEWLINE * * * * */ __attribute__ ( ( noinline ) ) void AudioResamplerOrder1 :: AsmStereo16Loop ( int16_t * in , int32_t * maxOutPt , int32_t maxInIdx , size_t & outputIndex , int32_t * out , size_t & inputIndex , int32_t vl , int32_t vr , uint32_t & phaseFraction , uint32_t phaseIncrement ) { ( void ) maxOutPt ; // ▁ remove ▁ unused ▁ parameter ▁ warnings ENDCOM ( void ) maxInIdx ; ( void ) outputIndex ; ( void ) out ; ( void ) inputIndex ; ( void ) vl ; ( void ) vr ; ( void ) phaseFraction ; ( void ) phaseIncrement ; ( void ) in ; # define ST_PARAM5 "40" // ▁ offset ▁ of ▁ parameter ▁ 5 ▁ ( outputIndex ) ENDCOM asm ( " stmfd ▁ ▁ sp ! , ▁ { r4 , ▁ r5 , ▁ r6 , ▁ r7 , ▁ r8 , ▁ r9 , ▁ r10 , ▁ r11 , ▁ r12 , ▁ lr } \n " // ▁ get ▁ parameters ENDCOM " ▁ ▁ ▁ ldr ▁ r6 , ▁ [ sp , ▁ # " ST_PARAM5 " ▁ + ▁ 20 ] \n " // ▁ & phaseFraction ENDCOM " ▁ ▁ ▁ ldr ▁ r6 , ▁ [ r6 ] \n " // ▁ phaseFraction ENDCOM " ▁ ▁ ▁ ldr ▁ r7 , ▁ [ sp , ▁ # " ST_PARAM5 " ▁ + ▁ 8 ] \n " // ▁ & inputIndex ENDCOM " ▁ ▁ ▁ ldr ▁ r7 , ▁ [ r7 ] \n " // ▁ inputIndex ENDCOM " ▁ ▁ ▁ ldr ▁ r8 , ▁ [ sp , ▁ # " ST_PARAM5 " ▁ + ▁ 4 ] \n " // ▁ out ENDCOM " ▁ ▁ ▁ ldr ▁ r0 , ▁ [ sp , ▁ # " ST_PARAM5 " ▁ + ▁ 0 ] \n " // ▁ & outputIndex ENDCOM " ▁ ▁ ▁ ldr ▁ r0 , ▁ [ r0 ] \n " // ▁ outputIndex ENDCOM " ▁ ▁ ▁ add ▁ r8 , ▁ r8 , ▁ r0 , ▁ asl ▁ # 2 \n " // ▁ curOut ENDCOM " ▁ ▁ ▁ ldr ▁ r9 , ▁ [ sp , ▁ # " ST_PARAM5 " ▁ + ▁ 24 ] \n " // ▁ phaseIncrement ENDCOM " ▁ ▁ ▁ ldr ▁ r10 , ▁ [ sp , ▁ # " ST_PARAM5 " ▁ + ▁ 12 ] \n " // ▁ vl ENDCOM " ▁ ▁ ▁ ldr ▁ r11 , ▁ [ sp , ▁ # " ST_PARAM5 " ▁ + ▁ 16 ] \n " // ▁ vr ENDCOM // ▁ r0 ▁ pin , ▁ x0 , ▁ Samp ENDCOM // ▁ r1 ▁ in ENDCOM // ▁ r2 ▁ maxOutPt ENDCOM // ▁ r3 ▁ maxInIdx ENDCOM // ▁ r4 ▁ x1 , ▁ i1 , ▁ i3 , ▁ out1 ENDCOM // ▁ r5 ▁ out0 ENDCOM // ▁ r6 ▁ frac ENDCOM // ▁ r7 ▁ inputIndex ENDCOM // ▁ r8 ▁ curOut ENDCOM // ▁ r9 ▁ inc ENDCOM // ▁ r10 ▁ vl ENDCOM // ▁ r11 ▁ vr ENDCOM // ▁ r12 ▁ temporary ENDCOM // ▁ r13 ▁ sp ENDCOM // ▁ r14 ENDCOM "3 : \n " " ▁ ▁ ▁ cmp ▁ r8 , ▁ r2 \n " // ▁ curOut ▁ - ▁ maxCurOut ENDCOM " ▁ ▁ ▁ bcs ▁ 4f \n " # define ST_ONE_FRAME " ▁ ▁ ▁ bic ▁ r6 , ▁ r6 , ▁ # 0xC0000000 \n " /* ▁ phaseFraction ▁ & ▁ . . . ▁ */ " ▁ ▁ ▁ add ▁ r0 , ▁ r1 , ▁ r7 , ▁ asl ▁ # 2 \n " /* ▁ in ▁ + ▁ 2 * inputIndex ▁ */ " ▁ ▁ ▁ ldrsh ▁ r4 , ▁ [ r0 ] \n " /* ▁ in [ 2 * inputIndex ] ▁ */ " ▁ ▁ ▁ ldr ▁ r5 , ▁ [ r8 ] \n " /* ▁ out [ outputIndex ] ▁ */ " ▁ ▁ ▁ ldrsh ▁ r12 , ▁ [ r0 , ▁ # -4 ] \n " /* ▁ in [ 2 * inputIndex - 2 ] ▁ */ " ▁ ▁ ▁ sub ▁ r4 , ▁ r4 , ▁ r12 \n " /* ▁ in [ 2 * InputIndex ] ▁ - ▁ in [ 2 * InputIndex - 2 ] ▁ */ " ▁ ▁ ▁ mov ▁ r4 , ▁ r4 , ▁ lsl ▁ # 2 \n " " ▁ ▁ ▁ smulwt ▁ r4 , ▁ r4 , ▁ r6 \n " /* ▁ ( x1 - x0 ) * . . ▁ */ " ▁ ▁ ▁ add ▁ r12 , ▁ r12 , ▁ r4 \n " /* ▁ x0 ▁ - ▁ ( . . ) ▁ */ " ▁ ▁ ▁ mla ▁ r5 , ▁ r12 , ▁ r10 , ▁ r5 \n " /* ▁ vl * interp ▁ + ▁ out [ ] ▁ */ " ▁ ▁ ▁ ldr ▁ r4 , ▁ [ r8 , ▁ # 4 ] \n " /* ▁ out [ outputIndex + 1 ] ▁ */ " ▁ ▁ ▁ str ▁ r5 , ▁ [ r8 ] , ▁ # 4 \n " /* ▁ out [ outputIndex + + ] ▁ = ▁ . . . ▁ */ " ▁ ▁ ▁ ldrsh ▁ r12 , ▁ [ r0 , ▁ # + 2 ] \n " /* ▁ in [ 2 * inputIndex + 1 ] ▁ */ " ▁ ▁ ▁ ldrsh ▁ r0 , ▁ [ r0 , ▁ # -2 ] \n " /* ▁ in [ 2 * inputIndex - 1 ] ▁ */ " ▁ ▁ ▁ sub ▁ r12 , ▁ r12 , ▁ r0 \n " /* ▁ in [ 2 * InputIndex ] ▁ - ▁ in [ 2 * InputIndex - 2 ] ▁ */ " ▁ ▁ ▁ mov ▁ r12 , ▁ r12 , ▁ lsl ▁ # 2 \n " " ▁ ▁ ▁ smulwt ▁ r12 , ▁ r12 , ▁ r6 \n " /* ▁ ( x1 - x0 ) * . . ▁ */ " ▁ ▁ ▁ add ▁ r12 , ▁ r0 , ▁ r12 \n " /* ▁ x0 ▁ - ▁ ( . . ) ▁ */ " ▁ ▁ ▁ mla ▁ r4 , ▁ r12 , ▁ r11 , ▁ r4 \n " /* ▁ vr * interp ▁ + ▁ out [ ] ▁ */ " ▁ ▁ ▁ str ▁ r4 , ▁ [ r8 ] , ▁ # 4 \n " /* ▁ out [ outputIndex + + ] ▁ = ▁ . . . ▁ */ " ▁ ▁ ▁ add ▁ r6 , ▁ r6 , ▁ r9 \n " /* ▁ phaseFraction ▁ + ▁ phaseIncrement ▁ */ " ▁ ▁ ▁ add ▁ r7 , ▁ r7 , ▁ r6 , ▁ lsr ▁ # 30 \n " /* ▁ inputIndex ▁ + ▁ phaseFraction > > 30 ▁ */ ST_ONE_FRAME // ▁ frame ▁ 1 ENDCOM ST_ONE_FRAME // ▁ frame ▁ 1 ENDCOM " ▁ ▁ ▁ cmp ▁ r7 , ▁ r3 \n " // ▁ inputIndex ▁ - ▁ maxInIdx ENDCOM " ▁ ▁ ▁ bcc ▁ 3b \n " "4 : \n " " ▁ ▁ ▁ bic ▁ r6 , ▁ r6 , ▁ # 0xC0000000 \n " // ▁ phaseFraction ▁ & ▁ . . . ENDCOM // ▁ save ▁ modified ▁ values ENDCOM " ▁ ▁ ▁ ldr ▁ r0 , ▁ [ sp , ▁ # " ST_PARAM5 " ▁ + ▁ 20 ] \n " // ▁ & phaseFraction ENDCOM " ▁ ▁ ▁ str ▁ r6 , ▁ [ r0 ] \n " // ▁ phaseFraction ENDCOM " ▁ ▁ ▁ ldr ▁ r0 , ▁ [ sp , ▁ # " ST_PARAM5 " ▁ + ▁ 8 ] \n " // ▁ & inputIndex ENDCOM " ▁ ▁ ▁ str ▁ r7 , ▁ [ r0 ] \n " // ▁ inputIndex ENDCOM " ▁ ▁ ▁ ldr ▁ r0 , ▁ [ sp , ▁ # " ST_PARAM5 " ▁ + ▁ 4 ] \n " // ▁ out ENDCOM " ▁ ▁ ▁ sub ▁ r8 , ▁ r0 \n " // ▁ curOut ▁ - ▁ out ENDCOM " ▁ ▁ ▁ asr ▁ r8 , ▁ # 2 \n " // ▁ new ▁ outputIndex ENDCOM " ▁ ▁ ▁ ldr ▁ r0 , ▁ [ sp , ▁ # " ST_PARAM5 " ▁ + ▁ 0 ] \n " // ▁ & outputIndex ENDCOM " ▁ ▁ ▁ str ▁ r8 , ▁ [ r0 ] \n " // ▁ save ▁ outputIndex ENDCOM " ▁ ▁ ▁ ldmfd ▁ ▁ ▁ sp ! , ▁ { r4 , ▁ r5 , ▁ r6 , ▁ r7 , ▁ r8 , ▁ r9 , ▁ r10 , ▁ r11 , ▁ r12 , ▁ pc } \n " ) ; } # endif // ▁ ASM _ ARM _ RESAMP1 ENDCOM } } // ▁ namespace ▁ cocos2d ▁ { ▁ namespace ▁ experimental ▁ { ENDCOM </DOCUMENT>
<DOCUMENT_ID="CharlieMarshall/xbmc/tree/master/xbmc/cores/dvdplayer/DVDSubtitles/DVDSubtitleTagMicroDVD.cpp"> /* STRNEWLINE ▁ * ▁ Copyright ▁ ( C ) ▁ 2005-2013 ▁ Team ▁ XBMC STRNEWLINE ▁ * ▁ http : // xbmc . org STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ This ▁ Program ▁ is ▁ free ▁ software ; ▁ you ▁ can ▁ redistribute ▁ it ▁ and / or ▁ modify STRNEWLINE ▁ * ▁ it ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ as ▁ published ▁ by STRNEWLINE ▁ * ▁ the ▁ Free ▁ Software ▁ Foundation ; ▁ either ▁ version ▁ 2 , ▁ or ▁ ( at ▁ your ▁ option ) STRNEWLINE ▁ * ▁ any ▁ later ▁ version . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ This ▁ Program ▁ is ▁ distributed ▁ in ▁ the ▁ hope ▁ that ▁ it ▁ will ▁ be ▁ useful , STRNEWLINE ▁ * ▁ but ▁ WITHOUT ▁ ANY ▁ WARRANTY ; ▁ without ▁ even ▁ the ▁ implied ▁ warranty ▁ of STRNEWLINE ▁ * ▁ MERCHANTABILITY ▁ or ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE . ▁ See ▁ the STRNEWLINE ▁ * ▁ GNU ▁ General ▁ Public ▁ License ▁ for ▁ more ▁ details . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ You ▁ should ▁ have ▁ received ▁ a ▁ copy ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License STRNEWLINE ▁ * ▁ along ▁ with ▁ XBMC ; ▁ see ▁ the ▁ file ▁ COPYING . ▁ If ▁ not , ▁ see STRNEWLINE ▁ * ▁ < http : // www . gnu . org / licenses / > . STRNEWLINE ▁ * STRNEWLINE ▁ */ # include " DVDSubtitleTagMicroDVD . h " # include " DVDCodecs / Overlay / DVDOverlayText . h " # include " utils / StdString . h " # include " utils / StringUtils . h " void CDVDSubtitleTagMicroDVD :: ConvertLine ( CDVDOverlayText * pOverlay , const char * line , int len ) { CStdString strUTF8 ; strUTF8 . assign ( line , len ) ; m_flag [ FLAG_BOLD ] = 0 ; m_flag [ FLAG_ITALIC ] = 0 ; m_flag [ FLAG_COLOR ] = 0 ; int machine_status = 1 ; size_t pos = 0 ; while ( machine_status > 0 ) { if ( machine_status == 1 ) { if ( strUTF8 [ pos ] == ' { ' ) { size_t pos2 , pos3 ; if ( ( ( pos2 = strUTF8 . find ( ' : ' , pos ) ) != CStdString :: npos ) && ( ( pos3 = strUTF8 . find ( ' } ' , pos2 ) ) != CStdString :: npos ) ) { CStdString tagName = strUTF8 . substr ( pos + 1 , pos2 - pos - 1 ) ; CStdString tagValue = strUTF8 . substr ( pos2 + 1 , pos3 - pos2 - 1 ) ; StringUtils :: ToLower ( tagValue ) ; strUTF8 . erase ( pos , pos3 - pos + 1 ) ; if ( ( tagName == " Y " ) || ( tagName == " y " ) ) { if ( ( tagValue == " b " ) && ( m_flag [ FLAG_BOLD ] == 0 ) ) { m_flag [ FLAG_BOLD ] = ( tagName == " Y " ) ? TAG_ALL_LINE : TAG_ONE_LINE ; strUTF8 . insert ( pos , " [ B ] " ) ; pos += 3 ; } else if ( ( tagValue == " i " ) && ( m_flag [ FLAG_ITALIC ] == 0 ) ) { m_flag [ FLAG_ITALIC ] = ( tagName == " Y " ) ? TAG_ALL_LINE : TAG_ONE_LINE ; strUTF8 . insert ( pos , " [ I ] " ) ; pos += 3 ; } } else if ( ( tagName == " C " ) || ( tagName == " c " ) ) { if ( ( tagValue [ 0 ] == ' $ ' ) && ( tagValue . size ( ) == 7 ) ) { bool bHex = true ; for ( int i = 1 ; i < 7 ; i ++ ) { char temp = tagValue [ i ] ; if ( ! ( ( '0' <= temp && temp <= '9' ) || ( ' a ' <= temp && temp <= ' f ' ) || ( ' A ' <= temp && temp <= ' F ' ) ) ) { bHex = false ; break ; } } if ( bHex && ( m_flag [ FLAG_COLOR ] == 0 ) ) { CStdString tempColorTag = " [ COLOR ▁ " ; tempColorTag += " FF " ; tempColorTag += tagValue . substr ( 1 , 6 ) ; tempColorTag += " ] " ; m_flag [ FLAG_COLOR ] = ( tagName == " C " ) ? TAG_ALL_LINE : TAG_ONE_LINE ; strUTF8 . insert ( pos , tempColorTag ) ; pos += tempColorTag . length ( ) ; } } } } else machine_status = 2 ; } else if ( strUTF8 [ pos ] == ' / ' ) { if ( m_flag [ FLAG_ITALIC ] == 0 ) { m_flag [ FLAG_ITALIC ] = TAG_ONE_LINE ; strUTF8 . replace ( pos , 1 , " [ I ] " ) ; pos += 3 ; } else strUTF8 . erase ( pos , 1 ) ; } else machine_status = 2 ; } else if ( machine_status == 2 ) { size_t pos4 ; if ( ( pos4 = strUTF8 . find ( ' | ' , pos ) ) != CStdString :: npos ) { pos = pos4 ; if ( m_flag [ FLAG_BOLD ] == TAG_ONE_LINE ) { m_flag [ FLAG_BOLD ] = 0 ; strUTF8 . insert ( pos , " [ / B ] " ) ; pos += 4 ; } if ( m_flag [ FLAG_ITALIC ] == TAG_ONE_LINE ) { m_flag [ FLAG_ITALIC ] = 0 ; strUTF8 . insert ( pos , " [ / I ] " ) ; pos += 4 ; } if ( m_flag [ FLAG_COLOR ] == TAG_ONE_LINE ) { m_flag [ FLAG_COLOR ] = 0 ; strUTF8 . insert ( pos , " [ / COLOR ] " ) ; pos += 8 ; } strUTF8 . replace ( pos , 1 , " [ CR ] " ) ; pos += 4 ; machine_status = 1 ; } else { if ( m_flag [ FLAG_BOLD ] != 0 ) strUTF8 . append ( " [ / B ] " ) ; if ( m_flag [ FLAG_ITALIC ] != 0 ) strUTF8 . append ( " [ / I ] " ) ; if ( m_flag [ FLAG_COLOR ] != 0 ) strUTF8 . append ( " [ / COLOR ] " ) ; machine_status = 0 ; } } } if ( strUTF8 . empty ( ) ) return ; if ( strUTF8 [ strUTF8 . size ( ) - 1 ] == ' \n ' ) strUTF8 . erase ( strUTF8 . size ( ) - 1 ) ; // ▁ add ▁ a ▁ new ▁ text ▁ element ▁ to ▁ our ▁ container ENDCOM pOverlay -> AddElement ( new CDVDOverlayText :: CElementText ( strUTF8 . c_str ( ) ) ) ; } </DOCUMENT>
<DOCUMENT_ID="xdajog/samsung_sources_i927/tree/master/external/webkit/Source/WebKit2/Shared/DictionaryPopupInfo.cpp"> /* STRNEWLINE ▁ * ▁ Copyright ▁ ( C ) ▁ 2011 ▁ Apple ▁ Inc . ▁ All ▁ rights ▁ reserved . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Redistribution ▁ and ▁ use ▁ in ▁ source ▁ and ▁ binary ▁ forms , ▁ with ▁ or ▁ without STRNEWLINE ▁ * ▁ modification , ▁ are ▁ permitted ▁ provided ▁ that ▁ the ▁ following ▁ conditions STRNEWLINE ▁ * ▁ are ▁ met : STRNEWLINE ▁ * ▁ 1 . ▁ Redistributions ▁ of ▁ source ▁ code ▁ must ▁ retain ▁ the ▁ above ▁ copyright STRNEWLINE ▁ * ▁ notice , ▁ this ▁ list ▁ of ▁ conditions ▁ and ▁ the ▁ following ▁ disclaimer . STRNEWLINE ▁ * ▁ 2 . ▁ Redistributions ▁ in ▁ binary ▁ form ▁ must ▁ reproduce ▁ the ▁ above ▁ copyright STRNEWLINE ▁ * ▁ notice , ▁ this ▁ list ▁ of ▁ conditions ▁ and ▁ the ▁ following ▁ disclaimer ▁ in ▁ the STRNEWLINE ▁ * ▁ documentation ▁ and / or ▁ other ▁ materials ▁ provided ▁ with ▁ the ▁ distribution . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ THIS ▁ SOFTWARE ▁ IS ▁ PROVIDED ▁ BY ▁ APPLE ▁ INC . ▁ AND ▁ ITS ▁ CONTRIBUTORS ▁ ` ` AS ▁ IS ' ' STRNEWLINE ▁ * ▁ AND ▁ ANY ▁ EXPRESS ▁ OR ▁ IMPLIED ▁ WARRANTIES , ▁ INCLUDING , ▁ BUT ▁ NOT ▁ LIMITED ▁ TO , STRNEWLINE ▁ * ▁ THE ▁ IMPLIED ▁ WARRANTIES ▁ OF ▁ MERCHANTABILITY ▁ AND ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR STRNEWLINE ▁ * ▁ PURPOSE ▁ ARE ▁ DISCLAIMED . ▁ IN ▁ NO ▁ EVENT ▁ SHALL ▁ APPLE ▁ INC . ▁ OR ▁ ITS ▁ CONTRIBUTORS STRNEWLINE ▁ * ▁ BE ▁ LIABLE ▁ FOR ▁ ANY ▁ DIRECT , ▁ INDIRECT , ▁ INCIDENTAL , ▁ SPECIAL , ▁ EXEMPLARY , ▁ OR STRNEWLINE ▁ * ▁ CONSEQUENTIAL ▁ DAMAGES ▁ ( INCLUDING , ▁ BUT ▁ NOT ▁ LIMITED ▁ TO , ▁ PROCUREMENT ▁ OF STRNEWLINE ▁ * ▁ SUBSTITUTE ▁ GOODS ▁ OR ▁ SERVICES ; ▁ LOSS ▁ OF ▁ USE , ▁ DATA , ▁ OR ▁ PROFITS ; ▁ OR ▁ BUSINESS STRNEWLINE ▁ * ▁ INTERRUPTION ) ▁ HOWEVER ▁ CAUSED ▁ AND ▁ ON ▁ ANY ▁ THEORY ▁ OF ▁ LIABILITY , ▁ WHETHER ▁ IN STRNEWLINE ▁ * ▁ CONTRACT , ▁ STRICT ▁ LIABILITY , ▁ OR ▁ TORT ▁ ( INCLUDING ▁ NEGLIGENCE ▁ OR ▁ OTHERWISE ) STRNEWLINE ▁ * ▁ ARISING ▁ IN ▁ ANY ▁ WAY ▁ OUT ▁ OF ▁ THE ▁ USE ▁ OF ▁ THIS ▁ SOFTWARE , ▁ EVEN ▁ IF ▁ ADVISED ▁ OF STRNEWLINE ▁ * ▁ THE ▁ POSSIBILITY ▁ OF ▁ SUCH ▁ DAMAGE . STRNEWLINE ▁ */ # include " config . h " # include " DictionaryPopupInfo . h " # include " WebCoreArgumentCoders . h " # if PLATFORM ( MAC ) # include " ArgumentCodersCF . h " # endif namespace WebKit { void DictionaryPopupInfo :: encode ( CoreIPC :: ArgumentEncoder * encoder ) const { encoder -> encode ( origin ) ; encoder -> encode ( fontInfo ) ; encoder -> encodeEnum ( type ) ; # if PLATFORM ( MAC ) && ! defined ( BUILDING_ON_SNOW_LEOPARD ) CoreIPC :: encode ( encoder , options . get ( ) ) ; # endif } bool DictionaryPopupInfo :: decode ( CoreIPC :: ArgumentDecoder * decoder , DictionaryPopupInfo & result ) { if ( ! decoder -> decode ( result . origin ) ) return false ; if ( ! decoder -> decode ( result . fontInfo ) ) return false ; if ( ! decoder -> decodeEnum ( result . type ) ) return false ; # if PLATFORM ( MAC ) && ! defined ( BUILDING_ON_SNOW_LEOPARD ) if ( ! CoreIPC :: decode ( decoder , result . options ) ) return false ; # endif return true ; } } // ▁ namespace ▁ WebKit ENDCOM </DOCUMENT>
