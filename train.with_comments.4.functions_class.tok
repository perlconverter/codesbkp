AboutDialog :: AboutDialog ( QWidget * parent ) : QDialog ( parent ) , ui ( new Ui :: AboutDialog ) { ui -> setupUi ( this ) ; // ▁ Set ▁ current ▁ copyright ▁ year ENDCOM ui -> copyrightLabel -> setText ( tr ( " Copyright " ) + QString ( " ▁ & copy ; ▁ 2009 - % 1 ▁ " ) . arg ( COPYRIGHT_YEAR ) + tr ( " The ▁ Bitcoin ▁ developers " ) + QString ( " < br > " ) + tr ( " Copyright " ) + QString ( " ▁ & copy ; ▁ " ) + tr ( " % 1 ▁ StartJOIN " ) . arg ( ABOUTDIALOG_COPYRIGHT_YEAR ) ) ; }
void AboutDialog :: setModel ( ClientModel * model ) { if ( model ) { ui -> versionLabel -> setText ( model -> formatFullVersion ( ) ) ; } }
AboutDialog :: ~ AboutDialog ( ) { delete ui ; }
void AboutDialog :: on_buttonBox_accepted ( ) { close ( ) ; }
ICMPPacket :: ICMPPacket ( IPAddress :: Family family , int dataSize ) : _pImpl ( 0 ) { if ( family == IPAddress :: IPv4 ) _pImpl = new ICMPv4PacketImpl ( dataSize ) ; else if ( family == IPAddress :: IPv6 ) throw NotImplementedException ( " ICMPv6 ▁ packets ▁ not ▁ implemented . " ) ; else throw InvalidArgumentException ( " Invalid ▁ or ▁ unsupported ▁ address ▁ family ▁ passed ▁ to ▁ ICMPPacket " ) ; }
ICMPPacket :: ~ ICMPPacket ( ) { delete _pImpl ; }
void ICMPPacket :: setDataSize ( int dataSize ) { _pImpl -> setDataSize ( dataSize ) ; }
const Poco :: UInt8 * ICMPPacket :: packet ( ) { return _pImpl -> packet ( ) ; }
std :: string ICMPPacket :: errorDescription ( Poco :: UInt8 * buffer , int length ) { return _pImpl -> errorDescription ( buffer , length ) ; }
std :: string ICMPPacket :: typeDescription ( int typeId ) { return _pImpl -> typeDescription ( typeId ) ; }
/* * * * * STRNEWLINE ▁ qgsnewhttpconnection . cpp ▁ - ▁ selector ▁ for ▁ a ▁ new ▁ HTTP ▁ server ▁ for ▁ WMS , ▁ etc . STRNEWLINE ▁ - - - - - STRNEWLINE ▁ begin ▁ : ▁ 3 ▁ April ▁ 2005 STRNEWLINE ▁ copyright ▁ : ▁ ( C ) ▁ 2005 ▁ by ▁ Brendan ▁ Morley STRNEWLINE ▁ email ▁ : ▁ morb ▁ at ▁ ozemail ▁ dot ▁ com ▁ dot ▁ au STRNEWLINE ▁ * * * * */ ENDCOM /* * * * * STRNEWLINE ▁ * ▁ * STRNEWLINE ▁ * ▁ This ▁ program ▁ is ▁ free ▁ software ; ▁ you ▁ can ▁ redistribute ▁ it ▁ and / or ▁ modify ▁ * STRNEWLINE ▁ * ▁ it ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ as ▁ published ▁ by ▁ * STRNEWLINE ▁ * ▁ the ▁ Free ▁ Software ▁ Foundation ; ▁ either ▁ version ▁ 2 ▁ of ▁ the ▁ License , ▁ or ▁ * STRNEWLINE ▁ * ▁ ( at ▁ your ▁ option ) ▁ any ▁ later ▁ version . ▁ * STRNEWLINE ▁ * ▁ * STRNEWLINE ▁ * * * * */ ENDCOM QgsNewHttpConnection :: QgsNewHttpConnection ( QWidget * parent , const QString & baseKey , const QString & connName , Qt :: WindowFlags fl ) : QDialog ( parent , fl ) , mBaseKey ( baseKey ) , mOriginalConnName ( connName ) , mAuthConfigSelect ( nullptr ) { setupUi ( this ) ; QString service = baseKey . mid ( 18 , 3 ) . toUpper ( ) ; setWindowTitle ( tr ( " Create ▁ a ▁ new ▁ % 1 ▁ connection " ) . arg ( service ) ) ; // ▁ It ▁ would ▁ be ▁ obviously ▁ much ▁ better ▁ to ▁ use ▁ mBaseKey ▁ also ▁ for ▁ credentials , ENDCOM // ▁ but ▁ for ▁ some ▁ strange ▁ reason ▁ a ▁ different ▁ hardcoded ▁ key ▁ was ▁ used ▁ instead . ENDCOM // ▁ WFS ▁ and ▁ WMS ▁ credentials ▁ were ▁ mixed ▁ with ▁ the ▁ same ▁ key ▁ WMS . ENDCOM // ▁ Only ▁ WMS ▁ and ▁ WFS ▁ providers ▁ are ▁ using ▁ QgsNewHttpConnection ▁ at ▁ this ▁ moment ENDCOM // ▁ using ▁ connection - wms ▁ and ▁ connection - wfs ▁ - > ▁ parse ▁ credential ▁ key ▁ fro ▁ it . ENDCOM mCredentialsBaseKey = mBaseKey . split ( ' - ' ) . last ( ) . toUpper ( ) ; txtName -> setValidator ( new QRegExpValidator ( QRegExp ( " [ ^ \\ / ] + " ) , txtName ) ) ; cmbDpiMode -> clear ( ) ; cmbDpiMode -> addItem ( tr ( " all " ) ) ; cmbDpiMode -> addItem ( tr ( " off " ) ) ; cmbDpiMode -> addItem ( tr ( " QGIS " ) ) ; cmbDpiMode -> addItem ( tr ( " UMN " ) ) ; cmbDpiMode -> addItem ( tr ( " GeoServer " ) ) ; cmbVersion -> clear ( ) ; cmbVersion -> addItem ( tr ( " Auto - detect " ) ) ; cmbVersion -> addItem ( tr ( "1.0" ) ) ; cmbVersion -> addItem ( tr ( "1.1" ) ) ; cmbVersion -> addItem ( tr ( "2.0" ) ) ; mAuthConfigSelect = new QgsAuthConfigSelect ( this ) ; tabAuth -> insertTab ( 1 , mAuthConfigSelect , tr ( " Configurations " ) ) ; if ( ! connName . isEmpty ( ) ) { // ▁ populate ▁ the ▁ dialog ▁ with ▁ the ▁ information ▁ stored ▁ for ▁ the ▁ connection ENDCOM // ▁ populate ▁ the ▁ fields ▁ with ▁ the ▁ stored ▁ setting ▁ parameters ENDCOM QSettings settings ; QString key = mBaseKey + connName ; QString credentialsKey = " / Qgis / " + mCredentialsBaseKey + ' / ' + connName ; txtName -> setText ( connName ) ; txtUrl -> setText ( settings . value ( key + " / url " ) . toString ( ) ) ; cbxIgnoreGetMapURI -> setChecked ( settings . value ( key + " / ignoreGetMapURI " , false ) . toBool ( ) ) ; cbxIgnoreAxisOrientation -> setChecked ( settings . value ( key + " / ignoreAxisOrientation " , false ) . toBool ( ) ) ; cbxInvertAxisOrientation -> setChecked ( settings . value ( key + " / invertAxisOrientation " , false ) . toBool ( ) ) ; cbxIgnoreGetFeatureInfoURI -> setChecked ( settings . value ( key + " / ignoreGetFeatureInfoURI " , false ) . toBool ( ) ) ; cbxSmoothPixmapTransform -> setChecked ( settings . value ( key + " / smoothPixmapTransform " , false ) . toBool ( ) ) ; int dpiIdx ; switch ( settings . value ( key + " / dpiMode " , 7 ) . toInt ( ) ) { case 0 : // ▁ off ENDCOM dpiIdx = 1 ; break ; case 1 : // ▁ QGIS ENDCOM dpiIdx = 2 ; break ; case 2 : // ▁ UMN ENDCOM dpiIdx = 3 ; break ; case 4 : // ▁ GeoServer ENDCOM dpiIdx = 4 ; break ; default : // ▁ other ▁ = > ▁ all ENDCOM dpiIdx = 0 ; break ; } cmbDpiMode -> setCurrentIndex ( dpiIdx ) ; QString version = settings . value ( key + " / version " ) . toString ( ) ; int versionIdx = 0 ; // ▁ AUTO ENDCOM if ( version == "1.0.0" ) versionIdx = 1 ; else if ( version == "1.1.0" ) versionIdx = 2 ; else if ( version == "2.0.0" ) versionIdx = 3 ; cmbVersion -> setCurrentIndex ( versionIdx ) ; txtReferer -> setText ( settings . value ( key + " / referer " ) . toString ( ) ) ; txtMaxNumFeatures -> setText ( settings . value ( key + " / maxnumfeatures " ) . toString ( ) ) ; txtUserName -> setText ( settings . value ( credentialsKey + " / username " ) . toString ( ) ) ; txtPassword -> setText ( settings . value ( credentialsKey + " / password " ) . toString ( ) ) ; QString authcfg = settings . value ( credentialsKey + " / authcfg " ) . toString ( ) ; mAuthConfigSelect -> setConfigId ( authcfg ) ; if ( ! authcfg . isEmpty ( ) ) { tabAuth -> setCurrentIndex ( tabAuth -> indexOf ( mAuthConfigSelect ) ) ; } } if ( mBaseKey != " / Qgis / connections - wms / " ) { if ( mBaseKey != " / Qgis / connections - wcs / " && mBaseKey != " / Qgis / connections - wfs / " ) { cbxIgnoreAxisOrientation -> setVisible ( false ) ; cbxInvertAxisOrientation -> setVisible ( false ) ; mGroupBox -> layout ( ) -> removeWidget ( cbxIgnoreAxisOrientation ) ; mGroupBox -> layout ( ) -> removeWidget ( cbxInvertAxisOrientation ) ; } if ( mBaseKey == " / Qgis / connections - wfs / " ) { cbxIgnoreAxisOrientation -> setText ( tr ( " Ignore ▁ axis ▁ orientation ▁ ( WFS ▁ 1.1 / WFS ▁ 2.0 ) " ) ) ; } if ( mBaseKey == " / Qgis / connections - wcs / " ) { cbxIgnoreGetMapURI -> setText ( tr ( " Ignore ▁ GetCoverage ▁ URI ▁ reported ▁ in ▁ capabilities " ) ) ; cbxIgnoreAxisOrientation -> setText ( tr ( " Ignore ▁ axis ▁ orientation " ) ) ; } else { cbxIgnoreGetMapURI -> setVisible ( false ) ; cbxSmoothPixmapTransform -> setVisible ( false ) ; mGroupBox -> layout ( ) -> removeWidget ( cbxIgnoreGetMapURI ) ; mGroupBox -> layout ( ) -> removeWidget ( cbxSmoothPixmapTransform ) ; } cbxIgnoreGetFeatureInfoURI -> setVisible ( false ) ; mGroupBox -> layout ( ) -> removeWidget ( cbxIgnoreGetFeatureInfoURI ) ; cmbDpiMode -> setVisible ( false ) ; mGroupBox -> layout ( ) -> removeWidget ( cmbDpiMode ) ; lblDpiMode -> setVisible ( false ) ; mGroupBox -> layout ( ) -> removeWidget ( lblDpiMode ) ; txtReferer -> setVisible ( false ) ; mGroupBox -> layout ( ) -> removeWidget ( txtReferer ) ; lblReferer -> setVisible ( false ) ; mGroupBox -> layout ( ) -> removeWidget ( lblReferer ) ; } if ( mBaseKey != " / Qgis / connections - wfs / " ) { cmbVersion -> setVisible ( false ) ; mGroupBox -> layout ( ) -> removeWidget ( cmbVersion ) ; lblMaxNumFeatures -> setVisible ( false ) ; mGroupBox -> layout ( ) -> removeWidget ( lblMaxNumFeatures ) ; txtMaxNumFeatures -> setVisible ( false ) ; mGroupBox -> layout ( ) -> removeWidget ( txtMaxNumFeatures ) ; } // ▁ Adjust ▁ height ENDCOM int w = width ( ) ; adjustSize ( ) ; resize ( w , height ( ) ) ; on_txtName_textChanged ( connName ) ; }
void QgsNewHttpConnection :: on_txtName_textChanged ( const QString & text ) { Q_UNUSED ( text ) ; buttonBox -> button ( QDialogButtonBox :: Ok ) -> setDisabled ( txtName -> text ( ) . isEmpty ( ) || txtUrl -> text ( ) . isEmpty ( ) ) ; }
void QgsNewHttpConnection :: on_txtUrl_textChanged ( const QString & text ) { Q_UNUSED ( text ) ; buttonBox -> button ( QDialogButtonBox :: Ok ) -> setDisabled ( txtName -> text ( ) . isEmpty ( ) || txtUrl -> text ( ) . isEmpty ( ) ) ; }
void QgsNewHttpConnection :: accept ( ) { QSettings settings ; QString key = mBaseKey + txtName -> text ( ) ; QString credentialsKey = " / Qgis / " + mCredentialsBaseKey + ' / ' + txtName -> text ( ) ; // ▁ warn ▁ if ▁ entry ▁ was ▁ renamed ▁ to ▁ an ▁ existing ▁ connection ENDCOM if ( ( mOriginalConnName . isNull ( ) || mOriginalConnName . compare ( txtName -> text ( ) , Qt :: CaseInsensitive ) != 0 ) && settings . contains ( key + " / url " ) && QMessageBox :: question ( this , tr ( " Save ▁ connection " ) , tr ( " Should ▁ the ▁ existing ▁ connection ▁ % 1 ▁ be ▁ overwritten ? " ) . arg ( txtName -> text ( ) ) , QMessageBox :: Ok | QMessageBox :: Cancel ) == QMessageBox :: Cancel ) { return ; } if ( ! txtPassword -> text ( ) . isEmpty ( ) && QMessageBox :: question ( this , tr ( " Saving ▁ passwords " ) , tr ( " WARNING : ▁ You ▁ have ▁ entered ▁ a ▁ password . ▁ It ▁ will ▁ be ▁ stored ▁ in ▁ plain ▁ text ▁ in ▁ your ▁ project ▁ files ▁ and ▁ in ▁ your ▁ home ▁ directory ▁ on ▁ Unix - like ▁ systems , ▁ or ▁ in ▁ your ▁ user ▁ profile ▁ on ▁ Windows . ▁ If ▁ you ▁ do ▁ not ▁ want ▁ this ▁ to ▁ happen , ▁ please ▁ press ▁ the ▁ Cancel ▁ button . \n Note : ▁ giving ▁ the ▁ password ▁ is ▁ optional . ▁ It ▁ will ▁ be ▁ requested ▁ interactivly , ▁ when ▁ needed . " ) , QMessageBox :: Ok | QMessageBox :: Cancel ) == QMessageBox :: Cancel ) { return ; } // ▁ on ▁ rename ▁ delete ▁ original ▁ entry ▁ first ENDCOM if ( ! mOriginalConnName . isNull ( ) && mOriginalConnName != key ) { settings . remove ( mBaseKey + mOriginalConnName ) ; settings . remove ( " / Qgis / " + mCredentialsBaseKey + ' / ' + mOriginalConnName ) ; settings . sync ( ) ; } QUrl url ( txtUrl -> text ( ) . trimmed ( ) ) ; const QList < QPair < QByteArray , QByteArray > > & items = url . encodedQueryItems ( ) ; QHash < QString , QPair < QByteArray , QByteArray > > params ; for ( QList < QPair < QByteArray , QByteArray > > :: const_iterator it = items . constBegin ( ) ; it != items . constEnd ( ) ; ++ it ) { params . insert ( QString ( it -> first ) . toUpper ( ) , * it ) ; } if ( params [ " SERVICE " ] . second . toUpper ( ) == " WMS " || params [ " SERVICE " ] . second . toUpper ( ) == " WFS " || params [ " SERVICE " ] . second . toUpper ( ) == " WCS " ) { url . removeEncodedQueryItem ( params [ " SERVICE " ] . first ) ; url . removeEncodedQueryItem ( params [ " REQUEST " ] . first ) ; url . removeEncodedQueryItem ( params [ " FORMAT " ] . first ) ; } if ( url . encodedPath ( ) . isEmpty ( ) ) { url . setEncodedPath ( " / " ) ; } settings . setValue ( key + " / url " , url . toString ( ) ) ; if ( mBaseKey == " / Qgis / connections - wms / " || mBaseKey == " / Qgis / connections - wcs / " || mBaseKey == " / Qgis / connections - wfs / " ) { settings . setValue ( key + " / ignoreAxisOrientation " , cbxIgnoreAxisOrientation -> isChecked ( ) ) ; settings . setValue ( key + " / invertAxisOrientation " , cbxInvertAxisOrientation -> isChecked ( ) ) ; } if ( mBaseKey == " / Qgis / connections - wms / " || mBaseKey == " / Qgis / connections - wcs / " ) { settings . setValue ( key + " / ignoreGetMapURI " , cbxIgnoreGetMapURI -> isChecked ( ) ) ; settings . setValue ( key + " / smoothPixmapTransform " , cbxSmoothPixmapTransform -> isChecked ( ) ) ; int dpiMode = 0 ; switch ( cmbDpiMode -> currentIndex ( ) ) { case 0 : // ▁ all ▁ = > ▁ QGIS | UMN | GeoServer ENDCOM dpiMode = 7 ; break ; case 1 : // ▁ off ENDCOM dpiMode = 0 ; break ; case 2 : // ▁ QGIS ENDCOM dpiMode = 1 ; break ; case 3 : // ▁ UMN ENDCOM dpiMode = 2 ; break ; case 4 : // ▁ GeoServer ENDCOM dpiMode = 4 ; break ; } settings . setValue ( key + " / dpiMode " , dpiMode ) ; } if ( mBaseKey == " / Qgis / connections - wms / " ) { settings . setValue ( key + " / ignoreGetFeatureInfoURI " , cbxIgnoreGetFeatureInfoURI -> isChecked ( ) ) ; } if ( mBaseKey == " / Qgis / connections - wfs / " ) { QString version = " auto " ; switch ( cmbVersion -> currentIndex ( ) ) { case 0 : version = " auto " ; break ; case 1 : version = "1.0.0" ; break ; case 2 : version = "1.1.0" ; break ; case 3 : version = "2.0.0" ; break ; } settings . setValue ( key + " / version " , version ) ; settings . setValue ( key + " / maxnumfeatures " , txtMaxNumFeatures -> text ( ) ) ; } settings . setValue ( key + " / referer " , txtReferer -> text ( ) ) ; settings . setValue ( credentialsKey + " / username " , txtUserName -> text ( ) ) ; settings . setValue ( credentialsKey + " / password " , txtPassword -> text ( ) ) ; settings . setValue ( credentialsKey + " / authcfg " , mAuthConfigSelect -> configId ( ) ) ; settings . setValue ( mBaseKey + " / selected " , txtName -> text ( ) ) ; QDialog :: accept ( ) ; }
/* ! STRNEWLINE ▁ * ▁ \class ▁ QtAws : : SSM : : DescribeInstancePatchStatesResponse STRNEWLINE ▁ * ▁ \brief ▁ The ▁ DescribeInstancePatchStatesResponse ▁ class ▁ provides ▁ an ▁ interace ▁ for ▁ SSM ▁ DescribeInstancePatchStates ▁ responses . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ \inmodule ▁ QtAwsSSM STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ < fullname > AWS ▁ Systems ▁ Manager < / fullname > STRNEWLINE ▁ * ▁ STRNEWLINE ▁ * ▁ AWS ▁ Systems ▁ Manager ▁ is ▁ a ▁ collection ▁ of ▁ capabilities ▁ that ▁ helps ▁ you ▁ automate ▁ management ▁ tasks ▁ such ▁ as ▁ collecting ▁ system STRNEWLINE ▁ * ▁ inventory , ▁ applying ▁ operating ▁ system ▁ ( OS ) ▁ patches , ▁ automating ▁ the ▁ creation ▁ of ▁ Amazon ▁ Machine ▁ Images ▁ ( AMIs ) , ▁ and STRNEWLINE ▁ * ▁ configuring ▁ operating ▁ systems ▁ ( OSs ) ▁ and ▁ applications ▁ at ▁ scale . ▁ Systems ▁ Manager ▁ lets ▁ you ▁ remotely ▁ and ▁ securely ▁ manage ▁ the STRNEWLINE ▁ * ▁ configuration ▁ of ▁ your ▁ managed ▁ instances . ▁ A ▁ < i > managed ▁ instance < / i > ▁ is ▁ any ▁ Amazon ▁ EC2 ▁ instance ▁ or ▁ on - premises ▁ machine ▁ in STRNEWLINE ▁ * ▁ your ▁ hybrid ▁ environment ▁ that ▁ has ▁ been ▁ configured ▁ for ▁ Systems STRNEWLINE ▁ * ▁ STRNEWLINE ▁ * ▁ Manager > STRNEWLINE ▁ * ▁ STRNEWLINE ▁ * ▁ This ▁ reference ▁ is ▁ intended ▁ to ▁ be ▁ used ▁ with ▁ the ▁ < a STRNEWLINE ▁ * ▁ href = " http : // docs . aws . amazon . com / systems - manager / latest / userguide / " > AWS ▁ Systems ▁ Manager ▁ User STRNEWLINE ▁ * ▁ STRNEWLINE ▁ * ▁ Guide < / a > > STRNEWLINE ▁ * ▁ STRNEWLINE ▁ * ▁ To ▁ get ▁ started , ▁ verify ▁ prerequisites ▁ and ▁ configure ▁ managed ▁ instances . ▁ For ▁ more ▁ information , ▁ see ▁ < a STRNEWLINE ▁ * ▁ href = " http : // docs . aws . amazon . com / systems - manager / latest / userguide / systems - manager - setting - up . html " > Systems ▁ Manager STRNEWLINE ▁ * ▁ Prerequisites < / a > ▁ in ▁ the ▁ < i > AWS ▁ Systems ▁ Manager ▁ User STRNEWLINE ▁ * ▁ STRNEWLINE ▁ * ▁ Guide < / i > > STRNEWLINE ▁ * ▁ STRNEWLINE ▁ * ▁ For ▁ information ▁ about ▁ other ▁ API ▁ actions ▁ you ▁ can ▁ perform ▁ on ▁ Amazon ▁ EC2 ▁ instances , ▁ see ▁ the ▁ < a STRNEWLINE ▁ * ▁ href = " http : // docs . aws . amazon . com / AWSEC2 / latest / APIReference / " > Amazon ▁ EC2 ▁ API ▁ Reference < / a > . ▁ For ▁ information ▁ about ▁ how ▁ to STRNEWLINE ▁ * ▁ use ▁ a ▁ Query ▁ API , ▁ see ▁ < a ▁ href = " http : // docs . aws . amazon . com / AWSEC2 / latest / APIReference / making - api - requests . html " > Making ▁ API STRNEWLINE ▁ * ▁ Requests < / a > . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ \sa ▁ SsmClient : : describeInstancePatchStates STRNEWLINE ▁ */ ENDCOM /* ! STRNEWLINE ▁ * ▁ Constructs ▁ a ▁ DescribeInstancePatchStatesResponse ▁ object ▁ for ▁ \a ▁ reply ▁ to ▁ \a ▁ request , ▁ with ▁ parent ▁ \a ▁ parent . STRNEWLINE ▁ */ ENDCOM DescribeInstancePatchStatesResponse :: DescribeInstancePatchStatesResponse ( const DescribeInstancePatchStatesRequest & request , QNetworkReply * const reply , QObject * const parent ) : SsmResponse ( new DescribeInstancePatchStatesResponsePrivate ( this ) , parent ) { setRequest ( new DescribeInstancePatchStatesRequest ( request ) ) ; setReply ( reply ) ; }
/* ! STRNEWLINE ▁ * ▁ eimp STRNEWLINE ▁ * ▁ Parses ▁ a ▁ successful ▁ SSM ▁ DescribeInstancePatchStates ▁ \a ▁ response . STRNEWLINE ▁ */ ENDCOM void DescribeInstancePatchStatesResponse :: parseSuccess ( QIODevice & response ) { // Q _ D ( DescribeInstancePatchStatesResponse ) ; ENDCOM QXmlStreamReader xml ( & response ) ; // / ▁ @ todo ENDCOM }
/* ! STRNEWLINE ▁ * ▁ Parses ▁ a ▁ SSM ▁ DescribeInstancePatchStates ▁ response ▁ element ▁ from ▁ \a ▁ xml . STRNEWLINE ▁ */ ENDCOM void DescribeInstancePatchStatesResponsePrivate :: parseDescribeInstancePatchStatesResponse ( QXmlStreamReader & xml ) { Q_ASSERT ( xml . name ( ) == QLatin1String ( " DescribeInstancePatchStatesResponse " ) ) ; Q_UNUSED ( xml ) // / < ▁ @ todo ENDCOM }
/* * * * * STRNEWLINE ▁ qgsfieldvalidator . cpp ▁ - ▁ description STRNEWLINE ▁ - - - - - STRNEWLINE ▁ begin ▁ : ▁ March ▁ 2011 STRNEWLINE ▁ copyright ▁ : ▁ ( C ) ▁ 2011 ▁ by ▁ SunilRajKiran - kCube STRNEWLINE ▁ email ▁ : ▁ sunilraj . kiran @ kcubeconsulting . com STRNEWLINE STRNEWLINE ▁ adapted ▁ version ▁ of ▁ QValidator ▁ for ▁ QgsField STRNEWLINE ▁ * * * * */ ENDCOM /* * * * * STRNEWLINE ▁ * ▁ * STRNEWLINE ▁ * ▁ This ▁ program ▁ is ▁ free ▁ software ; ▁ you ▁ can ▁ redistribute ▁ it ▁ and / or ▁ modify ▁ * STRNEWLINE ▁ * ▁ it ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ as ▁ published ▁ by ▁ * STRNEWLINE ▁ * ▁ the ▁ Free ▁ Software ▁ Foundation ; ▁ either ▁ version ▁ 2 ▁ of ▁ the ▁ License , ▁ or ▁ * STRNEWLINE ▁ * ▁ ( at ▁ your ▁ option ) ▁ any ▁ later ▁ version . ▁ * STRNEWLINE ▁ * ▁ * STRNEWLINE ▁ * * * * */ ENDCOM QgsFieldValidator :: QgsFieldValidator ( QObject * parent , const QgsField & field , QString dateFormat ) : QValidator ( parent ) , mField ( field ) , mDateFormat ( dateFormat ) { switch ( mField . type ( ) ) { case QVariant :: Int : { if ( mField . length ( ) > 0 ) { QString re = QString ( " - ? \\d { 0 , % 1 } " ) . arg ( mField . length ( ) ) ; mValidator = new QRegExpValidator ( QRegExp ( re ) , parent ) ; } else { mValidator = new QIntValidator ( parent ) ; } } break ; case QVariant :: Double : { if ( mField . length ( ) > 0 && mField . precision ( ) > 0 ) { QString re = QString ( " - ? \\d { 0 , % 1 } ( \\ . \\d { 0 , % 2 } ) ? " ) . arg ( mField . length ( ) - mField . precision ( ) ) . arg ( mField . precision ( ) ) ; mValidator = new QRegExpValidator ( QRegExp ( re ) , parent ) ; } else if ( mField . length ( ) > 0 && mField . precision ( ) == 0 ) { QString re = QString ( " - ? \\d { 0 , % 1 } " ) . arg ( mField . length ( ) ) ; mValidator = new QRegExpValidator ( QRegExp ( re ) , parent ) ; } else if ( mField . precision ( ) > 0 ) { QString re = QString ( " - ? \\d * ( \\ . \\d { 0 , % 1 } ) ? " ) . arg ( mField . precision ( ) ) ; mValidator = new QRegExpValidator ( QRegExp ( re ) , parent ) ; } else { mValidator = new QDoubleValidator ( parent ) ; } } break ; case QVariant :: LongLong : mValidator = new QgsLongLongValidator ( parent ) ; break ; default : mValidator = 0 ; } QSettings settings ; mNullValue = settings . value ( " qgis / nullValue " , " NULL " ) . toString ( ) ; }
QgsFieldValidator :: ~ QgsFieldValidator ( ) { delete mValidator ; }
HrPwPlot :: HrPwPlot ( MainWindow * mainWindow , HrPwWindow * hrPwWindow ) : QwtPlot ( hrPwWindow ) , hrPwWindow ( hrPwWindow ) , mainWindow ( mainWindow ) , bg ( NULL ) , delay ( - 1 ) , minHr ( 50 ) , minWatt ( 50 ) , maxWatt ( 500 ) , settings ( GC_SETTINGS_CO , GC_SETTINGS_APP ) , unit ( settings . value ( GC_UNIT ) ) { setCanvasBackground ( Qt :: white ) ; canvas ( ) -> setFrameStyle ( QFrame :: NoFrame ) ; setXTitle ( ) ; // ▁ Power ▁ ( Watts ) ENDCOM // ▁ Linear ▁ Regression ▁ Curve ENDCOM regCurve = new QwtPlotCurve ( " reg " ) ; regCurve -> setPen ( QPen ( GColor ( CPLOTMARKER ) ) ) ; regCurve -> attach ( this ) ; // ▁ Power ▁ distribution ENDCOM wattsStepCurve = new QwtPlotCurve ( " Power " ) ; wattsStepCurve -> setStyle ( QwtPlotCurve :: Steps ) ; wattsStepCurve -> setRenderHint ( QwtPlotItem :: RenderAntialiased ) ; QColor wattsColor = QColor ( 200 , 200 , 255 ) ; QColor wattsColor2 = QColor ( 100 , 100 , 255 ) ; wattsStepCurve -> setPen ( QPen ( wattsColor2 ) ) ; wattsStepCurve -> setBrush ( QBrush ( wattsColor ) ) ; wattsStepCurve -> attach ( this ) ; // ▁ Hr ▁ distribution ENDCOM hrStepCurve = new QwtPlotCurve ( " Hr " ) ; hrStepCurve -> setStyle ( QwtPlotCurve :: Steps ) ; hrStepCurve -> setRenderHint ( QwtPlotItem :: RenderAntialiased ) ; QColor hrColor = QColor ( 255 , 200 , 200 ) ; QColor hrColor2 = QColor ( 255 , 100 , 100 ) ; hrStepCurve -> setPen ( QPen ( hrColor2 ) ) ; hrStepCurve -> setBrush ( QBrush ( hrColor ) ) ; hrStepCurve -> attach ( this ) ; // ▁ Heart ▁ Rate ▁ Curve ENDCOM hrCurves . resize ( 36 ) ; for ( int i = 0 ; i < 36 ; ++ i ) { hrCurves [ i ] = new QwtPlotCurve ; hrCurves [ i ] -> attach ( this ) ; } // ▁ Grid ENDCOM grid = new QwtPlotGrid ( ) ; grid -> enableX ( false ) ; QPen gridPen ; gridPen . setStyle ( Qt :: DotLine ) ; gridPen . setColor ( GColor ( CPLOTGRID ) ) ; grid -> setPen ( gridPen ) ; grid -> attach ( this ) ; // ▁ axis ▁ markers ENDCOM r_mrk1 = new QwtPlotMarker ; r_mrk2 = new QwtPlotMarker ; r_mrk1 -> attach ( this ) ; r_mrk2 -> attach ( this ) ; shade_zones = true ; }
void HrPwPlot :: setAxisTitle ( int axis , QString label ) { // ▁ setup ▁ the ▁ default ▁ fonts ENDCOM QFont stGiles ; // ▁ hoho ▁ - ▁ Chart ▁ Font ▁ St . ▁ Giles ▁ . . . ▁ ok ▁ you ▁ have ▁ to ▁ be ▁ British ▁ to ▁ get ▁ this ▁ joke ENDCOM stGiles . fromString ( appsettings -> value ( this , GC_FONT_CHARTLABELS , QFont ( ) . toString ( ) ) . toString ( ) ) ; stGiles . setPointSize ( appsettings -> value ( NULL , GC_FONT_CHARTLABELS_SIZE , 8 ) . toInt ( ) ) ; QwtText title ( label ) ; title . setFont ( stGiles ) ; QwtPlot :: setAxisFont ( axis , stGiles ) ; QwtPlot :: setAxisTitle ( axis , title ) ; }
void HrPwPlot :: recalc ( ) { if ( timeArray . count ( ) == 0 ) return ; int rideTimeSecs = ( int ) ceil ( timeArray [ arrayLength - 1 ] ) ; if ( rideTimeSecs > 7 * 24 * 60 * 60 ) { return ; } // ▁ Find ▁ Hr ▁ Delay ENDCOM // int ▁ delayori ▁ = ▁ findDelay ( wattsArray , ▁ hrArray , ▁ rideTimeSecs / 5 ) ; ENDCOM // int ▁ delay ▁ = ▁ 0 ; ENDCOM // ▁ - - - - - ▁ smoothing ▁ - - - - - ENDCOM double totalWatts = 0.0 ; double totalHr = 0.0 ; QList < DataPoint * > list ; int i = 0 ; QVector < double > smoothWatts ( rideTimeSecs + 1 ) ; QVector < double > smoothHr ( rideTimeSecs + 1 ) ; QVector < double > smoothTime ( rideTimeSecs + 1 ) ; int decal = 0 ; /* for ▁ ( int ▁ secs ▁ = ▁ 0 ; ▁ ( ( secs ▁ < ▁ smooth ) ▁ & & ▁ ( secs ▁ < ▁ rideTimeSecs ) ) ; ▁ + + secs ) ▁ { STRNEWLINE ▁ smoothWatts [ secs ] ▁ = ▁ 0.0 ; STRNEWLINE ▁ smoothHr [ secs ] ▁ = ▁ 0.0 ; STRNEWLINE ▁ } */ ENDCOM // int ▁ interval ▁ = ▁ 0 ; ENDCOM int smooth = hrPwWindow -> smooth ; for ( int secs = smooth ; secs <= rideTimeSecs ; ++ secs ) { while ( ( i < arrayLength ) && ( timeArray [ i ] <= secs ) ) { DataPoint * dp = new DataPoint ( timeArray [ i ] , hrArray [ i ] , wattsArray [ i ] , interArray [ i ] ) ; totalWatts += wattsArray [ i ] ; totalHr += hrArray [ i ] ; list . append ( dp ) ; ++ i ; } while ( ! list . empty ( ) && ( list . front ( ) -> time < secs - smooth ) ) { DataPoint * dp = list . front ( ) ; list . removeFirst ( ) ; totalWatts -= dp -> watts ; totalHr -= dp -> hr ; delete dp ; } if ( list . empty ( ) ) { ++ decal ; } else { smoothWatts [ secs - decal ] = totalWatts / list . size ( ) ; smoothHr [ secs - decal ] = totalHr / list . size ( ) ; // ▁ Utiliser ▁ interval ▁ du ▁ fichier ENDCOM // if ▁ ( smooth / list . size ( ) > 0 ) ENDCOM // TABSYMBOL interval ▁ = ▁ smooth / list . size ( ) ; ENDCOM } smoothTime [ secs ] = secs / 60.0 ; } rideTimeSecs = rideTimeSecs - decal ; smoothWatts . resize ( rideTimeSecs ) ; smoothHr . resize ( rideTimeSecs ) ; // ▁ Clip ▁ to ▁ max ENDCOM QVector < double > clipWatts ( rideTimeSecs ) ; QVector < double > clipHr ( rideTimeSecs ) ; /* for ▁ ( int ▁ secs ▁ = ▁ 0 ; ▁ secs ▁ < ▁ rideTimeSecs ; ▁ + + secs ) ▁ { STRNEWLINE ▁ clipWatts [ secs ] ▁ = ▁ 0.0 ; STRNEWLINE ▁ clipHr [ secs ] ▁ = ▁ 0.0 ; STRNEWLINE ▁ } */ ENDCOM decal = 0 ; for ( int secs = 0 ; secs < rideTimeSecs ; ++ secs ) { if ( smoothHr [ secs ] >= minHr && smoothWatts [ secs ] >= minWatt && smoothWatts [ secs ] < maxWatt ) { clipWatts [ secs - decal ] = smoothWatts [ secs ] ; clipHr [ secs - decal ] = smoothHr [ secs ] ; } else decal ++ ; } rideTimeSecs = rideTimeSecs - decal ; clipWatts . resize ( rideTimeSecs ) ; clipHr . resize ( rideTimeSecs ) ; // ▁ Find ▁ Hr ▁ Delay ENDCOM if ( delay == - 1 ) delay = hrPwWindow -> findDelay ( clipWatts , clipHr , clipWatts . size ( ) ) ; // ▁ Apply ▁ delay ENDCOM QVector < double > delayWatts ( rideTimeSecs - delay ) ; QVector < double > delayHr ( rideTimeSecs - delay ) ; for ( int secs = 0 ; secs < rideTimeSecs - delay ; ++ secs ) { delayWatts [ secs ] = clipWatts [ secs ] ; delayHr [ secs ] = clipHr [ secs + delay ] ; } rideTimeSecs = rideTimeSecs - delay ; double rpente = hrPwWindow -> pente ( delayWatts , delayHr , delayWatts . size ( ) ) ; double rordonnee = hrPwWindow -> ordonnee ( delayWatts , delayHr , delayWatts . size ( ) ) ; double maxr = hrPwWindow -> corr ( delayWatts , delayHr , delayWatts . size ( ) ) ; // ▁ - - - - - ▁ limit ▁ plotted ▁ points ▁ - - - ENDCOM int intpoints = 10 ; // ▁ could ▁ be ▁ ride ▁ length ▁ dependent ENDCOM int nbpoints = ( int ) floor ( rideTimeSecs / intpoints ) ; QVector < double > plotedWatts ( nbpoints ) ; QVector < double > plotedHr ( nbpoints ) ; for ( int secs = 0 ; secs < nbpoints ; ++ secs ) { plotedWatts [ secs ] = clipWatts [ secs * intpoints ] ; plotedHr [ secs ] = clipHr [ secs * intpoints ] ; } int nbpoints2 = ( int ) floor ( nbpoints / 36 ) + 2 ; double * plotedWattsArray [ 36 ] ; double * plotedHrArray [ 36 ] ; for ( int i = 0 ; i < 36 ; ++ i ) { plotedWattsArray [ i ] = new double [ nbpoints2 ] ; plotedHrArray [ i ] = new double [ nbpoints2 ] ; } for ( int secs = 0 ; secs < nbpoints ; ++ secs ) { for ( int i = 0 ; i < 36 ; ++ i ) { if ( secs >= i * nbpoints2 && secs < ( i + 1 ) * nbpoints2 ) { plotedWattsArray [ i ] [ secs - i * nbpoints2 ] = plotedWatts [ secs - i ] ; plotedHrArray [ i ] [ secs - i * nbpoints2 ] = plotedHr [ secs - i ] ; } } } for ( int i = 0 ; i < 36 ; ++ i ) { if ( nbpoints - i * nbpoints2 > 0 ) { hrCurves [ i ] -> setData ( plotedWattsArray [ i ] , plotedHrArray [ i ] , ( nbpoints - i * nbpoints2 < nbpoints2 ? nbpoints - i * nbpoints2 : nbpoints2 ) ) ; hrCurves [ i ] -> setVisible ( true ) ; } else hrCurves [ i ] -> setVisible ( false ) ; } setAxisScale ( xBottom , 0.0 , maxWatt ) ; setYMax ( ) ; refreshZoneLabels ( ) ; QString labelp ; labelp . setNum ( rpente , ' f ' , 3 ) ; QString labelo ; labelo . setNum ( rordonnee , ' f ' , 1 ) ; QString labelr ; labelr . setNum ( maxr , ' f ' , 3 ) ; QString labeldelay ; labeldelay . setNum ( delay ) ; int power150 = ( int ) floor ( ( 150 - rordonnee ) / rpente ) ; QString labelpower150 ; labelpower150 . setNum ( power150 ) ; QwtText textr = QwtText ( labelp + " * x + " + labelo + " ▁ : ▁ R ▁ " + labelr + " ▁ ( " + labeldelay + " ) ▁ \n ▁ Power @ 150 : " + labelpower150 + " W " ) ; textr . setFont ( QFont ( " Helvetica " , 10 , QFont :: Bold ) ) ; textr . setColor ( Qt :: black ) ; r_mrk1 -> setValue ( 0 , 0 ) ; r_mrk1 -> setLineStyle ( QwtPlotMarker :: VLine ) ; r_mrk1 -> setLabelAlignment ( Qt :: AlignRight | Qt :: AlignTop ) ; r_mrk1 -> setLinePen ( QPen ( Qt :: black , 0 , Qt :: DashDotLine ) ) ; double moyennewatt = hrPwWindow -> moyenne ( clipWatts , clipWatts . size ( ) ) ; r_mrk1 -> setValue ( moyennewatt , 0.0 ) ; r_mrk1 -> setLabel ( textr ) ; r_mrk2 -> setValue ( 0 , 0 ) ; r_mrk2 -> setLineStyle ( QwtPlotMarker :: HLine ) ; r_mrk2 -> setLabelAlignment ( Qt :: AlignRight | Qt :: AlignTop ) ; r_mrk2 -> setLinePen ( QPen ( Qt :: black , 0 , Qt :: DashDotLine ) ) ; double moyennehr = hrPwWindow -> moyenne ( clipHr , clipHr . size ( ) ) ; r_mrk2 -> setValue ( 0.0 , moyennehr ) ; addWattStepCurve ( clipWatts , clipWatts . size ( ) ) ; addHrStepCurve ( clipHr , clipHr . size ( ) ) ; addRegLinCurve ( rpente , rordonnee ) ; setJoinLine ( joinLine ) ; replot ( ) ; }
void HrPwPlot :: setYMax ( ) { double ymax = 0 ; QString ylabel = " " ; for ( int i = 0 ; i < 36 ; ++ i ) { if ( hrCurves [ i ] -> isVisible ( ) ) { ymax = max ( ymax , hrCurves [ i ] -> maxYValue ( ) ) ; // ylabel ▁ + = ▁ QString ( ( ylabel ▁ = = ▁ " " ) ▁ ? ▁ " " ▁ : ▁ " ▁ / ▁ " ) ▁ + ▁ " BPM " ; ENDCOM } } setAxisScale ( yLeft , minHr , ymax * 1.2 ) ; setAxisTitle ( yLeft , tr ( " Heart ▁ Rate ( BPM ) " ) ) ; }
void HrPwPlot :: addWattStepCurve ( QVector < double > & finalWatts , int nbpoints ) { QMap < double , double > powerHist ; for ( int h = 0 ; h < nbpoints ; ++ h ) { if ( powerHist . contains ( finalWatts [ h ] ) ) powerHist [ finalWatts [ h ] ] += 1 ; else powerHist [ finalWatts [ h ] ] = 1 ; } int maxPower = 500 ; double * array = new double [ maxPower ] ; for ( int i = 0 ; i < maxPower ; ++ i ) array [ i ] = 0.0 ; QMapIterator < double , double > k ( powerHist ) ; while ( k . hasNext ( ) ) { k . next ( ) ; array [ ( int ) round ( k . key ( ) ) ] += k . value ( ) ; } int nbSteps = ( int ) ceil ( ( maxPower - 1 ) / 10 ) ; QVector < double > smoothWattsStep ( nbSteps + 1 ) ; QVector < double > smoothTimeStep ( nbSteps + 1 ) ; int t ; for ( t = 1 ; t < nbSteps ; ++ t ) { int low = t * 10 ; int high = low + 10 ; smoothWattsStep [ t ] = low ; smoothTimeStep [ t ] = minHr ; while ( low < high ) { smoothTimeStep [ t ] += array [ low ++ ] / nbpoints * 300 ; } } smoothTimeStep [ t ] = 0.0 ; smoothWattsStep [ t ] = t * 10 ; wattsStepCurve -> setData ( smoothWattsStep . data ( ) , smoothTimeStep . data ( ) , nbSteps + 1 ) ; }
void HrPwPlot :: addHrStepCurve ( QVector < double > & finalHr , int nbpoints ) { QMap < double , double > hrHist ; for ( int h = 0 ; h < nbpoints ; ++ h ) { if ( hrHist . contains ( finalHr [ h ] ) ) hrHist [ finalHr [ h ] ] += 1 ; else hrHist [ finalHr [ h ] ] = 1 ; } int maxHr = 220 ; double * array = new double [ maxHr ] ; for ( int i = 0 ; i < maxHr ; ++ i ) array [ i ] = 0.0 ; QMapIterator < double , double > l ( hrHist ) ; while ( l . hasNext ( ) ) { l . next ( ) ; array [ ( int ) round ( l . key ( ) ) ] += l . value ( ) ; } int nbSteps = ( int ) ceil ( ( maxHr - 1 ) / 2 ) ; QVector < double > smoothHrStep ( nbSteps + 1 ) ; QVector < double > smoothTimeStep2 ( nbSteps + 1 ) ; int t ; for ( t = 1 ; t < nbSteps ; ++ t ) { int low = t * 2 ; int high = low + 2 ; smoothHrStep [ t ] = low ; smoothTimeStep2 [ t ] = 0.0 ; while ( low < high ) { smoothTimeStep2 [ t ] += array [ low ++ ] / nbpoints * 500 ; } } smoothTimeStep2 [ t ] = 0.0 ; smoothHrStep [ t ] = t * 2 ; hrStepCurve -> setData ( smoothTimeStep2 . data ( ) , smoothHrStep . data ( ) , nbSteps + 1 ) ; }
void HrPwPlot :: addRegLinCurve ( double rpente , double rordonnee ) { double regWatts [ ] = { 0 , 0 } ; double regHr [ ] = { 0 , 500 } ; regWatts [ 0 ] = regHr [ 0 ] * rpente + rordonnee ; regWatts [ 1 ] = regHr [ 1 ] * rpente + rordonnee ; regCurve -> setData ( regHr , regWatts , 2 ) ; }
void HrPwPlot :: setXTitle ( ) { setAxisTitle ( xBottom , tr ( " Power ▁ ( Watts ) " ) ) ; }
void HrPwPlot :: setDataFromRide ( RideItem * _rideItem ) { rideItem = _rideItem ; // ▁ ignore ▁ null ▁ / ▁ bad ▁ rides ENDCOM if ( ! _rideItem || ! _rideItem -> ride ( ) ) return ; RideFile * ride = rideItem -> ride ( ) ; const RideFileDataPresent * dataPresent = ride -> areDataPresent ( ) ; int npoints = ride -> dataPoints ( ) . size ( ) ; if ( dataPresent -> watts && dataPresent -> hr ) { wattsArray . resize ( npoints ) ; hrArray . resize ( npoints ) ; timeArray . resize ( npoints ) ; interArray . resize ( npoints ) ; arrayLength = 0 ; // QListIterator < RideFilePoint * > ▁ i ( ride - > dataPoints ( ) ) ; ENDCOM // while ▁ ( i . hasNext ( ) ) ▁ { ENDCOM foreach ( const RideFilePoint * point , ride -> dataPoints ( ) ) { // RideFilePoint ▁ * point ▁ = ▁ i . next ( ) ; ENDCOM if ( ! timeArray . empty ( ) ) timeArray [ arrayLength ] = point -> secs ; if ( ! wattsArray . empty ( ) ) wattsArray [ arrayLength ] = max ( 0 , point -> watts ) ; if ( ! hrArray . empty ( ) ) hrArray [ arrayLength ] = max ( 0 , point -> hr ) ; if ( ! interArray . empty ( ) ) interArray [ arrayLength ] = point -> interval ; ++ arrayLength ; } delay = - 1 ; recalc ( ) ; } }
void HrPwPlot :: setJoinLine ( bool value ) { joinLine = value ; for ( int i = 0 ; i < 36 ; ++ i ) { QColor color = QColor ( 255 , 255 , 255 ) ; color . setHsv ( 60 + i * ( 360 / 36 ) , 255 , 255 , 255 ) ; if ( value ) { QwtSymbol sym ; sym . setStyle ( QwtSymbol :: NoSymbol ) ; QPen pen = QPen ( color ) ; pen . setWidth ( 1 ) ; hrCurves [ i ] -> setPen ( pen ) ; hrCurves [ i ] -> setStyle ( QwtPlotCurve :: Lines ) ; hrCurves [ i ] -> setSymbol ( new QwtSymbol ( sym ) ) ; } else { QwtSymbol sym ; sym . setStyle ( QwtSymbol :: Ellipse ) ; sym . setSize ( 5 ) ; sym . setPen ( QPen ( color ) ) ; sym . setBrush ( QBrush ( color ) ) ; hrCurves [ i ] -> setPen ( Qt :: NoPen ) ; hrCurves [ i ] -> setStyle ( QwtPlotCurve :: Dots ) ; hrCurves [ i ] -> setSymbol ( new QwtSymbol ( sym ) ) ; } // hrCurves [ i ] . setRenderHint ( QwtPlotItem : : RenderAntialiased ) ; ENDCOM } }
void HrPwPlot :: pointHover ( QwtPlotCurve * curve , int index ) { if ( index >= 0 ) { double yvalue = curve -> sample ( index ) . y ( ) ; double xvalue = curve -> sample ( index ) . x ( ) ; // ▁ output ▁ the ▁ tooltip ENDCOM QString text = QString ( " % 1 ▁ % 2 \n % 3 ▁ % 4" ) . arg ( yvalue , 0 , ' f ' , 0 ) . arg ( this -> axisTitle ( curve -> yAxis ( ) ) . text ( ) ) . arg ( xvalue , 0 , ' f ' , 2 ) . arg ( this -> axisTitle ( curve -> xAxis ( ) ) . text ( ) ) ; // ▁ set ▁ that ▁ text ▁ up ENDCOM tooltip -> setText ( text ) ; } else { tooltip -> setText ( " " ) ; } }
VariableDeltaSerializer :: VariableDeltaSerializer ( ) { didComparisonThisTick = false ; }
VariableDeltaSerializer :: ~ VariableDeltaSerializer ( ) { RemoveRemoteSystemVariableHistory ( ) ; }
VariableDeltaSerializer :: SerializationContext :: SerializationContext ( ) { variableHistoryIdentical = 0 ; variableHistoryUnique = 0 ; }
void VariableDeltaSerializer :: OnMessageReceipt ( RakNetGUID guid , uint32_t receiptId , bool messageArrived ) { // ▁ Module ? ENDCOM if ( messageArrived ) FreeVarsAssociatedWithReceipt ( guid , receiptId ) ; else DirtyAndFreeVarsAssociatedWithReceipt ( guid , receiptId ) ; }
void VariableDeltaSerializer :: BeginUnreliableAckedSerialize ( SerializationContext * context , RakNetGUID _guid , BitStream * _bitStream , uint32_t _sendReceipt ) { RakAssert ( _guid != UNASSIGNED_RAKNET_GUID ) ; context -> anyVariablesWritten = false ; context -> guid = _guid ; context -> bitStream = _bitStream ; if ( context -> variableHistoryUnique == 0 ) context -> variableHistoryUnique = StartVariableHistoryWrite ( _guid ) ; context -> variableHistory = context -> variableHistoryUnique ; context -> sendReceipt = _sendReceipt ; context -> changedVariables = AllocChangedVariablesList ( ) ; context -> newSystemSend = false ; context -> serializationMode = UNRELIABLE_WITH_ACK_RECEIPT ; }
void VariableDeltaSerializer :: BeginUniqueSerialize ( SerializationContext * context , RakNetGUID _guid , BitStream * _bitStream ) { RakAssert ( _guid != UNASSIGNED_RAKNET_GUID ) ; context -> anyVariablesWritten = false ; context -> guid = _guid ; context -> bitStream = _bitStream ; if ( context -> variableHistoryUnique == 0 ) context -> variableHistoryUnique = StartVariableHistoryWrite ( _guid ) ; context -> variableHistory = context -> variableHistoryUnique ; context -> newSystemSend = false ; context -> serializationMode = RELIABLE ; }
void VariableDeltaSerializer :: BeginIdenticalSerialize ( SerializationContext * context , bool _isFirstSendToRemoteSystem , BitStream * _bitStream ) { context -> anyVariablesWritten = false ; context -> guid = UNASSIGNED_RAKNET_GUID ; context -> bitStream = _bitStream ; context -> serializationMode = RELIABLE ; if ( context -> variableHistoryIdentical == 0 ) context -> variableHistoryIdentical = StartVariableHistoryWrite ( UNASSIGNED_RAKNET_GUID ) ; context -> variableHistory = context -> variableHistoryIdentical ; context -> newSystemSend = _isFirstSendToRemoteSystem ; }
void VariableDeltaSerializer :: EndSerialize ( SerializationContext * context ) { if ( context -> serializationMode == UNRELIABLE_WITH_ACK_RECEIPT ) { if ( context -> anyVariablesWritten == false ) { context -> bitStream -> Reset ( ) ; FreeChangedVariablesList ( context -> changedVariables ) ; return ; } StoreChangedVariablesList ( context -> variableHistory , context -> changedVariables , context -> sendReceipt ) ; } else { if ( context -> variableHistoryIdentical ) { if ( didComparisonThisTick == false ) { didComparisonThisTick = true ; identicalSerializationBs . Reset ( ) ; if ( context -> anyVariablesWritten == false ) { context -> bitStream -> Reset ( ) ; return ; } identicalSerializationBs . Write ( context -> bitStream ) ; context -> bitStream -> ResetReadPointer ( ) ; } else { context -> bitStream -> Write ( & identicalSerializationBs ) ; identicalSerializationBs . ResetReadPointer ( ) ; } } else if ( context -> anyVariablesWritten == false ) { context -> bitStream -> Reset ( ) ; return ; } } }
void VariableDeltaSerializer :: BeginDeserialize ( DeserializationContext * context , BitStream * _bitStream ) { context -> bitStream = _bitStream ; }
void VariableDeltaSerializer :: EndDeserialize ( DeserializationContext * context ) { ( void ) context ; }
void VariableDeltaSerializer :: AddRemoteSystemVariableHistory ( RakNetGUID guid ) { ( void ) guid ; }
void VariableDeltaSerializer :: RemoveRemoteSystemVariableHistory ( RakNetGUID guid ) { unsigned int idx , idx2 ; idx = GetVarsWrittenPerRemoteSystemListIndex ( guid ) ; if ( idx == ( unsigned int ) - 1 ) return ; if ( remoteSystemVariableHistoryList [ idx ] -> guid == guid ) { // ▁ Memory ▁ pool ▁ doesn ' t ▁ call ▁ destructor ENDCOM for ( idx2 = 0 ; idx2 < remoteSystemVariableHistoryList [ idx ] -> updatedVariablesHistory . Size ( ) ; idx2 ++ ) { FreeChangedVariablesList ( remoteSystemVariableHistoryList [ idx ] -> updatedVariablesHistory [ idx2 ] ) ; } delete remoteSystemVariableHistoryList [ idx ] ; remoteSystemVariableHistoryList . RemoveAtIndexFast ( idx ) ; return ; } }
int RakNet :: VariableDeltaSerializer :: UpdatedVariablesListPtrComp ( const uint32_t & key , ChangedVariablesList * const & data ) { if ( key < data -> sendReceipt ) return - 1 ; if ( key == data -> sendReceipt ) return 0 ; return 1 ; }
void VariableDeltaSerializer :: FreeVarsAssociatedWithReceipt ( RakNetGUID guid , uint32_t receiptId ) { unsigned int idx , idx2 ; idx = GetVarsWrittenPerRemoteSystemListIndex ( guid ) ; if ( idx == ( unsigned int ) - 1 ) return ; RemoteSystemVariableHistory * vprs = remoteSystemVariableHistoryList [ idx ] ; bool objectExists ; idx2 = vprs -> updatedVariablesHistory . GetIndexFromKey ( receiptId , & objectExists ) ; if ( objectExists ) { // ▁ Free ▁ this ▁ history ▁ node ENDCOM FreeChangedVariablesList ( vprs -> updatedVariablesHistory [ idx2 ] ) ; vprs -> updatedVariablesHistory . RemoveAtIndex ( idx2 ) ; } }
void VariableDeltaSerializer :: DirtyAndFreeVarsAssociatedWithReceipt ( RakNetGUID guid , uint32_t receiptId ) { unsigned int idx , idx2 ; idx = GetVarsWrittenPerRemoteSystemListIndex ( guid ) ; if ( idx == ( unsigned int ) - 1 ) return ; RemoteSystemVariableHistory * vprs = remoteSystemVariableHistoryList [ idx ] ; bool objectExists ; idx2 = vprs -> updatedVariablesHistory . GetIndexFromKey ( receiptId , & objectExists ) ; if ( objectExists ) { // ▁ ' Dirty ' ▁ all ▁ variables ▁ sent ▁ this ▁ update , ▁ meaning ▁ they ▁ will ▁ be ▁ resent ▁ the ▁ next ▁ time ▁ Serialize ( ) ▁ is ▁ called ENDCOM vprs -> variableListDeltaTracker . FlagDirtyFromBitArray ( vprs -> updatedVariablesHistory [ idx2 ] -> bitField ) ; // ▁ Free ▁ this ▁ history ▁ node ENDCOM FreeChangedVariablesList ( vprs -> updatedVariablesHistory [ idx2 ] ) ; vprs -> updatedVariablesHistory . RemoveAtIndex ( idx2 ) ; } }
unsigned int VariableDeltaSerializer :: GetVarsWrittenPerRemoteSystemListIndex ( RakNetGUID guid ) { unsigned int idx ; for ( idx = 0 ; idx < remoteSystemVariableHistoryList . Size ( ) ; idx ++ ) { if ( remoteSystemVariableHistoryList [ idx ] -> guid == guid ) return idx ; } return ( unsigned int ) - 1 ; }
void VariableDeltaSerializer :: RemoveRemoteSystemVariableHistory ( void ) { unsigned int idx , idx2 ; for ( idx = 0 ; idx < remoteSystemVariableHistoryList . Size ( ) ; idx ++ ) { for ( idx2 = 0 ; idx2 < remoteSystemVariableHistoryList [ idx ] -> updatedVariablesHistory . Size ( ) ; idx2 ++ ) { FreeChangedVariablesList ( remoteSystemVariableHistoryList [ idx ] -> updatedVariablesHistory [ idx2 ] ) ; } delete remoteSystemVariableHistoryList [ idx ] ; } remoteSystemVariableHistoryList . Clear ( false , _FILE_AND_LINE_ ) ; }
VariableDeltaSerializer :: RemoteSystemVariableHistory * VariableDeltaSerializer :: GetRemoteSystemVariableHistory ( RakNetGUID guid ) { unsigned int rshli = GetRemoteSystemHistoryListIndex ( guid ) ; return remoteSystemVariableHistoryList [ rshli ] ; }
VariableDeltaSerializer :: ChangedVariablesList * VariableDeltaSerializer :: AllocChangedVariablesList ( void ) { VariableDeltaSerializer :: ChangedVariablesList * p = updatedVariablesMemoryPool . Allocate ( _FILE_AND_LINE_ ) ; p -> bitWriteIndex = 0 ; p -> bitField [ 0 ] = 0 ; return p ; }
void VariableDeltaSerializer :: FreeChangedVariablesList ( ChangedVariablesList * changedVariables ) { updatedVariablesMemoryPool . Release ( changedVariables , _FILE_AND_LINE_ ) ; }
void VariableDeltaSerializer :: StoreChangedVariablesList ( RemoteSystemVariableHistory * variableHistory , ChangedVariablesList * changedVariables , uint32_t sendReceipt ) { changedVariables -> sendReceipt = sendReceipt ; variableHistory -> updatedVariablesHistory . Insert ( changedVariables -> sendReceipt , changedVariables , true , _FILE_AND_LINE_ ) ; }
VariableDeltaSerializer :: RemoteSystemVariableHistory * VariableDeltaSerializer :: StartVariableHistoryWrite ( RakNetGUID guid ) { RemoteSystemVariableHistory * variableHistory ; unsigned int rshli = GetRemoteSystemHistoryListIndex ( guid ) ; if ( rshli == ( unsigned int ) - 1 ) { variableHistory = new RemoteSystemVariableHistory ; variableHistory -> guid = guid ; remoteSystemVariableHistoryList . Push ( variableHistory , _FILE_AND_LINE_ ) ; } else { variableHistory = remoteSystemVariableHistoryList [ rshli ] ; } variableHistory -> variableListDeltaTracker . StartWrite ( ) ; return variableHistory ; }
unsigned int VariableDeltaSerializer :: GetRemoteSystemHistoryListIndex ( RakNetGUID guid ) { // ▁ Find ▁ the ▁ variable ▁ tracker ▁ for ▁ the ▁ target ▁ system ENDCOM unsigned int idx ; for ( idx = 0 ; idx < remoteSystemVariableHistoryList . Size ( ) ; idx ++ ) { if ( remoteSystemVariableHistoryList [ idx ] -> guid == guid ) { return idx ; } } return ( unsigned int ) - 1 ; }
void VariableDeltaSerializer :: OnPreSerializeTick ( void ) { didComparisonThisTick = false ; }
UINT32 mm1_state :: screen_update ( screen_device & screen , bitmap_rgb32 & bitmap , const rectangle & cliprect ) { /* ▁ text ▁ */ ENDCOM m_crtc -> screen_update ( screen , bitmap , cliprect ) ; /* ▁ graphics ▁ */ ENDCOM m_hgdc -> screen_update ( screen , bitmap , cliprect ) ; return 0 ; }
/* STRNEWLINE ▁ * ▁ Copyright ▁ 2011 ▁ Google ▁ Inc . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Use ▁ of ▁ this ▁ source ▁ code ▁ is ▁ governed ▁ by ▁ a ▁ BSD - style ▁ license ▁ that ▁ can ▁ be STRNEWLINE ▁ * ▁ found ▁ in ▁ the ▁ LICENSE ▁ file . STRNEWLINE ▁ */ ENDCOM void SkFlattenable :: InitializeFlattenables ( ) { SK_DEFINE_FLATTENABLE_REGISTRAR_ENTRY ( SkBitmapProcShader ) SK_DEFINE_FLATTENABLE_REGISTRAR_ENTRY ( SkBlurImageFilter ) SK_DEFINE_FLATTENABLE_REGISTRAR_ENTRY ( SkCornerPathEffect ) SK_DEFINE_FLATTENABLE_REGISTRAR_ENTRY ( SkDashPathEffect ) SK_DEFINE_FLATTENABLE_REGISTRAR_ENTRY ( SkLayerDrawLooper ) SK_DEFINE_FLATTENABLE_REGISTRAR_ENTRY ( SkMallocPixelRef ) SK_DEFINE_FLATTENABLE_REGISTRAR_ENTRY ( SkMagnifierImageFilter ) SkBlurMaskFilter :: InitializeFlattenables ( ) ; SkColorFilter :: InitializeFlattenables ( ) ; SkGradientShader :: InitializeFlattenables ( ) ; SkXfermode :: InitializeFlattenables ( ) ; }
/* *  STRNEWLINE ▁ * ▁ Build ▁ the ▁ vector ▁ of ▁ assignment ▁ operators .  STRNEWLINE ▁ * ▁ Used ▁ by ▁ BOTH ▁ ASFormatter . cpp ▁ and ▁ ASBeautifier . cpp STRNEWLINE ▁ *  STRNEWLINE ▁ * ▁ @ param ▁ assignmentOperators ▁ a ▁ reference ▁ to ▁ the ▁ vector ▁ to ▁ be ▁ built .  STRNEWLINE ▁ */ ENDCOM void ASResource :: buildAssignmentOperators ( vector < const string * > & assignmentOperators ) { assignmentOperators . push_back ( & AS_ASSIGN ) ; assignmentOperators . push_back ( & AS_PLUS_ASSIGN ) ; assignmentOperators . push_back ( & AS_MINUS_ASSIGN ) ; assignmentOperators . push_back ( & AS_MULT_ASSIGN ) ; assignmentOperators . push_back ( & AS_DIV_ASSIGN ) ; assignmentOperators . push_back ( & AS_MOD_ASSIGN ) ; assignmentOperators . push_back ( & AS_OR_ASSIGN ) ; assignmentOperators . push_back ( & AS_AND_ASSIGN ) ; assignmentOperators . push_back ( & AS_XOR_ASSIGN ) ; // ▁ Java ENDCOM assignmentOperators . push_back ( & AS_GR_GR_GR_ASSIGN ) ; assignmentOperators . push_back ( & AS_GR_GR_ASSIGN ) ; assignmentOperators . push_back ( & AS_LS_LS_ASSIGN ) ; // ▁ Unknown ENDCOM assignmentOperators . push_back ( & AS_LS_LS_LS_ASSIGN ) ; assignmentOperators . push_back ( & AS_RETURN ) ; }
/* *  STRNEWLINE ▁ * ▁ Build ▁ the ▁ vector ▁ of ▁ C + + ▁ cast ▁ operators .  STRNEWLINE ▁ * ▁ Used ▁ by ▁ ONLY ▁ ASFormatter . cpp STRNEWLINE ▁ *  STRNEWLINE ▁ * ▁ @ param ▁ castOperators ▁ a ▁ reference ▁ to ▁ the ▁ vector ▁ to ▁ be ▁ built .  STRNEWLINE ▁ */ ENDCOM void ASResource :: buildCastOperators ( vector < const string * > & castOperators ) { castOperators . push_back ( & AS_CONST_CAST ) ; castOperators . push_back ( & AS_DYNAMIC_CAST ) ; castOperators . push_back ( & AS_REINTERPRET_CAST ) ; castOperators . push_back ( & AS_STATIC_CAST ) ; }
/* *  STRNEWLINE ▁ * ▁ Build ▁ the ▁ vector ▁ of ▁ header ▁ words .  STRNEWLINE ▁ * ▁ Used ▁ by ▁ BOTH ▁ ASFormatter . cpp ▁ and ▁ ASBeautifier . cpp STRNEWLINE ▁ *  STRNEWLINE ▁ * ▁ @ param ▁ headers ▁ a ▁ reference ▁ to ▁ the ▁ vector ▁ to ▁ be ▁ built .  STRNEWLINE ▁ */ ENDCOM void ASResource :: buildHeaders ( vector < const string * > & headers , int fileType , bool beautifier ) { headers . push_back ( & AS_IF ) ; headers . push_back ( & AS_ELSE ) ; headers . push_back ( & AS_FOR ) ; headers . push_back ( & AS_WHILE ) ; headers . push_back ( & AS_DO ) ; headers . push_back ( & AS_SWITCH ) ; headers . push_back ( & AS_TRY ) ; headers . push_back ( & AS_CATCH ) ; if ( beautifier ) { headers . push_back ( & AS_CASE ) ; headers . push_back ( & AS_DEFAULT ) ; headers . push_back ( & AS_CONST ) ; headers . push_back ( & AS_STATIC ) ; headers . push_back ( & AS_EXTERN ) ; headers . push_back ( & AS_TEMPLATE ) ; } if ( fileType == JAVA_TYPE ) { headers . push_back ( & AS_FINALLY ) ; headers . push_back ( & AS_SYNCHRONIZED ) ; } if ( fileType == SHARP_TYPE ) { headers . push_back ( & AS_FINALLY ) ; headers . push_back ( & AS_FOREACH ) ; headers . push_back ( & AS_LOCK ) ; headers . push_back ( & AS_UNSAFE ) ; headers . push_back ( & AS_FIXED ) ; headers . push_back ( & AS_GET ) ; headers . push_back ( & AS_SET ) ; headers . push_back ( & AS_ADD ) ; headers . push_back ( & AS_REMOVE ) ; } }
/* *  STRNEWLINE ▁ * ▁ Build ▁ the ▁ vector ▁ of ▁ non - assignment ▁ operators .  STRNEWLINE ▁ * ▁ Used ▁ by ▁ ONLY ▁ ASBeautifier . cpp STRNEWLINE ▁ *  STRNEWLINE ▁ * ▁ @ param ▁ nonParenHeaders ▁ a ▁ reference ▁ to ▁ the ▁ vector ▁ to ▁ be ▁ built .  STRNEWLINE ▁ */ ENDCOM void ASResource :: buildNonAssignmentOperators ( vector < const string * > & nonAssignmentOperators ) { nonAssignmentOperators . push_back ( & AS_EQUAL ) ; nonAssignmentOperators . push_back ( & AS_PLUS_PLUS ) ; nonAssignmentOperators . push_back ( & AS_MINUS_MINUS ) ; nonAssignmentOperators . push_back ( & AS_NOT_EQUAL ) ; nonAssignmentOperators . push_back ( & AS_GR_EQUAL ) ; nonAssignmentOperators . push_back ( & AS_GR_GR_GR ) ; nonAssignmentOperators . push_back ( & AS_GR_GR ) ; nonAssignmentOperators . push_back ( & AS_LS_EQUAL ) ; nonAssignmentOperators . push_back ( & AS_LS_LS_LS ) ; nonAssignmentOperators . push_back ( & AS_LS_LS ) ; nonAssignmentOperators . push_back ( & AS_ARROW ) ; nonAssignmentOperators . push_back ( & AS_AND ) ; nonAssignmentOperators . push_back ( & AS_OR ) ; }
/* *  STRNEWLINE ▁ * ▁ Build ▁ the ▁ vector ▁ of ▁ header ▁ non - paren ▁ headers .  STRNEWLINE ▁ * ▁ Used ▁ by ▁ BOTH ▁ ASFormatter . cpp ▁ and ▁ ASBeautifier . cpp STRNEWLINE ▁ *  STRNEWLINE ▁ * ▁ @ param ▁ nonParenHeaders ▁ a ▁ reference ▁ to ▁ the ▁ vector ▁ to ▁ be ▁ built .  STRNEWLINE ▁ */ ENDCOM void ASResource :: buildNonParenHeaders ( vector < const string * > & nonParenHeaders , int fileType , bool beautifier ) { nonParenHeaders . push_back ( & AS_ELSE ) ; nonParenHeaders . push_back ( & AS_DO ) ; nonParenHeaders . push_back ( & AS_TRY ) ; if ( beautifier ) { nonParenHeaders . push_back ( & AS_CASE ) ; nonParenHeaders . push_back ( & AS_DEFAULT ) ; nonParenHeaders . push_back ( & AS_CONST ) ; nonParenHeaders . push_back ( & AS_STATIC ) ; nonParenHeaders . push_back ( & AS_EXTERN ) ; nonParenHeaders . push_back ( & AS_TEMPLATE ) ; } if ( fileType == JAVA_TYPE ) { nonParenHeaders . push_back ( & AS_FINALLY ) ; } if ( fileType == SHARP_TYPE ) { nonParenHeaders . push_back ( & AS_FINALLY ) ; nonParenHeaders . push_back ( & AS_UNSAFE ) ; nonParenHeaders . push_back ( & AS_GET ) ; nonParenHeaders . push_back ( & AS_SET ) ; nonParenHeaders . push_back ( & AS_ADD ) ; nonParenHeaders . push_back ( & AS_REMOVE ) ; } }
/* *  STRNEWLINE ▁ * ▁ Build ▁ the ▁ vector ▁ of ▁ operators .  STRNEWLINE ▁ * ▁ Used ▁ by ▁ ONLY ▁ ASFormatter . cpp STRNEWLINE ▁ *  STRNEWLINE ▁ * ▁ @ param ▁ operators ▁ a ▁ reference ▁ to ▁ the ▁ vector ▁ to ▁ be ▁ built .  STRNEWLINE ▁ */ ENDCOM void ASResource :: buildOperators ( vector < const string * > & operators ) { operators . push_back ( & AS_PLUS_ASSIGN ) ; operators . push_back ( & AS_MINUS_ASSIGN ) ; operators . push_back ( & AS_MULT_ASSIGN ) ; operators . push_back ( & AS_DIV_ASSIGN ) ; operators . push_back ( & AS_MOD_ASSIGN ) ; operators . push_back ( & AS_OR_ASSIGN ) ; operators . push_back ( & AS_AND_ASSIGN ) ; operators . push_back ( & AS_XOR_ASSIGN ) ; operators . push_back ( & AS_EQUAL ) ; operators . push_back ( & AS_PLUS_PLUS ) ; operators . push_back ( & AS_MINUS_MINUS ) ; operators . push_back ( & AS_NOT_EQUAL ) ; operators . push_back ( & AS_GR_EQUAL ) ; operators . push_back ( & AS_GR_GR_GR_ASSIGN ) ; operators . push_back ( & AS_GR_GR_ASSIGN ) ; operators . push_back ( & AS_GR_GR_GR ) ; operators . push_back ( & AS_GR_GR ) ; operators . push_back ( & AS_LS_EQUAL ) ; operators . push_back ( & AS_LS_LS_LS_ASSIGN ) ; operators . push_back ( & AS_LS_LS_ASSIGN ) ; operators . push_back ( & AS_LS_LS_LS ) ; operators . push_back ( & AS_LS_LS ) ; operators . push_back ( & AS_ARROW ) ; operators . push_back ( & AS_AND ) ; operators . push_back ( & AS_OR ) ; operators . push_back ( & AS_COLON_COLON ) ; operators . push_back ( & AS_PLUS ) ; operators . push_back ( & AS_MINUS ) ; operators . push_back ( & AS_MULT ) ; operators . push_back ( & AS_DIV ) ; operators . push_back ( & AS_MOD ) ; operators . push_back ( & AS_QUESTION ) ; operators . push_back ( & AS_COLON ) ; operators . push_back ( & AS_ASSIGN ) ; operators . push_back ( & AS_LS ) ; operators . push_back ( & AS_GR ) ; operators . push_back ( & AS_NOT ) ; operators . push_back ( & AS_BIT_OR ) ; operators . push_back ( & AS_BIT_AND ) ; operators . push_back ( & AS_BIT_NOT ) ; operators . push_back ( & AS_BIT_XOR ) ; operators . push_back ( & AS_OPERATOR ) ; operators . push_back ( & AS_COMMA ) ; operators . push_back ( & AS_RETURN ) ; }
/* *  STRNEWLINE ▁ * ▁ Build ▁ the ▁ vector ▁ of ▁ pre - block ▁ statements .  STRNEWLINE ▁ * ▁ Used ▁ by ▁ ONLY ▁ ASBeautifier . cpp STRNEWLINE ▁ *  STRNEWLINE ▁ * ▁ @ param ▁ preBlockStatements ▁ a ▁ reference ▁ to ▁ the ▁ vector ▁ to ▁ be ▁ built .  STRNEWLINE ▁ */ ENDCOM void ASResource :: buildPreBlockStatements ( vector < const string * > & preBlockStatements ) { preBlockStatements . push_back ( & AS_CLASS ) ; preBlockStatements . push_back ( & AS_STRUCT ) ; preBlockStatements . push_back ( & AS_UNION ) ; preBlockStatements . push_back ( & AS_INTERFACE ) ; preBlockStatements . push_back ( & AS_NAMESPACE ) ; preBlockStatements . push_back ( & AS_THROWS ) ; preBlockStatements . push_back ( & AS_EXTERN ) ; }
/* *  STRNEWLINE ▁ * ▁ Build ▁ the ▁ vector ▁ of ▁ pre - command ▁ headers .  STRNEWLINE ▁ * ▁ Used ▁ by ▁ ONLY ▁ ASFormatter . cpp STRNEWLINE ▁ *  STRNEWLINE ▁ * ▁ @ param ▁ preCommandHeaders ▁ a ▁ reference ▁ to ▁ the ▁ vector ▁ to ▁ be ▁ built .  STRNEWLINE ▁ */ ENDCOM void ASResource :: buildPreCommandHeaders ( vector < const string * > & preCommandHeaders ) { preCommandHeaders . push_back ( & AS_EXTERN ) ; preCommandHeaders . push_back ( & AS_THROWS ) ; preCommandHeaders . push_back ( & AS_CONST ) ; }
/* *  STRNEWLINE ▁ * ▁ Build ▁ the ▁ vector ▁ of ▁ pre - definition ▁ headers .  STRNEWLINE ▁ * ▁ Used ▁ by ▁ ONLY ▁ ASFormatter . cpp STRNEWLINE ▁ *  STRNEWLINE ▁ * ▁ @ param ▁ preDefinitionHeaders ▁ a ▁ reference ▁ to ▁ the ▁ vector ▁ to ▁ be ▁ built .  STRNEWLINE ▁ */ ENDCOM void ASResource :: buildPreDefinitionHeaders ( vector < const string * > & preDefinitionHeaders ) { preDefinitionHeaders . push_back ( & AS_CLASS ) ; preDefinitionHeaders . push_back ( & AS_INTERFACE ) ; preDefinitionHeaders . push_back ( & AS_NAMESPACE ) ; preDefinitionHeaders . push_back ( & AS_STRUCT ) ; }
std :: string HelpRequiringPassphrase ( ) { return pwalletMain && pwalletMain -> IsCrypted ( ) ? " \n requires ▁ wallet ▁ passphrase ▁ to ▁ be ▁ set ▁ with ▁ walletpassphrase ▁ first " : " " ; }
int asCScriptEngine :: SetEngineProperty ( asEEngineProp property , asPWORD value ) { switch ( property ) { case asEP_ALLOW_UNSAFE_REFERENCES : ep . allowUnsafeReferences = value ? true : false ; break ; case asEP_OPTIMIZE_BYTECODE : ep . optimizeByteCode = value ? true : false ; break ; case asEP_COPY_SCRIPT_SECTIONS : ep . copyScriptSections = value ? true : false ; break ; case asEP_MAX_STACK_SIZE : // ▁ The ▁ size ▁ is ▁ given ▁ in ▁ bytes , ▁ but ▁ we ▁ only ▁ store ▁ dwords ENDCOM ep . maximumContextStackSize = ( int ) value / 4 ; if ( initialContextStackSize > ep . maximumContextStackSize ) initialContextStackSize = ep . maximumContextStackSize ; break ; case asEP_USE_CHARACTER_LITERALS : ep . useCharacterLiterals = value ? true : false ; break ; case asEP_ALLOW_MULTILINE_STRINGS : ep . allowMultilineStrings = value ? true : false ; break ; case asEP_ALLOW_IMPLICIT_HANDLE_TYPES : ep . allowImplicitHandleTypes = value ? true : false ; break ; case asEP_BUILD_WITHOUT_LINE_CUES : ep . buildWithoutLineCues = value ? true : false ; break ; case asEP_INIT_GLOBAL_VARS_AFTER_BUILD : ep . initGlobalVarsAfterBuild = value ? true : false ; break ; case asEP_REQUIRE_ENUM_SCOPE : ep . requireEnumScope = value ? true : false ; break ; case asEP_SCRIPT_SCANNER : if ( value <= 1 ) ep . scanner = ( int ) value ; else return asINVALID_ARG ; break ; case asEP_INCLUDE_JIT_INSTRUCTIONS : ep . includeJitInstructions = value ? true : false ; break ; case asEP_STRING_ENCODING : if ( value <= 1 ) ep . stringEncoding = ( int ) value ; else return asINVALID_ARG ; break ; default : return asINVALID_ARG ; } return asSUCCESS ; }
asPWORD asCScriptEngine :: GetEngineProperty ( asEEngineProp property ) { switch ( property ) { case asEP_ALLOW_UNSAFE_REFERENCES : return ep . allowUnsafeReferences ; case asEP_OPTIMIZE_BYTECODE : return ep . optimizeByteCode ; case asEP_COPY_SCRIPT_SECTIONS : return ep . copyScriptSections ; case asEP_MAX_STACK_SIZE : return ep . maximumContextStackSize * 4 ; case asEP_USE_CHARACTER_LITERALS : return ep . useCharacterLiterals ; case asEP_ALLOW_MULTILINE_STRINGS : return ep . allowMultilineStrings ; case asEP_ALLOW_IMPLICIT_HANDLE_TYPES : return ep . allowImplicitHandleTypes ; case asEP_BUILD_WITHOUT_LINE_CUES : return ep . buildWithoutLineCues ; case asEP_INIT_GLOBAL_VARS_AFTER_BUILD : return ep . initGlobalVarsAfterBuild ; case asEP_REQUIRE_ENUM_SCOPE : return ep . requireEnumScope ; case asEP_SCRIPT_SCANNER : return ep . scanner ; case asEP_INCLUDE_JIT_INSTRUCTIONS : return ep . includeJitInstructions ; case asEP_STRING_ENCODING : return ep . stringEncoding ; } return 0 ; }
// ▁ extern ▁ " C " ENDCOM asCScriptEngine :: asCScriptEngine ( ) { // ▁ Instanciate ▁ the ▁ thread ▁ manager ENDCOM if ( threadManager == 0 ) threadManager = asNEW ( asCThreadManager ) ; else threadManager -> AddRef ( ) ; // ▁ Engine ▁ properties ENDCOM ep . allowUnsafeReferences = false ; ep . optimizeByteCode = true ; ep . copyScriptSections = true ; ep . maximumContextStackSize = 0 ; // ▁ no ▁ limit ENDCOM ep . useCharacterLiterals = false ; ep . allowMultilineStrings = false ; ep . allowImplicitHandleTypes = false ; ep . buildWithoutLineCues = false ; ep . initGlobalVarsAfterBuild = true ; ep . requireEnumScope = false ; ep . scanner = 1 ; // ▁ utf8 . ▁ 0 ▁ = ▁ ascii ENDCOM ep . includeJitInstructions = false ; ep . stringEncoding = 0 ; // ▁ utf8 . ▁ 1 ▁ = ▁ utf16 ENDCOM gc . engine = this ; refCount . set ( 1 ) ; stringFactory = 0 ; configFailed = false ; isPrepared = false ; isBuilding = false ; lastModule = 0 ; userData = 0 ; initialContextStackSize = 1024 ; // ▁ 1 ▁ KB ENDCOM typeIdSeqNbr = 0 ; currentGroup = & defaultGroup ; msgCallback = 0 ; jitCompiler = 0 ; // ▁ Reserve ▁ function ▁ id ▁ 0 ▁ for ▁ no ▁ function ENDCOM scriptFunctions . PushLast ( 0 ) ; // ▁ Make ▁ sure ▁ typeId ▁ for ▁ the ▁ built - in ▁ primitives ▁ are ▁ defined ▁ according ▁ to ▁ asETypeIdFlags ENDCOM int id ; id = GetTypeIdFromDataType ( asCDataType :: CreatePrimitive ( ttVoid , false ) ) ; asASSERT ( id == asTYPEID_VOID ) ; id = GetTypeIdFromDataType ( asCDataType :: CreatePrimitive ( ttBool , false ) ) ; asASSERT ( id == asTYPEID_BOOL ) ; id = GetTypeIdFromDataType ( asCDataType :: CreatePrimitive ( ttInt8 , false ) ) ; asASSERT ( id == asTYPEID_INT8 ) ; id = GetTypeIdFromDataType ( asCDataType :: CreatePrimitive ( ttInt16 , false ) ) ; asASSERT ( id == asTYPEID_INT16 ) ; id = GetTypeIdFromDataType ( asCDataType :: CreatePrimitive ( ttInt , false ) ) ; asASSERT ( id == asTYPEID_INT32 ) ; id = GetTypeIdFromDataType ( asCDataType :: CreatePrimitive ( ttInt64 , false ) ) ; asASSERT ( id == asTYPEID_INT64 ) ; id = GetTypeIdFromDataType ( asCDataType :: CreatePrimitive ( ttUInt8 , false ) ) ; asASSERT ( id == asTYPEID_UINT8 ) ; id = GetTypeIdFromDataType ( asCDataType :: CreatePrimitive ( ttUInt16 , false ) ) ; asASSERT ( id == asTYPEID_UINT16 ) ; id = GetTypeIdFromDataType ( asCDataType :: CreatePrimitive ( ttUInt , false ) ) ; asASSERT ( id == asTYPEID_UINT32 ) ; id = GetTypeIdFromDataType ( asCDataType :: CreatePrimitive ( ttUInt64 , false ) ) ; asASSERT ( id == asTYPEID_UINT64 ) ; id = GetTypeIdFromDataType ( asCDataType :: CreatePrimitive ( ttFloat , false ) ) ; asASSERT ( id == asTYPEID_FLOAT ) ; id = GetTypeIdFromDataType ( asCDataType :: CreatePrimitive ( ttDouble , false ) ) ; asASSERT ( id == asTYPEID_DOUBLE ) ; defaultArrayObjectType = 0 ; RegisterArrayObject ( this ) ; RegisterScriptObject ( this ) ; RegisterScriptFunction ( this ) ; RegisterObjectTypeGCBehaviours ( this ) ; }
asCScriptEngine :: ~ asCScriptEngine ( ) { asASSERT ( refCount . get ( ) == 0 ) ; asUINT n ; // ▁ The ▁ modules ▁ must ▁ be ▁ deleted ▁ first , ▁ as ▁ they ▁ may ▁ use ENDCOM // ▁ object ▁ types ▁ from ▁ the ▁ config ▁ groups ENDCOM for ( n = ( asUINT ) scriptModules . GetLength ( ) ; n -- > 0 ; ) { if ( scriptModules [ n ] ) { asDELETE ( scriptModules [ n ] , asCModule ) ; } } scriptModules . SetLength ( 0 ) ; GarbageCollect ( asGC_FULL_CYCLE ) ; // ▁ Delete ▁ the ▁ functions ▁ for ▁ template ▁ types ▁ that ▁ may ▁ references ▁ object ▁ types ENDCOM for ( n = 0 ; n < templateTypes . GetLength ( ) ; n ++ ) { if ( templateTypes [ n ] ) { asUINT f ; // ▁ Delete ▁ the ▁ factory ▁ stubs ▁ first ENDCOM for ( f = 0 ; f < templateTypes [ n ] -> beh . factories . GetLength ( ) ; f ++ ) { scriptFunctions [ templateTypes [ n ] -> beh . factories [ f ] ] -> Release ( ) ; } templateTypes [ n ] -> beh . factories . Allocate ( 0 , false ) ; // ▁ Delete ▁ the ▁ specialized ▁ functions ENDCOM for ( f = 1 ; f < templateTypes [ n ] -> beh . operators . GetLength ( ) ; f += 2 ) { if ( scriptFunctions [ templateTypes [ n ] -> beh . operators [ f ] ] -> objectType == templateTypes [ n ] ) { scriptFunctions [ templateTypes [ n ] -> beh . operators [ f ] ] -> Release ( ) ; templateTypes [ n ] -> beh . operators [ f ] = 0 ; } } } } // ▁ Do ▁ one ▁ more ▁ garbage ▁ collect ▁ to ▁ free ▁ gc ▁ objects ▁ that ▁ were ▁ global ▁ variables ENDCOM GarbageCollect ( asGC_FULL_CYCLE ) ; FreeUnusedGlobalProperties ( ) ; ClearUnusedTypes ( ) ; // ▁ Break ▁ all ▁ relationship ▁ between ▁ remaining ▁ class ▁ types ▁ and ▁ functions ENDCOM for ( n = 0 ; n < classTypes . GetLength ( ) ; n ++ ) { if ( classTypes [ n ] ) classTypes [ n ] -> ReleaseAllFunctions ( ) ; if ( classTypes [ n ] -> derivedFrom ) { classTypes [ n ] -> derivedFrom -> Release ( ) ; classTypes [ n ] -> derivedFrom = 0 ; } } GarbageCollect ( asGC_FULL_CYCLE ) ; FreeUnusedGlobalProperties ( ) ; ClearUnusedTypes ( ) ; asSMapNode < int , asCDataType * > * cursor = 0 ; while ( mapTypeIdToDataType . MoveFirst ( & cursor ) ) { asDELETE ( mapTypeIdToDataType . GetValue ( cursor ) , asCDataType ) ; mapTypeIdToDataType . Erase ( cursor ) ; } defaultGroup . RemoveConfiguration ( this ) ; while ( configGroups . GetLength ( ) ) { // ▁ Delete ▁ config ▁ groups ▁ in ▁ the ▁ right ▁ order ENDCOM asCConfigGroup * grp = configGroups . PopLast ( ) ; if ( grp ) { asDELETE ( grp , asCConfigGroup ) ; } } for ( n = 0 ; n < registeredGlobalProps . GetLength ( ) ; n ++ ) { if ( registeredGlobalProps [ n ] ) { asDELETE ( registeredGlobalProps [ n ] , asCGlobalProperty ) ; } } registeredGlobalProps . SetLength ( 0 ) ; FreeUnusedGlobalProperties ( ) ; for ( n = 0 ; n < templateTypes . GetLength ( ) ; n ++ ) { if ( templateTypes [ n ] ) { // ▁ Clear ▁ the ▁ sub ▁ type ▁ before ▁ deleting ▁ the ▁ template ▁ type ▁ so ▁ that ▁ the ▁ sub ▁ type ▁ isn ' t ▁ freed ▁ to ▁ soon ENDCOM templateTypes [ n ] -> templateSubType = asCDataType :: CreateNullHandle ( ) ; asDELETE ( templateTypes [ n ] , asCObjectType ) ; } } templateTypes . SetLength ( 0 ) ; for ( n = 0 ; n < objectTypes . GetLength ( ) ; n ++ ) { if ( objectTypes [ n ] ) { // ▁ Clear ▁ the ▁ sub ▁ type ▁ before ▁ deleting ▁ the ▁ template ▁ type ▁ so ▁ that ▁ the ▁ sub ▁ type ▁ isn ' t ▁ freed ▁ to ▁ soon ENDCOM objectTypes [ n ] -> templateSubType = asCDataType :: CreateNullHandle ( ) ; asDELETE ( objectTypes [ n ] , asCObjectType ) ; } } objectTypes . SetLength ( 0 ) ; for ( n = 0 ; n < templateSubTypes . GetLength ( ) ; n ++ ) { if ( templateSubTypes [ n ] ) { asDELETE ( templateSubTypes [ n ] , asCObjectType ) ; } } templateSubTypes . SetLength ( 0 ) ; registeredTypeDefs . SetLength ( 0 ) ; registeredEnums . SetLength ( 0 ) ; registeredObjTypes . SetLength ( 0 ) ; for ( n = 0 ; n < registeredGlobalFuncs . GetLength ( ) ; n ++ ) { if ( registeredGlobalFuncs [ n ] ) registeredGlobalFuncs [ n ] -> Release ( ) ; } registeredGlobalFuncs . SetLength ( 0 ) ; scriptTypeBehaviours . ReleaseAllFunctions ( ) ; functionBehaviours . ReleaseAllFunctions ( ) ; objectTypeBehaviours . ReleaseAllFunctions ( ) ; // ▁ Free ▁ string ▁ constants ENDCOM for ( n = 0 ; n < stringConstants . GetLength ( ) ; n ++ ) { asDELETE ( stringConstants [ n ] , asCString ) ; } stringConstants . SetLength ( 0 ) ; // ▁ Free ▁ the ▁ script ▁ section ▁ names ENDCOM for ( n = 0 ; n < scriptSectionNames . GetLength ( ) ; n ++ ) { asDELETE ( scriptSectionNames [ n ] , asCString ) ; } scriptSectionNames . SetLength ( 0 ) ; // ▁ Release ▁ the ▁ thread ▁ manager ENDCOM threadManager -> Release ( ) ; }
// ▁ interface ENDCOM int asCScriptEngine :: AddRef ( ) { return refCount . atomicInc ( ) ; }
// ▁ interface ENDCOM int asCScriptEngine :: Release ( ) { int r = refCount . atomicDec ( ) ; if ( r == 0 ) { asDELETE ( this , asCScriptEngine ) ; return 0 ; } return r ; }
// ▁ interface ENDCOM void * asCScriptEngine :: SetUserData ( void * data ) { void * old = userData ; userData = data ; return old ; }
// ▁ interface ENDCOM void * asCScriptEngine :: GetUserData ( ) { return userData ; }
// ▁ interface ENDCOM int asCScriptEngine :: SetMessageCallback ( const asSFuncPtr & callback , void * obj , asDWORD callConv ) { msgCallback = true ; msgCallbackObj = obj ; bool isObj = false ; if ( ( unsigned ) callConv == asCALL_GENERIC ) { msgCallback = false ; return asNOT_SUPPORTED ; } if ( ( unsigned ) callConv >= asCALL_THISCALL ) { isObj = true ; if ( obj == 0 ) { msgCallback = false ; return asINVALID_ARG ; } } int r = DetectCallingConvention ( isObj , callback , callConv , & msgCallbackFunc ) ; if ( r < 0 ) msgCallback = false ; return r ; }
// ▁ interface ENDCOM int asCScriptEngine :: ClearMessageCallback ( ) { msgCallback = false ; return 0 ; }
// ▁ interface ENDCOM int asCScriptEngine :: WriteMessage ( const char * section , int row , int col , asEMsgType type , const char * message ) { // ▁ Validate ▁ input ▁ parameters ENDCOM if ( section == 0 || message == 0 ) return asINVALID_ARG ; // ▁ If ▁ there ▁ is ▁ no ▁ callback ▁ then ▁ there ' s ▁ nothing ▁ to ▁ do ENDCOM if ( ! msgCallback ) return 0 ; asSMessageInfo msg ; msg . section = section ; msg . row = row ; msg . col = col ; msg . type = type ; msg . message = message ; if ( msgCallbackFunc . callConv < ICC_THISCALL ) CallGlobalFunction ( & msg , msgCallbackObj , & msgCallbackFunc , 0 ) ; else CallObjectMethod ( msgCallbackObj , & msg , & msgCallbackFunc , 0 ) ; return 0 ; }
int asCScriptEngine :: SetJITCompiler ( asIJITCompiler * compiler ) { jitCompiler = compiler ; return asSUCCESS ; }
asIJITCompiler * asCScriptEngine :: GetJITCompiler ( ) { return jitCompiler ; }
// ▁ interface ENDCOM asETokenClass asCScriptEngine :: ParseToken ( const char * string , size_t stringLength , int * tokenLength ) { if ( stringLength == 0 ) stringLength = strlen ( string ) ; size_t len ; asCTokenizer t ; asETokenClass tc ; t . GetToken ( string , stringLength , & len , & tc ) ; if ( tokenLength ) * tokenLength = ( int ) len ; return tc ; }
// ▁ interface ENDCOM asIScriptModule * asCScriptEngine :: GetModule ( const char * module , asEGMFlags flag ) { asCModule * mod = GetModule ( module , false ) ; if ( flag == asGM_ALWAYS_CREATE ) { if ( mod != 0 ) { asDELETE ( mod , asCModule ) ; } return GetModule ( module , true ) ; } if ( mod == 0 && flag == asGM_CREATE_IF_NOT_EXISTS ) { return GetModule ( module , true ) ; } return mod ; }
// ▁ interface ENDCOM int asCScriptEngine :: DiscardModule ( const char * module ) { asCModule * mod = GetModule ( module , false ) ; if ( mod == 0 ) return asNO_MODULE ; asDELETE ( mod , asCModule ) ; FreeUnusedGlobalProperties ( ) ; ClearUnusedTypes ( ) ; return 0 ; }
void asCScriptEngine :: ClearUnusedTypes ( ) { // ▁ Build ▁ a ▁ list ▁ of ▁ all ▁ types ▁ to ▁ check ▁ for ENDCOM asCArray < asCObjectType * > types ; types = classTypes ; types . Concatenate ( templateInstanceTypes ) ; // ▁ Go ▁ through ▁ all ▁ modules ENDCOM asUINT n ; for ( n = 0 ; n < scriptModules . GetLength ( ) && types . GetLength ( ) ; n ++ ) { asCModule * mod = scriptModules [ n ] ; if ( mod ) { // ▁ Functions / Methods / Globals ▁ are ▁ handled ▁ after ▁ this ENDCOM // ▁ Go ▁ through ▁ all ▁ type ▁ declarations ENDCOM asUINT m ; for ( m = 0 ; m < mod -> classTypes . GetLength ( ) && types . GetLength ( ) ; m ++ ) RemoveTypeAndRelatedFromList ( types , mod -> classTypes [ m ] ) ; for ( m = 0 ; m < mod -> enumTypes . GetLength ( ) && types . GetLength ( ) ; m ++ ) RemoveTypeAndRelatedFromList ( types , mod -> enumTypes [ m ] ) ; for ( m = 0 ; m < mod -> typeDefs . GetLength ( ) && types . GetLength ( ) ; m ++ ) RemoveTypeAndRelatedFromList ( types , mod -> typeDefs [ m ] ) ; } } // ▁ Go ▁ through ▁ all ▁ function ▁ parameters ▁ and ▁ remove ▁ used ▁ types ENDCOM for ( n = 0 ; n < scriptFunctions . GetLength ( ) && types . GetLength ( ) ; n ++ ) { asCScriptFunction * func = scriptFunctions [ n ] ; if ( func ) { // ▁ Ignore ▁ factory ▁ stubs ENDCOM if ( func -> name == " factstub " ) continue ; asCObjectType * ot = func -> returnType . GetObjectType ( ) ; if ( ot != 0 && ot != func -> objectType ) if ( func -> name != ot -> name ) RemoveTypeAndRelatedFromList ( types , ot ) ; for ( asUINT p = 0 ; p < func -> parameterTypes . GetLength ( ) ; p ++ ) { ot = func -> parameterTypes [ p ] . GetObjectType ( ) ; if ( ot != 0 && ot != func -> objectType ) if ( func -> name != ot -> name ) RemoveTypeAndRelatedFromList ( types , ot ) ; } } } // ▁ Go ▁ through ▁ all ▁ global ▁ properties ENDCOM for ( n = 0 ; n < globalProperties . GetLength ( ) && types . GetLength ( ) ; n ++ ) { if ( globalProperties [ n ] && globalProperties [ n ] -> type . GetObjectType ( ) ) RemoveTypeAndRelatedFromList ( types , globalProperties [ n ] -> type . GetObjectType ( ) ) ; } // ▁ All ▁ that ▁ remains ▁ in ▁ the ▁ list ▁ after ▁ this ▁ can ▁ be ▁ discarded , ▁ since ▁ they ▁ are ▁ no ▁ longer ▁ used ENDCOM for ( ; ; ) { bool didClearTemplateInstanceType = false ; for ( n = 0 ; n < types . GetLength ( ) ; n ++ ) { // ▁ Template ▁ types ▁ and ▁ script ▁ classes ▁ will ▁ have ▁ two ▁ references ▁ for ▁ each ▁ factory ▁ stub ENDCOM int refCount = ( ( types [ n ] -> flags & asOBJ_TEMPLATE ) || ( types [ n ] -> flags & asOBJ_SCRIPT_OBJECT ) ) ? 2 * ( int ) types [ n ] -> beh . factories . GetLength ( ) : 0 ; if ( types [ n ] -> GetRefCount ( ) == refCount ) { if ( types [ n ] -> flags & asOBJ_TEMPLATE ) { didClearTemplateInstanceType = true ; RemoveTemplateInstanceType ( types [ n ] ) ; } else { RemoveFromTypeIdMap ( types [ n ] ) ; asDELETE ( types [ n ] , asCObjectType ) ; int i = classTypes . IndexOf ( types [ n ] ) ; if ( i == ( signed ) classTypes . GetLength ( ) - 1 ) classTypes . PopLast ( ) ; else classTypes [ i ] = classTypes . PopLast ( ) ; } // ▁ Remove ▁ the ▁ type ▁ from ▁ the ▁ array ENDCOM if ( n < types . GetLength ( ) - 1 ) types [ n ] = types . PopLast ( ) ; else types . PopLast ( ) ; n -- ; } } if ( didClearTemplateInstanceType == false ) break ; } }
void asCScriptEngine :: RemoveTypeAndRelatedFromList ( asCArray < asCObjectType * > & types , asCObjectType * ot ) { // ▁ Remove ▁ the ▁ type ▁ from ▁ the ▁ list ENDCOM int i = types . IndexOf ( ot ) ; if ( i == - 1 ) return ; if ( i == ( signed ) types . GetLength ( ) - 1 ) types . PopLast ( ) ; else types [ i ] = types . PopLast ( ) ; // ▁ If ▁ the ▁ type ▁ is ▁ an ▁ template ▁ type , ▁ then ▁ remove ▁ all ▁ sub ▁ types ▁ as ▁ well ENDCOM if ( ot -> templateSubType . GetObjectType ( ) ) { while ( ot -> templateSubType . GetObjectType ( ) ) { ot = ot -> templateSubType . GetObjectType ( ) ; RemoveTypeAndRelatedFromList ( types , ot ) ; } return ; } // ▁ If ▁ the ▁ type ▁ is ▁ a ▁ class , ▁ then ▁ remove ▁ all ▁ properties ▁ types ▁ as ▁ well ENDCOM if ( ot -> properties . GetLength ( ) ) { for ( asUINT n = 0 ; n < ot -> properties . GetLength ( ) ; n ++ ) RemoveTypeAndRelatedFromList ( types , ot -> properties [ n ] -> type . GetObjectType ( ) ) ; } }
// ▁ internal ENDCOM int asCScriptEngine :: GetFactoryIdByDecl ( const asCObjectType * ot , const char * decl ) { asCModule * mod = 0 ; // ▁ Is ▁ this ▁ a ▁ script ▁ class ? ENDCOM if ( ot -> flags & asOBJ_SCRIPT_OBJECT && ot -> size > 0 ) mod = scriptFunctions [ ot -> beh . factory ] -> module ; asCBuilder bld ( this , mod ) ; asCScriptFunction func ( this , mod , - 1 ) ; int r = bld . ParseFunctionDeclaration ( 0 , decl , & func , false ) ; if ( r < 0 ) return asINVALID_DECLARATION ; // ▁ Search ▁ for ▁ matching ▁ factory ▁ function ENDCOM int id = - 1 ; for ( size_t n = 0 ; n < ot -> beh . factories . GetLength ( ) ; n ++ ) { asCScriptFunction * f = scriptFunctions [ ot -> beh . factories [ n ] ] ; if ( f -> IsSignatureEqual ( & func ) ) { id = ot -> beh . factories [ n ] ; break ; } } if ( id == - 1 ) return asNO_FUNCTION ; return id ; }
// ▁ internal ENDCOM int asCScriptEngine :: GetMethodIdByDecl ( const asCObjectType * ot , const char * decl , asCModule * mod ) { asCBuilder bld ( this , mod ) ; asCScriptFunction func ( this , mod , - 1 ) ; int r = bld . ParseFunctionDeclaration ( 0 , decl , & func , false ) ; if ( r < 0 ) return asINVALID_DECLARATION ; // ▁ Set ▁ the ▁ object ▁ type ▁ so ▁ that ▁ the ▁ signature ▁ can ▁ be ▁ properly ▁ compared ENDCOM // ▁ This ▁ cast ▁ is ▁ OK , ▁ it ▁ will ▁ only ▁ be ▁ used ▁ for ▁ comparison ENDCOM func . objectType = const_cast < asCObjectType * > ( ot ) ; // ▁ Search ▁ script ▁ functions ▁ for ▁ matching ▁ interface ENDCOM int id = - 1 ; for ( size_t n = 0 ; n < ot -> methods . GetLength ( ) ; ++ n ) { if ( func . IsSignatureEqual ( scriptFunctions [ ot -> methods [ n ] ] ) ) { if ( id == - 1 ) id = ot -> methods [ n ] ; else return asMULTIPLE_FUNCTIONS ; } } if ( id == - 1 ) return asNO_FUNCTION ; return id ; }
// ▁ Internal ENDCOM asCString asCScriptEngine :: GetFunctionDeclaration ( int funcID ) { asCString str ; asCScriptFunction * func = GetScriptFunction ( funcID ) ; if ( func ) str = func -> GetDeclarationStr ( ) ; return str ; }
asCScriptFunction * asCScriptEngine :: GetScriptFunction ( int funcId ) { if ( funcId < 0 || funcId >= ( int ) scriptFunctions . GetLength ( ) ) return 0 ; return scriptFunctions [ funcId ] ; }
asIScriptContext * asCScriptEngine :: CreateContext ( ) { asIScriptContext * ctx = 0 ; CreateContext ( & ctx , false ) ; return ctx ; }
int asCScriptEngine :: CreateContext ( asIScriptContext * * context , bool isInternal ) { * context = asNEW ( asCContext ) ( this , ! isInternal ) ; // ▁ We ▁ need ▁ to ▁ make ▁ sure ▁ the ▁ engine ▁ has ▁ been ▁ ENDCOM // ▁ prepared ▁ before ▁ any ▁ context ▁ is ▁ executed ENDCOM PrepareEngine ( ) ; return 0 ; }
int asCScriptEngine :: RegisterObjectProperty ( const char * obj , const char * declaration , int byteOffset ) { int r ; asCDataType dt ; asCBuilder bld ( this , 0 ) ; r = bld . ParseDataType ( obj , & dt ) ; if ( r < 0 ) return ConfigError ( r ) ; // ▁ Verify ▁ that ▁ the ▁ correct ▁ config ▁ group ▁ is ▁ used ENDCOM if ( currentGroup -> FindType ( dt . GetObjectType ( ) -> name . AddressOf ( ) ) == 0 ) return ConfigError ( asWRONG_CONFIG_GROUP ) ; asCDataType type ; asCString name ; if ( ( r = bld . VerifyProperty ( & dt , declaration , name , type ) ) < 0 ) return ConfigError ( r ) ; // ▁ Store ▁ the ▁ property ▁ info ENDCOM if ( dt . GetObjectType ( ) == 0 ) return ConfigError ( asINVALID_OBJECT ) ; asCObjectProperty * prop = asNEW ( asCObjectProperty ) ; prop -> name = name ; prop -> type = type ; prop -> byteOffset = byteOffset ; dt . GetObjectType ( ) -> properties . PushLast ( prop ) ; currentGroup -> RefConfigGroup ( FindConfigGroupForObjectType ( type . GetObjectType ( ) ) ) ; return asSUCCESS ; }
int asCScriptEngine :: RegisterInterface ( const char * name ) { if ( name == 0 ) return ConfigError ( asINVALID_NAME ) ; // ▁ Verify ▁ if ▁ the ▁ name ▁ has ▁ been ▁ registered ▁ as ▁ a ▁ type ▁ already ENDCOM asUINT n ; for ( n = 0 ; n < objectTypes . GetLength ( ) ; n ++ ) { if ( objectTypes [ n ] && objectTypes [ n ] -> name == name ) return asALREADY_REGISTERED ; } // ▁ Use ▁ builder ▁ to ▁ parse ▁ the ▁ datatype ENDCOM asCDataType dt ; asCBuilder bld ( this , 0 ) ; bool oldMsgCallback = msgCallback ; msgCallback = false ; int r = bld . ParseDataType ( name , & dt ) ; msgCallback = oldMsgCallback ; if ( r >= 0 ) return ConfigError ( asERROR ) ; // ▁ Make ▁ sure ▁ the ▁ name ▁ is ▁ not ▁ a ▁ reserved ▁ keyword ENDCOM asCTokenizer t ; size_t tokenLen ; int token = t . GetToken ( name , strlen ( name ) , & tokenLen ) ; if ( token != ttIdentifier || strlen ( name ) != tokenLen ) return ConfigError ( asINVALID_NAME ) ; r = bld . CheckNameConflict ( name , 0 , 0 ) ; if ( r < 0 ) return ConfigError ( asNAME_TAKEN ) ; // ▁ Don ' t ▁ have ▁ to ▁ check ▁ against ▁ members ▁ of ▁ object ENDCOM // ▁ types ▁ as ▁ they ▁ are ▁ allowed ▁ to ▁ use ▁ the ▁ names ENDCOM // ▁ Register ▁ the ▁ object ▁ type ▁ for ▁ the ▁ interface ENDCOM asCObjectType * st = asNEW ( asCObjectType ) ( this ) ; st -> flags = asOBJ_REF | asOBJ_SCRIPT_OBJECT ; st -> size = 0 ; // ▁ Cannot ▁ be ▁ instanciated ENDCOM st -> name = name ; // ▁ Use ▁ the ▁ default ▁ script ▁ class ▁ behaviours ENDCOM st -> beh . factory = 0 ; st -> beh . addref = scriptTypeBehaviours . beh . addref ; scriptFunctions [ st -> beh . addref ] -> AddRef ( ) ; st -> beh . release = scriptTypeBehaviours . beh . release ; scriptFunctions [ st -> beh . release ] -> AddRef ( ) ; st -> beh . copy = 0 ; objectTypes . PushLast ( st ) ; registeredObjTypes . PushLast ( st ) ; currentGroup -> objTypes . PushLast ( st ) ; return asSUCCESS ; }
int asCScriptEngine :: RegisterInterfaceMethod ( const char * intf , const char * declaration ) { // ▁ Verify ▁ that ▁ the ▁ correct ▁ config ▁ group ▁ is ▁ set . ENDCOM if ( currentGroup -> FindType ( intf ) == 0 ) return ConfigError ( asWRONG_CONFIG_GROUP ) ; asCDataType dt ; asCBuilder bld ( this , 0 ) ; int r = bld . ParseDataType ( intf , & dt ) ; if ( r < 0 ) return ConfigError ( r ) ; asCScriptFunction * func = asNEW ( asCScriptFunction ) ( this , 0 , asFUNC_INTERFACE ) ; func -> objectType = dt . GetObjectType ( ) ; r = bld . ParseFunctionDeclaration ( func -> objectType , declaration , func , false ) ; if ( r < 0 ) { asDELETE ( func , asCScriptFunction ) ; return ConfigError ( asINVALID_DECLARATION ) ; } // ▁ Check ▁ name ▁ conflicts ENDCOM r = bld . CheckNameConflictMember ( dt , func -> name . AddressOf ( ) , 0 , 0 ) ; if ( r < 0 ) { asDELETE ( func , asCScriptFunction ) ; return ConfigError ( asNAME_TAKEN ) ; } func -> id = GetNextScriptFunctionId ( ) ; SetScriptFunction ( func ) ; func -> objectType -> methods . PushLast ( func -> id ) ; // ▁ The ▁ refCount ▁ was ▁ already ▁ set ▁ to ▁ 1 ENDCOM func -> ComputeSignatureId ( ) ; // ▁ If ▁ parameter ▁ type ▁ from ▁ other ▁ groups ▁ are ▁ used , ▁ add ▁ references ENDCOM // ▁ TODO : ▁ The ▁ code ▁ for ▁ adding ▁ references ▁ to ▁ config ▁ groups ▁ is ▁ repeated ▁ in ▁ a ▁ lot ▁ of ▁ places ENDCOM if ( func -> returnType . GetObjectType ( ) ) { asCConfigGroup * group = FindConfigGroupForObjectType ( func -> returnType . GetObjectType ( ) ) ; currentGroup -> RefConfigGroup ( group ) ; } for ( asUINT n = 0 ; n < func -> parameterTypes . GetLength ( ) ; n ++ ) { if ( func -> parameterTypes [ n ] . GetObjectType ( ) ) { asCConfigGroup * group = FindConfigGroupForObjectType ( func -> parameterTypes [ n ] . GetObjectType ( ) ) ; currentGroup -> RefConfigGroup ( group ) ; } } // ▁ Return ▁ function ▁ id ▁ as ▁ success ENDCOM return func -> id ; }
int asCScriptEngine :: RegisterObjectType ( const char * name , int byteSize , asDWORD flags ) { int r ; isPrepared = false ; // ▁ Verify ▁ flags ENDCOM // ▁ Must ▁ have ▁ either ▁ asOBJ _ REF ▁ or ▁ asOBJ _ VALUE ENDCOM if ( flags & asOBJ_REF ) { // ▁ Can ▁ optionally ▁ have ▁ the ▁ asOBJ _ GC , ▁ asOBJ _ NOHANDLE , ▁ asOBJ _ SCOPED , ▁ or ▁ asOBJ _ TEMPLATE ▁ flag ▁ set , ▁ but ▁ nothing ▁ else ENDCOM if ( flags & ~ ( asOBJ_REF | asOBJ_GC | asOBJ_NOHANDLE | asOBJ_SCOPED | asOBJ_TEMPLATE ) ) return ConfigError ( asINVALID_ARG ) ; // ▁ flags ▁ are ▁ exclusive ENDCOM if ( ( flags & asOBJ_GC ) && ( flags & ( asOBJ_NOHANDLE | asOBJ_SCOPED ) ) ) return ConfigError ( asINVALID_ARG ) ; if ( ( flags & asOBJ_NOHANDLE ) && ( flags & ( asOBJ_GC | asOBJ_SCOPED ) ) ) return ConfigError ( asINVALID_ARG ) ; if ( ( flags & asOBJ_SCOPED ) && ( flags & ( asOBJ_GC | asOBJ_NOHANDLE ) ) ) return ConfigError ( asINVALID_ARG ) ; } else if ( flags & asOBJ_VALUE ) { // ▁ Cannot ▁ use ▁ reference ▁ flags ENDCOM // ▁ TODO : ▁ template : ▁ Should ▁ be ▁ possible ▁ to ▁ register ▁ a ▁ value ▁ type ▁ as ▁ template ▁ type ENDCOM if ( flags & ( asOBJ_REF | asOBJ_GC | asOBJ_SCOPED ) ) return ConfigError ( asINVALID_ARG ) ; // ▁ If ▁ the ▁ app ▁ type ▁ is ▁ given , ▁ we ▁ must ▁ validate ▁ the ▁ flags ENDCOM if ( flags & asOBJ_APP_CLASS ) { // ▁ Must ▁ not ▁ set ▁ the ▁ primitive ▁ or ▁ float ▁ flag ENDCOM if ( flags & ( asOBJ_APP_PRIMITIVE | asOBJ_APP_FLOAT ) ) return ConfigError ( asINVALID_ARG ) ; } else if ( flags & asOBJ_APP_PRIMITIVE ) { // ▁ Must ▁ not ▁ set ▁ the ▁ class ▁ flags ▁ nor ▁ the ▁ float ▁ flag ENDCOM if ( flags & ( asOBJ_APP_CLASS | asOBJ_APP_CLASS_CONSTRUCTOR | asOBJ_APP_CLASS_DESTRUCTOR | asOBJ_APP_CLASS_ASSIGNMENT | asOBJ_APP_FLOAT ) ) return ConfigError ( asINVALID_ARG ) ; } else if ( flags & asOBJ_APP_FLOAT ) { // ▁ Must ▁ not ▁ set ▁ the ▁ class ▁ flags ▁ nor ▁ the ▁ primitive ▁ flag ENDCOM if ( flags & ( asOBJ_APP_CLASS | asOBJ_APP_CLASS_CONSTRUCTOR | asOBJ_APP_CLASS_DESTRUCTOR | asOBJ_APP_CLASS_ASSIGNMENT | asOBJ_APP_PRIMITIVE ) ) return ConfigError ( asINVALID_ARG ) ; } else if ( flags & ( asOBJ_APP_CLASS_CONSTRUCTOR | asOBJ_APP_CLASS_DESTRUCTOR | asOBJ_APP_CLASS_ASSIGNMENT ) ) { // ▁ Must ▁ not ▁ set ▁ the ▁ class ▁ properties , ▁ without ▁ the ▁ class ▁ flag ENDCOM return ConfigError ( asINVALID_ARG ) ; } } else return ConfigError ( asINVALID_ARG ) ; // ▁ Don ' t ▁ allow ▁ anything ▁ else ▁ than ▁ the ▁ defined ▁ flags ENDCOM if ( flags - ( flags & asOBJ_MASK_VALID_FLAGS ) ) return ConfigError ( asINVALID_ARG ) ; // ▁ Value ▁ types ▁ must ▁ have ▁ a ▁ defined ▁ size ENDCOM if ( ( flags & asOBJ_VALUE ) && byteSize == 0 ) { WriteMessage ( " " , 0 , 0 , asMSGTYPE_ERROR , TXT_VALUE_TYPE_MUST_HAVE_SIZE ) ; return ConfigError ( asINVALID_ARG ) ; } // ▁ Verify ▁ type ▁ name ENDCOM if ( name == 0 ) return ConfigError ( asINVALID_NAME ) ; asCString typeName ; asCBuilder bld ( this , 0 ) ; if ( flags & asOBJ_TEMPLATE ) { asCString subtypeName ; r = bld . ParseTemplateDecl ( name , & typeName , & subtypeName ) ; if ( r < 0 ) return r ; // ▁ Verify ▁ that ▁ the ▁ template ▁ name ▁ hasn ' t ▁ been ▁ registered ▁ as ▁ a ▁ type ▁ already ENDCOM asUINT n ; for ( n = 0 ; n < objectTypes . GetLength ( ) ; n ++ ) { if ( objectTypes [ n ] && objectTypes [ n ] -> name == typeName ) return asALREADY_REGISTERED ; } asCObjectType * type = asNEW ( asCObjectType ) ( this ) ; type -> name = typeName ; type -> size = byteSize ; type -> flags = flags ; // ▁ Store ▁ it ▁ in ▁ the ▁ object ▁ types ENDCOM objectTypes . PushLast ( type ) ; // ▁ Define ▁ a ▁ template ▁ subtype ENDCOM asCObjectType * subtype = 0 ; for ( n = 0 ; n < templateSubTypes . GetLength ( ) ; n ++ ) { if ( templateSubTypes [ n ] -> name == subtypeName ) { subtype = templateSubTypes [ n ] ; break ; } } if ( subtype == 0 ) { // ▁ Create ▁ the ▁ new ▁ subtype ▁ if ▁ not ▁ already ▁ existing ENDCOM subtype = asNEW ( asCObjectType ) ( this ) ; subtype -> name = subtypeName ; subtype -> size = 0 ; subtype -> flags = asOBJ_TEMPLATE_SUBTYPE ; templateSubTypes . PushLast ( subtype ) ; subtype -> AddRef ( ) ; } type -> templateSubType = asCDataType :: CreateObject ( subtype , false ) ; subtype -> AddRef ( ) ; currentGroup -> objTypes . PushLast ( type ) ; if ( defaultArrayObjectType == 0 ) { // ▁ TODO : ▁ The ▁ default ▁ array ▁ object ▁ type ▁ should ▁ be ▁ defined ▁ by ▁ the ▁ application ENDCOM // ▁ The ▁ default ▁ array ▁ object ▁ type ▁ is ▁ registered ▁ by ▁ the ▁ engine ▁ itself ENDCOM defaultArrayObjectType = type ; type -> AddRef ( ) ; } else { registeredObjTypes . PushLast ( type ) ; } } else { typeName = name ; // ▁ Verify ▁ if ▁ the ▁ name ▁ has ▁ been ▁ registered ▁ as ▁ a ▁ type ▁ already ENDCOM asUINT n ; for ( n = 0 ; n < objectTypes . GetLength ( ) ; n ++ ) { if ( objectTypes [ n ] && objectTypes [ n ] -> name == typeName ) return asALREADY_REGISTERED ; } for ( n = 0 ; n < templateTypes . GetLength ( ) ; n ++ ) { if ( templateTypes [ n ] && templateTypes [ n ] -> name == typeName ) return asALREADY_REGISTERED ; } // ▁ Verify ▁ the ▁ most ▁ recently ▁ created ▁ template ▁ instance ▁ type ENDCOM asCObjectType * mostRecentTemplateInstanceType = 0 ; if ( templateInstanceTypes . GetLength ( ) ) mostRecentTemplateInstanceType = templateInstanceTypes [ templateInstanceTypes . GetLength ( ) - 1 ] ; // ▁ Use ▁ builder ▁ to ▁ parse ▁ the ▁ datatype ENDCOM asCDataType dt ; bool oldMsgCallback = msgCallback ; msgCallback = false ; r = bld . ParseDataType ( name , & dt ) ; msgCallback = oldMsgCallback ; // ▁ If ▁ the ▁ builder ▁ fails , ▁ then ▁ the ▁ type ▁ name ENDCOM // ▁ is ▁ new ▁ and ▁ it ▁ should ▁ be ▁ registered ENDCOM if ( r < 0 ) { // ▁ Make ▁ sure ▁ the ▁ name ▁ is ▁ not ▁ a ▁ reserved ▁ keyword ENDCOM asCTokenizer t ; size_t tokenLen ; int token = t . GetToken ( name , typeName . GetLength ( ) , & tokenLen ) ; if ( token != ttIdentifier || typeName . GetLength ( ) != tokenLen ) return ConfigError ( asINVALID_NAME ) ; int r = bld . CheckNameConflict ( name , 0 , 0 ) ; if ( r < 0 ) return ConfigError ( asNAME_TAKEN ) ; // ▁ Don ' t ▁ have ▁ to ▁ check ▁ against ▁ members ▁ of ▁ object ENDCOM // ▁ types ▁ as ▁ they ▁ are ▁ allowed ▁ to ▁ use ▁ the ▁ names ENDCOM // ▁ Put ▁ the ▁ data ▁ type ▁ in ▁ the ▁ list ENDCOM asCObjectType * type = asNEW ( asCObjectType ) ( this ) ; type -> name = typeName ; type -> size = byteSize ; type -> flags = flags ; objectTypes . PushLast ( type ) ; registeredObjTypes . PushLast ( type ) ; currentGroup -> objTypes . PushLast ( type ) ; } else { // ▁ The ▁ application ▁ is ▁ registering ▁ a ▁ template ▁ specialization ▁ so ▁ we ENDCOM // ▁ need ▁ to ▁ replace ▁ the ▁ template ▁ instance ▁ type ▁ with ▁ the ▁ new ▁ type . ENDCOM // ▁ TODO : ▁ Template : ▁ We ▁ don ' t ▁ require ▁ the ▁ lower ▁ dimensions ▁ to ▁ be ▁ registered ▁ first ▁ for ▁ registered ▁ template ▁ types ENDCOM // ▁ int [ ] [ ] ▁ must ▁ not ▁ be ▁ allowed ▁ to ▁ be ▁ registered ENDCOM // ▁ if ▁ int [ ] ▁ hasn ' t ▁ been ▁ registered ▁ first ENDCOM if ( dt . GetSubType ( ) . IsTemplate ( ) ) return ConfigError ( asLOWER_ARRAY_DIMENSION_NOT_REGISTERED ) ; if ( dt . IsReadOnly ( ) || dt . IsReference ( ) ) return ConfigError ( asINVALID_TYPE ) ; // ▁ Was ▁ the ▁ template ▁ instance ▁ type ▁ created ▁ before ? ENDCOM if ( templateInstanceTypes [ templateInstanceTypes . GetLength ( ) - 1 ] == mostRecentTemplateInstanceType || mostRecentTemplateInstanceType == dt . GetObjectType ( ) ) // ▁ TODO : ▁ Should ▁ have ▁ a ▁ better ▁ error ▁ message ENDCOM return ConfigError ( asNOT_SUPPORTED ) ; // ▁ TODO : ▁ Add ▁ this ▁ again . ▁ The ▁ type ▁ is ▁ used ▁ by ▁ the ▁ factory ▁ stubs ▁ so ▁ we ▁ need ▁ to ▁ discount ▁ that ENDCOM // ▁ Is ▁ the ▁ template ▁ instance ▁ type ▁ already ▁ being ▁ used ? ENDCOM // TABSYMBOL TABSYMBOL TABSYMBOL if ( ▁ dt . GetObjectType ( ) - > GetRefCount ( ) ▁ > ▁ 1 ▁ ) ENDCOM // TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL return ▁ ConfigError ( asNOT _ SUPPORTED ) ; ENDCOM // ▁ Put ▁ the ▁ data ▁ type ▁ in ▁ the ▁ list ENDCOM asCObjectType * type = asNEW ( asCObjectType ) ( this ) ; type -> name = dt . GetObjectType ( ) -> name ; type -> templateSubType = dt . GetSubType ( ) ; if ( type -> templateSubType . GetObjectType ( ) ) type -> templateSubType . GetObjectType ( ) -> AddRef ( ) ; type -> size = byteSize ; type -> flags = flags ; templateTypes . PushLast ( type ) ; currentGroup -> objTypes . PushLast ( type ) ; // ▁ Remove ▁ the ▁ template ▁ instance ▁ type , ▁ which ▁ will ▁ no ▁ longer ▁ be ▁ used . ENDCOM RemoveTemplateInstanceType ( dt . GetObjectType ( ) ) ; } } return asSUCCESS ; }
// ▁ interface ENDCOM int asCScriptEngine :: RegisterObjectBehaviour ( const char * datatype , asEBehaviours behaviour , const char * decl , const asSFuncPtr & funcPointer , asDWORD callConv ) { if ( datatype == 0 ) return ConfigError ( asINVALID_ARG ) ; // ▁ Determine ▁ the ▁ object ▁ type ENDCOM asCBuilder bld ( this , 0 ) ; asCDataType type ; int r = bld . ParseDataType ( datatype , & type ) ; if ( r < 0 ) return ConfigError ( r ) ; if ( type . GetObjectType ( ) == 0 ) return ConfigError ( asINVALID_TYPE ) ; if ( type . IsReadOnly ( ) || type . IsReference ( ) ) return ConfigError ( asINVALID_TYPE ) ; return RegisterBehaviourToObjectType ( type . GetObjectType ( ) , behaviour , decl , funcPointer , callConv ) ; }
// ▁ internal ENDCOM int asCScriptEngine :: RegisterBehaviourToObjectType ( asCObjectType * objectType , asEBehaviours behaviour , const char * decl , const asSFuncPtr & funcPointer , asDWORD callConv ) { asSSystemFunctionInterface internal ; if ( behaviour == asBEHAVE_FACTORY || behaviour == asBEHAVE_TEMPLATE_CALLBACK ) { if ( callConv != asCALL_GENERIC ) return ConfigError ( asNOT_SUPPORTED ) ; int r = DetectCallingConvention ( false , funcPointer , callConv , & internal ) ; if ( r < 0 ) return ConfigError ( r ) ; } else { if ( callConv != asCALL_GENERIC ) return ConfigError ( asNOT_SUPPORTED ) ; if ( callConv != asCALL_THISCALL && callConv != asCALL_CDECL_OBJLAST && callConv != asCALL_CDECL_OBJFIRST && callConv != asCALL_GENERIC ) return ConfigError ( asNOT_SUPPORTED ) ; int r = DetectCallingConvention ( true , funcPointer , callConv , & internal ) ; if ( r < 0 ) return ConfigError ( r ) ; } isPrepared = false ; asSTypeBehaviour * beh = & objectType -> beh ; // ▁ Verify ▁ function ▁ declaration ENDCOM asCScriptFunction func ( this , 0 , - 1 ) ; asCBuilder bld ( this , 0 ) ; int r = bld . ParseFunctionDeclaration ( objectType , decl , & func , true , & internal . paramAutoHandles , & internal . returnAutoHandle ) ; if ( r < 0 ) return ConfigError ( asINVALID_DECLARATION ) ; func . name . Format ( " _ beh _ % d _ " , behaviour ) ; if ( behaviour != asBEHAVE_FACTORY ) func . objectType = objectType ; // ▁ Check ▁ if ▁ the ▁ method ▁ restricts ▁ that ▁ use ▁ of ▁ the ▁ template ▁ to ▁ value ▁ types ▁ or ▁ reference ▁ types ENDCOM if ( objectType -> flags & asOBJ_TEMPLATE ) { if ( func . returnType . GetObjectType ( ) == objectType -> templateSubType . GetObjectType ( ) ) { if ( func . returnType . IsObjectHandle ( ) ) objectType -> acceptValueSubType = false ; else if ( ! func . returnType . IsReference ( ) ) objectType -> acceptRefSubType = false ; } for ( asUINT n = 0 ; n < func . parameterTypes . GetLength ( ) ; n ++ ) { if ( func . parameterTypes [ n ] . GetObjectType ( ) == objectType -> templateSubType . GetObjectType ( ) ) { // ▁ TODO : ▁ If ▁ unsafe ▁ references ▁ are ▁ allowed , ▁ then ▁ inout ▁ references ▁ allow ▁ value ▁ types ENDCOM if ( func . parameterTypes [ n ] . IsObjectHandle ( ) || ( func . parameterTypes [ n ] . IsReference ( ) && func . inOutFlags [ n ] == asTM_INOUTREF ) ) objectType -> acceptValueSubType = false ; else if ( ! func . parameterTypes [ n ] . IsReference ( ) ) objectType -> acceptRefSubType = false ; } } } if ( behaviour == asBEHAVE_CONSTRUCT ) { // ▁ TODO : ▁ Add ▁ asBEHAVE _ IMPLICIT _ CONSTRUCT ENDCOM // ▁ Verify ▁ that ▁ the ▁ return ▁ type ▁ is ▁ void ENDCOM if ( func . returnType != asCDataType :: CreatePrimitive ( ttVoid , false ) ) return ConfigError ( asINVALID_DECLARATION ) ; if ( objectType -> flags & asOBJ_SCRIPT_OBJECT ) { // ▁ The ▁ script ▁ object ▁ is ▁ a ▁ special ▁ case ENDCOM asASSERT ( func . parameterTypes . GetLength ( ) == 1 ) ; beh -> construct = AddBehaviourFunction ( func , internal ) ; beh -> factory = beh -> construct ; scriptFunctions [ beh -> factory ] -> AddRef ( ) ; beh -> constructors . PushLast ( beh -> construct ) ; beh -> factories . PushLast ( beh -> factory ) ; func . id = beh -> construct ; } else { // ▁ Verify ▁ that ▁ it ▁ is ▁ a ▁ value ▁ type ENDCOM if ( ! ( func . objectType -> flags & asOBJ_VALUE ) ) { WriteMessage ( " " , 0 , 0 , asMSGTYPE_ERROR , TXT_ILLEGAL_BEHAVIOUR_FOR_TYPE ) ; return ConfigError ( asILLEGAL_BEHAVIOUR_FOR_TYPE ) ; } // ▁ Implicit ▁ constructors ▁ must ▁ take ▁ one ▁ and ▁ only ▁ one ▁ parameter ENDCOM /* TABSYMBOL TABSYMBOL if ( ▁ behaviour ▁ = = ▁ asBEHAVE _ IMPLICIT _ CONSTRUCT ▁ & & STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL func . parameterTypes . GetLength ( ) ▁ ! = ▁ 1 ▁ ) STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL return ▁ ConfigError ( asINVALID _ DECLARATION ) ; STRNEWLINE TABSYMBOL */ ENDCOM // ▁ TODO : ▁ Verify ▁ that ▁ the ▁ same ▁ constructor ▁ hasn ' t ▁ been ▁ registered ▁ already ENDCOM // ▁ Store ▁ all ▁ constructors ▁ in ▁ a ▁ list ENDCOM if ( func . parameterTypes . GetLength ( ) == 0 ) { func . id = beh -> construct = AddBehaviourFunction ( func , internal ) ; beh -> constructors . PushLast ( beh -> construct ) ; } else { func . id = AddBehaviourFunction ( func , internal ) ; beh -> constructors . PushLast ( func . id ) ; /* STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL if ( ▁ behaviour ▁ = = ▁ asBEHAVE _ IMPLICIT _ CONSTRUCT ▁ ) STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL { STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL beh - > operators . PushLast ( behaviour ) ; STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL beh - > operators . PushLast ( func . id ) ; STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL } STRNEWLINE TABSYMBOL */ ENDCOM } } } else if ( behaviour == asBEHAVE_DESTRUCT ) { // ▁ Must ▁ be ▁ a ▁ value ▁ type ENDCOM if ( ! ( func . objectType -> flags & asOBJ_VALUE ) ) { WriteMessage ( " " , 0 , 0 , asMSGTYPE_ERROR , TXT_ILLEGAL_BEHAVIOUR_FOR_TYPE ) ; return ConfigError ( asILLEGAL_BEHAVIOUR_FOR_TYPE ) ; } if ( beh -> destruct ) return ConfigError ( asALREADY_REGISTERED ) ; // ▁ Verify ▁ that ▁ the ▁ return ▁ type ▁ is ▁ void ENDCOM if ( func . returnType != asCDataType :: CreatePrimitive ( ttVoid , false ) ) return ConfigError ( asINVALID_DECLARATION ) ; // ▁ Verify ▁ that ▁ there ▁ are ▁ no ▁ parameters ENDCOM if ( func . parameterTypes . GetLength ( ) > 0 ) return ConfigError ( asINVALID_DECLARATION ) ; func . id = beh -> destruct = AddBehaviourFunction ( func , internal ) ; } else if ( behaviour == asBEHAVE_FACTORY ) { // ▁ TODO : ▁ Add ▁ asBEHAVE _ IMPLICIT _ FACTORY ENDCOM // ▁ Must ▁ be ▁ a ▁ ref ▁ type ▁ and ▁ must ▁ not ▁ have ▁ asOBJ _ NOHANDLE ENDCOM if ( ! ( objectType -> flags & asOBJ_REF ) || ( objectType -> flags & asOBJ_NOHANDLE ) ) { WriteMessage ( " " , 0 , 0 , asMSGTYPE_ERROR , TXT_ILLEGAL_BEHAVIOUR_FOR_TYPE ) ; return ConfigError ( asILLEGAL_BEHAVIOUR_FOR_TYPE ) ; } // ▁ Verify ▁ that ▁ the ▁ return ▁ type ▁ is ▁ a ▁ handle ▁ to ▁ the ▁ type ENDCOM if ( func . returnType != asCDataType :: CreateObjectHandle ( objectType , false ) ) return ConfigError ( asINVALID_DECLARATION ) ; // ▁ Implicit ▁ factories ▁ must ▁ take ▁ one ▁ and ▁ only ▁ one ▁ parameter ENDCOM /* TABSYMBOL TABSYMBOL if ( ▁ behaviour ▁ = = ▁ asBEHAVE _ IMPLICIT _ FACTORY ▁ & & STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL func . parameterTypes . GetLength ( ) ▁ ! = ▁ 1 ▁ ) STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL return ▁ ConfigError ( asINVALID _ DECLARATION ) ; STRNEWLINE */ ENDCOM // ▁ TODO : ▁ Verify ▁ that ▁ the ▁ same ▁ factory ▁ function ▁ hasn ' t ▁ been ▁ registered ▁ already ENDCOM // ▁ The ▁ templates ▁ take ▁ a ▁ hidden ▁ parameter ▁ with ▁ the ▁ object ▁ type ENDCOM if ( ( objectType -> flags & asOBJ_TEMPLATE ) && ( func . parameterTypes . GetLength ( ) == 0 || ! func . parameterTypes [ 0 ] . IsReference ( ) ) ) { return ConfigError ( asINVALID_DECLARATION ) ; } // ▁ Store ▁ all ▁ factory ▁ functions ▁ in ▁ a ▁ list ENDCOM if ( ( func . parameterTypes . GetLength ( ) == 0 ) || ( func . parameterTypes . GetLength ( ) == 1 && ( objectType -> flags & asOBJ_TEMPLATE ) ) ) { func . id = beh -> factory = AddBehaviourFunction ( func , internal ) ; beh -> factories . PushLast ( beh -> factory ) ; } else { func . id = AddBehaviourFunction ( func , internal ) ; beh -> factories . PushLast ( func . id ) ; /* STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL if ( ▁ behaviour ▁ = = ▁ asBEHAVE _ IMPLICIT _ FACTORY ▁ ) STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL { STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL beh - > operators . PushLast ( behaviour ) ; STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL beh - > operators . PushLast ( func . id ) ; STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL } STRNEWLINE */ ENDCOM } } else if ( behaviour == asBEHAVE_ADDREF ) { // ▁ Must ▁ be ▁ a ▁ ref ▁ type ▁ and ▁ must ▁ not ▁ have ▁ asOBJ _ NOHANDLE , ▁ nor ▁ asOBJ _ SCOPED ENDCOM if ( ! ( func . objectType -> flags & asOBJ_REF ) || ( func . objectType -> flags & asOBJ_NOHANDLE ) || ( func . objectType -> flags & asOBJ_SCOPED ) ) { WriteMessage ( " " , 0 , 0 , asMSGTYPE_ERROR , TXT_ILLEGAL_BEHAVIOUR_FOR_TYPE ) ; return ConfigError ( asILLEGAL_BEHAVIOUR_FOR_TYPE ) ; } if ( beh -> addref ) return ConfigError ( asALREADY_REGISTERED ) ; // ▁ Verify ▁ that ▁ the ▁ return ▁ type ▁ is ▁ void ENDCOM if ( func . returnType != asCDataType :: CreatePrimitive ( ttVoid , false ) ) return ConfigError ( asINVALID_DECLARATION ) ; // ▁ Verify ▁ that ▁ there ▁ are ▁ no ▁ parameters ENDCOM if ( func . parameterTypes . GetLength ( ) > 0 ) return ConfigError ( asINVALID_DECLARATION ) ; func . id = beh -> addref = AddBehaviourFunction ( func , internal ) ; } else if ( behaviour == asBEHAVE_RELEASE ) { // ▁ Must ▁ be ▁ a ▁ ref ▁ type ▁ and ▁ must ▁ not ▁ have ▁ asOBJ _ NOHANDLE ENDCOM if ( ! ( func . objectType -> flags & asOBJ_REF ) || ( func . objectType -> flags & asOBJ_NOHANDLE ) ) { WriteMessage ( " " , 0 , 0 , asMSGTYPE_ERROR , TXT_ILLEGAL_BEHAVIOUR_FOR_TYPE ) ; return ConfigError ( asILLEGAL_BEHAVIOUR_FOR_TYPE ) ; } if ( beh -> release ) return ConfigError ( asALREADY_REGISTERED ) ; // ▁ Verify ▁ that ▁ the ▁ return ▁ type ▁ is ▁ void ENDCOM if ( func . returnType != asCDataType :: CreatePrimitive ( ttVoid , false ) ) return ConfigError ( asINVALID_DECLARATION ) ; // ▁ Verify ▁ that ▁ there ▁ are ▁ no ▁ parameters ENDCOM if ( func . parameterTypes . GetLength ( ) > 0 ) return ConfigError ( asINVALID_DECLARATION ) ; func . id = beh -> release = AddBehaviourFunction ( func , internal ) ; } else if ( behaviour == asBEHAVE_TEMPLATE_CALLBACK ) { // ▁ Must ▁ be ▁ a ▁ template ▁ type ▁ ENDCOM if ( ! ( func . objectType -> flags & asOBJ_TEMPLATE ) ) { WriteMessage ( " " , 0 , 0 , asMSGTYPE_ERROR , TXT_ILLEGAL_BEHAVIOUR_FOR_TYPE ) ; return ConfigError ( asILLEGAL_BEHAVIOUR_FOR_TYPE ) ; } if ( beh -> templateCallback ) return ConfigError ( asALREADY_REGISTERED ) ; // ▁ Verify ▁ that ▁ the ▁ return ▁ type ▁ is ▁ bool ENDCOM if ( func . returnType != asCDataType :: CreatePrimitive ( ttBool , false ) ) return ConfigError ( asINVALID_DECLARATION ) ; // ▁ Verify ▁ that ▁ there ▁ is ▁ one ▁ parameters ENDCOM if ( func . parameterTypes . GetLength ( ) != 1 ) return ConfigError ( asINVALID_DECLARATION ) ; func . id = beh -> templateCallback = AddBehaviourFunction ( func , internal ) ; } else if ( behaviour == asBEHAVE_INDEX ) { // ▁ Verify ▁ that ▁ the ▁ var ▁ type ▁ is ▁ not ▁ used ENDCOM if ( VerifyVarTypeNotInFunction ( & func ) < 0 ) return ConfigError ( asINVALID_DECLARATION ) ; // ▁ Verify ▁ that ▁ there ▁ is ▁ only ▁ one ▁ parameter ENDCOM if ( func . parameterTypes . GetLength ( ) != 1 ) return ConfigError ( asINVALID_DECLARATION ) ; // ▁ Verify ▁ that ▁ the ▁ return ▁ type ▁ is ▁ not ▁ void ENDCOM if ( func . returnType . GetTokenType ( ) == ttVoid ) return ConfigError ( asINVALID_DECLARATION ) ; // ▁ TODO : ▁ Verify ▁ that ▁ the ▁ operator ▁ hasn ' t ▁ been ▁ registered ▁ already ENDCOM beh -> operators . PushLast ( behaviour ) ; func . id = AddBehaviourFunction ( func , internal ) ; beh -> operators . PushLast ( func . id ) ; } else if ( behaviour >= asBEHAVE_FIRST_GC && behaviour <= asBEHAVE_LAST_GC ) { // ▁ Only ▁ allow ▁ GC ▁ behaviours ▁ for ▁ types ▁ registered ▁ to ▁ be ▁ garbage ▁ collected ENDCOM if ( ! ( func . objectType -> flags & asOBJ_GC ) ) { WriteMessage ( " " , 0 , 0 , asMSGTYPE_ERROR , TXT_ILLEGAL_BEHAVIOUR_FOR_TYPE ) ; return ConfigError ( asILLEGAL_BEHAVIOUR_FOR_TYPE ) ; } // ▁ Verify ▁ parameter ▁ count ENDCOM if ( ( behaviour == asBEHAVE_GETREFCOUNT || behaviour == asBEHAVE_SETGCFLAG || behaviour == asBEHAVE_GETGCFLAG ) && func . parameterTypes . GetLength ( ) != 0 ) return ConfigError ( asINVALID_DECLARATION ) ; if ( ( behaviour == asBEHAVE_ENUMREFS || behaviour == asBEHAVE_RELEASEREFS ) && func . parameterTypes . GetLength ( ) != 1 ) return ConfigError ( asINVALID_DECLARATION ) ; // ▁ Verify ▁ return ▁ type ENDCOM if ( behaviour == asBEHAVE_GETREFCOUNT && func . returnType != asCDataType :: CreatePrimitive ( ttInt , false ) ) return ConfigError ( asINVALID_DECLARATION ) ; if ( behaviour == asBEHAVE_GETGCFLAG && func . returnType != asCDataType :: CreatePrimitive ( ttBool , false ) ) return ConfigError ( asINVALID_DECLARATION ) ; if ( ( behaviour == asBEHAVE_SETGCFLAG || behaviour == asBEHAVE_ENUMREFS || behaviour == asBEHAVE_RELEASEREFS ) && func . returnType != asCDataType :: CreatePrimitive ( ttVoid , false ) ) return ConfigError ( asINVALID_DECLARATION ) ; if ( behaviour == asBEHAVE_GETREFCOUNT ) func . id = beh -> gcGetRefCount = AddBehaviourFunction ( func , internal ) ; else if ( behaviour == asBEHAVE_SETGCFLAG ) func . id = beh -> gcSetFlag = AddBehaviourFunction ( func , internal ) ; else if ( behaviour == asBEHAVE_GETGCFLAG ) func . id = beh -> gcGetFlag = AddBehaviourFunction ( func , internal ) ; else if ( behaviour == asBEHAVE_ENUMREFS ) func . id = beh -> gcEnumReferences = AddBehaviourFunction ( func , internal ) ; else if ( behaviour == asBEHAVE_RELEASEREFS ) func . id = beh -> gcReleaseAllReferences = AddBehaviourFunction ( func , internal ) ; } else if ( behaviour == asBEHAVE_IMPLICIT_VALUE_CAST || behaviour == asBEHAVE_VALUE_CAST ) { // ▁ Verify ▁ parameter ▁ count ENDCOM if ( func . parameterTypes . GetLength ( ) != 0 ) return ConfigError ( asINVALID_DECLARATION ) ; // ▁ Verify ▁ return ▁ type ENDCOM if ( func . returnType . IsEqualExceptRefAndConst ( asCDataType :: CreatePrimitive ( ttBool , false ) ) ) return ConfigError ( asNOT_SUPPORTED ) ; if ( func . returnType . IsEqualExceptRefAndConst ( asCDataType :: CreatePrimitive ( ttVoid , false ) ) ) return ConfigError ( asINVALID_DECLARATION ) ; // ▁ TODO : ▁ verify ▁ that ▁ the ▁ same ▁ cast ▁ is ▁ not ▁ registered ▁ already ▁ ( const ▁ or ▁ non - const ▁ is ▁ treated ▁ the ▁ same ▁ for ▁ the ▁ return ▁ type ) ENDCOM beh -> operators . PushLast ( behaviour ) ; func . id = AddBehaviourFunction ( func , internal ) ; beh -> operators . PushLast ( func . id ) ; } else if ( behaviour == asBEHAVE_REF_CAST || behaviour == asBEHAVE_IMPLICIT_REF_CAST ) { // ▁ Verify ▁ parameter ▁ count ENDCOM if ( func . parameterTypes . GetLength ( ) != 0 ) return ConfigError ( asINVALID_DECLARATION ) ; // ▁ Verify ▁ return ▁ type ENDCOM if ( ! func . returnType . IsObjectHandle ( ) ) return ConfigError ( asINVALID_DECLARATION ) ; // ▁ TODO : ▁ verify ▁ that ▁ the ▁ same ▁ cast ▁ is ▁ not ▁ registered ▁ already ▁ ( cosnt ▁ or ▁ non - const ▁ is ▁ treated ▁ the ▁ same ▁ for ▁ the ▁ return ▁ type ) ENDCOM beh -> operators . PushLast ( behaviour ) ; func . id = AddBehaviourFunction ( func , internal ) ; beh -> operators . PushLast ( func . id ) ; } else { asASSERT ( false ) ; return ConfigError ( asINVALID_ARG ) ; } // ▁ Return ▁ function ▁ id ▁ as ▁ success ENDCOM return func . id ; }
int asCScriptEngine :: VerifyVarTypeNotInFunction ( asCScriptFunction * func ) { // ▁ Don ' t ▁ allow ▁ var ▁ type ▁ in ▁ this ▁ function ENDCOM if ( func -> returnType . GetTokenType ( ) == ttQuestion ) return asINVALID_DECLARATION ; for ( unsigned int n = 0 ; n < func -> parameterTypes . GetLength ( ) ; n ++ ) if ( func -> parameterTypes [ n ] . GetTokenType ( ) == ttQuestion ) return asINVALID_DECLARATION ; return 0 ; }
int asCScriptEngine :: AddBehaviourFunction ( asCScriptFunction & func , asSSystemFunctionInterface & internal ) { asUINT n ; int id = GetNextScriptFunctionId ( ) ; asSSystemFunctionInterface * newInterface = asNEW ( asSSystemFunctionInterface ) ; newInterface -> func = internal . func ; newInterface -> baseOffset = internal . baseOffset ; newInterface -> callConv = internal . callConv ; newInterface -> scriptReturnSize = internal . scriptReturnSize ; newInterface -> hostReturnInMemory = internal . hostReturnInMemory ; newInterface -> hostReturnFloat = internal . hostReturnFloat ; newInterface -> hostReturnSize = internal . hostReturnSize ; newInterface -> paramSize = internal . paramSize ; newInterface -> takesObjByVal = internal . takesObjByVal ; newInterface -> paramAutoHandles = internal . paramAutoHandles ; newInterface -> returnAutoHandle = internal . returnAutoHandle ; newInterface -> hasAutoHandles = internal . hasAutoHandles ; asCScriptFunction * f = asNEW ( asCScriptFunction ) ( this , 0 , asFUNC_SYSTEM ) ; asASSERT ( func . name != " " && func . name != " f " ) ; f -> name = func . name ; f -> sysFuncIntf = newInterface ; f -> returnType = func . returnType ; f -> objectType = func . objectType ; f -> id = id ; f -> isReadOnly = func . isReadOnly ; for ( n = 0 ; n < func . parameterTypes . GetLength ( ) ; n ++ ) { f -> parameterTypes . PushLast ( func . parameterTypes [ n ] ) ; f -> inOutFlags . PushLast ( func . inOutFlags [ n ] ) ; } SetScriptFunction ( f ) ; // ▁ If ▁ parameter ▁ type ▁ from ▁ other ▁ groups ▁ are ▁ used , ▁ add ▁ references ENDCOM if ( f -> returnType . GetObjectType ( ) ) { asCConfigGroup * group = FindConfigGroupForObjectType ( f -> returnType . GetObjectType ( ) ) ; currentGroup -> RefConfigGroup ( group ) ; } for ( n = 0 ; n < f -> parameterTypes . GetLength ( ) ; n ++ ) { if ( f -> parameterTypes [ n ] . GetObjectType ( ) ) { asCConfigGroup * group = FindConfigGroupForObjectType ( f -> parameterTypes [ n ] . GetObjectType ( ) ) ; currentGroup -> RefConfigGroup ( group ) ; } } return id ; }
// ▁ interface ENDCOM int asCScriptEngine :: RegisterGlobalProperty ( const char * declaration , void * pointer ) { asCDataType type ; asCString name ; int r ; asCBuilder bld ( this , 0 ) ; if ( ( r = bld . VerifyProperty ( 0 , declaration , name , type ) ) < 0 ) return ConfigError ( r ) ; // ▁ Don ' t ▁ allow ▁ registering ▁ references ▁ as ▁ global ▁ properties ENDCOM if ( type . IsReference ( ) ) return ConfigError ( asINVALID_TYPE ) ; // ▁ Store ▁ the ▁ property ▁ info ENDCOM asCGlobalProperty * prop = AllocateGlobalProperty ( ) ; prop -> name = name ; prop -> type = type ; prop -> SetRegisteredAddress ( pointer ) ; registeredGlobalProps . PushLast ( prop ) ; currentGroup -> globalProps . PushLast ( prop ) ; // ▁ If ▁ from ▁ another ▁ group ▁ add ▁ reference ENDCOM if ( type . GetObjectType ( ) ) { asCConfigGroup * group = FindConfigGroupForObjectType ( type . GetObjectType ( ) ) ; currentGroup -> RefConfigGroup ( group ) ; } return asSUCCESS ; }
// ▁ internal ENDCOM asCGlobalProperty * asCScriptEngine :: AllocateGlobalProperty ( ) { asCGlobalProperty * prop = asNEW ( asCGlobalProperty ) ; // ▁ First ▁ check ▁ the ▁ availability ▁ of ▁ a ▁ free ▁ slot ENDCOM if ( freeGlobalPropertyIds . GetLength ( ) ) { prop -> id = freeGlobalPropertyIds . PopLast ( ) ; globalProperties [ prop -> id ] = prop ; return prop ; } prop -> id = ( asUINT ) globalProperties . GetLength ( ) ; globalProperties . PushLast ( prop ) ; return prop ; }
// ▁ internal ENDCOM void asCScriptEngine :: FreeUnusedGlobalProperties ( ) { for ( asUINT n = 0 ; n < globalProperties . GetLength ( ) ; n ++ ) { if ( globalProperties [ n ] && globalProperties [ n ] -> refCount . get ( ) == 0 ) { freeGlobalPropertyIds . PushLast ( n ) ; asDELETE ( globalProperties [ n ] , asCGlobalProperty ) ; globalProperties [ n ] = 0 ; } } }
// ▁ interface ENDCOM int asCScriptEngine :: GetGlobalPropertyCount ( ) { return ( int ) registeredGlobalProps . GetLength ( ) ; }
// ▁ interface ENDCOM // ▁ TODO : ▁ If ▁ the ▁ typeId ▁ ever ▁ encodes ▁ the ▁ const ▁ flag , ▁ then ▁ the ▁ isConst ▁ parameter ▁ should ▁ be ▁ removed ENDCOM int asCScriptEngine :: GetGlobalPropertyByIndex ( asUINT index , const char * * name , int * typeId , bool * isConst , const char * * configGroup , void * * pointer ) { if ( index >= registeredGlobalProps . GetLength ( ) ) return asINVALID_ARG ; if ( name ) * name = registeredGlobalProps [ index ] -> name . AddressOf ( ) ; if ( configGroup ) { asCConfigGroup * group = FindConfigGroupForGlobalVar ( index ) ; if ( group ) * configGroup = group -> groupName . AddressOf ( ) ; else * configGroup = 0 ; } if ( typeId ) * typeId = GetTypeIdFromDataType ( registeredGlobalProps [ index ] -> type ) ; if ( isConst ) * isConst = registeredGlobalProps [ index ] -> type . IsReadOnly ( ) ; if ( pointer ) * pointer = registeredGlobalProps [ index ] -> realAddress ; return asSUCCESS ; }
// ▁ interface ENDCOM int asCScriptEngine :: RegisterObjectMethod ( const char * obj , const char * declaration , const asSFuncPtr & funcPointer , asDWORD callConv ) { if ( obj == 0 ) return ConfigError ( asINVALID_ARG ) ; // ▁ Determine ▁ the ▁ object ▁ type ENDCOM asCDataType dt ; asCBuilder bld ( this , 0 ) ; int r = bld . ParseDataType ( obj , & dt ) ; if ( r < 0 ) return ConfigError ( r ) ; if ( dt . GetObjectType ( ) == 0 ) return ConfigError ( asINVALID_ARG ) ; return RegisterMethodToObjectType ( dt . GetObjectType ( ) , declaration , funcPointer , callConv ) ; }
// ▁ internal ENDCOM int asCScriptEngine :: RegisterMethodToObjectType ( asCObjectType * objectType , const char * declaration , const asSFuncPtr & funcPointer , asDWORD callConv ) { asSSystemFunctionInterface internal ; int r = DetectCallingConvention ( true , funcPointer , callConv , & internal ) ; if ( r < 0 ) return ConfigError ( r ) ; // ▁ We ▁ only ▁ support ▁ these ▁ calling ▁ conventions ▁ for ▁ object ▁ methods ENDCOM if ( callConv != asCALL_GENERIC ) return ConfigError ( asNOT_SUPPORTED ) ; if ( callConv != asCALL_THISCALL && callConv != asCALL_CDECL_OBJLAST && callConv != asCALL_CDECL_OBJFIRST && callConv != asCALL_GENERIC ) return ConfigError ( asNOT_SUPPORTED ) ; isPrepared = false ; // ▁ Put ▁ the ▁ system ▁ function ▁ in ▁ the ▁ list ▁ of ▁ system ▁ functions ENDCOM asSSystemFunctionInterface * newInterface = asNEW ( asSSystemFunctionInterface ) ( internal ) ; asCScriptFunction * func = asNEW ( asCScriptFunction ) ( this , 0 , asFUNC_SYSTEM ) ; func -> sysFuncIntf = newInterface ; func -> objectType = objectType ; asCBuilder bld ( this , 0 ) ; r = bld . ParseFunctionDeclaration ( func -> objectType , declaration , func , true , & newInterface -> paramAutoHandles , & newInterface -> returnAutoHandle ) ; if ( r < 0 ) { // ▁ Set ▁ as ▁ dummy ▁ function ▁ before ▁ deleting ENDCOM func -> funcType = - 1 ; asDELETE ( func , asCScriptFunction ) ; return ConfigError ( asINVALID_DECLARATION ) ; } // ▁ Check ▁ name ▁ conflicts ENDCOM asCDataType x = asCDataType :: CreateObject ( objectType , false ) ; r = bld . CheckNameConflictMember ( x , func -> name . AddressOf ( ) , 0 , 0 ) ; if ( r < 0 ) { asDELETE ( func , asCScriptFunction ) ; return ConfigError ( asNAME_TAKEN ) ; } func -> id = GetNextScriptFunctionId ( ) ; func -> objectType -> methods . PushLast ( func -> id ) ; SetScriptFunction ( func ) ; // ▁ TODO : ▁ This ▁ code ▁ is ▁ repeated ▁ in ▁ many ▁ places ENDCOM // ▁ If ▁ parameter ▁ type ▁ from ▁ other ▁ groups ▁ are ▁ used , ▁ add ▁ references ENDCOM if ( func -> returnType . GetObjectType ( ) ) { asCConfigGroup * group = FindConfigGroupForObjectType ( func -> returnType . GetObjectType ( ) ) ; currentGroup -> RefConfigGroup ( group ) ; } for ( asUINT n = 0 ; n < func -> parameterTypes . GetLength ( ) ; n ++ ) { if ( func -> parameterTypes [ n ] . GetObjectType ( ) ) { asCConfigGroup * group = FindConfigGroupForObjectType ( func -> parameterTypes [ n ] . GetObjectType ( ) ) ; currentGroup -> RefConfigGroup ( group ) ; } } // ▁ Check ▁ if ▁ the ▁ method ▁ restricts ▁ that ▁ use ▁ of ▁ the ▁ template ▁ to ▁ value ▁ types ▁ or ▁ reference ▁ types ENDCOM if ( func -> objectType -> flags & asOBJ_TEMPLATE ) { if ( func -> returnType . GetObjectType ( ) == func -> objectType -> templateSubType . GetObjectType ( ) ) { if ( func -> returnType . IsObjectHandle ( ) ) func -> objectType -> acceptValueSubType = false ; else if ( ! func -> returnType . IsReference ( ) ) func -> objectType -> acceptRefSubType = false ; } for ( asUINT n = 0 ; n < func -> parameterTypes . GetLength ( ) ; n ++ ) { if ( func -> parameterTypes [ n ] . GetObjectType ( ) == func -> objectType -> templateSubType . GetObjectType ( ) ) { // ▁ TODO : ▁ If ▁ unsafe ▁ references ▁ are ▁ allowed , ▁ then ▁ inout ▁ references ▁ allow ▁ value ▁ types ENDCOM if ( func -> parameterTypes [ n ] . IsObjectHandle ( ) || ( func -> parameterTypes [ n ] . IsReference ( ) && func -> inOutFlags [ n ] == asTM_INOUTREF ) ) func -> objectType -> acceptValueSubType = false ; else if ( ! func -> parameterTypes [ n ] . IsReference ( ) ) func -> objectType -> acceptRefSubType = false ; } } } // ▁ TODO : ▁ beh . copy ▁ member ▁ will ▁ be ▁ removed , ▁ so ▁ this ▁ is ▁ not ▁ necessary ENDCOM // ▁ Is ▁ this ▁ the ▁ default ▁ copy ▁ behaviour ? ENDCOM if ( func -> name == " opAssign " && func -> parameterTypes . GetLength ( ) == 1 && func -> isReadOnly == false && ( objectType -> flags & asOBJ_SCRIPT_OBJECT || func -> parameterTypes [ 0 ] . IsEqualExceptRefAndConst ( asCDataType :: CreateObject ( func -> objectType , false ) ) ) ) { func -> objectType -> beh . copy = func -> id ; func -> AddRef ( ) ; } // ▁ Return ▁ the ▁ function ▁ id ▁ as ▁ success ENDCOM return func -> id ; }
// ▁ interface ENDCOM int asCScriptEngine :: RegisterGlobalFunction ( const char * declaration , const asSFuncPtr & funcPointer , asDWORD callConv ) { asSSystemFunctionInterface internal ; int r = DetectCallingConvention ( false , funcPointer , callConv , & internal ) ; if ( r < 0 ) return ConfigError ( r ) ; if ( callConv != asCALL_GENERIC ) return ConfigError ( asNOT_SUPPORTED ) ; if ( callConv != asCALL_CDECL && callConv != asCALL_STDCALL && callConv != asCALL_GENERIC ) return ConfigError ( asNOT_SUPPORTED ) ; isPrepared = false ; // ▁ Put ▁ the ▁ system ▁ function ▁ in ▁ the ▁ list ▁ of ▁ system ▁ functions ENDCOM asSSystemFunctionInterface * newInterface = asNEW ( asSSystemFunctionInterface ) ( internal ) ; asCScriptFunction * func = asNEW ( asCScriptFunction ) ( this , 0 , asFUNC_SYSTEM ) ; func -> sysFuncIntf = newInterface ; asCBuilder bld ( this , 0 ) ; r = bld . ParseFunctionDeclaration ( 0 , declaration , func , true , & newInterface -> paramAutoHandles , & newInterface -> returnAutoHandle ) ; if ( r < 0 ) { // ▁ Set ▁ as ▁ dummy ▁ function ▁ before ▁ deleting ENDCOM func -> funcType = - 1 ; asDELETE ( func , asCScriptFunction ) ; return ConfigError ( asINVALID_DECLARATION ) ; } // ▁ Check ▁ name ▁ conflicts ENDCOM r = bld . CheckNameConflict ( func -> name . AddressOf ( ) , 0 , 0 ) ; if ( r < 0 ) { asDELETE ( func , asCScriptFunction ) ; return ConfigError ( asNAME_TAKEN ) ; } func -> id = GetNextScriptFunctionId ( ) ; SetScriptFunction ( func ) ; currentGroup -> scriptFunctions . PushLast ( func ) ; registeredGlobalFuncs . PushLast ( func ) ; // ▁ If ▁ parameter ▁ type ▁ from ▁ other ▁ groups ▁ are ▁ used , ▁ add ▁ references ENDCOM if ( func -> returnType . GetObjectType ( ) ) { asCConfigGroup * group = FindConfigGroupForObjectType ( func -> returnType . GetObjectType ( ) ) ; currentGroup -> RefConfigGroup ( group ) ; } for ( asUINT n = 0 ; n < func -> parameterTypes . GetLength ( ) ; n ++ ) { if ( func -> parameterTypes [ n ] . GetObjectType ( ) ) { asCConfigGroup * group = FindConfigGroupForObjectType ( func -> parameterTypes [ n ] . GetObjectType ( ) ) ; currentGroup -> RefConfigGroup ( group ) ; } } // ▁ Return ▁ the ▁ function ▁ id ▁ as ▁ success ENDCOM return func -> id ; }
// ▁ interface ENDCOM int asCScriptEngine :: GetGlobalFunctionCount ( ) { return ( int ) registeredGlobalFuncs . GetLength ( ) ; }
// ▁ interface ENDCOM int asCScriptEngine :: GetGlobalFunctionIdByIndex ( asUINT index ) { if ( index >= registeredGlobalFuncs . GetLength ( ) ) return asINVALID_ARG ; return registeredGlobalFuncs [ index ] -> id ; }
asCObjectType * asCScriptEngine :: GetObjectType ( const char * type ) { // ▁ TODO : ▁ optimize : ▁ Improve ▁ linear ▁ search ENDCOM for ( asUINT n = 0 ; n < objectTypes . GetLength ( ) ; n ++ ) if ( objectTypes [ n ] && objectTypes [ n ] -> name == type ) // ▁ TODO : ▁ template : ▁ Should ▁ we ▁ check ▁ the ▁ subtype ▁ in ▁ case ▁ of ▁ template ▁ instances ? ENDCOM return objectTypes [ n ] ; return 0 ; }
void asCScriptEngine :: PrepareEngine ( ) { if ( isPrepared ) return ; if ( configFailed ) return ; asUINT n ; for ( n = 0 ; n < scriptFunctions . GetLength ( ) ; n ++ ) { // ▁ Determine ▁ the ▁ host ▁ application ▁ interface ENDCOM if ( scriptFunctions [ n ] && scriptFunctions [ n ] -> funcType == asFUNC_SYSTEM ) { if ( scriptFunctions [ n ] -> sysFuncIntf -> callConv == ICC_GENERIC_FUNC || scriptFunctions [ n ] -> sysFuncIntf -> callConv == ICC_GENERIC_METHOD ) PrepareSystemFunctionGeneric ( scriptFunctions [ n ] , scriptFunctions [ n ] -> sysFuncIntf , this ) ; else PrepareSystemFunction ( scriptFunctions [ n ] , scriptFunctions [ n ] -> sysFuncIntf , this ) ; } } // ▁ Validate ▁ object ▁ type ▁ registrations ENDCOM for ( n = 0 ; n < objectTypes . GetLength ( ) ; n ++ ) { if ( objectTypes [ n ] && ! ( objectTypes [ n ] -> flags & asOBJ_SCRIPT_OBJECT ) ) { bool missingBehaviour = false ; const char * infoMsg = 0 ; // ▁ Verify ▁ that ▁ GC ▁ types ▁ have ▁ all ▁ behaviours ENDCOM if ( objectTypes [ n ] -> flags & asOBJ_GC ) { if ( objectTypes [ n ] -> beh . addref == 0 || objectTypes [ n ] -> beh . release == 0 || objectTypes [ n ] -> beh . gcGetRefCount == 0 || objectTypes [ n ] -> beh . gcSetFlag == 0 || objectTypes [ n ] -> beh . gcGetFlag == 0 || objectTypes [ n ] -> beh . gcEnumReferences == 0 || objectTypes [ n ] -> beh . gcReleaseAllReferences == 0 ) { infoMsg = TXT_GC_REQUIRE_ADD_REL_GC_BEHAVIOUR ; missingBehaviour = true ; } } // ▁ Verify ▁ that ▁ scoped ▁ ref ▁ types ▁ have ▁ the ▁ release ▁ behaviour ENDCOM else if ( objectTypes [ n ] -> flags & asOBJ_SCOPED ) { if ( objectTypes [ n ] -> beh . release == 0 ) { infoMsg = TXT_SCOPE_REQUIRE_REL_BEHAVIOUR ; missingBehaviour = true ; } } // ▁ Verify ▁ that ▁ ref ▁ types ▁ have ▁ add ▁ ref ▁ and ▁ release ▁ behaviours ENDCOM else if ( ( objectTypes [ n ] -> flags & asOBJ_REF ) && ! ( objectTypes [ n ] -> flags & asOBJ_NOHANDLE ) ) { if ( objectTypes [ n ] -> beh . addref == 0 || objectTypes [ n ] -> beh . release == 0 ) { infoMsg = TXT_REF_REQUIRE_ADD_REL_BEHAVIOUR ; missingBehaviour = true ; } } // ▁ Verify ▁ that ▁ non - pod ▁ value ▁ types ▁ have ▁ the ▁ constructor ▁ and ▁ destructor ▁ registered ENDCOM else if ( ( objectTypes [ n ] -> flags & asOBJ_VALUE ) && ! ( objectTypes [ n ] -> flags & asOBJ_POD ) ) { if ( objectTypes [ n ] -> beh . construct == 0 || objectTypes [ n ] -> beh . destruct == 0 ) { infoMsg = TXT_NON_POD_REQUIRE_CONSTR_DESTR_BEHAVIOUR ; missingBehaviour = true ; } } if ( missingBehaviour ) { asCString str ; str . Format ( TXT_TYPE_s_IS_MISSING_BEHAVIOURS , objectTypes [ n ] -> name . AddressOf ( ) ) ; WriteMessage ( " " , 0 , 0 , asMSGTYPE_ERROR , str . AddressOf ( ) ) ; WriteMessage ( " " , 0 , 0 , asMSGTYPE_INFORMATION , infoMsg ) ; ConfigError ( asINVALID_CONFIGURATION ) ; } } } isPrepared = true ; }
int asCScriptEngine :: ConfigError ( int err ) { configFailed = true ; return err ; }
// ▁ interface ENDCOM int asCScriptEngine :: RegisterStringFactory ( const char * datatype , const asSFuncPtr & funcPointer , asDWORD callConv ) { asSSystemFunctionInterface internal ; int r = DetectCallingConvention ( false , funcPointer , callConv , & internal ) ; if ( r < 0 ) return ConfigError ( r ) ; if ( callConv != asCALL_GENERIC ) return ConfigError ( asNOT_SUPPORTED ) ; if ( callConv != asCALL_CDECL && callConv != asCALL_STDCALL && callConv != asCALL_GENERIC ) return ConfigError ( asNOT_SUPPORTED ) ; // ▁ Put ▁ the ▁ system ▁ function ▁ in ▁ the ▁ list ▁ of ▁ system ▁ functions ENDCOM asSSystemFunctionInterface * newInterface = asNEW ( asSSystemFunctionInterface ) ( internal ) ; asCScriptFunction * func = asNEW ( asCScriptFunction ) ( this , 0 , asFUNC_SYSTEM ) ; func -> name = " _ string _ factory _ " ; func -> sysFuncIntf = newInterface ; asCBuilder bld ( this , 0 ) ; asCDataType dt ; r = bld . ParseDataType ( datatype , & dt ) ; if ( r < 0 ) { // ▁ Set ▁ as ▁ dummy ▁ before ▁ deleting ENDCOM func -> funcType = - 1 ; asDELETE ( func , asCScriptFunction ) ; return ConfigError ( asINVALID_TYPE ) ; } func -> returnType = dt ; func -> parameterTypes . PushLast ( asCDataType :: CreatePrimitive ( ttInt , true ) ) ; asCDataType parm1 = asCDataType :: CreatePrimitive ( ttUInt8 , true ) ; parm1 . MakeReference ( true ) ; func -> parameterTypes . PushLast ( parm1 ) ; func -> id = GetNextScriptFunctionId ( ) ; SetScriptFunction ( func ) ; stringFactory = func ; if ( func -> returnType . GetObjectType ( ) ) { asCConfigGroup * group = FindConfigGroupForObjectType ( func -> returnType . GetObjectType ( ) ) ; if ( group == 0 ) group = & defaultGroup ; group -> scriptFunctions . PushLast ( func ) ; } // ▁ Register ▁ function ▁ id ▁ as ▁ success ENDCOM return func -> id ; }
// ▁ interface ENDCOM int asCScriptEngine :: GetStringFactoryReturnTypeId ( ) { if ( stringFactory == 0 ) return asNO_FUNCTION ; return GetTypeIdFromDataType ( stringFactory -> returnType ) ; }
// ▁ interface ENDCOM asCModule * asCScriptEngine :: GetModule ( const char * _name , bool create ) { // ▁ Accept ▁ null ▁ as ▁ well ▁ as ▁ zero - length ▁ string ENDCOM const char * name = " " ; if ( _name != 0 ) name = _name ; if ( lastModule && lastModule -> name == name ) return lastModule ; // ▁ TODO : ▁ optimize : ▁ Improve ▁ linear ▁ search ENDCOM for ( asUINT n = 0 ; n < scriptModules . GetLength ( ) ; ++ n ) if ( scriptModules [ n ] && scriptModules [ n ] -> name == name ) { lastModule = scriptModules [ n ] ; return lastModule ; } if ( create ) { asCModule * module = asNEW ( asCModule ) ( name , this ) ; scriptModules . PushLast ( module ) ; lastModule = module ; return lastModule ; } return 0 ; }
asCModule * asCScriptEngine :: GetModuleFromFuncId ( int id ) { if ( id < 0 ) return 0 ; if ( id >= ( int ) scriptFunctions . GetLength ( ) ) return 0 ; asCScriptFunction * func = scriptFunctions [ id ] ; if ( func == 0 ) return 0 ; return func -> module ; }
// ▁ internal ENDCOM int asCScriptEngine :: RequestBuild ( ) { ENTERCRITICALSECTION ( engineCritical ) ; if ( isBuilding ) { LEAVECRITICALSECTION ( engineCritical ) ; return asBUILD_IN_PROGRESS ; } isBuilding = true ; LEAVECRITICALSECTION ( engineCritical ) ; return 0 ; }
// ▁ internal ENDCOM void asCScriptEngine :: BuildCompleted ( ) { // ▁ Always ▁ free ▁ up ▁ pooled ▁ memory ▁ after ▁ a ▁ completed ▁ build ENDCOM memoryMgr . FreeUnusedMemory ( ) ; isBuilding = false ; }
// ▁ Deprecated ▁ since ▁ 2009-12-08 , ▁ 2.18.0 ENDCOM // ▁ interface ENDCOM int asCScriptEngine :: ExecuteString ( const char * module , const char * script , asIScriptContext * * ctx , asDWORD flags ) { int r ; if ( ( r = RequestBuild ( ) ) < 0 ) return r ; PrepareEngine ( ) ; // ▁ Make ▁ sure ▁ the ▁ config ▁ worked ENDCOM if ( configFailed ) { if ( ctx && ! ( flags & asEXECSTRING_USE_MY_CONTEXT ) ) * ctx = 0 ; WriteMessage ( " " , 0 , 0 , asMSGTYPE_ERROR , TXT_INVALID_CONFIGURATION ) ; isBuilding = false ; return asINVALID_CONFIGURATION ; } asIScriptContext * exec = 0 ; if ( ! ( flags & asEXECSTRING_USE_MY_CONTEXT ) ) { int r = CreateContext ( & exec , false ) ; if ( r < 0 ) { if ( ctx && ! ( flags & asEXECSTRING_USE_MY_CONTEXT ) ) * ctx = 0 ; isBuilding = false ; return r ; } if ( ctx ) { * ctx = exec ; exec -> AddRef ( ) ; } } else { if ( * ctx == 0 ) { isBuilding = false ; return asINVALID_ARG ; } exec = * ctx ; exec -> AddRef ( ) ; } // ▁ Make ▁ sure ▁ the ▁ context ▁ isn ' t ▁ holding ▁ a ▁ reference ▁ to ▁ the ▁ previous ▁ ExecuteString ▁ function ( ) ENDCOM exec -> Unprepare ( ) ; // ▁ Get ▁ the ▁ module ▁ to ▁ compile ▁ the ▁ string ▁ in ENDCOM asCModule * mod = GetModule ( module , true ) ; // ▁ Compile ▁ string ▁ function ENDCOM asCBuilder builder ( this , mod ) ; asCString str = script ; str = " void ▁ ExecuteString ( ) { \n " + str + " \n ; } " ; r = builder . BuildString ( str . AddressOf ( ) , ( asCContext * ) exec ) ; BuildCompleted ( ) ; if ( r < 0 ) { if ( ctx && ! ( flags & asEXECSTRING_USE_MY_CONTEXT ) ) { ( * ctx ) -> Release ( ) ; * ctx = 0 ; } exec -> Release ( ) ; return asERROR ; } // ▁ Prepare ▁ and ▁ execute ▁ the ▁ context ENDCOM r = ( ( asCContext * ) exec ) -> Prepare ( ( ( asCContext * ) exec ) -> stringFunction -> id ) ; if ( r < 0 ) { if ( ctx && ! ( flags & asEXECSTRING_USE_MY_CONTEXT ) ) { ( * ctx ) -> Release ( ) ; * ctx = 0 ; } exec -> Release ( ) ; return r ; } if ( flags & asEXECSTRING_ONLY_PREPARE ) r = asEXECUTION_PREPARED ; else r = exec -> Execute ( ) ; exec -> Release ( ) ; return r ; }
void asCScriptEngine :: RemoveTemplateInstanceType ( asCObjectType * t ) { int n ; // ▁ Destroy ▁ the ▁ factory ▁ stubs ENDCOM for ( n = 0 ; n < ( int ) t -> beh . factories . GetLength ( ) ; n ++ ) { // ▁ Make ▁ sure ▁ the ▁ factory ▁ stub ▁ isn ' t ▁ referencing ▁ this ▁ object ▁ anymore ENDCOM scriptFunctions [ t -> beh . factories [ n ] ] -> ReleaseAllHandles ( this ) ; scriptFunctions [ t -> beh . factories [ n ] ] -> Release ( ) ; } t -> beh . factories . SetLength ( 0 ) ; // ▁ Destroy ▁ the ▁ specialized ▁ functions ENDCOM for ( n = 1 ; n < ( int ) t -> beh . operators . GetLength ( ) ; n += 2 ) { if ( t -> beh . operators [ n ] && scriptFunctions [ t -> beh . operators [ n ] ] -> objectType == t ) { scriptFunctions [ t -> beh . operators [ n ] ] -> Release ( ) ; } } t -> beh . operators . SetLength ( 0 ) ; // ▁ Start ▁ searching ▁ from ▁ the ▁ end ▁ of ▁ the ▁ list , ▁ as ▁ most ▁ of ENDCOM // ▁ the ▁ time ▁ it ▁ will ▁ be ▁ the ▁ last ▁ two ▁ types ENDCOM for ( n = ( int ) templateTypes . GetLength ( ) - 1 ; n >= 0 ; n -- ) { if ( templateTypes [ n ] == t ) { if ( n == ( signed ) templateTypes . GetLength ( ) - 1 ) templateTypes . PopLast ( ) ; else templateTypes [ n ] = templateTypes . PopLast ( ) ; } } for ( n = ( int ) templateInstanceTypes . GetLength ( ) - 1 ; n >= 0 ; n -- ) { if ( templateInstanceTypes [ n ] == t ) { if ( n == ( signed ) templateInstanceTypes . GetLength ( ) - 1 ) templateInstanceTypes . PopLast ( ) ; else templateInstanceTypes [ n ] = templateInstanceTypes . PopLast ( ) ; } } asDELETE ( t , asCObjectType ) ; }
asCObjectType * asCScriptEngine :: GetTemplateInstanceType ( asCObjectType * templateType , asCDataType & subType ) { asUINT n ; // ▁ Is ▁ there ▁ any ▁ template ▁ instance ▁ type ▁ or ▁ template ▁ specialization ▁ already ▁ with ▁ this ▁ subtype ? ENDCOM for ( n = 0 ; n < templateTypes . GetLength ( ) ; n ++ ) { if ( templateTypes [ n ] && templateTypes [ n ] -> name == templateType -> name && templateTypes [ n ] -> templateSubType == subType ) return templateTypes [ n ] ; } // ▁ No ▁ previous ▁ template ▁ instance ▁ exists ENDCOM // ▁ Make ▁ sure ▁ this ▁ template ▁ supports ▁ the ▁ subtype ENDCOM if ( ! templateType -> acceptValueSubType && ( subType . IsPrimitive ( ) || ( subType . GetObjectType ( ) -> flags & asOBJ_VALUE ) ) ) return 0 ; if ( ! templateType -> acceptRefSubType && ( subType . IsObject ( ) && ( subType . GetObjectType ( ) -> flags & asOBJ_REF ) ) ) return 0 ; // ▁ Create ▁ a ▁ new ▁ template ▁ instance ▁ type ▁ based ▁ on ▁ the ▁ templateType ENDCOM asCObjectType * ot = asNEW ( asCObjectType ) ( this ) ; ot -> templateSubType = subType ; ot -> flags = templateType -> flags ; ot -> size = templateType -> size ; ot -> name = templateType -> name ; // ▁ Before ▁ filling ▁ in ▁ the ▁ methods , ▁ call ▁ the ▁ template ▁ instance ▁ callback ▁ behaviour ▁ to ▁ validate ▁ the ▁ type ENDCOM if ( templateType -> beh . templateCallback ) { asCScriptFunction * callback = scriptFunctions [ templateType -> beh . templateCallback ] ; if ( ! CallGlobalFunctionRetBool ( ot , 0 , callback -> sysFuncIntf , callback ) ) { // ▁ The ▁ type ▁ cannot ▁ be ▁ instanciated ENDCOM ot -> templateSubType = asCDataType ( ) ; asDELETE ( ot , asCObjectType ) ; return 0 ; } } ot -> methods = templateType -> methods ; for ( n = 0 ; n < ot -> methods . GetLength ( ) ; n ++ ) scriptFunctions [ ot -> methods [ n ] ] -> AddRef ( ) ; // ▁ Store ▁ the ▁ real ▁ factory ▁ in ▁ the ▁ constructor ENDCOM ot -> beh . construct = templateType -> beh . factory ; ot -> beh . constructors = templateType -> beh . factories ; for ( n = 0 ; n < ot -> beh . constructors . GetLength ( ) ; n ++ ) scriptFunctions [ ot -> beh . constructors [ n ] ] -> AddRef ( ) ; // ▁ Generate ▁ factory ▁ stubs ▁ for ▁ each ▁ of ▁ the ▁ factories ENDCOM for ( n = 0 ; n < templateType -> beh . factories . GetLength ( ) ; n ++ ) { int factoryId = templateType -> beh . factories [ n ] ; asCScriptFunction * factory = scriptFunctions [ factoryId ] ; asCScriptFunction * func = asNEW ( asCScriptFunction ) ( this , 0 , asFUNC_SCRIPT ) ; func -> name = " factstub " ; func -> id = GetNextScriptFunctionId ( ) ; func -> returnType = asCDataType :: CreateObjectHandle ( ot , false ) ; // ▁ Skip ▁ the ▁ first ▁ parameter ▁ as ▁ this ▁ is ▁ the ▁ object ▁ type ▁ pointer ▁ that ▁ the ▁ stub ▁ will ▁ add ENDCOM for ( asUINT p = 1 ; p < factory -> parameterTypes . GetLength ( ) ; p ++ ) { func -> parameterTypes . PushLast ( factory -> parameterTypes [ p ] ) ; func -> inOutFlags . PushLast ( factory -> inOutFlags [ p ] ) ; } SetScriptFunction ( func ) ; asCBuilder builder ( this , 0 ) ; asCCompiler compiler ( this ) ; compiler . CompileTemplateFactoryStub ( & builder , factoryId , ot , func ) ; // ▁ The ▁ function ' s ▁ refCount ▁ was ▁ already ▁ initialized ▁ to ▁ 1 ENDCOM ot -> beh . factories . PushLast ( func -> id ) ; } if ( ot -> beh . factories . GetLength ( ) ) ot -> beh . factory = ot -> beh . factories [ 0 ] ; else { asASSERT ( false ) ; ot -> beh . factory = templateType -> beh . factory ; } ot -> beh . addref = templateType -> beh . addref ; if ( scriptFunctions [ ot -> beh . addref ] ) scriptFunctions [ ot -> beh . addref ] -> AddRef ( ) ; ot -> beh . release = templateType -> beh . release ; if ( scriptFunctions [ ot -> beh . release ] ) scriptFunctions [ ot -> beh . release ] -> AddRef ( ) ; ot -> beh . copy = templateType -> beh . copy ; if ( scriptFunctions [ ot -> beh . copy ] ) scriptFunctions [ ot -> beh . copy ] -> AddRef ( ) ; ot -> beh . operators = templateType -> beh . operators ; for ( n = 1 ; n < ot -> beh . operators . GetLength ( ) ; n += 2 ) { scriptFunctions [ ot -> beh . operators [ n ] ] -> AddRef ( ) ; } ot -> beh . gcGetRefCount = templateType -> beh . gcGetRefCount ; if ( scriptFunctions [ ot -> beh . gcGetRefCount ] ) scriptFunctions [ ot -> beh . gcGetRefCount ] -> AddRef ( ) ; ot -> beh . gcSetFlag = templateType -> beh . gcSetFlag ; if ( scriptFunctions [ ot -> beh . gcSetFlag ] ) scriptFunctions [ ot -> beh . gcSetFlag ] -> AddRef ( ) ; ot -> beh . gcGetFlag = templateType -> beh . gcGetFlag ; if ( scriptFunctions [ ot -> beh . gcGetFlag ] ) scriptFunctions [ ot -> beh . gcGetFlag ] -> AddRef ( ) ; ot -> beh . gcEnumReferences = templateType -> beh . gcEnumReferences ; if ( scriptFunctions [ ot -> beh . gcEnumReferences ] ) scriptFunctions [ ot -> beh . gcEnumReferences ] -> AddRef ( ) ; ot -> beh . gcReleaseAllReferences = templateType -> beh . gcReleaseAllReferences ; if ( scriptFunctions [ ot -> beh . gcReleaseAllReferences ] ) scriptFunctions [ ot -> beh . gcReleaseAllReferences ] -> AddRef ( ) ; // ▁ As ▁ the ▁ new ▁ template ▁ type ▁ is ▁ instanciated , ▁ the ▁ engine ▁ should ENDCOM // ▁ generate ▁ new ▁ functions ▁ to ▁ substitute ▁ the ▁ ones ▁ with ▁ the ▁ template ▁ subtype . ENDCOM for ( n = 1 ; n < ot -> beh . operators . GetLength ( ) ; n += 2 ) { int funcId = ot -> beh . operators [ n ] ; asCScriptFunction * func = scriptFunctions [ funcId ] ; if ( GenerateNewTemplateFunction ( templateType , ot , subType , func , & func ) ) { // ▁ Release ▁ the ▁ old ▁ function , ▁ the ▁ new ▁ one ▁ already ▁ has ▁ its ▁ ref ▁ count ▁ set ▁ to ▁ 1 ENDCOM scriptFunctions [ ot -> beh . operators [ n ] ] -> Release ( ) ; ot -> beh . operators [ n ] = func -> id ; } } // ▁ As ▁ the ▁ new ▁ template ▁ type ▁ is ▁ instanciated , ▁ the ▁ engine ▁ should ENDCOM // ▁ generate ▁ new ▁ functions ▁ to ▁ substitute ▁ the ▁ ones ▁ with ▁ the ▁ template ▁ subtype . ENDCOM for ( n = 0 ; n < ot -> methods . GetLength ( ) ; n ++ ) { int funcId = ot -> methods [ n ] ; asCScriptFunction * func = scriptFunctions [ funcId ] ; if ( GenerateNewTemplateFunction ( templateType , ot , subType , func , & func ) ) { // ▁ Release ▁ the ▁ old ▁ function , ▁ the ▁ new ▁ one ▁ already ▁ has ▁ its ▁ ref ▁ count ▁ set ▁ to ▁ 1 ENDCOM scriptFunctions [ ot -> methods [ n ] ] -> Release ( ) ; ot -> methods [ n ] = func -> id ; } } // ▁ Increase ▁ ref ▁ counter ▁ for ▁ sub ▁ type ▁ if ▁ it ▁ is ▁ an ▁ object ▁ type ENDCOM if ( ot -> templateSubType . GetObjectType ( ) ) ot -> templateSubType . GetObjectType ( ) -> AddRef ( ) ; // ▁ Verify ▁ if ▁ the ▁ subtype ▁ contains ▁ a ▁ garbage ▁ collected ▁ object , ▁ in ▁ which ▁ case ▁ this ▁ template ▁ is ▁ a ▁ potential ▁ circular ▁ reference ENDCOM // ▁ TODO : ▁ We ▁ may ▁ be ▁ a ▁ bit ▁ smarter ▁ here . ▁ If ▁ we ▁ can ▁ guarantee ▁ that ▁ the ▁ array ▁ type ▁ cannot ▁ be ▁ part ▁ of ▁ the ENDCOM // ▁ potential ▁ circular ▁ reference ▁ then ▁ we ▁ don ' t ▁ need ▁ to ▁ set ▁ the ▁ flag ENDCOM if ( ot -> templateSubType . GetObjectType ( ) && ( ot -> templateSubType . GetObjectType ( ) -> flags & asOBJ_GC ) ) ot -> flags |= asOBJ_GC ; else if ( ot -> name == defaultArrayObjectType -> name ) ot -> flags &= ~ asOBJ_GC ; templateTypes . PushLast ( ot ) ; // ▁ We ▁ need ▁ to ▁ store ▁ the ▁ object ▁ type ▁ somewhere ▁ for ▁ clean - up ▁ later ENDCOM // ▁ TODO : ▁ Why ▁ do ▁ we ▁ need ▁ both ▁ templateTypes ▁ and ▁ templateInstanceTypes ? ▁ It ▁ is ▁ possible ▁ to ▁ differ ▁ between ▁ template ▁ instance ▁ and ▁ template ▁ specialization ▁ by ▁ checking ▁ for ▁ the ▁ asOBJ _ TEMPLATE ▁ flag ENDCOM templateInstanceTypes . PushLast ( ot ) ; return ot ; }
bool asCScriptEngine :: GenerateNewTemplateFunction ( asCObjectType * templateType , asCObjectType * ot , asCDataType & subType , asCScriptFunction * func , asCScriptFunction * * newFunc ) { bool needNewFunc = false ; if ( func -> returnType . GetObjectType ( ) == templateType -> templateSubType . GetObjectType ( ) || func -> returnType . GetObjectType ( ) == templateType ) needNewFunc = true ; else { for ( asUINT p = 0 ; p < func -> parameterTypes . GetLength ( ) ; p ++ ) { if ( func -> parameterTypes [ p ] . GetObjectType ( ) == templateType -> templateSubType . GetObjectType ( ) || func -> parameterTypes [ p ] . GetObjectType ( ) == templateType ) { needNewFunc = true ; break ; } } } if ( needNewFunc ) { asCScriptFunction * func2 = asNEW ( asCScriptFunction ) ( this , 0 , func -> funcType ) ; func2 -> name = func -> name ; func2 -> id = GetNextScriptFunctionId ( ) ; if ( func -> returnType . GetObjectType ( ) == templateType -> templateSubType . GetObjectType ( ) ) { func2 -> returnType = subType ; if ( func -> returnType . IsObjectHandle ( ) ) func2 -> returnType . MakeHandle ( true , true ) ; func2 -> returnType . MakeReference ( func -> returnType . IsReference ( ) ) ; func2 -> returnType . MakeReadOnly ( func -> returnType . IsReadOnly ( ) ) ; } else if ( func -> returnType . GetObjectType ( ) == templateType ) { if ( func2 -> returnType . IsObjectHandle ( ) ) func2 -> returnType = asCDataType :: CreateObjectHandle ( ot , false ) ; else func2 -> returnType = asCDataType :: CreateObject ( ot , false ) ; func2 -> returnType . MakeReference ( func -> returnType . IsReference ( ) ) ; func2 -> returnType . MakeReadOnly ( func -> returnType . IsReadOnly ( ) ) ; } else func2 -> returnType = func -> returnType ; func2 -> parameterTypes . SetLength ( func -> parameterTypes . GetLength ( ) ) ; for ( asUINT p = 0 ; p < func -> parameterTypes . GetLength ( ) ; p ++ ) { if ( func -> parameterTypes [ p ] . GetObjectType ( ) == templateType -> templateSubType . GetObjectType ( ) ) { func2 -> parameterTypes [ p ] = subType ; if ( func -> parameterTypes [ p ] . IsObjectHandle ( ) ) func2 -> parameterTypes [ p ] . MakeHandle ( true ) ; func2 -> parameterTypes [ p ] . MakeReference ( func -> parameterTypes [ p ] . IsReference ( ) ) ; func2 -> parameterTypes [ p ] . MakeReadOnly ( func -> parameterTypes [ p ] . IsReference ( ) ) ; } else if ( func -> parameterTypes [ p ] . GetObjectType ( ) == templateType ) { if ( func2 -> parameterTypes [ p ] . IsObjectHandle ( ) ) func2 -> parameterTypes [ p ] = asCDataType :: CreateObjectHandle ( ot , false ) ; else func2 -> parameterTypes [ p ] = asCDataType :: CreateObject ( ot , false ) ; func2 -> parameterTypes [ p ] . MakeReference ( func -> parameterTypes [ p ] . IsReference ( ) ) ; func2 -> parameterTypes [ p ] . MakeReadOnly ( func -> parameterTypes [ p ] . IsReadOnly ( ) ) ; } else func2 -> parameterTypes [ p ] = func -> parameterTypes [ p ] ; } // ▁ TODO : ▁ template : ▁ Must ▁ be ▁ careful ▁ when ▁ instanciating ▁ templates ▁ for ▁ garbage ▁ collected ▁ types ENDCOM // ▁ If ▁ the ▁ template ▁ hasn ' t ▁ been ▁ registered ▁ with ▁ the ▁ behaviours , ▁ it ▁ shouldn ' t ENDCOM // ▁ permit ▁ instanciation ▁ of ▁ garbage ▁ collected ▁ types ▁ that ▁ in ▁ turn ▁ may ▁ refer ▁ to ENDCOM // ▁ this ▁ instance . ENDCOM func2 -> inOutFlags = func -> inOutFlags ; func2 -> isReadOnly = func -> isReadOnly ; func2 -> objectType = ot ; func2 -> stackNeeded = func -> stackNeeded ; func2 -> sysFuncIntf = asNEW ( asSSystemFunctionInterface ) ( * func -> sysFuncIntf ) ; SetScriptFunction ( func2 ) ; // ▁ Return ▁ the ▁ new ▁ function ENDCOM * newFunc = func2 ; } return needNewFunc ; }
void asCScriptEngine :: CallObjectMethod ( void * obj , int func ) { asCScriptFunction * s = scriptFunctions [ func ] ; CallObjectMethod ( obj , s -> sysFuncIntf , s ) ; }
void asCScriptEngine :: CallObjectMethod ( void * obj , asSSystemFunctionInterface * i , asCScriptFunction * s ) { if ( i -> callConv == ICC_GENERIC_METHOD ) { asCGeneric gen ( this , s , obj , 0 ) ; void ( * f ) ( asIScriptGeneric * ) = ( void ( * ) ( asIScriptGeneric * ) ) ( i -> func ) ; f ( & gen ) ; } else if ( i -> callConv == ICC_VIRTUAL_THISCALL ) { // ▁ For ▁ virtual ▁ thiscalls ▁ we ▁ must ▁ call ▁ the ▁ method ▁ as ▁ a ▁ true ▁ class ▁ method ENDCOM // ▁ so ▁ that ▁ the ▁ compiler ▁ will ▁ lookup ▁ the ▁ function ▁ address ▁ in ▁ the ▁ vftable ENDCOM union { asSIMPLEMETHOD_t mthd ; struct { asFUNCTION_t func ; asPWORD baseOffset ; // ▁ Same ▁ size ▁ as ▁ the ▁ pointer ENDCOM } f ; } p ; p . f . func = ( void ( * ) ( ) ) ( i -> func ) ; p . f . baseOffset = asPWORD ( i -> baseOffset ) ; void ( asCSimpleDummy :: * f ) ( ) = p . mthd ; ( ( ( asCSimpleDummy * ) obj ) ->* f ) ( ) ; } else /* if ( ▁ i - > callConv ▁ = = ▁ ICC _ THISCALL ▁ | | ▁ i - > callConv ▁ = = ▁ ICC _ CDECL _ OBJLAST ▁ | | ▁ i - > callConv ▁ = = ▁ ICC _ CDECL _ OBJFIRST ▁ ) */ ENDCOM { // ▁ Non - virtual ▁ thiscall ▁ can ▁ be ▁ called ▁ just ▁ like ▁ any ▁ global ▁ function , ▁ passing ▁ the ▁ object ▁ as ▁ the ▁ first ▁ parameter ENDCOM void ( * f ) ( void * ) = ( void ( * ) ( void * ) ) ( i -> func ) ; f ( obj ) ; } if ( i -> callConv == ICC_THISCALL ) { union { asSIMPLEMETHOD_t mthd ; asFUNCTION_t func ; } p ; p . func = ( void ( * ) ( ) ) ( i -> func ) ; void ( asCSimpleDummy :: * f ) ( ) = p . mthd ; ( ( ( asCSimpleDummy * ) obj ) ->* f ) ( ) ; } else if ( i -> callConv == ICC_GENERIC_METHOD ) { asCGeneric gen ( this , s , obj , 0 ) ; void ( * f ) ( asIScriptGeneric * ) = ( void ( * ) ( asIScriptGeneric * ) ) ( i -> func ) ; f ( & gen ) ; } else /* if ( ▁ i - > callConv ▁ = = ▁ ICC _ CDECL _ OBJLAST ▁ | | ▁ i - > callConv ▁ = = ▁ ICC _ CDECL _ OBJFIRST ▁ ) */ ENDCOM { void ( * f ) ( void * ) = ( void ( * ) ( void * ) ) ( i -> func ) ; f ( obj ) ; } }
bool asCScriptEngine :: CallObjectMethodRetBool ( void * obj , int func ) { asCScriptFunction * s = scriptFunctions [ func ] ; asSSystemFunctionInterface * i = s -> sysFuncIntf ; if ( i -> callConv == ICC_GENERIC_METHOD ) { asCGeneric gen ( this , s , obj , 0 ) ; void ( * f ) ( asIScriptGeneric * ) = ( void ( * ) ( asIScriptGeneric * ) ) ( i -> func ) ; f ( & gen ) ; return * ( bool * ) gen . GetReturnPointer ( ) ; } else if ( i -> callConv == ICC_VIRTUAL_THISCALL ) { // ▁ For ▁ virtual ▁ thiscalls ▁ we ▁ must ▁ call ▁ the ▁ method ▁ as ▁ a ▁ true ▁ class ▁ method ▁ so ▁ that ▁ the ▁ compiler ▁ will ▁ lookup ▁ the ▁ function ▁ address ▁ in ▁ the ▁ vftable ENDCOM union { asSIMPLEMETHOD_t mthd ; struct { asFUNCTION_t func ; asDWORD baseOffset ; } f ; } p ; p . f . func = ( void ( * ) ( ) ) ( i -> func ) ; p . f . baseOffset = i -> baseOffset ; bool ( asCSimpleDummy :: * f ) ( ) = ( bool ( asCSimpleDummy :: * ) ( ) ) ( p . mthd ) ; return ( ( ( asCSimpleDummy * ) obj ) ->* f ) ( ) ; } else /* if ( ▁ i - > callConv ▁ = = ▁ ICC _ THISCALL ▁ | | ▁ i - > callConv ▁ = = ▁ ICC _ CDECL _ OBJLAST ▁ | | ▁ i - > callConv ▁ = = ▁ ICC _ CDECL _ OBJFIRST ▁ ) */ ENDCOM { // ▁ Non - virtual ▁ thiscall ▁ can ▁ be ▁ called ▁ just ▁ like ▁ any ▁ global ▁ function , ▁ passing ▁ the ▁ object ▁ as ▁ the ▁ first ▁ parameter ENDCOM bool ( * f ) ( void * ) = ( bool ( * ) ( void * ) ) ( i -> func ) ; return f ( obj ) ; } if ( i -> callConv == ICC_THISCALL ) { union { asSIMPLEMETHOD_t mthd ; asFUNCTION_t func ; } p ; p . func = ( void ( * ) ( ) ) ( i -> func ) ; bool ( asCSimpleDummy :: * f ) ( ) = ( bool ( asCSimpleDummy :: * ) ( ) ) p . mthd ; return ( ( ( asCSimpleDummy * ) obj ) ->* f ) ( ) ; } else if ( i -> callConv == ICC_GENERIC_METHOD ) { asCGeneric gen ( this , s , obj , 0 ) ; void ( * f ) ( asIScriptGeneric * ) = ( void ( * ) ( asIScriptGeneric * ) ) ( i -> func ) ; f ( & gen ) ; return * ( bool * ) gen . GetReturnPointer ( ) ; } else /* if ( ▁ i - > callConv ▁ = = ▁ ICC _ CDECL _ OBJLAST ▁ | | ▁ i - > callConv ▁ = = ▁ ICC _ CDECL _ OBJFIRST ▁ ) */ ENDCOM { bool ( * f ) ( void * ) = ( bool ( * ) ( void * ) ) ( i -> func ) ; return f ( obj ) ; } }
int asCScriptEngine :: CallObjectMethodRetInt ( void * obj , int func ) { asCScriptFunction * s = scriptFunctions [ func ] ; asSSystemFunctionInterface * i = s -> sysFuncIntf ; if ( i -> callConv == ICC_GENERIC_METHOD ) { asCGeneric gen ( this , s , obj , 0 ) ; void ( * f ) ( asIScriptGeneric * ) = ( void ( * ) ( asIScriptGeneric * ) ) ( i -> func ) ; f ( & gen ) ; return * ( int * ) gen . GetReturnPointer ( ) ; } else if ( i -> callConv == ICC_VIRTUAL_THISCALL ) { // ▁ For ▁ virtual ▁ thiscalls ▁ we ▁ must ▁ call ▁ the ▁ method ▁ as ▁ a ▁ true ▁ class ▁ method ▁ so ▁ that ▁ the ▁ compiler ▁ will ▁ lookup ▁ the ▁ function ▁ address ▁ in ▁ the ▁ vftable ENDCOM union { asSIMPLEMETHOD_t mthd ; struct { asFUNCTION_t func ; asDWORD baseOffset ; } f ; } p ; p . f . func = ( void ( * ) ( ) ) ( i -> func ) ; p . f . baseOffset = i -> baseOffset ; int ( asCSimpleDummy :: * f ) ( ) = ( int ( asCSimpleDummy :: * ) ( ) ) ( p . mthd ) ; return ( ( ( asCSimpleDummy * ) obj ) ->* f ) ( ) ; } else /* if ( ▁ i - > callConv ▁ = = ▁ ICC _ THISCALL ▁ | | ▁ i - > callConv ▁ = = ▁ ICC _ CDECL _ OBJLAST ▁ | | ▁ i - > callConv ▁ = = ▁ ICC _ CDECL _ OBJFIRST ▁ ) */ ENDCOM { // ▁ Non - virtual ▁ thiscall ▁ can ▁ be ▁ called ▁ just ▁ like ▁ any ▁ global ▁ function , ▁ passing ▁ the ▁ object ▁ as ▁ the ▁ first ▁ parameter ENDCOM int ( * f ) ( void * ) = ( int ( * ) ( void * ) ) ( i -> func ) ; return f ( obj ) ; } if ( i -> callConv == ICC_THISCALL ) { union { asSIMPLEMETHOD_t mthd ; asFUNCTION_t func ; } p ; p . func = ( void ( * ) ( ) ) ( i -> func ) ; int ( asCSimpleDummy :: * f ) ( ) = ( int ( asCSimpleDummy :: * ) ( ) ) p . mthd ; return ( ( ( asCSimpleDummy * ) obj ) ->* f ) ( ) ; } else if ( i -> callConv == ICC_GENERIC_METHOD ) { asCGeneric gen ( this , s , obj , 0 ) ; void ( * f ) ( asIScriptGeneric * ) = ( void ( * ) ( asIScriptGeneric * ) ) ( i -> func ) ; f ( & gen ) ; return * ( int * ) gen . GetReturnPointer ( ) ; } else /* if ( ▁ i - > callConv ▁ = = ▁ ICC _ CDECL _ OBJLAST ▁ | | ▁ i - > callConv ▁ = = ▁ ICC _ CDECL _ OBJFIRST ▁ ) */ ENDCOM { int ( * f ) ( void * ) = ( int ( * ) ( void * ) ) ( i -> func ) ; return f ( obj ) ; } }
void * asCScriptEngine :: CallGlobalFunctionRetPtr ( int func ) { asCScriptFunction * s = scriptFunctions [ func ] ; return CallGlobalFunctionRetPtr ( s -> sysFuncIntf , s ) ; }
void * asCScriptEngine :: CallGlobalFunctionRetPtr ( int func , void * param1 ) { asCScriptFunction * s = scriptFunctions [ func ] ; return CallGlobalFunctionRetPtr ( s -> sysFuncIntf , s , param1 ) ; }
void * asCScriptEngine :: CallGlobalFunctionRetPtr ( asSSystemFunctionInterface * i , asCScriptFunction * s ) { if ( i -> callConv == ICC_CDECL ) { void * ( * f ) ( ) = ( void * ( * ) ( ) ) ( i -> func ) ; return f ( ) ; } else if ( i -> callConv == ICC_STDCALL ) { void * ( STDCALL * f ) ( ) = ( void * ( STDCALL * ) ( ) ) ( i -> func ) ; return f ( ) ; } else { asCGeneric gen ( this , s , 0 , 0 ) ; void ( * f ) ( asIScriptGeneric * ) = ( void ( * ) ( asIScriptGeneric * ) ) ( i -> func ) ; f ( & gen ) ; return * ( void * * ) gen . GetReturnPointer ( ) ; } }
void * asCScriptEngine :: CallGlobalFunctionRetPtr ( asSSystemFunctionInterface * i , asCScriptFunction * s , void * param1 ) { if ( i -> callConv == ICC_CDECL ) { void * ( * f ) ( void * ) = ( void * ( * ) ( void * ) ) ( i -> func ) ; return f ( param1 ) ; } else if ( i -> callConv == ICC_STDCALL ) { void * ( STDCALL * f ) ( void * ) = ( void * ( STDCALL * ) ( void * ) ) ( i -> func ) ; return f ( param1 ) ; } else { asCGeneric gen ( this , s , 0 , ( asDWORD * ) & param1 ) ; void ( * f ) ( asIScriptGeneric * ) = ( void ( * ) ( asIScriptGeneric * ) ) ( i -> func ) ; f ( & gen ) ; return * ( void * * ) gen . GetReturnPointer ( ) ; } }
void asCScriptEngine :: CallObjectMethod ( void * obj , void * param , int func ) { asCScriptFunction * s = scriptFunctions [ func ] ; CallObjectMethod ( obj , param , s -> sysFuncIntf , s ) ; }
void asCScriptEngine :: CallObjectMethod ( void * obj , void * param , asSSystemFunctionInterface * i , asCScriptFunction * s ) { if ( i -> callConv == ICC_CDECL_OBJLAST ) { void ( * f ) ( void * , void * ) = ( void ( * ) ( void * , void * ) ) ( i -> func ) ; f ( param , obj ) ; } else if ( i -> callConv == ICC_GENERIC_METHOD ) { asCGeneric gen ( this , s , obj , ( asDWORD * ) & param ) ; void ( * f ) ( asIScriptGeneric * ) = ( void ( * ) ( asIScriptGeneric * ) ) ( i -> func ) ; f ( & gen ) ; } else /* if ( ▁ i - > callConv ▁ = = ▁ ICC _ CDECL _ OBJFIRST ▁ | | ▁ i - > callConv ▁ = = ▁ ICC _ THISCALL ▁ ) */ ENDCOM { void ( * f ) ( void * , void * ) = ( void ( * ) ( void * , void * ) ) ( i -> func ) ; f ( obj , param ) ; } if ( i -> callConv == ICC_THISCALL ) { union { asSIMPLEMETHOD_t mthd ; asFUNCTION_t func ; } p ; p . func = ( void ( * ) ( ) ) ( i -> func ) ; void ( asCSimpleDummy :: * f ) ( void * ) = ( void ( asCSimpleDummy :: * ) ( void * ) ) ( p . mthd ) ; ( ( ( asCSimpleDummy * ) obj ) ->* f ) ( param ) ; } else if ( i -> callConv == ICC_CDECL_OBJLAST ) { void ( * f ) ( void * , void * ) = ( void ( * ) ( void * , void * ) ) ( i -> func ) ; f ( param , obj ) ; } else if ( i -> callConv == ICC_GENERIC_METHOD ) { asCGeneric gen ( this , s , obj , ( asDWORD * ) & param ) ; void ( * f ) ( asIScriptGeneric * ) = ( void ( * ) ( asIScriptGeneric * ) ) ( i -> func ) ; f ( & gen ) ; } else /* if ( ▁ i - > callConv ▁ = = ▁ ICC _ CDECL _ OBJFIRST ▁ ) */ ENDCOM { void ( * f ) ( void * , void * ) = ( void ( * ) ( void * , void * ) ) ( i -> func ) ; f ( obj , param ) ; } }
void asCScriptEngine :: CallGlobalFunction ( void * param1 , void * param2 , asSSystemFunctionInterface * i , asCScriptFunction * s ) { if ( i -> callConv == ICC_CDECL ) { void ( * f ) ( void * , void * ) = ( void ( * ) ( void * , void * ) ) ( i -> func ) ; f ( param1 , param2 ) ; } else if ( i -> callConv == ICC_STDCALL ) { void ( STDCALL * f ) ( void * , void * ) = ( void ( STDCALL * ) ( void * , void * ) ) ( i -> func ) ; f ( param1 , param2 ) ; } else { asCGeneric gen ( this , s , 0 , ( asDWORD * ) & param1 ) ; void ( * f ) ( asIScriptGeneric * ) = ( void ( * ) ( asIScriptGeneric * ) ) ( i -> func ) ; f ( & gen ) ; } }
bool asCScriptEngine :: CallGlobalFunctionRetBool ( void * param1 , void * param2 , asSSystemFunctionInterface * i , asCScriptFunction * s ) { if ( i -> callConv == ICC_CDECL ) { bool ( * f ) ( void * , void * ) = ( bool ( * ) ( void * , void * ) ) ( i -> func ) ; return f ( param1 , param2 ) ; } else if ( i -> callConv == ICC_STDCALL ) { bool ( STDCALL * f ) ( void * , void * ) = ( bool ( STDCALL * ) ( void * , void * ) ) ( i -> func ) ; return f ( param1 , param2 ) ; } else { // ▁ TODO : ▁ When ▁ simulating ▁ a ▁ 64bit ▁ environment ▁ by ▁ defining ▁ AS _ 64BIT _ PTR ▁ on ▁ a ▁ 32bit ▁ platform ▁ this ▁ code ENDCOM // ▁ fails , ▁ because ▁ the ▁ stack ▁ given ▁ to ▁ asCGeneric ▁ is ▁ not ▁ prepared ▁ with ▁ two ▁ 64bit ▁ arguments . ENDCOM asCGeneric gen ( this , s , 0 , ( asDWORD * ) & param1 ) ; void ( * f ) ( asIScriptGeneric * ) = ( void ( * ) ( asIScriptGeneric * ) ) ( i -> func ) ; f ( & gen ) ; return * ( bool * ) gen . GetReturnPointer ( ) ; } }
void * asCScriptEngine :: CallAlloc ( asCObjectType * type ) { // ▁ Allocate ▁ 4 ▁ bytes ▁ as ▁ the ▁ smallest ▁ size . ▁ Otherwise ▁ CallSystemFunction ▁ may ▁ try ▁ to ENDCOM // ▁ copy ▁ a ▁ DWORD ▁ onto ▁ a ▁ smaller ▁ memory ▁ block , ▁ in ▁ case ▁ the ▁ object ▁ type ▁ is ▁ return ▁ in ▁ registers . ENDCOM return ( ( asALLOCFUNCDEBUG_t ) ( userAlloc ) ) ( type -> size < 4 ? 4 : type -> size , __FILE__ , __LINE__ ) ; return userAlloc ( type -> size < 4 ? 4 : type -> size ) ; }
void asCScriptEngine :: CallFree ( void * obj ) { userFree ( obj ) ; }
// ▁ interface ENDCOM void asCScriptEngine :: NotifyGarbageCollectorOfNewObject ( void * obj , int typeId ) { asCObjectType * objType = GetObjectTypeFromTypeId ( typeId ) ; gc . AddScriptObjectToGC ( obj , objType ) ; }
// ▁ interface ENDCOM int asCScriptEngine :: GarbageCollect ( asDWORD flags ) { return gc . GarbageCollect ( flags ) ; }
// ▁ interface ENDCOM void asCScriptEngine :: GetGCStatistics ( asUINT * currentSize , asUINT * totalDestroyed , asUINT * totalDetected ) { gc . GetStatistics ( currentSize , totalDestroyed , totalDetected ) ; }
// ▁ interface ENDCOM void asCScriptEngine :: GCEnumCallback ( void * reference ) { gc . GCEnumCallback ( reference ) ; }
// ▁ TODO : ▁ multithread : ▁ The ▁ mapTypeIdToDataType ▁ must ▁ be ▁ protected ▁ with ▁ critical ▁ sections ▁ in ▁ all ▁ functions ▁ that ▁ access ▁ it ENDCOM int asCScriptEngine :: GetTypeIdFromDataType ( const asCDataType & dt ) { if ( dt . IsNullHandle ( ) ) return 0 ; // ▁ Find ▁ the ▁ existing ▁ type ▁ id ENDCOM asSMapNode < int , asCDataType * > * cursor = 0 ; mapTypeIdToDataType . MoveFirst ( & cursor ) ; while ( cursor ) { if ( mapTypeIdToDataType . GetValue ( cursor ) -> IsEqualExceptRefAndConst ( dt ) ) return mapTypeIdToDataType . GetKey ( cursor ) ; mapTypeIdToDataType . MoveNext ( & cursor , cursor ) ; } // ▁ The ▁ type ▁ id ▁ doesn ' t ▁ exist , ▁ create ▁ it ENDCOM // ▁ Setup ▁ the ▁ basic ▁ type ▁ id ENDCOM int typeId = typeIdSeqNbr ++ ; if ( dt . GetObjectType ( ) ) { if ( dt . GetObjectType ( ) -> flags & asOBJ_SCRIPT_OBJECT ) typeId |= asTYPEID_SCRIPTOBJECT ; else if ( dt . GetObjectType ( ) -> flags & asOBJ_TEMPLATE ) typeId |= asTYPEID_SCRIPTARRAY ; // ▁ TODO : ▁ Should ▁ be ▁ asTYPEID _ TEMPLATE ENDCOM else if ( dt . GetObjectType ( ) -> flags & asOBJ_ENUM ) ; // ▁ TODO : ▁ Should ▁ we ▁ have ▁ a ▁ specific ▁ bit ▁ for ▁ this ? ENDCOM else typeId |= asTYPEID_APPOBJECT ; } // ▁ Insert ▁ the ▁ basic ▁ object ▁ type ENDCOM asCDataType * newDt = asNEW ( asCDataType ) ( dt ) ; newDt -> MakeReference ( false ) ; newDt -> MakeReadOnly ( false ) ; newDt -> MakeHandle ( false ) ; mapTypeIdToDataType . Insert ( typeId , newDt ) ; // ▁ If ▁ the ▁ object ▁ type ▁ supports ▁ object ▁ handles ▁ then ▁ register ▁ those ▁ types ▁ as ▁ well ENDCOM // ▁ Note : ▁ Don ' t ▁ check ▁ for ▁ addref , ▁ as ▁ asOBJ _ SCOPED ▁ don ' t ▁ have ▁ this ENDCOM if ( dt . IsObject ( ) && dt . GetObjectType ( ) -> beh . release ) { newDt = asNEW ( asCDataType ) ( dt ) ; newDt -> MakeReference ( false ) ; newDt -> MakeReadOnly ( false ) ; newDt -> MakeHandle ( true ) ; newDt -> MakeHandleToConst ( false ) ; mapTypeIdToDataType . Insert ( typeId | asTYPEID_OBJHANDLE , newDt ) ; newDt = asNEW ( asCDataType ) ( dt ) ; newDt -> MakeReference ( false ) ; newDt -> MakeReadOnly ( false ) ; newDt -> MakeHandle ( true ) ; newDt -> MakeHandleToConst ( true ) ; mapTypeIdToDataType . Insert ( typeId | asTYPEID_OBJHANDLE | asTYPEID_HANDLETOCONST , newDt ) ; } // ▁ Call ▁ the ▁ method ▁ recursively ▁ to ▁ get ▁ the ▁ correct ▁ type ▁ id ENDCOM return GetTypeIdFromDataType ( dt ) ; }
const asCDataType * asCScriptEngine :: GetDataTypeFromTypeId ( int typeId ) { asSMapNode < int , asCDataType * > * cursor = 0 ; if ( mapTypeIdToDataType . MoveTo ( & cursor , typeId ) ) return mapTypeIdToDataType . GetValue ( cursor ) ; return 0 ; }
asCObjectType * asCScriptEngine :: GetObjectTypeFromTypeId ( int typeId ) { asSMapNode < int , asCDataType * > * cursor = 0 ; if ( mapTypeIdToDataType . MoveTo ( & cursor , typeId ) ) return mapTypeIdToDataType . GetValue ( cursor ) -> GetObjectType ( ) ; return 0 ; }
void asCScriptEngine :: RemoveFromTypeIdMap ( asCObjectType * type ) { asSMapNode < int , asCDataType * > * cursor = 0 ; mapTypeIdToDataType . MoveFirst ( & cursor ) ; while ( cursor ) { asCDataType * dt = mapTypeIdToDataType . GetValue ( cursor ) ; asSMapNode < int , asCDataType * > * old = cursor ; mapTypeIdToDataType . MoveNext ( & cursor , cursor ) ; if ( dt -> GetObjectType ( ) == type ) { asDELETE ( dt , asCDataType ) ; mapTypeIdToDataType . Erase ( old ) ; } } }
// ▁ interface ENDCOM int asCScriptEngine :: GetTypeIdByDecl ( const char * decl ) { asCDataType dt ; asCBuilder bld ( this , 0 ) ; int r = bld . ParseDataType ( decl , & dt ) ; if ( r < 0 ) return asINVALID_TYPE ; return GetTypeIdFromDataType ( dt ) ; }
const char * asCScriptEngine :: GetTypeDeclaration ( int typeId ) { const asCDataType * dt = GetDataTypeFromTypeId ( typeId ) ; if ( dt == 0 ) return 0 ; asASSERT ( threadManager ) ; asCString * tempString = & threadManager -> GetLocalData ( ) -> string ; * tempString = dt -> Format ( ) ; return tempString -> AddressOf ( ) ; }
int asCScriptEngine :: GetSizeOfPrimitiveType ( int typeId ) { const asCDataType * dt = GetDataTypeFromTypeId ( typeId ) ; if ( dt == 0 ) return 0 ; if ( ! dt -> IsPrimitive ( ) ) return 0 ; return dt -> GetSizeInMemoryBytes ( ) ; }
void * asCScriptEngine :: CreateScriptObject ( int typeId ) { // ▁ Make ▁ sure ▁ the ▁ type ▁ id ▁ is ▁ for ▁ an ▁ object ▁ type , ▁ and ▁ not ▁ a ▁ primitive ▁ or ▁ a ▁ handle ENDCOM if ( ( typeId & ( asTYPEID_MASK_OBJECT | asTYPEID_MASK_SEQNBR ) ) != typeId ) return 0 ; if ( ( typeId & asTYPEID_MASK_OBJECT ) == 0 ) return 0 ; const asCDataType * dt = GetDataTypeFromTypeId ( typeId ) ; // ▁ Is ▁ the ▁ type ▁ id ▁ valid ? ENDCOM if ( ! dt ) return 0 ; // ▁ Allocate ▁ the ▁ memory ENDCOM asCObjectType * objType = dt -> GetObjectType ( ) ; void * ptr = 0 ; // ▁ Construct ▁ the ▁ object ENDCOM if ( objType -> flags & asOBJ_SCRIPT_OBJECT ) ptr = ScriptObjectFactory ( objType , this ) ; else if ( objType -> flags & asOBJ_TEMPLATE ) // ▁ The ▁ registered ▁ factory ▁ is ▁ moved ▁ to ▁ the ▁ construct ▁ behaviour ▁ when ▁ the ▁ type ▁ is ▁ instanciated ENDCOM ptr = CallGlobalFunctionRetPtr ( objType -> beh . construct , objType ) ; else if ( objType -> flags & asOBJ_REF ) ptr = CallGlobalFunctionRetPtr ( objType -> beh . factory ) ; else { ptr = CallAlloc ( objType ) ; int funcIndex = objType -> beh . construct ; if ( funcIndex ) CallObjectMethod ( ptr , funcIndex ) ; } return ptr ; }
void * asCScriptEngine :: CreateScriptObjectCopy ( void * origObj , int typeId ) { void * newObj = CreateScriptObject ( typeId ) ; if ( newObj == 0 ) return 0 ; CopyScriptObject ( newObj , origObj , typeId ) ; return newObj ; }
void asCScriptEngine :: CopyScriptObject ( void * dstObj , void * srcObj , int typeId ) { // ▁ Make ▁ sure ▁ the ▁ type ▁ id ▁ is ▁ for ▁ an ▁ object ▁ type , ▁ and ▁ not ▁ a ▁ primitive ▁ or ▁ a ▁ handle ENDCOM if ( ( typeId & ( asTYPEID_MASK_OBJECT | asTYPEID_MASK_SEQNBR ) ) != typeId ) return ; if ( ( typeId & asTYPEID_MASK_OBJECT ) == 0 ) return ; // ▁ Copy ▁ the ▁ contents ▁ from ▁ the ▁ original ▁ object , ▁ using ▁ the ▁ assignment ▁ operator ENDCOM const asCDataType * dt = GetDataTypeFromTypeId ( typeId ) ; // ▁ Is ▁ the ▁ type ▁ id ▁ valid ? ENDCOM if ( ! dt ) return ; asCObjectType * objType = dt -> GetObjectType ( ) ; // ▁ TODO : ▁ beh . copy ▁ will ▁ be ▁ removed , ▁ so ▁ we ▁ need ▁ to ▁ find ▁ the ▁ default ▁ opAssign ▁ method ▁ instead ENDCOM if ( objType -> beh . copy ) { CallObjectMethod ( dstObj , srcObj , objType -> beh . copy ) ; } else if ( objType -> size ) { memcpy ( dstObj , srcObj , objType -> size ) ; } }
void asCScriptEngine :: AddRefScriptObject ( void * obj , int typeId ) { // ▁ Make ▁ sure ▁ it ▁ is ▁ not ▁ a ▁ null ▁ pointer ENDCOM if ( obj == 0 ) return ; // ▁ Make ▁ sure ▁ the ▁ type ▁ id ▁ is ▁ for ▁ an ▁ object ▁ type ▁ or ▁ a ▁ handle ENDCOM if ( ( typeId & asTYPEID_MASK_OBJECT ) == 0 ) return ; const asCDataType * dt = GetDataTypeFromTypeId ( typeId ) ; // ▁ Is ▁ the ▁ type ▁ id ▁ valid ? ENDCOM if ( ! dt ) return ; asCObjectType * objType = dt -> GetObjectType ( ) ; if ( objType -> beh . addref ) { // ▁ Call ▁ the ▁ addref ▁ behaviour ENDCOM CallObjectMethod ( obj , objType -> beh . addref ) ; } }
void asCScriptEngine :: ReleaseScriptObject ( void * obj , int typeId ) { // ▁ Make ▁ sure ▁ it ▁ is ▁ not ▁ a ▁ null ▁ pointer ENDCOM if ( obj == 0 ) return ; // ▁ Make ▁ sure ▁ the ▁ type ▁ id ▁ is ▁ for ▁ an ▁ object ▁ type ▁ or ▁ a ▁ handle ENDCOM if ( ( typeId & asTYPEID_MASK_OBJECT ) == 0 ) return ; const asCDataType * dt = GetDataTypeFromTypeId ( typeId ) ; // ▁ Is ▁ the ▁ type ▁ id ▁ valid ? ENDCOM if ( ! dt ) return ; asCObjectType * objType = dt -> GetObjectType ( ) ; if ( objType -> beh . release ) { // ▁ Call ▁ the ▁ release ▁ behaviour ENDCOM CallObjectMethod ( obj , objType -> beh . release ) ; } else { // ▁ Call ▁ the ▁ destructor ENDCOM if ( objType -> beh . destruct ) CallObjectMethod ( obj , objType -> beh . destruct ) ; // ▁ Then ▁ free ▁ the ▁ memory ENDCOM CallFree ( obj ) ; } }
bool asCScriptEngine :: IsHandleCompatibleWithObject ( void * obj , int objTypeId , int handleTypeId ) { // ▁ if ▁ equal , ▁ then ▁ it ▁ is ▁ obvious ▁ they ▁ are ▁ compatible ENDCOM if ( objTypeId == handleTypeId ) return true ; // ▁ Get ▁ the ▁ actual ▁ data ▁ types ▁ from ▁ the ▁ type ▁ ids ENDCOM const asCDataType * objDt = GetDataTypeFromTypeId ( objTypeId ) ; const asCDataType * hdlDt = GetDataTypeFromTypeId ( handleTypeId ) ; // ▁ A ▁ handle ▁ to ▁ const ▁ cannot ▁ be ▁ passed ▁ to ▁ a ▁ handle ▁ that ▁ is ▁ not ▁ referencing ▁ a ▁ const ▁ object ENDCOM if ( objDt -> IsHandleToConst ( ) && ! hdlDt -> IsHandleToConst ( ) ) return false ; if ( objDt -> GetObjectType ( ) == hdlDt -> GetObjectType ( ) ) { // ▁ The ▁ object ▁ type ▁ is ▁ equal ENDCOM return true ; } else if ( objDt -> IsScriptObject ( ) && obj ) { // ▁ There ' s ▁ still ▁ a ▁ chance ▁ the ▁ object ▁ implements ▁ the ▁ requested ▁ interface ENDCOM asCObjectType * objType = ( ( asCScriptObject * ) obj ) -> objType ; if ( objType -> Implements ( hdlDt -> GetObjectType ( ) ) ) return true ; } return false ; }
int asCScriptEngine :: BeginConfigGroup ( const char * groupName ) { // ▁ Make ▁ sure ▁ the ▁ group ▁ name ▁ doesn ' t ▁ already ▁ exist ENDCOM for ( asUINT n = 0 ; n < configGroups . GetLength ( ) ; n ++ ) { if ( configGroups [ n ] -> groupName == groupName ) return asNAME_TAKEN ; } if ( currentGroup != & defaultGroup ) return asNOT_SUPPORTED ; asCConfigGroup * group = asNEW ( asCConfigGroup ) ( ) ; group -> groupName = groupName ; configGroups . PushLast ( group ) ; currentGroup = group ; return 0 ; }
int asCScriptEngine :: EndConfigGroup ( ) { // ▁ Raise ▁ error ▁ if ▁ trying ▁ to ▁ end ▁ the ▁ default ▁ config ENDCOM if ( currentGroup == & defaultGroup ) return asNOT_SUPPORTED ; currentGroup = & defaultGroup ; return 0 ; }
int asCScriptEngine :: RemoveConfigGroup ( const char * groupName ) { // ▁ It ▁ is ▁ not ▁ allowed ▁ to ▁ remove ▁ a ▁ group ▁ that ▁ is ▁ still ▁ in ▁ use . ▁ ENDCOM // ▁ It ▁ would ▁ be ▁ possible ▁ to ▁ change ▁ the ▁ code ▁ in ▁ such ▁ a ▁ way ▁ that ENDCOM // ▁ the ▁ group ▁ could ▁ be ▁ removed ▁ even ▁ though ▁ it ▁ was ▁ still ▁ in ▁ use , ENDCOM // ▁ but ▁ that ▁ would ▁ cause ▁ severe ▁ negative ▁ impact ▁ on ▁ runtime ▁ ENDCOM // ▁ performance , ▁ since ▁ the ▁ VM ▁ would ▁ then ▁ have ▁ to ▁ be ▁ able ▁ handle ENDCOM // ▁ situations ▁ where ▁ the ▁ types , ▁ functions , ▁ and ▁ global ▁ variables ENDCOM // ▁ can ▁ be ▁ removed ▁ at ▁ any ▁ time . ENDCOM for ( asUINT n = 0 ; n < configGroups . GetLength ( ) ; n ++ ) { if ( configGroups [ n ] -> groupName == groupName ) { asCConfigGroup * group = configGroups [ n ] ; // ▁ Make ▁ sure ▁ the ▁ group ▁ isn ' t ▁ referenced ▁ by ▁ anyone ENDCOM if ( group -> refCount > 0 ) return asCONFIG_GROUP_IS_IN_USE ; // ▁ Verify ▁ if ▁ any ▁ objects ▁ registered ▁ in ▁ this ▁ group ▁ is ▁ still ▁ alive ENDCOM if ( group -> HasLiveObjects ( ) ) return asCONFIG_GROUP_IS_IN_USE ; // ▁ Remove ▁ the ▁ group ▁ from ▁ the ▁ list ENDCOM if ( n == configGroups . GetLength ( ) - 1 ) configGroups . PopLast ( ) ; else configGroups [ n ] = configGroups . PopLast ( ) ; // ▁ Remove ▁ the ▁ configurations ▁ registered ▁ with ▁ this ▁ group ENDCOM group -> RemoveConfiguration ( this ) ; asDELETE ( group , asCConfigGroup ) ; } } return 0 ; }
asCConfigGroup * asCScriptEngine :: FindConfigGroupForFunction ( int funcId ) { for ( asUINT n = 0 ; n < configGroups . GetLength ( ) ; n ++ ) { // ▁ Check ▁ global ▁ functions ENDCOM asUINT m ; for ( m = 0 ; m < configGroups [ n ] -> scriptFunctions . GetLength ( ) ; m ++ ) { if ( configGroups [ n ] -> scriptFunctions [ m ] -> id == funcId ) return configGroups [ n ] ; } } return 0 ; }
asCConfigGroup * asCScriptEngine :: FindConfigGroupForGlobalVar ( int gvarId ) { for ( asUINT n = 0 ; n < configGroups . GetLength ( ) ; n ++ ) { for ( asUINT m = 0 ; m < configGroups [ n ] -> globalProps . GetLength ( ) ; m ++ ) { if ( configGroups [ n ] -> globalProps [ m ] -> id == gvarId ) return configGroups [ n ] ; } } return 0 ; }
asCConfigGroup * asCScriptEngine :: FindConfigGroupForObjectType ( const asCObjectType * objType ) { for ( asUINT n = 0 ; n < configGroups . GetLength ( ) ; n ++ ) { for ( asUINT m = 0 ; m < configGroups [ n ] -> objTypes . GetLength ( ) ; m ++ ) { if ( configGroups [ n ] -> objTypes [ m ] == objType ) return configGroups [ n ] ; } } return 0 ; }
int asCScriptEngine :: SetConfigGroupModuleAccess ( const char * groupName , const char * module , bool hasAccess ) { asCConfigGroup * group = 0 ; // ▁ Make ▁ sure ▁ the ▁ group ▁ name ▁ doesn ' t ▁ already ▁ exist ENDCOM for ( asUINT n = 0 ; n < configGroups . GetLength ( ) ; n ++ ) { if ( configGroups [ n ] -> groupName == groupName ) { group = configGroups [ n ] ; break ; } } if ( group == 0 ) return asWRONG_CONFIG_GROUP ; return group -> SetModuleAccess ( module , hasAccess ) ; }
int asCScriptEngine :: GetNextScriptFunctionId ( ) { if ( freeScriptFunctionIds . GetLength ( ) ) return freeScriptFunctionIds . PopLast ( ) ; int id = ( int ) scriptFunctions . GetLength ( ) ; scriptFunctions . PushLast ( 0 ) ; return id ; }
void asCScriptEngine :: SetScriptFunction ( asCScriptFunction * func ) { scriptFunctions [ func -> id ] = func ; }
void asCScriptEngine :: FreeScriptFunctionId ( int id ) { if ( id < 0 ) return ; id &= 0xFFFF ; if ( id >= ( int ) scriptFunctions . GetLength ( ) ) return ; if ( scriptFunctions [ id ] ) { asCScriptFunction * func = scriptFunctions [ id ] ; // ▁ Remove ▁ the ▁ function ▁ from ▁ the ▁ list ▁ of ▁ script ▁ functions ENDCOM if ( id == ( int ) scriptFunctions . GetLength ( ) - 1 ) { scriptFunctions . PopLast ( ) ; } else { scriptFunctions [ id ] = 0 ; freeScriptFunctionIds . PushLast ( id ) ; } // ▁ Is ▁ the ▁ function ▁ used ▁ as ▁ signature ▁ id ? ENDCOM if ( func -> signatureId == id ) { // ▁ Remove ▁ the ▁ signature ▁ id ENDCOM signatureIds . RemoveValue ( func ) ; // ▁ Update ▁ all ▁ functions ▁ using ▁ the ▁ signature ▁ id ENDCOM int newSigId = 0 ; for ( asUINT n = 0 ; n < scriptFunctions . GetLength ( ) ; n ++ ) { if ( scriptFunctions [ n ] && scriptFunctions [ n ] -> signatureId == id ) { if ( newSigId == 0 ) { newSigId = scriptFunctions [ n ] -> id ; signatureIds . PushLast ( scriptFunctions [ n ] ) ; } scriptFunctions [ n ] -> signatureId = newSigId ; } } } } }
// ▁ interface ENDCOM // ▁ TODO : ▁ typedef : ▁ Accept ▁ complex ▁ types ▁ for ▁ the ▁ typedefs ENDCOM int asCScriptEngine :: RegisterTypedef ( const char * type , const char * decl ) { if ( type == 0 ) return ConfigError ( asINVALID_NAME ) ; // ▁ Verify ▁ if ▁ the ▁ name ▁ has ▁ been ▁ registered ▁ as ▁ a ▁ type ▁ already ENDCOM asUINT n ; for ( n = 0 ; n < objectTypes . GetLength ( ) ; n ++ ) { if ( objectTypes [ n ] && objectTypes [ n ] -> name == type ) return asALREADY_REGISTERED ; } // ▁ Grab ▁ the ▁ data ▁ type ENDCOM asCTokenizer t ; size_t tokenLen ; eTokenType token ; asCDataType dataType ; // TABSYMBOL Create ▁ the ▁ data ▁ type ENDCOM token = t . GetToken ( decl , strlen ( decl ) , & tokenLen ) ; switch ( token ) { case ttBool : case ttInt : case ttInt8 : case ttInt16 : case ttInt64 : case ttUInt : case ttUInt8 : case ttUInt16 : case ttUInt64 : case ttFloat : case ttDouble : if ( strlen ( decl ) != tokenLen ) { return ConfigError ( asINVALID_TYPE ) ; } break ; default : return ConfigError ( asINVALID_TYPE ) ; } dataType = asCDataType :: CreatePrimitive ( token , false ) ; // ▁ Make ▁ sure ▁ the ▁ name ▁ is ▁ not ▁ a ▁ reserved ▁ keyword ENDCOM token = t . GetToken ( type , strlen ( type ) , & tokenLen ) ; if ( token != ttIdentifier || strlen ( type ) != tokenLen ) return ConfigError ( asINVALID_NAME ) ; asCBuilder bld ( this , 0 ) ; int r = bld . CheckNameConflict ( type , 0 , 0 ) ; if ( r < 0 ) return ConfigError ( asNAME_TAKEN ) ; // ▁ Don ' t ▁ have ▁ to ▁ check ▁ against ▁ members ▁ of ▁ object ENDCOM // ▁ types ▁ as ▁ they ▁ are ▁ allowed ▁ to ▁ use ▁ the ▁ names ENDCOM // ▁ Put ▁ the ▁ data ▁ type ▁ in ▁ the ▁ list ENDCOM asCObjectType * object = asNEW ( asCObjectType ) ( this ) ; object -> flags = asOBJ_TYPEDEF ; object -> size = dataType . GetSizeInMemoryBytes ( ) ; object -> name = type ; object -> templateSubType = dataType ; objectTypes . PushLast ( object ) ; registeredTypeDefs . PushLast ( object ) ; currentGroup -> objTypes . PushLast ( object ) ; return asSUCCESS ; }
// ▁ interface ENDCOM int asCScriptEngine :: GetTypedefCount ( ) { return ( int ) registeredTypeDefs . GetLength ( ) ; }
// ▁ interface ENDCOM const char * asCScriptEngine :: GetTypedefByIndex ( asUINT index , int * typeId , const char * * configGroup ) { if ( index >= registeredTypeDefs . GetLength ( ) ) return 0 ; if ( typeId ) * typeId = GetTypeIdByDecl ( registeredTypeDefs [ index ] -> name . AddressOf ( ) ) ; if ( configGroup ) { asCConfigGroup * group = FindConfigGroupForObjectType ( registeredTypeDefs [ index ] ) ; if ( group ) * configGroup = group -> groupName . AddressOf ( ) ; else * configGroup = 0 ; } return registeredTypeDefs [ index ] -> name . AddressOf ( ) ; }
// ▁ interface ENDCOM int asCScriptEngine :: RegisterEnum ( const char * name ) { // TABSYMBOL Check ▁ the ▁ name ENDCOM if ( NULL == name ) return ConfigError ( asINVALID_NAME ) ; // ▁ Verify ▁ if ▁ the ▁ name ▁ has ▁ been ▁ registered ▁ as ▁ a ▁ type ▁ already ENDCOM asUINT n ; for ( n = 0 ; n < objectTypes . GetLength ( ) ; n ++ ) if ( objectTypes [ n ] && objectTypes [ n ] -> name == name ) return asALREADY_REGISTERED ; // ▁ Use ▁ builder ▁ to ▁ parse ▁ the ▁ datatype ENDCOM asCDataType dt ; asCBuilder bld ( this , 0 ) ; bool oldMsgCallback = msgCallback ; msgCallback = false ; int r = bld . ParseDataType ( name , & dt ) ; msgCallback = oldMsgCallback ; if ( r >= 0 ) return ConfigError ( asERROR ) ; // ▁ Make ▁ sure ▁ the ▁ name ▁ is ▁ not ▁ a ▁ reserved ▁ keyword ENDCOM asCTokenizer t ; size_t tokenLen ; int token = t . GetToken ( name , strlen ( name ) , & tokenLen ) ; if ( token != ttIdentifier || strlen ( name ) != tokenLen ) return ConfigError ( asINVALID_NAME ) ; r = bld . CheckNameConflict ( name , 0 , 0 ) ; if ( r < 0 ) return ConfigError ( asNAME_TAKEN ) ; asCObjectType * st = asNEW ( asCObjectType ) ( this ) ; asCDataType dataType ; dataType . CreatePrimitive ( ttInt , false ) ; st -> flags = asOBJ_ENUM ; st -> size = dataType . GetSizeInMemoryBytes ( ) ; st -> name = name ; objectTypes . PushLast ( st ) ; registeredEnums . PushLast ( st ) ; currentGroup -> objTypes . PushLast ( st ) ; return asSUCCESS ; }
// ▁ interface ENDCOM int asCScriptEngine :: RegisterEnumValue ( const char * typeName , const char * valueName , int value ) { // ▁ Verify ▁ that ▁ the ▁ correct ▁ config ▁ group ▁ is ▁ used ENDCOM if ( currentGroup -> FindType ( typeName ) == 0 ) return asWRONG_CONFIG_GROUP ; asCDataType dt ; int r ; asCBuilder bld ( this , 0 ) ; r = bld . ParseDataType ( typeName , & dt ) ; if ( r < 0 ) return ConfigError ( r ) ; // ▁ Store ▁ the ▁ enum ▁ value ENDCOM asCObjectType * ot = dt . GetObjectType ( ) ; if ( ot == 0 || ! ( ot -> flags & asOBJ_ENUM ) ) return ConfigError ( asINVALID_TYPE ) ; if ( NULL == valueName ) return ConfigError ( asINVALID_NAME ) ; for ( unsigned int n = 0 ; n < ot -> enumValues . GetLength ( ) ; n ++ ) { if ( ot -> enumValues [ n ] -> name == valueName ) return ConfigError ( asALREADY_REGISTERED ) ; } asSEnumValue * e = asNEW ( asSEnumValue ) ; e -> name = valueName ; e -> value = value ; ot -> enumValues . PushLast ( e ) ; return asSUCCESS ; }
// ▁ interface ENDCOM int asCScriptEngine :: GetEnumCount ( ) { return ( int ) registeredEnums . GetLength ( ) ; }
// ▁ interface ENDCOM const char * asCScriptEngine :: GetEnumByIndex ( asUINT index , int * enumTypeId , const char * * configGroup ) { if ( index >= registeredEnums . GetLength ( ) ) return 0 ; if ( configGroup ) { asCConfigGroup * group = FindConfigGroupForObjectType ( registeredEnums [ index ] ) ; if ( group ) * configGroup = group -> groupName . AddressOf ( ) ; else * configGroup = 0 ; } if ( enumTypeId ) * enumTypeId = GetTypeIdByDecl ( registeredEnums [ index ] -> name . AddressOf ( ) ) ; return registeredEnums [ index ] -> name . AddressOf ( ) ; }
// ▁ interface ENDCOM int asCScriptEngine :: GetEnumValueCount ( int enumTypeId ) { const asCDataType * dt = GetDataTypeFromTypeId ( enumTypeId ) ; asCObjectType * t = dt -> GetObjectType ( ) ; if ( t == 0 || ! ( t -> GetFlags ( ) & asOBJ_ENUM ) ) return asINVALID_TYPE ; return ( int ) t -> enumValues . GetLength ( ) ; }
// ▁ interface ENDCOM const char * asCScriptEngine :: GetEnumValueByIndex ( int enumTypeId , asUINT index , int * outValue ) { // ▁ TODO : ▁ This ▁ same ▁ function ▁ is ▁ implemented ▁ in ▁ as _ module . cpp ▁ as ▁ well . ▁ Perhaps ▁ it ▁ should ▁ be ▁ moved ▁ to ▁ asCObjectType ? ENDCOM const asCDataType * dt = GetDataTypeFromTypeId ( enumTypeId ) ; asCObjectType * t = dt -> GetObjectType ( ) ; if ( t == 0 || ! ( t -> GetFlags ( ) & asOBJ_ENUM ) ) return 0 ; if ( index >= t -> enumValues . GetLength ( ) ) return 0 ; if ( outValue ) * outValue = t -> enumValues [ index ] -> value ; return t -> enumValues [ index ] -> name . AddressOf ( ) ; }
// ▁ interface ENDCOM int asCScriptEngine :: GetObjectTypeCount ( ) { return ( int ) registeredObjTypes . GetLength ( ) ; }
// ▁ interface ENDCOM asIObjectType * asCScriptEngine :: GetObjectTypeByIndex ( asUINT index ) { if ( index >= registeredObjTypes . GetLength ( ) ) return 0 ; return registeredObjTypes [ index ] ; }
// ▁ interface ENDCOM asIObjectType * asCScriptEngine :: GetObjectTypeById ( int typeId ) { const asCDataType * dt = GetDataTypeFromTypeId ( typeId ) ; // ▁ Is ▁ the ▁ type ▁ id ▁ valid ? ENDCOM if ( ! dt ) return 0 ; // ▁ Enum ▁ types ▁ are ▁ not ▁ objects , ▁ so ▁ we ▁ shouldn ' t ▁ return ▁ an ▁ object ▁ type ▁ for ▁ them ENDCOM if ( dt -> GetObjectType ( ) && dt -> GetObjectType ( ) -> GetFlags ( ) & asOBJ_ENUM ) return 0 ; return dt -> GetObjectType ( ) ; }
asIScriptFunction * asCScriptEngine :: GetFunctionDescriptorById ( int funcId ) { return GetScriptFunction ( funcId ) ; }
// ▁ internal ENDCOM bool asCScriptEngine :: IsTemplateType ( const char * name ) { // ▁ TODO : ▁ optimize : ▁ Improve ▁ linear ▁ search ENDCOM for ( unsigned int n = 0 ; n < objectTypes . GetLength ( ) ; n ++ ) { if ( objectTypes [ n ] && objectTypes [ n ] -> name == name ) { return objectTypes [ n ] -> flags & asOBJ_TEMPLATE ? true : false ; } } return false ; }
// ▁ internal ENDCOM int asCScriptEngine :: AddConstantString ( const char * str , size_t len ) { // ▁ The ▁ str ▁ may ▁ contain ▁ null ▁ chars , ▁ so ▁ we ▁ cannot ▁ use ▁ strlen , ▁ or ▁ strcmp , ▁ or ▁ strcpy ENDCOM // ▁ TODO : ▁ optimize : ▁ Improve ▁ linear ▁ search ENDCOM // ▁ Has ▁ the ▁ string ▁ been ▁ registered ▁ before ? ENDCOM for ( size_t n = 0 ; n < stringConstants . GetLength ( ) ; n ++ ) { if ( stringConstants [ n ] -> Compare ( str , len ) == 0 ) { return ( int ) n ; } } // ▁ No ▁ match ▁ was ▁ found , ▁ add ▁ the ▁ string ENDCOM asCString * cstr = asNEW ( asCString ) ( str , len ) ; stringConstants . PushLast ( cstr ) ; // ▁ The ▁ VM ▁ currently ▁ doesn ' t ▁ handle ▁ string ▁ ids ▁ larger ▁ than ▁ 65535 ENDCOM asASSERT ( stringConstants . GetLength ( ) <= 65536 ) ; return ( int ) stringConstants . GetLength ( ) - 1 ; }
// ▁ internal ENDCOM const asCString & asCScriptEngine :: GetConstantString ( int id ) { return * stringConstants [ id ] ; }
// ▁ internal ENDCOM int asCScriptEngine :: GetScriptSectionNameIndex ( const char * name ) { // ▁ TODO : ▁ These ▁ names ▁ are ▁ only ▁ released ▁ when ▁ the ▁ engine ▁ is ▁ freed . ▁ The ▁ assumption ▁ is ▁ that ENDCOM // ▁ the ▁ same ▁ script ▁ section ▁ names ▁ will ▁ be ▁ reused ▁ instead ▁ of ▁ there ▁ always ▁ being ▁ new ENDCOM // ▁ names . ▁ Is ▁ this ▁ assumption ▁ valid ? ▁ Do ▁ we ▁ need ▁ to ▁ add ▁ reference ▁ counting ? ENDCOM // ▁ Store ▁ the ▁ script ▁ section ▁ names ▁ for ▁ future ▁ reference ENDCOM for ( asUINT n = 0 ; n < scriptSectionNames . GetLength ( ) ; n ++ ) { if ( scriptSectionNames [ n ] -> Compare ( name ) == 0 ) return n ; } scriptSectionNames . PushLast ( asNEW ( asCString ) ( name ) ) ; return int ( scriptSectionNames . GetLength ( ) - 1 ) ; }
CCFreeTypeFont :: ~ CCFreeTypeFont ( ) { reset ( ) ; }
void CCFreeTypeFont :: reset ( ) { for ( auto line : m_lines ) { line -> glyphs . clear ( ) ; delete line ; } m_lines . clear ( ) ; if ( m_face ) { FT_Done_Face ( m_face ) ; m_face = nullptr ; } }
unsigned char * CCFreeTypeFont :: initWithString ( const char * text , const FontDefinition & textDefinition , Device :: TextAlign align , int & width , int & height , ssize_t & dataLength ) { FT_Error error = 0 ; ssize_t size = 0 ; unsigned char * pBuffer = nullptr ; unsigned char * data = nullptr ; Size winSize = Director :: getInstance ( ) -> getWinSizeInPixels ( ) ; m_windowWidth = ( int ) winSize . width ; m_inWidth = textDefinition . _dimensions . width ; m_inHeight = textDefinition . _dimensions . height ; m_fontFillColorR = textDefinition . _fontFillColor . r ; m_fontFillColorG = textDefinition . _fontFillColor . g ; m_fontFillColorB = textDefinition . _fontFillColor . b ; // ▁ check ▁ the ▁ cache ▁ for ▁ the ▁ font ▁ file ▁ buffer ENDCOM auto ittFontNames = s_fontsNames . find ( textDefinition . _fontName ) ; if ( ittFontNames != s_fontsNames . end ( ) ) { pBuffer = ittFontNames -> second . pBuffer ; size = ittFontNames -> second . size ; } if ( ! pBuffer ) { // ▁ attempt ▁ to ▁ load ▁ font ▁ from ▁ Resources ▁ fonts ▁ folder ENDCOM pBuffer = loadFont ( textDefinition . _fontName . c_str ( ) , & size ) ; if ( ! pBuffer ) { // ▁ attempt ▁ to ▁ load ▁ font ▁ from ▁ System ▁ fonts ▁ folder ENDCOM pBuffer = loadSystemFont ( textDefinition . _fontName . c_str ( ) , & size ) ; } if ( ! pBuffer ) { // ▁ attempt ▁ to ▁ load ▁ default ▁ font ▁ from ▁ Resources ▁ fonts ▁ folder ENDCOM pBuffer = loadFont ( " Arial " , & size ) ; } if ( ! pBuffer ) { // ▁ attempt ▁ to ▁ load ▁ default ▁ font ▁ from ▁ System ▁ fonts ▁ folder ENDCOM pBuffer = loadSystemFont ( " Arial " , & size ) ; } if ( ! pBuffer ) // ▁ font ▁ not ▁ found ! ENDCOM { return false ; } // ▁ cache ▁ the ▁ font ▁ file ▁ buffer ENDCOM FontBufferInfo info ; info . pBuffer = pBuffer ; info . size = size ; s_fontsNames [ textDefinition . _fontName ] = info ; } m_fontName = textDefinition . _fontName ; m_text = text ; if ( ! s_FreeTypeLibrary ) { error = FT_Init_FreeType ( & s_FreeTypeLibrary ) ; } if ( ! error && ! m_face ) { error = FT_New_Memory_Face ( s_FreeTypeLibrary , pBuffer , size , 0 , & m_face ) ; } if ( ! error ) { error = FT_Select_Charmap ( m_face , FT_ENCODING_UNICODE ) ; } if ( ! error ) { error = FT_Set_Char_Size ( m_face , textDefinition . _fontSize << 6 , textDefinition . _fontSize << 6 , 72 , 72 ) ; } if ( ! error ) { error = initGlyphs ( text ) ; } if ( ! error ) { data = getBitmap ( align , width , height , dataLength ) ; } delete [ ] pBuffer ; reset ( ) ; return data ; }
unsigned char * CCFreeTypeFont :: getBitmap ( Device :: TextAlign eAlignMask , int & width , int & height , ssize_t & dataLength ) { int lineNumber = 0 ; int totalLines = m_lines . size ( ) ; m_width = m_inWidth ? m_inWidth : m_textWidth ; m_height = m_inHeight ? m_inHeight : m_textHeight ; unsigned int size = m_width * m_height * 4 ; unsigned char * pBuffer = new unsigned char [ size ] ; dataLength = size ; if ( ! pBuffer ) { dataLength = 0 ; return nullptr ; } memset ( pBuffer , 0 , size ) ; for ( auto line = m_lines . begin ( ) ; line != m_lines . end ( ) ; ++ line ) { FT_Vector pen = getPenForAlignment ( * line , eAlignMask , lineNumber , totalLines ) ; drawText ( * line , pBuffer , & pen ) ; lineNumber ++ ; } width = m_width ; height = m_height ; return pBuffer ; }
FT_Vector CCFreeTypeFont :: getPenForAlignment ( FTLineInfo * pInfo , Device :: TextAlign eAlignMask , int lineNumber , int totalLines ) { FT_Error error = 0 ; FT_Vector pen ; int top ; int stringWidth = pInfo -> bbox . xMax - pInfo -> bbox . xMin ; int maxLineNumber = totalLines - 1 ; pen . x = 0 ; pen . y = 0 ; switch ( eAlignMask ) { case Device :: TextAlign :: TOP : // ▁ Horizontal ▁ center ▁ and ▁ vertical ▁ top . ENDCOM pen . x = ( ( m_width - stringWidth ) / 2 ) - pInfo -> bbox . xMin ; pen . y = pInfo -> bbox . yMax + ( lineNumber * m_lineHeight ) ; break ; case Device :: TextAlign :: TOP_LEFT : // ▁ Horizontal ▁ left ▁ and ▁ vertical ▁ top . ENDCOM pen . x -= pInfo -> bbox . xMin ; pen . y = pInfo -> bbox . yMax + ( lineNumber * m_lineHeight ) ; break ; case Device :: TextAlign :: TOP_RIGHT : // ▁ Horizontal ▁ right ▁ and ▁ vertical ▁ top . ENDCOM pen . x = m_width - stringWidth - pInfo -> bbox . xMin ; pen . y = pInfo -> bbox . yMax + ( lineNumber * m_lineHeight ) ; break ; case Device :: TextAlign :: BOTTOM_RIGHT : // ▁ Horizontal ▁ right ▁ and ▁ vertical ▁ bottom . ENDCOM pen . x = m_width - stringWidth - pInfo -> bbox . xMin ; pen . y = m_height + pInfo -> bbox . yMin - ( ( maxLineNumber - lineNumber ) * m_lineHeight ) ; break ; case Device :: TextAlign :: BOTTOM : // ▁ Horizontal ▁ center ▁ and ▁ vertical ▁ bottom . ENDCOM pen . x = ( ( m_width - stringWidth ) / 2 ) - pInfo -> bbox . xMin ; pen . y = m_height + pInfo -> bbox . yMin - ( ( maxLineNumber - lineNumber ) * m_lineHeight ) ; break ; case Device :: TextAlign :: BOTTOM_LEFT : // ▁ Horizontal ▁ left ▁ and ▁ vertical ▁ bottom . ENDCOM pen . x -= pInfo -> bbox . xMin ; top = ( m_height - m_textHeight ) / 2 ; pen . y = m_height + pInfo -> bbox . yMin - ( ( maxLineNumber - lineNumber ) * m_lineHeight ) ; break ; case Device :: TextAlign :: CENTER : // ▁ Horizontal ▁ center ▁ and ▁ vertical ▁ center ENDCOM pen . x = ( ( m_width - stringWidth ) / 2 ) - pInfo -> bbox . xMin ; top = ( m_height - m_textHeight ) / 2 ; pen . y = top + ( lineNumber * m_lineHeight ) + pInfo -> bbox . yMax ; break ; case Device :: TextAlign :: RIGHT : // ▁ Horizontal ▁ right ▁ and ▁ vertical ▁ center . ENDCOM pen . x = m_width - stringWidth - pInfo -> bbox . xMin ; top = ( m_height - m_textHeight ) / 2 ; pen . y = top + ( lineNumber * m_lineHeight ) + pInfo -> bbox . yMax ; break ; case Device :: TextAlign :: LEFT : // ▁ Horizontal ▁ left ▁ and ▁ vertical ▁ center . ENDCOM default : pen . x -= pInfo -> bbox . xMin ; top = ( m_height - m_textHeight ) / 2 ; pen . y = top + ( lineNumber * m_lineHeight ) + pInfo -> bbox . yMax ; break ; } return pen ; }
void CCFreeTypeFont :: drawText ( FTLineInfo * pInfo , unsigned char * pBuffer , FT_Vector * pen ) { auto glyphs = pInfo -> glyphs ; for ( auto glyph = glyphs . begin ( ) ; glyph != glyphs . end ( ) ; ++ glyph ) { FT_Glyph image = glyph -> image ; FT_Error error = FT_Glyph_To_Bitmap ( & image , FT_RENDER_MODE_NORMAL , 0 , 1 ) ; if ( ! error ) { FT_BitmapGlyph bit = ( FT_BitmapGlyph ) image ; draw_bitmap ( pBuffer , & bit -> bitmap , pen -> x + glyph -> pos . x + bit -> left , pen -> y - bit -> top ) ; FT_Done_Glyph ( image ) ; } } }
void CCFreeTypeFont :: draw_bitmap ( unsigned char * pBuffer , FT_Bitmap * bitmap , FT_Int x , FT_Int y ) { FT_Int i , j , p , q ; FT_Int x_max = x + bitmap -> width ; FT_Int y_max = y + bitmap -> rows ; for ( i = x , p = 0 ; i < x_max ; i ++ , p ++ ) { for ( j = y , q = 0 ; j < y_max ; j ++ , q ++ ) { if ( i < 0 || j < 0 || i >= m_width || j >= m_height ) continue ; unsigned char value = bitmap -> buffer [ q * bitmap -> width + p ] ; if ( value > 0 ) { FT_Int index = ( j * m_width * 4 ) + ( i * 4 ) ; pBuffer [ index ++ ] = m_fontFillColorR ; pBuffer [ index ++ ] = m_fontFillColorG ; pBuffer [ index ++ ] = m_fontFillColorB ; pBuffer [ index ++ ] = value ; } } } }
void CCFreeTypeFont :: endLine ( ) { if ( m_currentLine ) { m_lines . push_back ( m_currentLine ) ; m_textWidth = std :: max ( ( long ) m_textWidth , m_currentLine -> bbox . xMax - m_currentLine -> bbox . xMin ) ; m_textHeight += m_lineHeight ; } }
void CCFreeTypeFont :: newLine ( ) { m_currentLine = new FTLineInfo ( ) ; m_currentLine -> width = 0 ; m_currentLine -> pen . x = 0 ; m_currentLine -> pen . y = 0 ; }
FT_Error CCFreeTypeFont :: addWord ( const std :: string & word ) { std :: vector < TGlyph > glyphs ; // ▁ glyphs ▁ for ▁ the ▁ word ENDCOM FT_BBox bbox ; // ▁ bounding ▁ box ▁ containing ▁ all ▁ of ▁ the ▁ glyphs ▁ in ▁ the ▁ word ENDCOM int maxWidth = m_inWidth ? m_inWidth : m_windowWidth ; std :: string newWord ; if ( m_currentLine -> width > 0 ) { newWord = ' ▁ ' + word ; } else { newWord = word ; } FT_Error error = initWordGlyphs ( glyphs , newWord , m_currentLine -> pen ) ; if ( ! error ) { compute_bbox ( glyphs , & bbox ) ; if ( m_currentLine -> width == 0 || bbox . xMax <= maxWidth ) { m_currentLine -> glyphs . insert ( m_currentLine -> glyphs . end ( ) , glyphs . begin ( ) , glyphs . end ( ) ) ; if ( m_currentLine -> width == 0 ) { m_currentLine -> bbox = bbox ; } else { m_currentLine -> bbox . xMax = bbox . xMax ; } m_currentLine -> width = m_currentLine -> bbox . xMax - m_currentLine -> bbox . xMin ; } else { endLine ( ) ; newLine ( ) ; addWord ( word ) ; } } return error ; }
FT_Error CCFreeTypeFont :: initGlyphs ( const char * text ) { FT_Error error = 0 ; std :: stringstream stringStream ( text ) ; std :: string line ; vector < std :: string > lines ; vector < std :: string > words ; m_textWidth = 0 ; m_textHeight = 0 ; // ▁ the ▁ height ▁ of ▁ a ▁ line ▁ of ▁ text ▁ based ▁ on ▁ the ▁ max ▁ height ▁ of ▁ a ▁ glyph ▁ in ▁ the ▁ font ▁ size ENDCOM m_lineHeight = ( ( m_face -> size -> metrics . ascender ) >> 6 ) - ( ( m_face -> size -> metrics . descender ) >> 6 ) ; m_lines . clear ( ) ; while ( std :: getline ( stringStream , line ) && ! error ) { newLine ( ) ; std :: size_t prev = 0 , pos ; while ( ( pos = line . find_first_of ( " ▁ " , prev ) ) != std :: string :: npos ) { if ( pos > prev ) { addWord ( line . substr ( prev , pos - prev ) ) ; } prev = pos + 1 ; } if ( prev < line . length ( ) ) { addWord ( line . substr ( prev , std :: string :: npos ) ) ; } endLine ( ) ; } return error ; }
// ▁ if ▁ linewidth ▁ > ▁ m _ inWidth ENDCOM // ▁ get ▁ words ▁ for ▁ line ENDCOM void CCFreeTypeFont :: initWords ( const char * text ) { std :: stringstream stringStream ( text ) ; std :: string line ; vector < std :: string > lines ; vector < std :: string > words ; while ( std :: getline ( stringStream , line ) ) { lines . push_back ( line ) ; } for ( auto it = lines . begin ( ) ; it != lines . end ( ) ; ++ it ) { std :: size_t prev = 0 , pos ; while ( ( pos = it -> find_first_of ( " ▁ ' ; " , prev ) ) != std :: string :: npos ) { if ( pos > prev ) words . push_back ( it -> substr ( prev , pos - prev ) ) ; prev = pos + 1 ; } if ( prev < it -> length ( ) ) words . push_back ( it -> substr ( prev , std :: string :: npos ) ) ; } for ( auto it = words . begin ( ) ; it != words . end ( ) ; ++ it ) { std :: string foo ( * it ) ; } }
FT_Error CCFreeTypeFont :: initWordGlyphs ( std :: vector < TGlyph > & glyphs , const std :: string & text , FT_Vector & pen ) { FT_GlyphSlot slot = m_face -> glyph ; FT_UInt glyph_index ; FT_UInt previous = 0 ; FT_Error error = 0 ; PGlyph glyph ; unsigned int numGlyphs = 0 ; wchar_t * pwszBuffer = nullptr ; int num_chars = text . size ( ) ; int nBufLen = num_chars + 1 ; pwszBuffer = new wchar_t [ nBufLen ] ; if ( ! pwszBuffer ) { return - 1 ; } memset ( pwszBuffer , 0 , nBufLen ) ; num_chars = MultiByteToWideChar ( CP_UTF8 , 0 , text . c_str ( ) , num_chars , pwszBuffer , nBufLen ) ; pwszBuffer [ num_chars ] = ' \0' ; glyphs . clear ( ) ; glyphs . resize ( num_chars ) ; FT_Bool useKerning = FT_HAS_KERNING ( m_face ) ; for ( int n = 0 ; n < num_chars ; n ++ ) { glyph = & glyphs [ numGlyphs ] ; /* ▁ convert ▁ character ▁ code ▁ to ▁ glyph ▁ index ▁ */ ENDCOM FT_ULong c = pwszBuffer [ n ] ; glyph_index = FT_Get_Char_Index ( m_face , c ) ; if ( useKerning && previous && glyph_index ) { FT_Vector delta ; FT_Get_Kerning ( m_face , previous , glyph_index , FT_KERNING_DEFAULT , & delta ) ; pen . x += delta . x >> 6 ; } /* ▁ store ▁ current ▁ pen ▁ position ▁ */ ENDCOM glyph -> pos = pen ; glyph -> index = glyph_index ; /* ▁ load ▁ glyph ▁ image ▁ into ▁ the ▁ slot ▁ without ▁ rendering ▁ */ ENDCOM error = FT_Load_Glyph ( m_face , glyph_index , FT_LOAD_DEFAULT ) ; if ( error ) continue ; /* ▁ ignore ▁ errors , ▁ jump ▁ to ▁ next ▁ glyph ▁ */ ENDCOM /* ▁ extract ▁ glyph ▁ image ▁ and ▁ store ▁ it ▁ in ▁ our ▁ table ▁ */ ENDCOM error = FT_Get_Glyph ( m_face -> glyph , & glyph -> image ) ; if ( error ) continue ; /* ▁ ignore ▁ errors , ▁ jump ▁ to ▁ next ▁ glyph ▁ */ ENDCOM /* ▁ translate ▁ the ▁ glyph ▁ image ▁ now ▁ */ ENDCOM FT_Glyph_Transform ( glyph -> image , 0 , & glyph -> pos ) ; /* ▁ increment ▁ pen ▁ position ▁ */ ENDCOM pen . x += slot -> advance . x >> 6 ; /* ▁ record ▁ current ▁ glyph ▁ index ▁ */ ENDCOM previous = glyph_index ; numGlyphs ++ ; } CC_SAFE_DELETE_ARRAY ( pwszBuffer ) ; return error ; }
void CCFreeTypeFont :: compute_bbox ( std :: vector < TGlyph > & glyphs , FT_BBox * abbox ) { FT_BBox bbox ; FT_BBox glyph_bbox ; /* ▁ initialize ▁ string ▁ bbox ▁ to ▁ " empty " ▁ values ▁ */ ENDCOM bbox . xMin = 32000 ; bbox . xMax = - 32000 ; // ▁ use ▁ the ▁ max ▁ and ▁ min ▁ values ▁ for ▁ the ▁ entire ▁ font ▁ face ENDCOM bbox . yMin = ( m_face -> size -> metrics . descender ) >> 6 ; bbox . yMax = ( m_face -> size -> metrics . ascender ) >> 6 ; /* ▁ for ▁ each ▁ glyph ▁ image , ▁ compute ▁ its ▁ bounding ▁ box , ▁ */ ENDCOM /* ▁ translate ▁ it , ▁ and ▁ grow ▁ the ▁ string ▁ bbox ▁ */ ENDCOM for ( auto glyph = glyphs . begin ( ) ; glyph != glyphs . end ( ) ; ++ glyph ) { FT_Glyph_Get_CBox ( glyph -> image , ft_glyph_bbox_pixels , & glyph_bbox ) ; glyph_bbox . xMin += glyph -> pos . x ; glyph_bbox . xMax += glyph -> pos . x ; glyph_bbox . yMin += glyph -> pos . y ; glyph_bbox . yMax += glyph -> pos . y ; if ( glyph_bbox . xMin < bbox . xMin ) bbox . xMin = glyph_bbox . xMin ; if ( glyph_bbox . yMin < bbox . yMin ) bbox . yMin = glyph_bbox . yMin ; if ( glyph_bbox . xMax > bbox . xMax ) bbox . xMax = glyph_bbox . xMax ; if ( glyph_bbox . yMax > bbox . yMax ) bbox . yMax = glyph_bbox . yMax ; } /* ▁ check ▁ that ▁ we ▁ really ▁ grew ▁ the ▁ string ▁ bbox ▁ */ ENDCOM if ( bbox . xMin > bbox . xMax ) { bbox . xMin = 0 ; bbox . yMin = 0 ; bbox . xMax = 0 ; bbox . yMax = 0 ; } /* ▁ return ▁ string ▁ bbox ▁ */ ENDCOM * abbox = bbox ; }
unsigned char * CCFreeTypeFont :: loadFont ( const char * pFontName , ssize_t * size ) { std :: string lowerCase ( pFontName ) ; std :: string path ( pFontName ) ; for ( unsigned int i = 0 ; i < lowerCase . length ( ) ; ++ i ) { lowerCase [ i ] = tolower ( lowerCase [ i ] ) ; } if ( std :: string :: npos == lowerCase . find ( " fonts / " ) ) { path = " fonts / " ; path += pFontName ; } if ( std :: string :: npos == lowerCase . find ( " . ttf " ) ) { path += " . ttf " ; } std :: string fullpath = FileUtils :: getInstance ( ) -> fullPathForFilename ( path . c_str ( ) ) ; return FileUtils :: sharedFileUtils ( ) -> getFileData ( fullpath . c_str ( ) , " rb " , size ) ; }
unsigned char * CCFreeTypeFont :: loadSystemFont ( const char * pFontName , ssize_t * size ) { CC_TARGET_PLATFORM == CC_PLATFORM_WP8 ) return nullptr ; std :: string aName ( pFontName ) ; unsigned char * pBuffer = nullptr ; HRESULT hr = S_OK ; IDWriteFactory * writeFactory = nullptr ; IDWriteFontCollection * fontCollection = nullptr ; IDWriteFontFamily * fontFamily = nullptr ; IDWriteFont * matchingFont = nullptr ; IDWriteFontFace * fontFace = nullptr ; IDWriteFontFile * fontFile = nullptr ; IDWriteFontFileLoader * fontFileLoader = nullptr ; IDWriteFontFileStream * fontFileStream = nullptr ; UINT32 index ; BOOL exists ; std :: wstring fontNameW ; const void * fontFileReferenceKey = nullptr ; UINT32 fontFileReferenceKeySize ; void * fragmentContext = nullptr ; for ( unsigned int i = 0 ; i < aName . length ( ) ; ++ i ) { aName [ i ] = tolower ( aName [ i ] ) ; } fontNameW . assign ( aName . begin ( ) , aName . end ( ) ) ; // create ▁ the ▁ factory ENDCOM hr = DWriteCreateFactory ( DWRITE_FACTORY_TYPE_SHARED , __uuidof ( IDWriteFactory ) , reinterpret_cast < IUnknown * * > ( & writeFactory ) ) ; if ( SUCCEEDED ( hr ) ) { // obtain ▁ the ▁ fonts ▁ owned ▁ by ▁ the ▁ machine ENDCOM hr = writeFactory -> GetSystemFontCollection ( & fontCollection , TRUE ) ; } // get ▁ the ▁ font ▁ ENDCOM if ( SUCCEEDED ( hr ) ) { hr = fontCollection -> FindFamilyName ( fontNameW . c_str ( ) , & index , & exists ) ; if ( SUCCEEDED ( hr ) && exists ) { hr = fontCollection -> GetFontFamily ( index , & fontFamily ) ; if ( SUCCEEDED ( hr ) ) { hr = fontFamily -> GetFirstMatchingFont ( DWRITE_FONT_WEIGHT_REGULAR , DWRITE_FONT_STRETCH_NORMAL , DWRITE_FONT_STYLE_NORMAL , & matchingFont ) ; } if ( SUCCEEDED ( hr ) ) { hr = matchingFont -> CreateFontFace ( & fontFace ) ; } if ( SUCCEEDED ( hr ) ) { UINT32 numberOfFiles = 1 ; hr = fontFace -> GetFiles ( & numberOfFiles , & fontFile ) ; } if ( SUCCEEDED ( hr ) ) { // create ▁ the ▁ font ▁ file ▁ stream ENDCOM hr = fontFile -> GetReferenceKey ( & fontFileReferenceKey , & fontFileReferenceKeySize ) ; } if ( SUCCEEDED ( hr ) ) { hr = fontFile -> GetLoader ( & fontFileLoader ) ; } if ( SUCCEEDED ( hr ) ) { hr = fontFileLoader -> CreateStreamFromKey ( fontFileReferenceKey , fontFileReferenceKeySize , & fontFileStream ) ; } if ( SUCCEEDED ( hr ) ) { // finally ▁ get ▁ the ▁ font ▁ file ▁ dat ENDCOM UINT64 fileSize ; const void * fragmentStart = nullptr ; hr = fontFileStream -> GetFileSize ( & fileSize ) ; if ( SUCCEEDED ( hr ) ) { hr = fontFileStream -> ReadFileFragment ( & fragmentStart , 0 , fileSize , & fragmentContext ) ; } if ( SUCCEEDED ( hr ) ) { pBuffer = ( unsigned char * ) malloc ( ( size_t ) fileSize ) ; memcpy ( pBuffer , fragmentStart , ( size_t ) fileSize ) ; * size = ( unsigned long ) fileSize ; } } } } // clean ▁ up ▁ all ▁ the ▁ DWrite ▁ stuff ENDCOM if ( fontFileStream ) { fontFileStream -> ReleaseFileFragment ( fragmentContext ) ; fontFileStream -> Release ( ) ; } if ( fontFileLoader ) { fontFileLoader -> Release ( ) ; } if ( fontFile ) { fontFile -> Release ( ) ; } if ( fontFace ) { fontFace -> Release ( ) ; } if ( matchingFont ) { matchingFont -> Release ( ) ; } if ( fontFamily ) { fontFamily -> Release ( ) ; } if ( fontCollection ) { fontCollection -> Release ( ) ; } if ( writeFactory ) { writeFactory -> Release ( ) ; } return pBuffer ; }
