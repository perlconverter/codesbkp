public ItemReed ( int i , Block block ) { super ( i ) ; this . id = block . id ; }
public boolean a ( ItemStack itemstack , EntityHuman entityhuman , World world , int i , int j , int k , int l ) { int clickedX = i , clickedY = j , clickedZ = k ; // ▁ CraftBukkit ENDCOM if ( world . getTypeId ( i , j , k ) == Block . SNOW . id ) { l = 0 ; } else { if ( l == 0 ) { -- j ; } if ( l == 1 ) { ++ j ; } if ( l == 2 ) { -- k ; } if ( l == 3 ) { ++ k ; } if ( l == 4 ) { -- i ; } if ( l == 5 ) { ++ i ; } } if ( itemstack . count == 0 ) { return false ; } else { if ( world . a ( this . id , i , j , k , false ) ) { Block block = Block . byId [ this . id ] ; // ▁ CraftBukkit ▁ start ▁ - ▁ This ▁ executes ▁ the ▁ placement ▁ of ▁ the ▁ block ENDCOM BlockState replacedBlockState = CraftBlockState . getBlockState ( world , i , j , k ) ; // ▁ CraftBukkit ENDCOM /* * STRNEWLINE ▁ * ▁ @ see ▁ net . minecraft . server . World # setTypeId ( int ▁ i , ▁ int ▁ j , ▁ int ▁ k , ▁ int ▁ l ) STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ This ▁ replaces ▁ world . setTypeId ( IIII ) , ▁ we ' re ▁ doing ▁ this ▁ because ▁ we ▁ need ▁ to STRNEWLINE ▁ * ▁ hook ▁ between ▁ the ▁ ' placement ' ▁ and ▁ the ▁ informing ▁ to ▁ ' world ' ▁ so ▁ we ▁ can STRNEWLINE ▁ * ▁ sanely ▁ undo ▁ this . STRNEWLINE ▁ * STRNEWLINE ▁ * ▁ Whenever ▁ the ▁ call ▁ to ▁ ' world . setTypeId ' ▁ changes ▁ we ▁ need ▁ to ▁ figure ▁ out ▁ again ▁ what ▁ to STRNEWLINE ▁ * ▁ replace ▁ this ▁ with . STRNEWLINE ▁ */ if ( world . setRawTypeId ( i , j , k , this . id ) ) { // ▁ < - - ▁ world . e ▁ does ▁ this ▁ to ▁ place ▁ the ▁ block ENDCOM BlockPlaceEvent event = CraftEventFactory . callBlockPlaceEvent ( world , entityhuman , replacedBlockState , clickedX , clickedY , clickedZ , block ) ; if ( event . isCancelled ( ) || ! event . canBuild ( ) ) { // ▁ CraftBukkit ▁ - ▁ undo ; ▁ this ▁ only ▁ has ▁ reed , ▁ repeater ▁ and ▁ pie ▁ blocks ENDCOM world . setTypeIdAndData ( i , j , k , replacedBlockState . getTypeId ( ) , replacedBlockState . getRawData ( ) ) ; } else { world . update ( i , j , k , this . id ) ; // ▁ < - - ▁ world . setTypeId ▁ does ▁ this ▁ on ▁ success ▁ ( tell ▁ the ▁ world ) ENDCOM Block . byId [ this . id ] . postPlace ( world , i , j , k , l ) ; Block . byId [ this . id ] . postPlace ( world , i , j , k , entityhuman ) ; world . makeSound ( ( double ) ( ( float ) i + 0.5F ) , ( double ) ( ( float ) j + 0.5F ) , ( double ) ( ( float ) k + 0.5F ) , block . stepSound . getName ( ) , ( block . stepSound . getVolume1 ( ) + 1.0F ) / 2.0F , block . stepSound . getVolume2 ( ) * 0.8F ) ; -- itemstack . count ; } // ▁ CraftBukkit ▁ end ENDCOM } } return true ; } }
for ( DateFormat format : DATE_FORMATS ) { format . setLenient ( false ) ; }
// ▁ positions , ▁ based ▁ on ▁ which ▁ fields ▁ are ▁ present ▁ in ▁ this ▁ barcode . ENDCOM private int mapIndexToAction ( int index ) { if ( index < buttonCount ) { int count = - 1 ; for ( int x = 0 ; x < MAX_BUTTON_COUNT ; x ++ ) { if ( fields [ x ] ) { count ++ ; } if ( count == index ) { return x ; } } } return - 1 ; }
public AddressBookResultHandler ( Activity activity , ParsedResult result ) { super ( activity , result ) ; AddressBookParsedResult addressResult = ( AddressBookParsedResult ) result ; String [ ] addresses = addressResult . getAddresses ( ) ; boolean hasAddress = addresses != null && addresses . length > 0 && addresses [ 0 ] != null && ! addresses [ 0 ] . isEmpty ( ) ; String [ ] phoneNumbers = addressResult . getPhoneNumbers ( ) ; boolean hasPhoneNumber = phoneNumbers != null && phoneNumbers . length > 0 ; String [ ] emails = addressResult . getEmails ( ) ; boolean hasEmailAddress = emails != null && emails . length > 0 ; fields = new boolean [ MAX_BUTTON_COUNT ] ; fields [ 0 ] = true ; // ▁ Add ▁ contact ▁ is ▁ always ▁ available ENDCOM fields [ 1 ] = hasAddress ; fields [ 2 ] = hasPhoneNumber ; fields [ 3 ] = hasEmailAddress ; buttonCount = 0 ; for ( int x = 0 ; x < MAX_BUTTON_COUNT ; x ++ ) { if ( fields [ x ] ) { buttonCount ++ ; } } }
public int getButtonCount ( ) { return buttonCount ; }
public int getButtonText ( int index ) { return BUTTON_TEXTS [ mapIndexToAction ( index ) ] ; }
public void handleButtonPress ( int index ) { AddressBookParsedResult addressResult = ( AddressBookParsedResult ) getResult ( ) ; String [ ] addresses = addressResult . getAddresses ( ) ; String address1 = addresses == null || addresses . length < 1 ? null : addresses [ 0 ] ; String [ ] addressTypes = addressResult . getAddressTypes ( ) ; String address1Type = addressTypes == null || addressTypes . length < 1 ? null : addressTypes [ 0 ] ; int action = mapIndexToAction ( index ) ; switch ( action ) { case 0 : addContact ( addressResult . getNames ( ) , addressResult . getNicknames ( ) , addressResult . getPronunciation ( ) , addressResult . getPhoneNumbers ( ) , addressResult . getPhoneTypes ( ) , addressResult . getEmails ( ) , addressResult . getEmailTypes ( ) , addressResult . getNote ( ) , addressResult . getInstantMessenger ( ) , address1 , address1Type , addressResult . getOrg ( ) , addressResult . getTitle ( ) , addressResult . getURLs ( ) , addressResult . getBirthday ( ) , addressResult . getGeo ( ) ) ; break ; case 1 : searchMap ( address1 ) ; break ; case 2 : dialPhone ( addressResult . getPhoneNumbers ( ) [ 0 ] ) ; break ; case 3 : sendEmail ( addressResult . getEmails ( ) , null , null , null , null ) ; break ; default : break ; } }
// ▁ Overriden ▁ so ▁ we ▁ can ▁ hyphenate ▁ phone ▁ numbers , ▁ format ▁ birthdays , ▁ and ▁ bold ▁ the ▁ name . ENDCOM @ Override public CharSequence getDisplayContents ( ) { AddressBookParsedResult result = ( AddressBookParsedResult ) getResult ( ) ; StringBuilder contents = new StringBuilder ( 100 ) ; ParsedResult . maybeAppend ( result . getNames ( ) , contents ) ; int namesLength = contents . length ( ) ; String pronunciation = result . getPronunciation ( ) ; if ( pronunciation != null && ! pronunciation . isEmpty ( ) ) { contents . append ( " \n ( " ) ; contents . append ( pronunciation ) ; contents . append ( ' ) ' ) ; } ParsedResult . maybeAppend ( result . getTitle ( ) , contents ) ; ParsedResult . maybeAppend ( result . getOrg ( ) , contents ) ; ParsedResult . maybeAppend ( result . getAddresses ( ) , contents ) ; String [ ] numbers = result . getPhoneNumbers ( ) ; if ( numbers != null ) { for ( String number : numbers ) { if ( number != null ) { ParsedResult . maybeAppend ( PhoneNumberUtils . formatNumber ( number ) , contents ) ; } } } ParsedResult . maybeAppend ( result . getEmails ( ) , contents ) ; ParsedResult . maybeAppend ( result . getURLs ( ) , contents ) ; String birthday = result . getBirthday ( ) ; if ( birthday != null && ! birthday . isEmpty ( ) ) { Date date = parseDate ( birthday ) ; if ( date != null ) { ParsedResult . maybeAppend ( DateFormat . getDateInstance ( DateFormat . MEDIUM ) . format ( date . getTime ( ) ) , contents ) ; } } ParsedResult . maybeAppend ( result . getNote ( ) , contents ) ; if ( namesLength > 0 ) { // ▁ Bold ▁ the ▁ full ▁ name ▁ to ▁ make ▁ it ▁ stand ▁ out ▁ a ▁ bit . ENDCOM Spannable styled = new SpannableString ( contents . toString ( ) ) ; styled . setSpan ( new StyleSpan ( android . graphics . Typeface . BOLD ) , 0 , namesLength , 0 ) ; return styled ; } else { return contents . toString ( ) ; } }
public int getDisplayTitle ( ) { return R . string . result_address_book ; }
public ReactModalHostView ( Context context ) { super ( context ) ; ( ( ReactContext ) context ) . addLifecycleEventListener ( this ) ; mHostView = new DialogRootViewGroup ( context ) ; }
protected void onLayout ( boolean changed , int l , int t , int r , int b ) { // ▁ Do ▁ nothing ▁ as ▁ we ▁ are ▁ laid ▁ out ▁ by ▁ UIManager ENDCOM }
public void addView ( View child , int index ) { mHostView . addView ( child , index ) ; }
public int getChildCount ( ) { return mHostView . getChildCount ( ) ; }
public View getChildAt ( int index ) { return mHostView . getChildAt ( index ) ; }
public void removeView ( View child ) { mHostView . removeView ( child ) ; }
public void removeViewAt ( int index ) { View child = getChildAt ( index ) ; mHostView . removeView ( child ) ; }
public void addChildrenForAccessibility ( ArrayList < View > outChildren ) { // ▁ Explicitly ▁ override ▁ this ▁ to ▁ prevent ▁ accessibility ▁ events ▁ being ▁ passed ▁ down ▁ to ▁ children ENDCOM // ▁ Those ▁ will ▁ be ▁ handled ▁ by ▁ the ▁ mHostView ▁ which ▁ lives ▁ in ▁ the ▁ dialog ENDCOM }
public boolean dispatchPopulateAccessibilityEvent ( AccessibilityEvent event ) { // ▁ Explicitly ▁ override ▁ this ▁ to ▁ prevent ▁ accessibility ▁ events ▁ being ▁ passed ▁ down ▁ to ▁ children ENDCOM // ▁ Those ▁ will ▁ be ▁ handled ▁ by ▁ the ▁ mHostView ▁ which ▁ lives ▁ in ▁ the ▁ dialog ENDCOM return false ; }
public void onDropInstance ( ) { ( ( ReactContext ) getContext ( ) ) . removeLifecycleEventListener ( this ) ; dismiss ( ) ; }
private void dismiss ( ) { if ( mDialog != null ) { mDialog . dismiss ( ) ; mDialog = null ; // ▁ We ▁ need ▁ to ▁ remove ▁ the ▁ mHostView ▁ from ▁ the ▁ parent ENDCOM // ▁ It ▁ is ▁ possible ▁ we ▁ are ▁ dismissing ▁ this ▁ dialog ▁ and ▁ reattaching ▁ the ▁ hostView ▁ to ▁ another ENDCOM ViewGroup parent = ( ViewGroup ) mHostView . getParent ( ) ; parent . removeViewAt ( 0 ) ; } }
protected void setOnRequestCloseListener ( OnRequestCloseListener listener ) { mOnRequestCloseListener = listener ; }
protected void setOnShowListener ( DialogInterface . OnShowListener listener ) { mOnShowListener = listener ; }
protected void setTransparent ( boolean transparent ) { mTransparent = transparent ; }
protected void setAnimationType ( String animationType ) { mAnimationType = animationType ; mPropertyRequiresNewDialog = true ; }
public void onHostResume ( ) { // ▁ We ▁ show ▁ the ▁ dialog ▁ again ▁ when ▁ the ▁ host ▁ resumes ENDCOM showOrUpdate ( ) ; }
public void onHostPause ( ) { // ▁ We ▁ dismiss ▁ the ▁ dialog ▁ and ▁ reconstitute ▁ it ▁ onHostResume ENDCOM dismiss ( ) ; }
public void onHostDestroy ( ) { // ▁ Drop ▁ the ▁ instance ▁ if ▁ the ▁ host ▁ is ▁ destroyed ▁ which ▁ will ▁ dismiss ▁ the ▁ dialog ENDCOM onDropInstance ( ) ; }
@ VisibleForTesting public @ Nullable Dialog getDialog ( ) { return mDialog ; }
/* * STRNEWLINE ▁ * ▁ showOrUpdate ▁ will ▁ display ▁ the ▁ Dialog . ▁ It ▁ is ▁ called ▁ by ▁ the ▁ manager ▁ once ▁ all ▁ properties ▁ are ▁ set STRNEWLINE ▁ * ▁ because ▁ we ▁ need ▁ to ▁ know ▁ all ▁ of ▁ them ▁ before ▁ creating ▁ the ▁ Dialog . ▁ It ▁ is ▁ also ▁ smart ▁ during STRNEWLINE ▁ * ▁ updates ▁ if ▁ the ▁ changed ▁ properties ▁ can ▁ be ▁ applied ▁ directly ▁ to ▁ the ▁ Dialog ▁ or ▁ require ▁ the STRNEWLINE ▁ * ▁ recreation ▁ of ▁ a ▁ new ▁ Dialog . STRNEWLINE ▁ */ protected void showOrUpdate ( ) { // ▁ If ▁ the ▁ existing ▁ Dialog ▁ is ▁ currently ▁ up , ▁ we ▁ may ▁ need ▁ to ▁ redraw ▁ it ▁ or ▁ we ▁ may ▁ be ▁ able ▁ to ▁ update ENDCOM // ▁ the ▁ property ▁ without ▁ having ▁ to ▁ recreate ▁ the ▁ dialog ENDCOM if ( mDialog != null ) { if ( mPropertyRequiresNewDialog ) { dismiss ( ) ; } else { updateProperties ( ) ; return ; } } // ▁ Reset ▁ the ▁ flag ▁ since ▁ we ▁ are ▁ going ▁ to ▁ create ▁ a ▁ new ▁ dialog ENDCOM mPropertyRequiresNewDialog = false ; int theme = R . style . Theme_FullScreenDialog ; if ( mAnimationType . equals ( " fade " ) ) { theme = R . style . Theme_FullScreenDialogAnimatedFade ; } else if ( mAnimationType . equals ( " slide " ) ) { theme = R . style . Theme_FullScreenDialogAnimatedSlide ; } mDialog = new Dialog ( getContext ( ) , theme ) ; mDialog . setContentView ( getContentView ( ) ) ; updateProperties ( ) ; mDialog . setOnShowListener ( mOnShowListener ) ; mDialog . setOnKeyListener ( new DialogInterface . OnKeyListener ( ) { @ Override public boolean onKey ( DialogInterface dialog , int keyCode , KeyEvent event ) { if ( event . getAction ( ) == KeyEvent . ACTION_UP ) { // ▁ We ▁ need ▁ to ▁ stop ▁ the ▁ BACK ▁ button ▁ from ▁ closing ▁ the ▁ dialog ▁ by ▁ default ▁ so ▁ we ▁ capture ▁ that ENDCOM // ▁ event ▁ and ▁ instead ▁ inform ▁ JS ▁ so ▁ that ▁ it ▁ can ▁ make ▁ the ▁ decision ▁ as ▁ to ▁ whether ▁ or ▁ not ▁ to ENDCOM // ▁ allow ▁ the ▁ back ▁ button ▁ to ▁ close ▁ the ▁ dialog . ▁ If ▁ it ▁ chooses ▁ to , ▁ it ▁ can ▁ just ▁ set ▁ visible ENDCOM // ▁ to ▁ false ▁ on ▁ the ▁ Modal ▁ and ▁ the ▁ Modal ▁ will ▁ go ▁ away ENDCOM if ( keyCode == KeyEvent . KEYCODE_BACK ) { Assertions . assertNotNull ( mOnRequestCloseListener , " setOnRequestCloseListener ▁ must ▁ be ▁ called ▁ by ▁ the ▁ manager " ) ; mOnRequestCloseListener . onRequestClose ( dialog ) ; return true ; } else { // ▁ We ▁ redirect ▁ the ▁ rest ▁ of ▁ the ▁ key ▁ events ▁ to ▁ the ▁ current ▁ activity , ▁ since ▁ the ▁ activity ENDCOM // ▁ expects ▁ to ▁ receive ▁ those ▁ events ▁ and ▁ react ▁ to ▁ them , ▁ ie . ▁ in ▁ the ▁ case ▁ of ▁ the ▁ dev ▁ menu ENDCOM Activity currentActivity = ( ( ReactContext ) getContext ( ) ) . getCurrentActivity ( ) ; if ( currentActivity != null ) { return currentActivity . onKeyUp ( keyCode , event ) ; } } } return false ; } } ) ; mDialog . getWindow ( ) . setSoftInputMode ( WindowManager . LayoutParams . SOFT_INPUT_ADJUST_RESIZE ) ; mDialog . show ( ) ; }
/* * STRNEWLINE ▁ * ▁ Returns ▁ the ▁ view ▁ that ▁ will ▁ be ▁ the ▁ root ▁ view ▁ of ▁ the ▁ dialog . ▁ We ▁ are ▁ wrapping ▁ this ▁ in ▁ a STRNEWLINE ▁ * ▁ FrameLayout ▁ because ▁ this ▁ is ▁ the ▁ system ' s ▁ way ▁ of ▁ notifying ▁ us ▁ that ▁ the ▁ dialog ▁ size ▁ has ▁ changed . STRNEWLINE ▁ * ▁ This ▁ has ▁ the ▁ pleasant ▁ side - effect ▁ of ▁ us ▁ not ▁ having ▁ to ▁ preface ▁ all ▁ Modals ▁ with STRNEWLINE ▁ * ▁ " top : ▁ statusBarHeight " , ▁ since ▁ that ▁ margin ▁ will ▁ be ▁ included ▁ in ▁ the ▁ FrameLayout . STRNEWLINE ▁ */ private View getContentView ( ) { FrameLayout frameLayout = new FrameLayout ( getContext ( ) ) ; frameLayout . addView ( mHostView ) ; frameLayout . setFitsSystemWindows ( true ) ; return frameLayout ; }
/* * STRNEWLINE ▁ * ▁ updateProperties ▁ will ▁ update ▁ the ▁ properties ▁ that ▁ do ▁ not ▁ require ▁ us ▁ to ▁ recreate ▁ the ▁ dialog STRNEWLINE ▁ * ▁ Properties ▁ that ▁ do ▁ require ▁ us ▁ to ▁ recreate ▁ the ▁ dialog ▁ should ▁ set ▁ mPropertyRequiresNewDialog ▁ to STRNEWLINE ▁ * ▁ true ▁ when ▁ the ▁ property ▁ changes STRNEWLINE ▁ */ private void updateProperties ( ) { Assertions . assertNotNull ( mDialog , " mDialog ▁ must ▁ exist ▁ when ▁ we ▁ call ▁ updateProperties " ) ; if ( mTransparent ) { mDialog . getWindow ( ) . clearFlags ( WindowManager . LayoutParams . FLAG_DIM_BEHIND ) ; } else { mDialog . getWindow ( ) . setDimAmount ( 0.5f ) ; mDialog . getWindow ( ) . setFlags ( WindowManager . LayoutParams . FLAG_DIM_BEHIND , WindowManager . LayoutParams . FLAG_DIM_BEHIND ) ; } }
public DialogRootViewGroup ( Context context ) { super ( context ) ; }
protected void onSizeChanged ( final int w , final int h , int oldw , int oldh ) { super . onSizeChanged ( w , h , oldw , oldh ) ; if ( getChildCount ( ) > 0 ) { ( ( ReactContext ) getContext ( ) ) . runOnNativeModulesQueueThread ( new Runnable ( ) { @ Override public void run ( ) { ( ( ReactContext ) getContext ( ) ) . getNativeModule ( UIManagerModule . class ) . updateNodeSize ( getChildAt ( 0 ) . getId ( ) , w , h ) ; } } ) ; } }
public boolean onInterceptTouchEvent ( MotionEvent event ) { mJSTouchDispatcher . handleTouchEvent ( event , getEventDispatcher ( ) ) ; return super . onInterceptTouchEvent ( event ) ; }
public boolean onTouchEvent ( MotionEvent event ) { mJSTouchDispatcher . handleTouchEvent ( event , getEventDispatcher ( ) ) ; super . onTouchEvent ( event ) ; // ▁ In ▁ case ▁ when ▁ there ▁ is ▁ no ▁ children ▁ interested ▁ in ▁ handling ▁ touch ▁ event , ▁ we ▁ return ▁ true ▁ from ENDCOM // ▁ the ▁ root ▁ view ▁ in ▁ order ▁ to ▁ receive ▁ subsequent ▁ events ▁ related ▁ to ▁ that ▁ gesture ENDCOM return true ; }
public void onChildStartedNativeGesture ( MotionEvent androidEvent ) { mJSTouchDispatcher . onChildStartedNativeGesture ( androidEvent , getEventDispatcher ( ) ) ; }
public void requestDisallowInterceptTouchEvent ( boolean disallowIntercept ) { // ▁ No - op ▁ - ▁ override ▁ in ▁ order ▁ to ▁ still ▁ receive ▁ events ▁ to ▁ onInterceptTouchEvent ENDCOM // ▁ even ▁ when ▁ some ▁ other ▁ view ▁ disallow ▁ that ENDCOM }
private EventDispatcher getEventDispatcher ( ) { ReactContext reactContext = ( ReactContext ) getContext ( ) ; return reactContext . getNativeModule ( UIManagerModule . class ) . getEventDispatcher ( ) ; }
@ Before public void setup ( ) { creator = new SjukfallIntygEnhetCreator ( ) ; parameters = new IntygParametrar ( 5 , LocalDate . parse ( "2016-02-16" ) ) ; }
@ Test public void testCreatingMap ( ) { Map < String , List < SjukfallIntyg > > map = creator . createMap ( intygDataList , parameters ) ; assertTrue ( " Expected ▁ 7 ▁ but ▁ was ▁ " + map . size ( ) , map . size ( ) == 7 ) ; }
@ Test public void testReducedMap ( ) { Map < String , List < SjukfallIntyg > > map = creator . createMap ( intygDataList , parameters ) ; Map < String , List < SjukfallIntyg > > reducedMap = creator . reduceMap ( map ) ; // ▁ Map ▁ should ▁ be ▁ reduced ▁ with ▁ one ▁ entry ENDCOM assertTrue ( " Expected ▁ 6 ▁ but ▁ was ▁ " + reducedMap . size ( ) , reducedMap . size ( ) == 6 ) ; }
@ Test public void testSortedMap ( ) { Map < String , List < SjukfallIntyg > > map = creator . createMap ( intygDataList , parameters ) ; Map < String , List < SjukfallIntyg > > sortedMap = creator . sortValues ( map ) ; for ( Map . Entry < String , List < SjukfallIntyg > > entry : sortedMap . entrySet ( ) ) { if ( entry . getValue ( ) . size ( ) > 1 ) { SjukfallIntyg [ ] arr = entry . getValue ( ) . toArray ( new SjukfallIntyg [ entry . getValue ( ) . size ( ) ] ) ; // ▁ Check ▁ sort ▁ order ▁ when ▁ list ▁ size ▁ is ▁ greater ▁ than ▁ one ENDCOM for ( int i = 0 ; i < arr . length - 1 ; i ++ ) { assertTrue ( arr [ i ] . getSlutDatum ( ) . isBefore ( arr [ i + 1 ] . getSlutDatum ( ) ) ) ; } } } }
@ Test public void testSetActiveCertificate ( ) { Map < String , List < SjukfallIntyg > > map = creator . createMap ( intygDataList , parameters ) ; Map < String , List < SjukfallIntyg > > activeMap = creator . setActive ( map ) ; // ▁ It ▁ can ▁ only ▁ be ▁ zero ▁ or ▁ one ▁ active ▁ object ENDCOM assertTrue ( activeMap . entrySet ( ) . stream ( ) . allMatch ( e -> e . getValue ( ) . stream ( ) . filter ( o -> o . isAktivtIntyg ( ) ) . count ( ) < 2 ) ) ; }
/* STRNEWLINE ▁ * ▁ Test ▁ methods ▁ below ▁ refers ▁ to ▁ specified ▁ cases ▁ in ▁ SjukfallEnhet . xlsx . STRNEWLINE ▁ * ▁ https : // inera - certificate . atlassian . net / wiki / pages / viewpage . action ? pageId = 39747618 & preview = / 39747618/39747617 / Sjukfall . xlsx STRNEWLINE ▁ */ @ Test public void testFall1 ( ) { String key = "19791110-9291" ; Map < String , List < SjukfallIntyg > > map = creator . create ( intygDataList , parameters ) ; List < SjukfallIntyg > list = map . get ( key ) ; assertTrue ( " Expected ▁ 2 ▁ but ▁ was ▁ " + list . size ( ) , list . size ( ) == 2 ) ; assertStartDate ( list . get ( 0 ) , "2016-02-01" ) ; assertEndDate ( list . get ( 1 ) , "2016-02-20" ) ; assertTrue ( list . get ( 1 ) . isAktivtIntyg ( ) ) ; }
@ Test public void testFall2 ( ) { String key = "19791123-9262" ; Map < String , List < SjukfallIntyg > > map = creator . create ( intygDataList , parameters ) ; List < SjukfallIntyg > list = map . get ( key ) ; assertTrue ( " Expected ▁ 2 ▁ but ▁ was ▁ " + list . size ( ) , list . size ( ) == 2 ) ; assertStartDate ( list . get ( 0 ) , "2016-02-01" ) ; assertEndDate ( list . get ( 1 ) , "2016-02-20" ) ; assertTrue ( list . get ( 1 ) . isAktivtIntyg ( ) ) ; }
@ Test public void testFall3 ( ) { String key = "19791212-9280" ; Map < String , List < SjukfallIntyg > > map = creator . create ( intygDataList , parameters ) ; List < SjukfallIntyg > list = map . get ( key ) ; assertTrue ( " Expected ▁ 3 ▁ but ▁ was ▁ " + list . size ( ) , list . size ( ) == 3 ) ; assertStartDate ( list . get ( 0 ) , "2016-02-01" ) ; assertEndDate ( list . get ( 2 ) , "2016-02-25" ) ; assertTrue ( list . get ( 1 ) . isAktivtIntyg ( ) ) ; }
@ Test public void testFall4 ( ) { String key = "19800113-9297" ; Map < String , List < SjukfallIntyg > > map = creator . create ( intygDataList , parameters ) ; List < SjukfallIntyg > list = map . get ( key ) ; assertTrue ( " Expected ▁ 3 ▁ but ▁ was ▁ " + list . size ( ) , list . size ( ) == 3 ) ; assertStartDate ( list . get ( 0 ) , "2016-02-01" ) ; assertEndDate ( list . get ( 2 ) , "2016-02-25" ) ; assertTrue ( list . get ( 1 ) . isAktivtIntyg ( ) ) ; }
@ Test public void testFall5 ( ) { String key = "19800124-9286" ; Map < String , List < SjukfallIntyg > > map = creator . create ( intygDataList , parameters ) ; List < SjukfallIntyg > list = map . get ( key ) ; assertTrue ( " Expected ▁ 2 ▁ but ▁ was ▁ " + list . size ( ) , list . size ( ) == 2 ) ; assertStartDate ( list . get ( 0 ) , "2016-02-12" ) ; assertEndDate ( list . get ( 1 ) , "2016-02-25" ) ; assertTrue ( list . get ( 0 ) . isAktivtIntyg ( ) ) ; assertFalse ( list . get ( 1 ) . isAktivtIntyg ( ) ) ; }
@ Test public void testFall6 ( ) { String key = "19800207-9294" ; Map < String , List < SjukfallIntyg > > map = creator . create ( intygDataList , parameters ) ; List < SjukfallIntyg > list = map . get ( key ) ; assertTrue ( " Expected ▁ 2 ▁ but ▁ was ▁ " + list . size ( ) , list . size ( ) == 2 ) ; assertStartDate ( list . get ( 0 ) , "2016-02-12" ) ; assertEndDate ( list . get ( 1 ) , "2016-02-25" ) ; assertFalse ( list . get ( 0 ) . isAktivtIntyg ( ) ) ; assertTrue ( list . get ( 1 ) . isAktivtIntyg ( ) ) ; }
@ Test public void testFall7 ( ) { String key = "19800228-9224" ; Map < String , List < SjukfallIntyg > > map = creator . create ( intygDataList , parameters ) ; assertNull ( map . get ( key ) ) ; }
public UTName ( ColumnIdentifier ksName , ColumnIdentifier utName ) { this . ksName = ksName == null ? null : ksName . toString ( ) ; this . utName = utName ; }
public boolean hasKeyspace ( ) { return ksName != null ; }
public void setKeyspace ( String keyspace ) { this . ksName = keyspace ; }
public String getKeyspace ( ) { return ksName ; }
public ByteBuffer getUserTypeName ( ) { return utName . bytes ; }
public String getStringTypeName ( ) { return utName . toString ( ) ; }
public String toString ( ) { return ( hasKeyspace ( ) ? ( ksName + " . " ) : " " ) + utName ; }
ConnectionThread ( BluetoothSocket socket , Handler handler ) { super ( ) ; mBluetoothSocket = socket ; mHandler = handler ; try { mInStream = mBluetoothSocket . getInputStream ( ) ; mOutStream = mBluetoothSocket . getOutputStream ( ) ; } catch ( IOException e ) { } }
public void run ( ) { byte [ ] buffer = new byte [ 1024 ] ; int bytes ; while ( true ) { try { bytes = mInStream . read ( buffer ) ; String data = new String ( buffer , 0 , bytes ) ; mHandler . obtainMessage ( DataTransferActivity . DATA_RECEIVED , data ) . sendToTarget ( ) ; } catch ( IOException e ) { break ; } } }
public void write ( byte [ ] bytes ) { try { mOutStream . write ( bytes ) ; } catch ( IOException e ) { } }
public void run ( ) { try { synchronized ( this ) { this . notify ( ) ; this . wait ( delay ) ; } } catch ( InterruptedException e ) { return ; } }
public SimpleThread ( int d ) { if ( d >= 0 ) delay = d ; }
public void run ( ) { int x = 0 ; while ( true ) { ++ x ; } }
public YieldThread ( int d ) { if ( d >= 0 ) delay = d ; }
public void run ( ) { try { synchronized ( this ) { this . notify ( ) ; } while ( true ) { checkVal ++ ; zz ( ) ; Thread . sleep ( 100 ) ; } } catch ( InterruptedException e ) { return ; } catch ( BogusException e ) { try { // ▁ Give ▁ parent ▁ a ▁ chance ▁ to ▁ sleep ENDCOM Thread . sleep ( 500 ) ; } catch ( InterruptedException x ) { } parent . interrupt ( ) ; while ( ! Thread . currentThread ( ) . isInterrupted ( ) ) { // ▁ Don ' t ▁ hog ▁ the ▁ CPU ENDCOM try { Thread . sleep ( 50 ) ; } catch ( InterruptedException x ) { // ▁ This ▁ is ▁ what ▁ we ' ve ▁ been ▁ waiting ▁ for . . . don ' t ▁ throw ▁ it ENDCOM // ▁ away ! ENDCOM break ; } } } }
public void zz ( ) throws BogusException { }
public ResSupThread ( Thread t ) { parent = t ; }
public synchronized int getCheckVal ( ) { return checkVal ; }
public BogusException ( String s ) { super ( s ) ; }
/* * STRNEWLINE TABSYMBOL ▁ * ▁ @ tests ▁ java . lang . Thread # Thread ( ) STRNEWLINE TABSYMBOL ▁ */ public void test_Constructor ( ) { // ▁ Test ▁ for ▁ method ▁ java . lang . Thread ( ) ENDCOM Thread t ; SecurityManager m = new SecurityManager ( ) { @ Override public ThreadGroup getThreadGroup ( ) { calledMySecurityManager = true ; return Thread . currentThread ( ) . getThreadGroup ( ) ; } @ Override public void checkPermission ( Permission permission ) { if ( permission . getName ( ) . equals ( " setSecurityManager " ) ) { return ; } super . checkPermission ( permission ) ; } } ; try { // ▁ To ▁ see ▁ if ▁ it ▁ checks ▁ Thread ▁ creation ▁ with ▁ our ▁ SecurityManager ENDCOM System . setSecurityManager ( m ) ; t = new Thread ( ) ; } finally { // ▁ restore ▁ original , ▁ no ▁ side - effects ENDCOM System . setSecurityManager ( null ) ; } assertTrue ( " Did ▁ not ▁ call ▁ SecurityManager . getThreadGroup ▁ ( ) " , calledMySecurityManager ) ; t . start ( ) ; }
/* * STRNEWLINE TABSYMBOL ▁ * ▁ @ tests ▁ java . lang . Thread # Thread ( java . lang . Runnable ) STRNEWLINE TABSYMBOL ▁ */ public void test_ConstructorLjava_lang_Runnable ( ) { // ▁ Test ▁ for ▁ method ▁ java . lang . Thread ( java . lang . Runnable ) ENDCOM ct = new Thread ( new SimpleThread ( 10 ) ) ; ct . start ( ) ; }
/* * STRNEWLINE TABSYMBOL ▁ * ▁ @ tests ▁ java . lang . Thread # Thread ( java . lang . Runnable , ▁ java . lang . String ) STRNEWLINE TABSYMBOL ▁ */ public void test_ConstructorLjava_lang_RunnableLjava_lang_String ( ) { // ▁ Test ▁ for ▁ method ▁ java . lang . Thread ( java . lang . Runnable , ENDCOM // ▁ java . lang . String ) ENDCOM Thread st1 = new Thread ( new SimpleThread ( 1 ) , " SimpleThread1" ) ; assertEquals ( " Constructed ▁ thread ▁ with ▁ incorrect ▁ thread ▁ name " , " SimpleThread1" , st1 . getName ( ) ) ; st1 . start ( ) ; }
/* * STRNEWLINE TABSYMBOL ▁ * ▁ @ tests ▁ java . lang . Thread # Thread ( java . lang . String ) STRNEWLINE TABSYMBOL ▁ */ public void test_ConstructorLjava_lang_String ( ) { // ▁ Test ▁ for ▁ method ▁ java . lang . Thread ( java . lang . String ) ENDCOM Thread t = new Thread ( " Testing " ) ; assertEquals ( " Created ▁ tread ▁ with ▁ incorrect ▁ name " , " Testing " , t . getName ( ) ) ; t . start ( ) ; }
/* * STRNEWLINE TABSYMBOL ▁ * ▁ @ tests ▁ java . lang . Thread # Thread ( java . lang . ThreadGroup , ▁ java . lang . Runnable ) STRNEWLINE TABSYMBOL ▁ */ public void test_ConstructorLjava_lang_ThreadGroupLjava_lang_Runnable ( ) { // ▁ Test ▁ for ▁ method ▁ java . lang . Thread ( java . lang . ThreadGroup , ENDCOM // ▁ java . lang . Runnable ) ENDCOM ThreadGroup tg = new ThreadGroup ( " Test ▁ Group1" ) ; st = new Thread ( tg , new SimpleThread ( 1 ) , " SimpleThread2" ) ; assertTrue ( " Returned ▁ incorrect ▁ thread ▁ group " , st . getThreadGroup ( ) == tg ) ; st . start ( ) ; try { st . join ( ) ; } catch ( InterruptedException e ) { } tg . destroy ( ) ; }
/* * STRNEWLINE TABSYMBOL ▁ * ▁ @ tests ▁ java . lang . Thread # Thread ( java . lang . ThreadGroup , ▁ java . lang . Runnable , STRNEWLINE TABSYMBOL ▁ * ▁ java . lang . String ) STRNEWLINE TABSYMBOL ▁ */ public void test_ConstructorLjava_lang_ThreadGroupLjava_lang_RunnableLjava_lang_String ( ) { // ▁ Test ▁ for ▁ method ▁ java . lang . Thread ( java . lang . ThreadGroup , ENDCOM // ▁ java . lang . Runnable , ▁ java . lang . String ) ENDCOM ThreadGroup tg = new ThreadGroup ( " Test ▁ Group2" ) ; st = new Thread ( tg , new SimpleThread ( 1 ) , " SimpleThread3" ) ; assertTrue ( " Constructed ▁ incorrect ▁ thread " , ( st . getThreadGroup ( ) == tg ) && st . getName ( ) . equals ( " SimpleThread3" ) ) ; st . start ( ) ; try { st . join ( ) ; } catch ( InterruptedException e ) { } tg . destroy ( ) ; Runnable r = new Runnable ( ) { public void run ( ) { } } ; ThreadGroup foo = null ; try { new Thread ( foo = new ThreadGroup ( " foo " ) , r , null ) ; // ▁ Should ▁ not ▁ get ▁ here ENDCOM fail ( " Null ▁ cannot ▁ be ▁ accepted ▁ as ▁ Thread ▁ name " ) ; } catch ( NullPointerException npe ) { assertTrue ( " Null ▁ cannot ▁ be ▁ accepted ▁ as ▁ Thread ▁ name " , true ) ; foo . destroy ( ) ; } }
/* * STRNEWLINE TABSYMBOL ▁ * ▁ @ tests ▁ java . lang . Thread # Thread ( java . lang . ThreadGroup , ▁ java . lang . String ) STRNEWLINE TABSYMBOL ▁ */ public void test_ConstructorLjava_lang_ThreadGroupLjava_lang_String ( ) { // ▁ Test ▁ for ▁ method ▁ java . lang . Thread ( java . lang . ThreadGroup , ENDCOM // ▁ java . lang . String ) ENDCOM st = new Thread ( new SimpleThread ( 1 ) , " SimpleThread4" ) ; assertEquals ( " Returned ▁ incorrect ▁ thread ▁ name " , " SimpleThread4" , st . getName ( ) ) ; st . start ( ) ; }
/* * STRNEWLINE TABSYMBOL ▁ * ▁ @ tests ▁ java . lang . Thread # activeCount ( ) STRNEWLINE TABSYMBOL ▁ */ public void test_activeCount ( ) { // ▁ Test ▁ for ▁ method ▁ int ▁ java . lang . Thread . activeCount ( ) ENDCOM Thread t = new Thread ( new SimpleThread ( 10 ) ) ; int active = 0 ; synchronized ( t ) { t . start ( ) ; active = Thread . activeCount ( ) ; } assertTrue ( " Incorrect ▁ activeCount ▁ for ▁ current ▁ group : ▁ " + active , active > 1 ) ; try { t . join ( ) ; } catch ( InterruptedException e ) { } }
/* * STRNEWLINE TABSYMBOL ▁ * ▁ @ tests ▁ java . lang . Thread # checkAccess ( ) STRNEWLINE TABSYMBOL ▁ */ public void test_checkAccess ( ) { // ▁ Test ▁ for ▁ method ▁ void ▁ java . lang . Thread . checkAccess ( ) ENDCOM ThreadGroup tg = new ThreadGroup ( " Test ▁ Group3" ) ; try { st = new Thread ( tg , new SimpleThread ( 1 ) , " SimpleThread5" ) ; st . checkAccess ( ) ; assertTrue ( " CheckAccess ▁ passed " , true ) ; } catch ( SecurityException e ) { fail ( " CheckAccess ▁ failed ▁ : ▁ " + e . getMessage ( ) ) ; } st . start ( ) ; try { st . join ( ) ; } catch ( InterruptedException e ) { } tg . destroy ( ) ; }
/* * STRNEWLINE ▁ * ▁ @ tests ▁ java . lang . Thread # countStackFrames ( ) STRNEWLINE ▁ */ @ SuppressWarnings ( " deprecation " ) public void test_countStackFrames ( ) { /* STRNEWLINE ▁ * ▁ Thread . countStackFrames ( ) ▁ is ▁ unpredictable , ▁ so ▁ we ▁ just ▁ test ▁ that ▁ it STRNEWLINE ▁ * ▁ doesn ' t ▁ throw ▁ an ▁ exception . STRNEWLINE ▁ */ Thread . currentThread ( ) . countStackFrames ( ) ; }
/* * STRNEWLINE TABSYMBOL ▁ * ▁ @ tests ▁ java . lang . Thread # currentThread ( ) STRNEWLINE TABSYMBOL ▁ */ public void test_currentThread ( ) { assertNotNull ( Thread . currentThread ( ) ) ; }
/* * STRNEWLINE TABSYMBOL ▁ * ▁ @ tests ▁ java . lang . Thread # destroy ( ) STRNEWLINE TABSYMBOL ▁ */ @ SuppressWarnings ( " deprecation " ) public void test_destroy ( ) { try { new Thread ( ) . destroy ( ) ; // ▁ FIXME ▁ uncomment ▁ when ▁ IBM ▁ VME ▁ is ▁ updated ENDCOM // fail ( " NoSuchMethodError ▁ was ▁ not ▁ thrown " ) ; ENDCOM } catch ( NoSuchMethodError e ) { } }
/* * STRNEWLINE TABSYMBOL ▁ * ▁ @ tests ▁ java . lang . Thread # enumerate ( java . lang . Thread [ ] ) STRNEWLINE TABSYMBOL ▁ */ public void test_enumerate$Ljava_lang_Thread ( ) { // ▁ Test ▁ for ▁ method ▁ int ▁ java . lang . Thread . enumerate ( java . lang . Thread ▁ [ ] ) ENDCOM // ▁ The ▁ test ▁ has ▁ been ▁ updated ▁ according ▁ to ▁ HARMONY - 1974 ▁ JIRA ▁ issue . ENDCOM class MyThread extends Thread { MyThread ( ThreadGroup tg , String name ) { super ( tg , name ) ; } boolean failed = false ; String failMessage = null ; public void run ( ) { SimpleThread st1 = null ; SimpleThread st2 = null ; ThreadGroup mytg = null ; Thread firstOne = null ; Thread secondOne = null ; try { int arrayLength = 10 ; Thread [ ] tarray = new Thread [ arrayLength ] ; st1 = new SimpleThread ( - 1 ) ; st2 = new SimpleThread ( - 1 ) ; mytg = new ThreadGroup ( " jp " ) ; firstOne = new Thread ( mytg , st1 , " firstOne2" ) ; secondOne = new Thread ( mytg , st2 , " secondOne1" ) ; int count = Thread . enumerate ( tarray ) ; assertEquals ( " Incorrect ▁ value ▁ returned1" , 1 , count ) ; synchronized ( st1 ) { firstOne . start ( ) ; try { st1 . wait ( ) ; } catch ( InterruptedException e ) { } } count = Thread . enumerate ( tarray ) ; assertEquals ( " Incorrect ▁ value ▁ returned2" , 2 , count ) ; synchronized ( st2 ) { secondOne . start ( ) ; try { st2 . wait ( ) ; } catch ( InterruptedException e ) { } } count = Thread . enumerate ( tarray ) ; assertEquals ( " Incorrect ▁ value ▁ returned3" , 3 , count ) ; } catch ( junit . framework . AssertionFailedError e ) { failed = true ; failMessage = e . getMessage ( ) ; } finally { synchronized ( st1 ) { firstOne . interrupt ( ) ; } synchronized ( st2 ) { secondOne . interrupt ( ) ; } try { firstOne . join ( ) ; secondOne . join ( ) ; } catch ( InterruptedException e ) { } mytg . destroy ( ) ; } } } ; ThreadGroup tg = new ThreadGroup ( " tg " ) ; MyThread t = new MyThread ( tg , " top " ) ; t . start ( ) ; try { t . join ( ) ; } catch ( InterruptedException e ) { fail ( " Unexpected ▁ interrupt " ) ; } finally { tg . destroy ( ) ; } assertFalse ( t . failMessage , t . failed ) ; }
/* * STRNEWLINE TABSYMBOL ▁ * ▁ @ tests ▁ java . lang . Thread # getContextClassLoader ( ) STRNEWLINE TABSYMBOL ▁ */ public void test_getContextClassLoader ( ) { // ▁ Test ▁ for ▁ method ▁ java . lang . ClassLoader ENDCOM // ▁ java . lang . Thread . getContextClassLoader ( ) ENDCOM Thread t = new Thread ( ) ; assertTrue ( " Incorrect ▁ class ▁ loader ▁ returned " , t . getContextClassLoader ( ) == Thread . currentThread ( ) . getContextClassLoader ( ) ) ; t . start ( ) ; }
/* * STRNEWLINE TABSYMBOL ▁ * ▁ @ tests ▁ java . lang . Thread # getName ( ) STRNEWLINE TABSYMBOL ▁ */ public void test_getName ( ) { // ▁ Test ▁ for ▁ method ▁ java . lang . String ▁ java . lang . Thread . getName ( ) ENDCOM st = new Thread ( new SimpleThread ( 1 ) , " SimpleThread6" ) ; assertEquals ( " Returned ▁ incorrect ▁ thread ▁ name " , " SimpleThread6" , st . getName ( ) ) ; st . start ( ) ; }
/* * STRNEWLINE TABSYMBOL ▁ * ▁ @ tests ▁ java . lang . Thread # getPriority ( ) STRNEWLINE TABSYMBOL ▁ */ public void test_getPriority ( ) { // ▁ Test ▁ for ▁ method ▁ int ▁ java . lang . Thread . getPriority ( ) ENDCOM st = new Thread ( new SimpleThread ( 1 ) ) ; st . setPriority ( Thread . MAX_PRIORITY ) ; assertTrue ( " Returned ▁ incorrect ▁ thread ▁ priority " , st . getPriority ( ) == Thread . MAX_PRIORITY ) ; st . start ( ) ; }
/* * STRNEWLINE TABSYMBOL ▁ * ▁ @ tests ▁ java . lang . Thread # getThreadGroup ( ) STRNEWLINE TABSYMBOL ▁ */ public void test_getThreadGroup ( ) { // ▁ Test ▁ for ▁ method ▁ java . lang . ThreadGroup ENDCOM // ▁ java . lang . Thread . getThreadGroup ( ) ENDCOM ThreadGroup tg = new ThreadGroup ( " Test ▁ Group4" ) ; st = new Thread ( tg , new SimpleThread ( 1 ) , " SimpleThread8" ) ; assertTrue ( " Returned ▁ incorrect ▁ thread ▁ group " , st . getThreadGroup ( ) == tg ) ; st . start ( ) ; try { st . join ( ) ; } catch ( InterruptedException e ) { } assertNull ( " group ▁ should ▁ be ▁ null " , st . getThreadGroup ( ) ) ; assertNotNull ( " toString ( ) ▁ should ▁ not ▁ be ▁ null " , st . toString ( ) ) ; tg . destroy ( ) ; final Object lock = new Object ( ) ; Thread t = new Thread ( ) { @ Override public void run ( ) { synchronized ( lock ) { lock . notifyAll ( ) ; } } } ; synchronized ( lock ) { t . start ( ) ; try { lock . wait ( ) ; } catch ( InterruptedException e ) { } } int running = 0 ; while ( t . isAlive ( ) ) running ++ ; ThreadGroup group = t . getThreadGroup ( ) ; assertNull ( " ThreadGroup ▁ is ▁ not ▁ null " , group ) ; }
/* * STRNEWLINE TABSYMBOL ▁ * ▁ @ tests ▁ java . lang . Thread # interrupt ( ) STRNEWLINE TABSYMBOL ▁ */ public void test_interrupt ( ) { // ▁ Test ▁ for ▁ method ▁ void ▁ java . lang . Thread . interrupt ( ) ENDCOM final Object lock = new Object ( ) ; class ChildThread1 extends Thread { Thread parent ; boolean sync ; @ Override public void run ( ) { if ( sync ) { synchronized ( lock ) { lock . notify ( ) ; try { lock . wait ( ) ; } catch ( InterruptedException e ) { } } } parent . interrupt ( ) ; } public ChildThread1 ( Thread p , String name , boolean sync ) { super ( name ) ; parent = p ; this . sync = sync ; } } boolean interrupted = false ; try { ct = new ChildThread1 ( Thread . currentThread ( ) , " Interrupt ▁ Test1" , false ) ; synchronized ( lock ) { ct . start ( ) ; lock . wait ( ) ; } } catch ( InterruptedException e ) { interrupted = true ; } assertTrue ( " Failed ▁ to ▁ Interrupt ▁ thread1" , interrupted ) ; interrupted = false ; try { ct = new ChildThread1 ( Thread . currentThread ( ) , " Interrupt ▁ Test2" , true ) ; synchronized ( lock ) { ct . start ( ) ; lock . wait ( ) ; lock . notify ( ) ; } Thread . sleep ( 20000 ) ; } catch ( InterruptedException e ) { interrupted = true ; } assertTrue ( " Failed ▁ to ▁ Interrupt ▁ thread2" , interrupted ) ; }
/* * STRNEWLINE TABSYMBOL ▁ * ▁ @ tests ▁ java . lang . Thread # interrupted ( ) STRNEWLINE TABSYMBOL ▁ */ public void test_interrupted ( ) { assertFalse ( " Interrupted ▁ returned ▁ true ▁ for ▁ non - interrupted ▁ thread " , Thread . interrupted ( ) ) ; Thread . currentThread ( ) . interrupt ( ) ; assertTrue ( " Interrupted ▁ returned ▁ true ▁ for ▁ non - interrupted ▁ thread " , Thread . interrupted ( ) ) ; assertFalse ( " Failed ▁ to ▁ clear ▁ interrupted ▁ flag " , Thread . interrupted ( ) ) ; }
/* * STRNEWLINE TABSYMBOL ▁ * ▁ @ tests ▁ java . lang . Thread # isAlive ( ) STRNEWLINE TABSYMBOL ▁ */ public void test_isAlive ( ) { // ▁ Test ▁ for ▁ method ▁ boolean ▁ java . lang . Thread . isAlive ( ) ENDCOM SimpleThread simple ; st = new Thread ( simple = new SimpleThread ( 500 ) ) ; assertFalse ( " A ▁ thread ▁ that ▁ wasn ' t ▁ started ▁ is ▁ alive . " , st . isAlive ( ) ) ; synchronized ( simple ) { st . start ( ) ; try { simple . wait ( ) ; } catch ( InterruptedException e ) { } } assertTrue ( " Started ▁ thread ▁ returned ▁ false " , st . isAlive ( ) ) ; try { st . join ( ) ; } catch ( InterruptedException e ) { fail ( " Thread ▁ did ▁ not ▁ die " ) ; } assertTrue ( " Stopped ▁ thread ▁ returned ▁ true " , ! st . isAlive ( ) ) ; }
/* * STRNEWLINE TABSYMBOL ▁ * ▁ @ tests ▁ java . lang . Thread # isDaemon ( ) STRNEWLINE TABSYMBOL ▁ */ public void test_isDaemon ( ) { // ▁ Test ▁ for ▁ method ▁ boolean ▁ java . lang . Thread . isDaemon ( ) ENDCOM st = new Thread ( new SimpleThread ( 1 ) , " SimpleThread10" ) ; assertTrue ( " Non - Daemon ▁ thread ▁ returned ▁ true " , ! st . isDaemon ( ) ) ; st . setDaemon ( true ) ; assertTrue ( " Daemon ▁ thread ▁ returned ▁ false " , st . isDaemon ( ) ) ; st . start ( ) ; }
/* * STRNEWLINE TABSYMBOL ▁ * ▁ @ tests ▁ java . lang . Thread # isInterrupted ( ) STRNEWLINE TABSYMBOL ▁ */ public void test_isInterrupted ( ) { // ▁ Test ▁ for ▁ method ▁ boolean ▁ java . lang . Thread . isInterrupted ( ) ENDCOM class SpinThread implements Runnable { public volatile boolean done = false ; public void run ( ) { while ( ! Thread . currentThread ( ) . isInterrupted ( ) ) ; while ( ! done ) ; } } SpinThread spin = new SpinThread ( ) ; spinner = new Thread ( spin ) ; spinner . start ( ) ; Thread . yield ( ) ; try { assertTrue ( " Non - Interrupted ▁ thread ▁ returned ▁ true " , ! spinner . isInterrupted ( ) ) ; spinner . interrupt ( ) ; assertTrue ( " Interrupted ▁ thread ▁ returned ▁ false " , spinner . isInterrupted ( ) ) ; spin . done = true ; } finally { spinner . interrupt ( ) ; spin . done = true ; } }
/* * STRNEWLINE TABSYMBOL ▁ * ▁ @ tests ▁ java . lang . Thread # join ( ) STRNEWLINE TABSYMBOL ▁ */ public void test_join ( ) { // ▁ Test ▁ for ▁ method ▁ void ▁ java . lang . Thread . join ( ) ENDCOM SimpleThread simple ; try { st = new Thread ( simple = new SimpleThread ( 100 ) ) ; // ▁ cause ▁ isAlive ( ) ▁ to ▁ be ▁ compiled ▁ by ▁ the ▁ JIT , ▁ as ▁ it ▁ must ▁ be ▁ called ENDCOM // ▁ within ▁ 100ms ▁ below . ENDCOM assertTrue ( " Thread ▁ is ▁ alive " , ! st . isAlive ( ) ) ; synchronized ( simple ) { st . start ( ) ; simple . wait ( ) ; } st . join ( ) ; } catch ( InterruptedException e ) { fail ( " Join ▁ failed ▁ " ) ; } assertTrue ( " Joined ▁ thread ▁ is ▁ still ▁ alive " , ! st . isAlive ( ) ) ; boolean result = true ; Thread th = new Thread ( " test " ) ; try { th . join ( ) ; } catch ( InterruptedException e ) { result = false ; } assertTrue ( " Hung ▁ joining ▁ a ▁ non - started ▁ thread " , result ) ; th . start ( ) ; }
/* * STRNEWLINE TABSYMBOL ▁ * ▁ @ tests ▁ java . lang . Thread # join ( long ) STRNEWLINE TABSYMBOL ▁ */ public void test_joinJ ( ) { // ▁ Test ▁ for ▁ method ▁ void ▁ java . lang . Thread . join ( long ) ENDCOM SimpleThread simple ; try { st = new Thread ( simple = new SimpleThread ( 1000 ) , " SimpleThread12" ) ; // ▁ cause ▁ isAlive ( ) ▁ to ▁ be ▁ compiled ▁ by ▁ the ▁ JIT , ▁ as ▁ it ▁ must ▁ be ▁ called ENDCOM // ▁ within ▁ 100ms ▁ below . ENDCOM assertTrue ( " Thread ▁ is ▁ alive " , ! st . isAlive ( ) ) ; synchronized ( simple ) { st . start ( ) ; simple . wait ( ) ; } st . join ( 10 ) ; } catch ( InterruptedException e ) { fail ( " Join ▁ failed ▁ " ) ; } assertTrue ( " Join ▁ failed ▁ to ▁ timeout " , st . isAlive ( ) ) ; st . interrupt ( ) ; try { st = new Thread ( simple = new SimpleThread ( 100 ) , " SimpleThread13" ) ; synchronized ( simple ) { st . start ( ) ; simple . wait ( ) ; } st . join ( 1000 ) ; } catch ( InterruptedException e ) { fail ( " Join ▁ failed ▁ : ▁ " + e . getMessage ( ) ) ; return ; } assertTrue ( " Joined ▁ thread ▁ is ▁ still ▁ alive " , ! st . isAlive ( ) ) ; final Object lock = new Object ( ) ; final Thread main = Thread . currentThread ( ) ; Thread killer = new Thread ( new Runnable ( ) { public void run ( ) { try { synchronized ( lock ) { lock . notify ( ) ; } Thread . sleep ( 100 ) ; } catch ( InterruptedException e ) { return ; } main . interrupt ( ) ; } } ) ; boolean result = true ; Thread th = new Thread ( " test " ) ; try { synchronized ( lock ) { killer . start ( ) ; lock . wait ( ) ; } th . join ( 200 ) ; } catch ( InterruptedException e ) { result = false ; } killer . interrupt ( ) ; assertTrue ( " Hung ▁ joining ▁ a ▁ non - started ▁ thread " , result ) ; th . start ( ) ; }
/* * STRNEWLINE TABSYMBOL ▁ * ▁ @ tests ▁ java . lang . Thread # join ( long , ▁ int ) STRNEWLINE TABSYMBOL ▁ */ public void test_joinJI ( ) throws Exception { // ▁ Test ▁ for ▁ method ▁ void ▁ java . lang . Thread . join ( long , ▁ int ) ENDCOM SimpleThread simple ; st = new Thread ( simple = new SimpleThread ( 1000 ) , " Squawk1" ) ; assertTrue ( " Thread ▁ is ▁ alive " , ! st . isAlive ( ) ) ; synchronized ( simple ) { st . start ( ) ; simple . wait ( ) ; } long firstRead = System . currentTimeMillis ( ) ; st . join ( 100 , 999999 ) ; long secondRead = System . currentTimeMillis ( ) ; assertTrue ( " Did ▁ not ▁ join ▁ by ▁ appropriate ▁ time : ▁ " + secondRead + " - " + firstRead + " = " + ( secondRead - firstRead ) , secondRead - firstRead <= 300 ) ; assertTrue ( " Joined ▁ thread ▁ is ▁ not ▁ alive " , st . isAlive ( ) ) ; st . interrupt ( ) ; final Object lock = new Object ( ) ; final Thread main = Thread . currentThread ( ) ; Thread killer = new Thread ( new Runnable ( ) { public void run ( ) { try { synchronized ( lock ) { lock . notify ( ) ; } Thread . sleep ( 100 ) ; } catch ( InterruptedException e ) { return ; } main . interrupt ( ) ; } } ) ; boolean result = true ; Thread th = new Thread ( " test " ) ; try { synchronized ( lock ) { killer . start ( ) ; lock . wait ( ) ; } th . join ( 200 , 20 ) ; } catch ( InterruptedException e ) { result = false ; } killer . interrupt ( ) ; assertTrue ( " Hung ▁ joining ▁ a ▁ non - started ▁ thread " , result ) ; th . start ( ) ; }
/* * STRNEWLINE TABSYMBOL ▁ * ▁ @ tests ▁ java . lang . Thread # resume ( ) STRNEWLINE TABSYMBOL ▁ */ @ SuppressWarnings ( " deprecation " ) public void test_resume ( ) { // ▁ Test ▁ for ▁ method ▁ void ▁ java . lang . Thread . resume ( ) ENDCOM int orgval ; ResSupThread t ; try { t = new ResSupThread ( Thread . currentThread ( ) ) ; synchronized ( t ) { ct = new Thread ( t , " Interrupt ▁ Test2" ) ; ct . start ( ) ; t . wait ( ) ; } ct . suspend ( ) ; // ▁ Wait ▁ to ▁ be ▁ sure ▁ the ▁ suspend ▁ has ▁ occurred ENDCOM Thread . sleep ( 500 ) ; orgval = t . getCheckVal ( ) ; // ▁ Wait ▁ to ▁ be ▁ sure ▁ the ▁ thread ▁ is ▁ suspended ENDCOM Thread . sleep ( 500 ) ; assertTrue ( " Failed ▁ to ▁ suspend ▁ thread " , orgval == t . getCheckVal ( ) ) ; ct . resume ( ) ; // ▁ Wait ▁ to ▁ be ▁ sure ▁ the ▁ resume ▁ has ▁ occurred . ENDCOM Thread . sleep ( 500 ) ; assertTrue ( " Failed ▁ to ▁ resume ▁ thread " , orgval != t . getCheckVal ( ) ) ; ct . interrupt ( ) ; } catch ( InterruptedException e ) { fail ( " Unexpected ▁ interrupt ▁ occurred ▁ : ▁ " + e . getMessage ( ) ) ; } }
/* * STRNEWLINE TABSYMBOL ▁ * ▁ @ tests ▁ java . lang . Thread # run ( ) STRNEWLINE TABSYMBOL ▁ */ public void test_run ( ) { // ▁ Test ▁ for ▁ method ▁ void ▁ java . lang . Thread . run ( ) ENDCOM class RunThread implements Runnable { boolean didThreadRun = false ; public void run ( ) { didThreadRun = true ; } } RunThread rt = new RunThread ( ) ; Thread t = new Thread ( rt ) ; try { t . start ( ) ; int count = 0 ; while ( ! rt . didThreadRun && count < 20 ) { Thread . sleep ( 100 ) ; count ++ ; } assertTrue ( " Thread ▁ did ▁ not ▁ run " , rt . didThreadRun ) ; t . join ( ) ; } catch ( InterruptedException e ) { assertTrue ( " Joined ▁ thread ▁ was ▁ interrupted " , true ) ; } assertTrue ( " Joined ▁ thread ▁ is ▁ still ▁ alive " , ! t . isAlive ( ) ) ; }
/* * STRNEWLINE TABSYMBOL ▁ * ▁ @ tests ▁ java . lang . Thread # setDaemon ( boolean ) STRNEWLINE TABSYMBOL ▁ */ public void test_setDaemonZ ( ) { // ▁ Test ▁ for ▁ method ▁ void ▁ java . lang . Thread . setDaemon ( boolean ) ENDCOM st = new Thread ( new SimpleThread ( 1 ) , " SimpleThread14" ) ; st . setDaemon ( true ) ; assertTrue ( " Failed ▁ to ▁ set ▁ thread ▁ as ▁ daemon ▁ thread " , st . isDaemon ( ) ) ; st . start ( ) ; }
/* * STRNEWLINE TABSYMBOL ▁ * ▁ @ tests ▁ java . lang . Thread # setName ( java . lang . String ) STRNEWLINE TABSYMBOL ▁ */ public void test_setNameLjava_lang_String ( ) { // ▁ Test ▁ for ▁ method ▁ void ▁ java . lang . Thread . setName ( java . lang . String ) ENDCOM st = new Thread ( new SimpleThread ( 1 ) , " SimpleThread15" ) ; st . setName ( " Bogus ▁ Name " ) ; assertEquals ( " Failed ▁ to ▁ set ▁ thread ▁ name " , " Bogus ▁ Name " , st . getName ( ) ) ; try { st . setName ( null ) ; fail ( " Null ▁ should ▁ not ▁ be ▁ accepted ▁ as ▁ a ▁ valid ▁ name " ) ; } catch ( NullPointerException e ) { // ▁ success ENDCOM assertTrue ( " Null ▁ should ▁ not ▁ be ▁ accepted ▁ as ▁ a ▁ valid ▁ name " , true ) ; } st . start ( ) ; }
/* * STRNEWLINE TABSYMBOL ▁ * ▁ @ tests ▁ java . lang . Thread # setPriority ( int ) STRNEWLINE TABSYMBOL ▁ */ public void test_setPriorityI ( ) { // ▁ Test ▁ for ▁ method ▁ void ▁ java . lang . Thread . setPriority ( int ) ENDCOM st = new Thread ( new SimpleThread ( 1 ) ) ; st . setPriority ( Thread . MAX_PRIORITY ) ; assertTrue ( " Failed ▁ to ▁ set ▁ priority " , st . getPriority ( ) == Thread . MAX_PRIORITY ) ; st . start ( ) ; }
/* * STRNEWLINE TABSYMBOL ▁ * ▁ @ tests ▁ java . lang . Thread # sleep ( long ) STRNEWLINE TABSYMBOL ▁ */ public void test_sleepJ ( ) { // ▁ Test ▁ for ▁ method ▁ void ▁ java . lang . Thread . sleep ( long ) ENDCOM // ▁ TODO ▁ : ▁ Test ▁ needs ▁ enhancing . ENDCOM long stime = 0 , ftime = 0 ; try { stime = System . currentTimeMillis ( ) ; Thread . sleep ( 1000 ) ; ftime = System . currentTimeMillis ( ) ; } catch ( InterruptedException e ) { fail ( " Unexpected ▁ interrupt ▁ received " ) ; } assertTrue ( " Failed ▁ to ▁ sleep ▁ long ▁ enough " , ( ftime - stime ) >= 800 ) ; }
/* * STRNEWLINE TABSYMBOL ▁ * ▁ @ tests ▁ java . lang . Thread # sleep ( long , ▁ int ) STRNEWLINE TABSYMBOL ▁ */ public void test_sleepJI ( ) { // ▁ Test ▁ for ▁ method ▁ void ▁ java . lang . Thread . sleep ( long , ▁ int ) ENDCOM // ▁ TODO ▁ : ▁ Test ▁ needs ▁ revisiting . ENDCOM long stime = 0 , ftime = 0 ; try { stime = System . currentTimeMillis ( ) ; Thread . sleep ( 1000 , 999999 ) ; ftime = System . currentTimeMillis ( ) ; } catch ( InterruptedException e ) { fail ( " Unexpected ▁ interrupt ▁ received " ) ; } long result = ftime - stime ; assertTrue ( " Failed ▁ to ▁ sleep ▁ long ▁ enough : ▁ " + result , result >= 900 && result <= 1100 ) ; }
/* * STRNEWLINE TABSYMBOL ▁ * ▁ @ tests ▁ java . lang . Thread # start ( ) STRNEWLINE TABSYMBOL ▁ */ public void test_start ( ) { // ▁ Test ▁ for ▁ method ▁ void ▁ java . lang . Thread . start ( ) ENDCOM try { ResSupThread t = new ResSupThread ( Thread . currentThread ( ) ) ; synchronized ( t ) { ct = new Thread ( t , " Interrupt ▁ Test4" ) ; ct . start ( ) ; t . wait ( ) ; } assertTrue ( " Thread ▁ is ▁ not ▁ running1" , ct . isAlive ( ) ) ; // ▁ Let ▁ the ▁ child ▁ thread ▁ get ▁ going . ENDCOM int orgval = t . getCheckVal ( ) ; Thread . sleep ( 150 ) ; assertTrue ( " Thread ▁ is ▁ not ▁ running2" , orgval != t . getCheckVal ( ) ) ; ct . interrupt ( ) ; } catch ( InterruptedException e ) { fail ( " Unexpected ▁ interrupt ▁ occurred " ) ; } }
/* * STRNEWLINE TABSYMBOL ▁ * ▁ @ tests ▁ java . lang . Thread # stop ( ) STRNEWLINE TABSYMBOL ▁ */ @ SuppressWarnings ( " deprecation " ) public void test_stop ( ) { // ▁ Test ▁ for ▁ method ▁ void ▁ java . lang . Thread . stop ( ) ENDCOM try { Runnable r = new ResSupThread ( null ) ; synchronized ( r ) { st = new Thread ( r , " Interupt ▁ Test5" ) ; st . start ( ) ; r . wait ( ) ; } } catch ( InterruptedException e ) { fail ( " Unexpected ▁ interrupt ▁ received " ) ; } st . stop ( ) ; try { st . join ( 10000 ) ; } catch ( InterruptedException e1 ) { st . interrupt ( ) ; fail ( " Failed ▁ to ▁ stopThread ▁ before ▁ 10000 ▁ timeout " ) ; } assertTrue ( " Failed ▁ to ▁ stopThread " , ! st . isAlive ( ) ) ; }
/* * STRNEWLINE TABSYMBOL ▁ * ▁ @ tests ▁ java . lang . Thread # stop ( ) STRNEWLINE TABSYMBOL ▁ */ @ SuppressWarnings ( " deprecation " ) public void test_stop_subtest0 ( ) { Thread t = new Thread ( " t " ) ; class MySecurityManager extends SecurityManager { public boolean intest = false ; @ Override public void checkAccess ( Thread t ) { if ( intest ) { fail ( " checkAccess ▁ called " ) ; } } @ Override public void checkPermission ( Permission permission ) { if ( permission . getName ( ) . equals ( " setSecurityManager " ) ) { return ; } super . checkPermission ( permission ) ; } } MySecurityManager sm = new MySecurityManager ( ) ; System . setSecurityManager ( sm ) ; try { sm . intest = true ; try { t . stop ( ) ; // ▁ Ignore ▁ any ▁ SecurityExceptions , ▁ may ▁ not ▁ have ▁ stopThread ENDCOM // ▁ permission ENDCOM } catch ( SecurityException e ) { } sm . intest = false ; t . start ( ) ; try { t . join ( 2000 ) ; } catch ( InterruptedException e ) { } sm . intest = true ; try { t . stop ( ) ; // ▁ Ignore ▁ any ▁ SecurityExceptions , ▁ may ▁ not ▁ have ▁ stopThread ENDCOM // ▁ permission ENDCOM } catch ( SecurityException e ) { } sm . intest = false ; } finally { System . setSecurityManager ( null ) ; } }
/* * STRNEWLINE TABSYMBOL ▁ * ▁ @ tests ▁ java . lang . Thread # stop ( java . lang . Throwable ) STRNEWLINE TABSYMBOL ▁ */ @ SuppressWarnings ( " deprecation " ) public void test_stopLjava_lang_Throwable_subtest0 ( ) { Thread t = new Thread ( " t " ) ; class MySecurityManager extends SecurityManager { public boolean intest = false ; public boolean checkAccess = false ; @ Override public void checkAccess ( Thread t ) { if ( intest ) { checkAccess = true ; } } @ Override public void checkPermission ( Permission permission ) { if ( permission . getName ( ) . equals ( " setSecurityManager " ) ) { return ; } super . checkPermission ( permission ) ; } } MySecurityManager sm = new MySecurityManager ( ) ; System . setSecurityManager ( sm ) ; try { sm . intest = true ; try { t . stop ( new ThreadDeath ( ) ) ; // ▁ Ignore ▁ any ▁ SecurityExceptions , ▁ may ▁ not ▁ have ▁ stopThread ENDCOM // ▁ permission ENDCOM } catch ( SecurityException e ) { } sm . intest = false ; assertTrue ( " no ▁ checkAccess ▁ 1" , sm . checkAccess ) ; t . start ( ) ; try { t . join ( 2000 ) ; } catch ( InterruptedException e ) { } sm . intest = true ; sm . checkAccess = false ; try { t . stop ( new ThreadDeath ( ) ) ; // ▁ Ignore ▁ any ▁ SecurityExceptions , ▁ may ▁ not ▁ have ▁ stopThread ENDCOM // ▁ permission ENDCOM } catch ( SecurityException e ) { } assertTrue ( " no ▁ checkAccess ▁ 2" , sm . checkAccess ) ; sm . intest = false ; } finally { System . setSecurityManager ( null ) ; } }
/* * STRNEWLINE TABSYMBOL ▁ * ▁ @ tests ▁ java . lang . Thread # stop ( java . lang . Throwable ) STRNEWLINE TABSYMBOL ▁ */ @ SuppressWarnings ( " deprecation " ) public void test_stopLjava_lang_Throwable ( ) { // ▁ Test ▁ for ▁ method ▁ void ▁ java . lang . Thread . stop ( java . lang . Throwable ) ENDCOM ResSupThread t = new ResSupThread ( Thread . currentThread ( ) ) ; synchronized ( t ) { st = new Thread ( t , " StopThread " ) ; st . setPriority ( Thread . MAX_PRIORITY ) ; st . start ( ) ; try { t . wait ( ) ; } catch ( InterruptedException e ) { } } try { st . stop ( new BogusException ( " Bogus " ) ) ; Thread . sleep ( 20000 ) ; } catch ( InterruptedException e ) { assertTrue ( " Stopped ▁ child ▁ with ▁ exception ▁ not ▁ alive " , st . isAlive ( ) ) ; st . interrupt ( ) ; return ; } st . interrupt ( ) ; fail ( " Stopped ▁ child ▁ did ▁ not ▁ throw ▁ exception " ) ; }
/* * STRNEWLINE TABSYMBOL ▁ * ▁ @ tests ▁ java . lang . Thread # suspend ( ) STRNEWLINE TABSYMBOL ▁ */ @ SuppressWarnings ( " deprecation " ) public void test_suspend ( ) { // ▁ Test ▁ for ▁ method ▁ void ▁ java . lang . Thread . suspend ( ) ENDCOM int orgval ; ResSupThread t = new ResSupThread ( Thread . currentThread ( ) ) ; try { synchronized ( t ) { ct = new Thread ( t , " Interupt ▁ Test6" ) ; ct . start ( ) ; t . wait ( ) ; } ct . suspend ( ) ; // ▁ Wait ▁ to ▁ be ▁ sure ▁ the ▁ suspend ▁ has ▁ occurred ENDCOM Thread . sleep ( 500 ) ; orgval = t . getCheckVal ( ) ; // ▁ Wait ▁ to ▁ be ▁ sure ▁ the ▁ thread ▁ is ▁ suspended ENDCOM Thread . sleep ( 500 ) ; assertTrue ( " Failed ▁ to ▁ suspend ▁ thread " , orgval == t . getCheckVal ( ) ) ; ct . resume ( ) ; // ▁ Wait ▁ to ▁ be ▁ sure ▁ the ▁ resume ▁ has ▁ occurred . ENDCOM Thread . sleep ( 500 ) ; assertTrue ( " Failed ▁ to ▁ resume ▁ thread " , orgval != t . getCheckVal ( ) ) ; ct . interrupt ( ) ; } catch ( InterruptedException e ) { fail ( " Unexpected ▁ interrupt ▁ occurred " ) ; } final Object notify = new Object ( ) ; Thread t1 = new Thread ( new Runnable ( ) { public void run ( ) { synchronized ( notify ) { notify . notify ( ) ; } Thread . currentThread ( ) . suspend ( ) ; } } ) ; try { synchronized ( notify ) { t1 . start ( ) ; notify . wait ( ) ; } // ▁ wait ▁ for ▁ Thread ▁ to ▁ suspend ENDCOM Thread . sleep ( 500 ) ; assertTrue ( " Thread ▁ should ▁ be ▁ alive " , t1 . isAlive ( ) ) ; t1 . resume ( ) ; t1 . join ( ) ; } catch ( InterruptedException e ) { } }
/* * STRNEWLINE TABSYMBOL ▁ * ▁ @ tests ▁ java . lang . Thread # toString ( ) STRNEWLINE TABSYMBOL ▁ */ public void test_toString ( ) { // ▁ Test ▁ for ▁ method ▁ java . lang . String ▁ java . lang . Thread . toString ( ) ENDCOM ThreadGroup tg = new ThreadGroup ( " Test ▁ Group5" ) ; st = new Thread ( tg , new SimpleThread ( 1 ) , " SimpleThread17" ) ; final String stString = st . toString ( ) ; final String expected = " Thread [ SimpleThread17,5 , Test ▁ Group5 ] " ; assertTrue ( " Returned ▁ incorrect ▁ string : ▁ " + stString + " \t ( expecting ▁ : " + expected + " ) " , stString . equals ( expected ) ) ; st . start ( ) ; try { st . join ( ) ; } catch ( InterruptedException e ) { } tg . destroy ( ) ; }
/* * STRNEWLINE ▁ * ▁ @ tests ▁ java . lang . Thread # getAllStackTraces ( ) STRNEWLINE ▁ */ public void test_getAllStackTraces ( ) { Map < Thread , StackTraceElement [ ] > stMap = Thread . getAllStackTraces ( ) ; assertNotNull ( stMap ) ; // TODO ▁ add ▁ security - based ▁ tests ENDCOM }
/* * STRNEWLINE ▁ * ▁ @ tests ▁ java . lang . Thread # getDefaultUncaughtExceptionHandler STRNEWLINE ▁ * ▁ @ tests ▁ java . lang . Thread # setDefaultUncaughtExceptionHandler STRNEWLINE ▁ */ public void test_get_setDefaultUncaughtExceptionHandler ( ) { class Handler implements UncaughtExceptionHandler { public void uncaughtException ( Thread thread , Throwable ex ) { } } final Handler handler = new Handler ( ) ; Thread . setDefaultUncaughtExceptionHandler ( handler ) ; assertSame ( handler , Thread . getDefaultUncaughtExceptionHandler ( ) ) ; Thread . setDefaultUncaughtExceptionHandler ( null ) ; assertNull ( Thread . getDefaultUncaughtExceptionHandler ( ) ) ; // TODO ▁ add ▁ security - based ▁ tests ENDCOM }
/* * STRNEWLINE ▁ * ▁ @ tests ▁ java . lang . Thread # getStackTrace ( ) STRNEWLINE ▁ */ public void test_getStackTrace ( ) { StackTraceElement [ ] stackTrace = Thread . currentThread ( ) . getStackTrace ( ) ; assertNotNull ( stackTrace ) ; stack_trace_loop : { for ( int i = 0 ; i < stackTrace . length ; i ++ ) { StackTraceElement e = stackTrace [ i ] ; if ( getClass ( ) . getName ( ) . equals ( e . getClassName ( ) ) ) { if ( " test _ getStackTrace " . equals ( e . getMethodName ( ) ) ) { break stack_trace_loop ; } } } fail ( " class ▁ and ▁ method ▁ not ▁ found ▁ in ▁ stack ▁ trace " ) ; } // TODO ▁ add ▁ security - based ▁ tests ENDCOM }
/* * STRNEWLINE ▁ * ▁ @ tests ▁ java . lang . Thread # getState ( ) STRNEWLINE ▁ */ public void test_getState ( ) { Thread . State state = Thread . currentThread ( ) . getState ( ) ; assertNotNull ( state ) ; assertEquals ( Thread . State . RUNNABLE , state ) ; // TODO ▁ add ▁ additional ▁ state ▁ tests ENDCOM }
/* * STRNEWLINE ▁ * ▁ @ tests ▁ java . lang . Thread # getUncaughtExceptionHandler STRNEWLINE ▁ * ▁ @ tests ▁ java . lang . Thread # setUncaughtExceptionHandler STRNEWLINE ▁ */ public void test_get_setUncaughtExceptionHandler ( ) { class Handler implements UncaughtExceptionHandler { public void uncaughtException ( Thread thread , Throwable ex ) { } } final Handler handler = new Handler ( ) ; Thread . currentThread ( ) . setUncaughtExceptionHandler ( handler ) ; assertSame ( handler , Thread . currentThread ( ) . getUncaughtExceptionHandler ( ) ) ; Thread . currentThread ( ) . setUncaughtExceptionHandler ( null ) ; // TODO ▁ add ▁ security - based ▁ tests ENDCOM }
/* * STRNEWLINE ▁ * ▁ @ tests ▁ java . lang . Thread # getId ( ) STRNEWLINE ▁ */ public void test_getId ( ) { assertTrue ( " current ▁ thread ' s ▁ ID ▁ is ▁ not ▁ positive " , Thread . currentThread ( ) . getId ( ) > 0 ) ; // check ▁ all ▁ the ▁ current ▁ threads ▁ for ▁ positive ▁ IDs ENDCOM Map < Thread , StackTraceElement [ ] > stMap = Thread . getAllStackTraces ( ) ; for ( Thread thread : stMap . keySet ( ) ) { assertTrue ( " thread ' s ▁ ID ▁ is ▁ not ▁ positive : ▁ " + thread . getName ( ) , thread . getId ( ) > 0 ) ; } }
protected void tearDown ( ) { try { if ( st != null ) st . interrupt ( ) ; } catch ( Exception e ) { } try { if ( spinner != null ) spinner . interrupt ( ) ; } catch ( Exception e ) { } try { if ( ct != null ) ct . interrupt ( ) ; } catch ( Exception e ) { } try { spinner = null ; st = null ; ct = null ; System . runFinalization ( ) ; } catch ( Exception e ) { } }
