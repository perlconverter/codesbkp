boss_ormorokAI ( Creature * creature ) : BossAI ( creature , DATA_ORMOROK ) { Initialize ( ) ; }
void Initialize ( ) { frenzy = false ; }
npc_crystal_spike_triggerAI ( Creature * creature ) : ScriptedAI ( creature ) { _count = 0 ; _despawntimer = 0 ; }
void HandlePeriodic ( AuraEffect const * /* aurEff */ ENDCOM ) { Unit * target = GetTarget ( ) ; if ( target -> GetEntry ( ) == NPC_CRYSTAL_SPIKE_INITIAL || target -> GetEntry ( ) == NPC_CRYSTAL_SPIKE_TRIGGER ) if ( Creature * trigger = target -> ToCreature ( ) ) { uint32 spell = target -> GetEntry ( ) == NPC_CRYSTAL_SPIKE_INITIAL ? crystalSpikeSummon [ 0 ] : crystalSpikeSummon [ urand ( 0 , 2 ) ] ; if ( trigger -> AI ( ) -> GetData ( DATA_COUNT ) < MAX_COUNT ) trigger -> CastSpell ( trigger , spell , true ) ; } }
void AddSC_boss_ormorok ( ) { new boss_ormorok ( ) ; new npc_crystal_spike_trigger ( ) ; new spell_crystal_spike ( ) ; }
Q_OBJECT public : explicit GLWidget ( QMainWindow * parent = NULL ) : QGLWidget ( QGLFormat ( QGL :: SampleBuffers ) , parent ) , primary_edges_only_ ( false ) , internal_edges_only_ ( false ) { startTimer ( 40 ) ; }
void build ( const QString & file_path ) { // ▁ Clear ▁ all ▁ containers . ENDCOM clear ( ) ; // ▁ Read ▁ data . ENDCOM read_data ( file_path ) ; // ▁ No ▁ data , ▁ don ' t ▁ proceed . ENDCOM if ( ! brect_initialized_ ) { return ; } // ▁ Construct ▁ bounding ▁ rectangle . ENDCOM construct_brect ( ) ; // ▁ Construct ▁ voronoi ▁ diagram . ENDCOM construct_voronoi ( point_data_ . begin ( ) , point_data_ . end ( ) , segment_data_ . begin ( ) , segment_data_ . end ( ) , & vd_ ) ; // ▁ Color ▁ exterior ▁ edges . ENDCOM for ( const_edge_iterator it = vd_ . edges ( ) . begin ( ) ; it != vd_ . edges ( ) . end ( ) ; ++ it ) { if ( ! it -> is_finite ( ) ) { color_exterior ( & ( * it ) ) ; } } // ▁ Update ▁ view ▁ port . ENDCOM update_view_port ( ) ; }
void show_primary_edges_only ( ) { primary_edges_only_ ^= true ; }
void show_internal_edges_only ( ) { internal_edges_only_ ^= true ; }
protected : void initializeGL ( ) { glHint ( GL_POINT_SMOOTH_HINT , GL_NICEST ) ; glBlendFunc ( GL_SRC_ALPHA , GL_ONE_MINUS_SRC_ALPHA ) ; glEnable ( GL_BLEND ) ; glEnable ( GL_POINT_SMOOTH ) ; }
void paintGL ( ) { qglClearColor ( QColor :: fromRgb ( 255 , 255 , 255 ) ) ; glClear ( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT ) ; draw_points ( ) ; draw_segments ( ) ; draw_vertices ( ) ; draw_edges ( ) ; }
void resizeGL ( int width , int height ) { int side = qMin ( width , height ) ; glViewport ( ( width - side ) / 2 , ( height - side ) / 2 , side , side ) ; }
void timerEvent ( QTimerEvent * e ) { update ( ) ; }
void clear ( ) { brect_initialized_ = false ; point_data_ . clear ( ) ; segment_data_ . clear ( ) ; vd_ . clear ( ) ; }
void read_data ( const QString & file_path ) { QFile data ( file_path ) ; if ( ! data . open ( QFile :: ReadOnly ) ) { QMessageBox :: warning ( this , tr ( " Voronoi ▁ Visualizer " ) , tr ( " Disable ▁ to ▁ open ▁ file ▁ " ) + file_path ) ; } QTextStream in_stream ( & data ) ; std :: size_t num_points , num_segments ; int x1 , y1 , x2 , y2 ; in_stream >> num_points ; for ( std :: size_t i = 0 ; i < num_points ; ++ i ) { in_stream >> x1 >> y1 ; point_type p ( x1 , y1 ) ; update_brect ( p ) ; point_data_ . push_back ( p ) ; } in_stream >> num_segments ; for ( std :: size_t i = 0 ; i < num_segments ; ++ i ) { in_stream >> x1 >> y1 >> x2 >> y2 ; point_type lp ( x1 , y1 ) ; point_type hp ( x2 , y2 ) ; update_brect ( lp ) ; update_brect ( hp ) ; segment_data_ . push_back ( segment_type ( lp , hp ) ) ; } in_stream . flush ( ) ; }
void update_brect ( const point_type & point ) { if ( brect_initialized_ ) { encompass ( brect_ , point ) ; } else { set_points ( brect_ , point , point ) ; brect_initialized_ = true ; } }
void construct_brect ( ) { double side = ( std :: max ) ( xh ( brect_ ) - xl ( brect_ ) , yh ( brect_ ) - yl ( brect_ ) ) ; center ( shift_ , brect_ ) ; set_points ( brect_ , shift_ , shift_ ) ; bloat ( brect_ , side * 1.2 ) ; }
void color_exterior ( const VD :: edge_type * edge ) { if ( edge -> color ( ) == EXTERNAL_COLOR ) { return ; } edge -> color ( EXTERNAL_COLOR ) ; edge -> twin ( ) -> color ( EXTERNAL_COLOR ) ; const VD :: vertex_type * v = edge -> vertex1 ( ) ; if ( v == NULL || ! edge -> is_primary ( ) ) { return ; } v -> color ( EXTERNAL_COLOR ) ; const VD :: edge_type * e = v -> incident_edge ( ) ; do { color_exterior ( e ) ; e = e -> rot_next ( ) ; } while ( e != v -> incident_edge ( ) ) ; }
void update_view_port ( ) { glMatrixMode ( GL_PROJECTION ) ; glLoadIdentity ( ) ; rect_type view_rect = brect_ ; deconvolve ( view_rect , shift_ ) ; glOrtho ( xl ( view_rect ) , xh ( view_rect ) , yl ( view_rect ) , yh ( view_rect ) , - 1.0 , 1.0 ) ; glMatrixMode ( GL_MODELVIEW ) ; }
void draw_points ( ) { // ▁ Draw ▁ input ▁ points ▁ and ▁ endpoints ▁ of ▁ the ▁ input ▁ segments . ENDCOM glColor3f ( 0.0f , 0.5f , 1.0f ) ; glPointSize ( 9 ) ; glBegin ( GL_POINTS ) ; for ( std :: size_t i = 0 ; i < point_data_ . size ( ) ; ++ i ) { point_type point = point_data_ [ i ] ; deconvolve ( point , shift_ ) ; glVertex2f ( point . x ( ) , point . y ( ) ) ; } for ( std :: size_t i = 0 ; i < segment_data_ . size ( ) ; ++ i ) { point_type lp = low ( segment_data_ [ i ] ) ; lp = deconvolve ( lp , shift_ ) ; glVertex2f ( lp . x ( ) , lp . y ( ) ) ; point_type hp = high ( segment_data_ [ i ] ) ; hp = deconvolve ( hp , shift_ ) ; glVertex2f ( hp . x ( ) , hp . y ( ) ) ; } glEnd ( ) ; }
void draw_segments ( ) { // ▁ Draw ▁ input ▁ segments . ENDCOM glColor3f ( 0.0f , 0.5f , 1.0f ) ; glLineWidth ( 2.7f ) ; glBegin ( GL_LINES ) ; for ( std :: size_t i = 0 ; i < segment_data_ . size ( ) ; ++ i ) { point_type lp = low ( segment_data_ [ i ] ) ; lp = deconvolve ( lp , shift_ ) ; glVertex2f ( lp . x ( ) , lp . y ( ) ) ; point_type hp = high ( segment_data_ [ i ] ) ; hp = deconvolve ( hp , shift_ ) ; glVertex2f ( hp . x ( ) , hp . y ( ) ) ; } glEnd ( ) ; }
void draw_vertices ( ) { // ▁ Draw ▁ voronoi ▁ vertices . ENDCOM glColor3f ( 0.0f , 0.0f , 0.0f ) ; glPointSize ( 6 ) ; glBegin ( GL_POINTS ) ; for ( const_vertex_iterator it = vd_ . vertices ( ) . begin ( ) ; it != vd_ . vertices ( ) . end ( ) ; ++ it ) { if ( internal_edges_only_ && ( it -> color ( ) == EXTERNAL_COLOR ) ) { continue ; } point_type vertex ( it -> x ( ) , it -> y ( ) ) ; vertex = deconvolve ( vertex , shift_ ) ; glVertex2f ( vertex . x ( ) , vertex . y ( ) ) ; } glEnd ( ) ; }
void draw_edges ( ) { // ▁ Draw ▁ voronoi ▁ edges . ENDCOM glColor3f ( 0.0f , 0.0f , 0.0f ) ; glLineWidth ( 1.7f ) ; for ( const_edge_iterator it = vd_ . edges ( ) . begin ( ) ; it != vd_ . edges ( ) . end ( ) ; ++ it ) { if ( primary_edges_only_ && ! it -> is_primary ( ) ) { continue ; } if ( internal_edges_only_ && ( it -> color ( ) == EXTERNAL_COLOR ) ) { continue ; } std :: vector < point_type > samples ; if ( ! it -> is_finite ( ) ) { clip_infinite_edge ( * it , & samples ) ; } else { point_type vertex0 ( it -> vertex0 ( ) -> x ( ) , it -> vertex0 ( ) -> y ( ) ) ; samples . push_back ( vertex0 ) ; point_type vertex1 ( it -> vertex1 ( ) -> x ( ) , it -> vertex1 ( ) -> y ( ) ) ; samples . push_back ( vertex1 ) ; if ( it -> is_curved ( ) ) { sample_curved_edge ( * it , & samples ) ; } } glBegin ( GL_LINE_STRIP ) ; for ( std :: size_t i = 0 ; i < samples . size ( ) ; ++ i ) { point_type vertex = deconvolve ( samples [ i ] , shift_ ) ; glVertex2f ( vertex . x ( ) , vertex . y ( ) ) ; } glEnd ( ) ; } }
void clip_infinite_edge ( const edge_type & edge , std :: vector < point_type > * clipped_edge ) { const cell_type & cell1 = * edge . cell ( ) ; const cell_type & cell2 = * edge . twin ( ) -> cell ( ) ; point_type origin , direction ; // ▁ Infinite ▁ edges ▁ could ▁ not ▁ be ▁ created ▁ by ▁ two ▁ segment ▁ sites . ENDCOM if ( cell1 . contains_point ( ) && cell2 . contains_point ( ) ) { point_type p1 = retrieve_point ( cell1 ) ; point_type p2 = retrieve_point ( cell2 ) ; origin . x ( ( p1 . x ( ) + p2 . x ( ) ) * 0.5 ) ; origin . y ( ( p1 . y ( ) + p2 . y ( ) ) * 0.5 ) ; direction . x ( p1 . y ( ) - p2 . y ( ) ) ; direction . y ( p2 . x ( ) - p1 . x ( ) ) ; } else { origin = cell1 . contains_segment ( ) ? retrieve_point ( cell2 ) : retrieve_point ( cell1 ) ; segment_type segment = cell1 . contains_segment ( ) ? retrieve_segment ( cell1 ) : retrieve_segment ( cell2 ) ; coordinate_type dx = high ( segment ) . x ( ) - low ( segment ) . x ( ) ; coordinate_type dy = high ( segment ) . y ( ) - low ( segment ) . y ( ) ; if ( ( low ( segment ) == origin ) ^ cell1 . contains_point ( ) ) { direction . x ( dy ) ; direction . y ( - dx ) ; } else { direction . x ( - dy ) ; direction . y ( dx ) ; } } coordinate_type side = xh ( brect_ ) - xl ( brect_ ) ; coordinate_type koef = side / ( std :: max ) ( fabs ( direction . x ( ) ) , fabs ( direction . y ( ) ) ) ; if ( edge . vertex0 ( ) == NULL ) { clipped_edge -> push_back ( point_type ( origin . x ( ) - direction . x ( ) * koef , origin . y ( ) - direction . y ( ) * koef ) ) ; } else { clipped_edge -> push_back ( point_type ( edge . vertex0 ( ) -> x ( ) , edge . vertex0 ( ) -> y ( ) ) ) ; } if ( edge . vertex1 ( ) == NULL ) { clipped_edge -> push_back ( point_type ( origin . x ( ) + direction . x ( ) * koef , origin . y ( ) + direction . y ( ) * koef ) ) ; } else { clipped_edge -> push_back ( point_type ( edge . vertex1 ( ) -> x ( ) , edge . vertex1 ( ) -> y ( ) ) ) ; } }
void sample_curved_edge ( const edge_type & edge , std :: vector < point_type > * sampled_edge ) { coordinate_type max_dist = 1E - 3 * ( xh ( brect_ ) - xl ( brect_ ) ) ; point_type point = edge . cell ( ) -> contains_point ( ) ? retrieve_point ( * edge . cell ( ) ) : retrieve_point ( * edge . twin ( ) -> cell ( ) ) ; segment_type segment = edge . cell ( ) -> contains_point ( ) ? retrieve_segment ( * edge . twin ( ) -> cell ( ) ) : retrieve_segment ( * edge . cell ( ) ) ; voronoi_visual_utils < coordinate_type > :: discretize ( point , segment , max_dist , sampled_edge ) ; }
point_type retrieve_point ( const cell_type & cell ) { source_index_type index = cell . source_index ( ) ; source_category_type category = cell . source_category ( ) ; if ( category == SOURCE_CATEGORY_SINGLE_POINT ) { return point_data_ [ index ] ; } index -= point_data_ . size ( ) ; if ( category == SOURCE_CATEGORY_SEGMENT_START_POINT ) { return low ( segment_data_ [ index ] ) ; } else { return high ( segment_data_ [ index ] ) ; } }
segment_type retrieve_segment ( const cell_type & cell ) { source_index_type index = cell . source_index ( ) - point_data_ . size ( ) ; return segment_data_ [ index ] ; }
Q_OBJECT public : MainWindow ( ) { glWidget_ = new GLWidget ( ) ; file_dir_ = QDir ( QDir :: currentPath ( ) , tr ( " * . txt " ) ) ; file_name_ = tr ( " " ) ; QHBoxLayout * centralLayout = new QHBoxLayout ; centralLayout -> addWidget ( glWidget_ ) ; centralLayout -> addLayout ( create_file_layout ( ) ) ; setLayout ( centralLayout ) ; update_file_list ( ) ; setWindowTitle ( tr ( " Voronoi ▁ Visualizer " ) ) ; layout ( ) -> setSizeConstraint ( QLayout :: SetFixedSize ) ; }
private slots : void primary_edges_only ( ) { glWidget_ -> show_primary_edges_only ( ) ; }
void internal_edges_only ( ) { glWidget_ -> show_internal_edges_only ( ) ; }
void browse ( ) { QString new_path = QFileDialog :: getExistingDirectory ( 0 , tr ( " Choose ▁ Directory " ) , file_dir_ . absolutePath ( ) ) ; if ( new_path . isEmpty ( ) ) { return ; } file_dir_ . setPath ( new_path ) ; update_file_list ( ) ; }
void build ( ) { file_name_ = file_list_ -> currentItem ( ) -> text ( ) ; QString file_path = file_dir_ . filePath ( file_name_ ) ; message_label_ -> setText ( " Building . . . " ) ; glWidget_ -> build ( file_path ) ; message_label_ -> setText ( " Double ▁ click ▁ the ▁ item ▁ to ▁ build ▁ voronoi ▁ diagram : " ) ; setWindowTitle ( tr ( " Voronoi ▁ Visualizer ▁ - ▁ " ) + file_path ) ; }
void print_scr ( ) { if ( ! file_name_ . isEmpty ( ) ) { QImage screenshot = glWidget_ -> grabFrameBuffer ( true ) ; QString output_file = file_dir_ . absolutePath ( ) + tr ( " / " ) + file_name_ . left ( file_name_ . indexOf ( ' . ' ) ) + tr ( " . png " ) ; screenshot . save ( output_file , 0 , - 1 ) ; } }
private : QGridLayout * create_file_layout ( ) { QGridLayout * file_layout = new QGridLayout ; message_label_ = new QLabel ( " Double ▁ click ▁ item ▁ to ▁ build ▁ voronoi ▁ diagram : " ) ; file_list_ = new QListWidget ( ) ; file_list_ -> connect ( file_list_ , SIGNAL ( itemDoubleClicked ( QListWidgetItem * ) ) , this , SLOT ( build ( ) ) ) ; QCheckBox * primary_checkbox = new QCheckBox ( " Show ▁ primary ▁ edges ▁ only . " ) ; connect ( primary_checkbox , SIGNAL ( clicked ( ) ) , this , SLOT ( primary_edges_only ( ) ) ) ; QCheckBox * internal_checkbox = new QCheckBox ( " Show ▁ internal ▁ edges ▁ only . " ) ; connect ( internal_checkbox , SIGNAL ( clicked ( ) ) , this , SLOT ( internal_edges_only ( ) ) ) ; QPushButton * browse_button = new QPushButton ( tr ( " Browse ▁ Input ▁ Directory " ) ) ; connect ( browse_button , SIGNAL ( clicked ( ) ) , this , SLOT ( browse ( ) ) ) ; browse_button -> setMinimumHeight ( 50 ) ; QPushButton * print_scr_button = new QPushButton ( tr ( " Make ▁ Screenshot " ) ) ; connect ( print_scr_button , SIGNAL ( clicked ( ) ) , this , SLOT ( print_scr ( ) ) ) ; print_scr_button -> setMinimumHeight ( 50 ) ; file_layout -> addWidget ( message_label_ , 0 , 0 ) ; file_layout -> addWidget ( file_list_ , 1 , 0 ) ; file_layout -> addWidget ( primary_checkbox , 2 , 0 ) ; file_layout -> addWidget ( internal_checkbox , 3 , 0 ) ; file_layout -> addWidget ( browse_button , 4 , 0 ) ; file_layout -> addWidget ( print_scr_button , 5 , 0 ) ; return file_layout ; }
void update_file_list ( ) { QFileInfoList list = file_dir_ . entryInfoList ( ) ; file_list_ -> clear ( ) ; if ( file_dir_ . count ( ) == 0 ) { return ; } QFileInfoList :: const_iterator it ; for ( it = list . begin ( ) ; it != list . end ( ) ; it ++ ) { file_list_ -> addItem ( it -> fileName ( ) ) ; } file_list_ -> setCurrentRow ( 0 ) ; }
int main ( int argc , char * argv [ ] ) { QApplication app ( argc , argv ) ; MainWindow window ; window . show ( ) ; return app . exec ( ) ; }
void ImHere ( ) { DEBUG_LOG ( CPU , " JIT ▁ Here : ▁ % 08x " , currentMIPS -> pc ) ; }
BENCHMARK ( ipv4_to_string_inet_ntop , iters ) { folly :: IPAddressV4 ipv4Addr ( "127.0.0.1" ) ; in_addr ip = ipv4Addr . toAddr ( ) ; char outputString [ INET_ADDRSTRLEN ] = { 0 } ; while ( iters -- ) { const char * val = inet_ntop ( AF_INET , & ip , outputString , sizeof ( outputString ) ) ; } }
BENCHMARK_RELATIVE ( ipv4_to_fully_qualified , iters ) { IPAddressV4 ip ( "127.0.0.1" ) ; while ( iters -- ) { string outputString = ip . toFullyQualified ( ) ; } }
BENCHMARK_DRAW_LINE ( ) BENCHMARK ( ipv6_to_string_inet_ntop , iters ) { IPAddressV6 ipv6Addr ( " F1E0:0ACE : FB94:7ADF : 22E8:6DE6:9672:3725" ) ; in6_addr ip = ipv6Addr . toAddr ( ) ; char outputString [ INET6_ADDRSTRLEN ] = { 0 } ; bool checkResult = ( iters == 1 ) ; while ( iters -- ) { const char * val = inet_ntop ( AF_INET6 , & ip , outputString , sizeof ( outputString ) ) ; } }
BENCHMARK_RELATIVE ( ipv6_to_fully_qualified , iters ) { IPAddressV6 ip ( " F1E0:0ACE : FB94:7ADF : 22E8:6DE6:9672:3725" ) ; string outputString ; while ( iters -- ) { outputString = ip . toFullyQualified ( ) ; } }
// ▁ Benchmark ▁ results ▁ on ▁ Intel ▁ Xeon ▁ CPU ▁ E5-2660 ▁ @ ▁ 2.20GHz ENDCOM // ▁ folly / test / IPAddressBenchmark . cpp ▁ relative ▁ time / iter ▁ iters / s ENDCOM // ▁ ipv4 _ to _ string _ inet _ ntop ▁ 237.87ns ▁ 4.20M ENDCOM // ▁ ipv4 _ to _ fully _ qualified ▁ 362.31 % ▁ 65.65ns ▁ 15.23M ENDCOM // ▁ ipv6 _ to _ string _ inet _ ntop ▁ 768.60ns ▁ 1.30M ENDCOM // ▁ ipv6 _ to _ fully _ qualified ▁ 821.81 % ▁ 93.53ns ▁ 10.69M ENDCOM int main ( int argc , char * argv [ ] ) { gflags :: ParseCommandLineFlags ( & argc , & argv , true ) ; runBenchmarks ( ) ; return 0 ; }
int main ( int argc , char * * argv ) { // ▁ Setup ▁ the ▁ main ▁ app ENDCOM LightBulb :: App * app = new LightBulb :: App ( ) ; app -> addTrainingPlan ( new PigChaseEvolution ( ) ) ; app -> addExporter ( new TensorflowExporter ( ) ) ; wxApp :: SetInstance ( app ) ; wxEntry ( argc , argv ) ; return 0 ; }
/* STRNEWLINE = = = = = STRNEWLINE CG _ InitMarkPolys STRNEWLINE STRNEWLINE This ▁ is ▁ called ▁ at ▁ startup ▁ and ▁ for ▁ tournement ▁ restarts STRNEWLINE = = = = = STRNEWLINE */ ENDCOM void CG_InitMarkPolys ( void ) { int i ; memset ( cg_markPolys , 0 , sizeof ( cg_markPolys ) ) ; cg_activeMarkPolys . nextMark = & cg_activeMarkPolys ; cg_activeMarkPolys . prevMark = & cg_activeMarkPolys ; cg_freeMarkPolys = cg_markPolys ; for ( i = 0 ; i < MAX_MARK_POLYS - 1 ; i ++ ) { cg_markPolys [ i ] . nextMark = & cg_markPolys [ i + 1 ] ; } }
/* STRNEWLINE = = = = = STRNEWLINE CG _ FreeMarkPoly STRNEWLINE = = = = = STRNEWLINE */ ENDCOM void CG_FreeMarkPoly ( markPoly_t * le ) { if ( ! le -> prevMark ) { CG_Error ( " CG _ FreeLocalEntity : ▁ not ▁ active " ) ; } // ▁ remove ▁ from ▁ the ▁ doubly ▁ linked ▁ active ▁ list ENDCOM le -> prevMark -> nextMark = le -> nextMark ; le -> nextMark -> prevMark = le -> prevMark ; // ▁ the ▁ free ▁ list ▁ is ▁ only ▁ singly ▁ linked ENDCOM le -> nextMark = cg_freeMarkPolys ; cg_freeMarkPolys = le ; }
/* STRNEWLINE = = = = = STRNEWLINE CG _ AllocMark STRNEWLINE STRNEWLINE Will ▁ allways ▁ succeed , ▁ even ▁ if ▁ it ▁ requires ▁ freeing ▁ an ▁ old ▁ active ▁ mark STRNEWLINE = = = = = STRNEWLINE */ ENDCOM markPoly_t * CG_AllocMark ( void ) { markPoly_t * le ; int time ; if ( ! cg_freeMarkPolys ) { // ▁ no ▁ free ▁ entities , ▁ so ▁ free ▁ the ▁ one ▁ at ▁ the ▁ end ▁ of ▁ the ▁ chain ENDCOM // ▁ remove ▁ the ▁ oldest ▁ active ▁ entity ENDCOM time = cg_activeMarkPolys . prevMark -> time ; while ( cg_activeMarkPolys . prevMark && time == cg_activeMarkPolys . prevMark -> time ) { CG_FreeMarkPoly ( cg_activeMarkPolys . prevMark ) ; } } le = cg_freeMarkPolys ; cg_freeMarkPolys = cg_freeMarkPolys -> nextMark ; memset ( le , 0 , sizeof ( * le ) ) ; // ▁ link ▁ into ▁ the ▁ active ▁ list ENDCOM le -> nextMark = cg_activeMarkPolys . nextMark ; le -> prevMark = & cg_activeMarkPolys ; cg_activeMarkPolys . nextMark -> prevMark = le ; cg_activeMarkPolys . nextMark = le ; return le ; }
/* STRNEWLINE = = = = = STRNEWLINE CG _ ImpactMark STRNEWLINE STRNEWLINE origin ▁ should ▁ be ▁ a ▁ point ▁ within ▁ a ▁ unit ▁ of ▁ the ▁ plane STRNEWLINE dir ▁ should ▁ be ▁ the ▁ plane ▁ normal STRNEWLINE STRNEWLINE temporary ▁ marks ▁ will ▁ not ▁ be ▁ stored ▁ or ▁ randomly ▁ oriented , ▁ but ▁ immediately STRNEWLINE passed ▁ to ▁ the ▁ renderer . STRNEWLINE = = = = = STRNEWLINE */ ENDCOM void CG_ImpactMark ( qhandle_t markShader , const vec3_t origin , const vec3_t dir , float orientation , float red , float green , float blue , float alpha , qboolean alphaFade , float radius , qboolean temporary ) { vec3_t axis [ 3 ] ; float texCoordScale ; vec3_t originalPoints [ 4 ] ; byte colors [ 4 ] ; int i , j ; int numFragments ; markFragment_t markFragments [ MAX_MARK_FRAGMENTS ] , * mf ; vec3_t markPoints [ MAX_MARK_POINTS ] ; vec3_t projection ; if ( ! cg_addMarks . integer ) { return ; } if ( radius <= 0 ) { CG_Error ( " CG _ ImpactMark ▁ called ▁ with ▁ < = ▁ 0 ▁ radius " ) ; } // ▁ create ▁ the ▁ texture ▁ axis ENDCOM VectorNormalize2 ( dir , axis [ 0 ] ) ; PerpendicularVector ( axis [ 1 ] , axis [ 0 ] ) ; RotatePointAroundVector ( axis [ 2 ] , axis [ 0 ] , axis [ 1 ] , orientation ) ; CrossProduct ( axis [ 0 ] , axis [ 2 ] , axis [ 1 ] ) ; texCoordScale = 0.5 * 1.0 / radius ; // ▁ create ▁ the ▁ full ▁ polygon ENDCOM for ( i = 0 ; i < 3 ; i ++ ) { originalPoints [ 0 ] [ i ] = origin [ i ] - radius * axis [ 1 ] [ i ] - radius * axis [ 2 ] [ i ] ; originalPoints [ 1 ] [ i ] = origin [ i ] + radius * axis [ 1 ] [ i ] - radius * axis [ 2 ] [ i ] ; originalPoints [ 2 ] [ i ] = origin [ i ] + radius * axis [ 1 ] [ i ] + radius * axis [ 2 ] [ i ] ; originalPoints [ 3 ] [ i ] = origin [ i ] - radius * axis [ 1 ] [ i ] + radius * axis [ 2 ] [ i ] ; } // ▁ get ▁ the ▁ fragments ENDCOM VectorScale ( dir , - 20 , projection ) ; numFragments = cgi_CM_MarkFragments ( 4 , ( const float ( * ) [ 3 ] ) originalPoints , projection , MAX_MARK_POINTS , markPoints [ 0 ] , MAX_MARK_FRAGMENTS , markFragments ) ; colors [ 0 ] = red * 255 ; colors [ 1 ] = green * 255 ; colors [ 2 ] = blue * 255 ; colors [ 3 ] = alpha * 255 ; for ( i = 0 , mf = markFragments ; i < numFragments ; i ++ , mf ++ ) { polyVert_t * v ; polyVert_t verts [ MAX_VERTS_ON_POLY ] ; markPoly_t * mark ; // ▁ we ▁ have ▁ an ▁ upper ▁ limit ▁ on ▁ the ▁ complexity ▁ of ▁ polygons ENDCOM // ▁ that ▁ we ▁ store ▁ persistantly ENDCOM if ( mf -> numPoints > MAX_VERTS_ON_POLY ) { mf -> numPoints = MAX_VERTS_ON_POLY ; } for ( j = 0 , v = verts ; j < mf -> numPoints ; j ++ , v ++ ) { vec3_t delta ; VectorCopy ( markPoints [ mf -> firstPoint + j ] , v -> xyz ) ; VectorSubtract ( v -> xyz , origin , delta ) ; v -> st [ 0 ] = 0.5f + DotProduct ( delta , axis [ 1 ] ) * texCoordScale ; v -> st [ 1 ] = 0.5f + DotProduct ( delta , axis [ 2 ] ) * texCoordScale ; for ( int k = 0 ; k < 4 ; k ++ ) { v -> modulate [ k ] = colors [ k ] ; } } // ▁ if ▁ it ▁ is ▁ a ▁ temporary ▁ ( shadow ) ▁ mark , ▁ add ▁ it ▁ immediately ▁ and ▁ forget ▁ about ▁ it ENDCOM if ( temporary ) { cgi_R_AddPolyToScene ( markShader , mf -> numPoints , verts ) ; continue ; } // ▁ otherwise ▁ save ▁ it ▁ persistantly ENDCOM mark = CG_AllocMark ( ) ; mark -> time = cg . time ; mark -> alphaFade = alphaFade ; mark -> markShader = markShader ; mark -> poly . numVerts = mf -> numPoints ; mark -> color [ 0 ] = colors [ 0 ] ; // red ; ENDCOM mark -> color [ 1 ] = colors [ 1 ] ; // green ; ENDCOM mark -> color [ 2 ] = colors [ 2 ] ; // blue ; ENDCOM mark -> color [ 3 ] = colors [ 3 ] ; // alpha ; ENDCOM memcpy ( mark -> verts , verts , mf -> numPoints * sizeof ( verts [ 0 ] ) ) ; } }
/* STRNEWLINE = = = = = STRNEWLINE CG _ AddMarks STRNEWLINE = = = = = STRNEWLINE */ ENDCOM void CG_AddMarks ( void ) { int j ; markPoly_t * mp , * next ; int t ; int fade ; if ( ! cg_addMarks . integer ) { return ; } mp = cg_activeMarkPolys . nextMark ; for ( ; mp != & cg_activeMarkPolys ; mp = next ) { // ▁ grab ▁ next ▁ now , ▁ so ▁ if ▁ the ▁ local ▁ entity ▁ is ▁ freed ▁ we ENDCOM // ▁ still ▁ have ▁ it ENDCOM next = mp -> nextMark ; // ▁ see ▁ if ▁ it ▁ is ▁ time ▁ to ▁ completely ▁ remove ▁ it ENDCOM if ( cg . time > mp -> time + MARK_TOTAL_TIME ) { CG_FreeMarkPoly ( mp ) ; continue ; } // ▁ fade ▁ all ▁ marks ▁ out ▁ with ▁ time ENDCOM t = mp -> time + MARK_TOTAL_TIME - cg . time ; if ( t < MARK_FADE_TIME ) { fade = 255 * t / MARK_FADE_TIME ; if ( mp -> alphaFade ) { for ( j = 0 ; j < mp -> poly . numVerts ; j ++ ) { mp -> verts [ j ] . modulate [ 3 ] = fade ; } } else { float f = ( float ) t / MARK_FADE_TIME ; for ( j = 0 ; j < mp -> poly . numVerts ; j ++ ) { mp -> verts [ j ] . modulate [ 0 ] = mp -> color [ 0 ] * f ; mp -> verts [ j ] . modulate [ 1 ] = mp -> color [ 1 ] * f ; mp -> verts [ j ] . modulate [ 2 ] = mp -> color [ 2 ] * f ; } } } else { for ( j = 0 ; j < mp -> poly . numVerts ; j ++ ) { mp -> verts [ j ] . modulate [ 0 ] = mp -> color [ 0 ] ; mp -> verts [ j ] . modulate [ 1 ] = mp -> color [ 1 ] ; mp -> verts [ j ] . modulate [ 2 ] = mp -> color [ 2 ] ; } } cgi_R_AddPolyToScene ( mp -> markShader , mp -> poly . numVerts , mp -> verts ) ; } }
// ▁ Copyright ▁ 2002 ▁ The ▁ Trustees ▁ of ▁ Indiana ▁ University . ENDCOM // ▁ Use , ▁ modification ▁ and ▁ distribution ▁ is ▁ subject ▁ to ▁ the ▁ Boost ▁ Software ▁ ENDCOM // ▁ License , ▁ Version ▁ 1.0 . ▁ ( See ▁ accompanying ▁ file ▁ LICENSE _ 1_0 . txt ▁ or ▁ copy ▁ at ENDCOM // ▁ http : // www . boost . org / LICENSE _ 1_0 . txt ) ENDCOM // ▁ Boost . MultiArray ▁ Library ENDCOM // ▁ Authors : ▁ Ronald ▁ Garcia ENDCOM // ▁ Jeremy ▁ Siek ENDCOM // ▁ Andrew ▁ Lumsdaine ENDCOM // ▁ See ▁ http : // www . boost . org / libs / multi _ array ▁ for ▁ documentation . ENDCOM int main ( ) { using boost :: extents ; using boost :: indices ; typedef boost :: multi_array < int , 3 > array ; int data [ ] = { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 } ; const int data_size = 24 ; array myarray ( extents [ 2 ] [ 3 ] [ 4 ] ) ; myarray . assign ( data , data + data_size ) ; // ▁ array _ view ▁ dims : ENDCOM // ▁ [ base , stride , bound ) ENDCOM // ▁ [ 0,1,2 ) , ▁ [ 1,1,3 ) , ▁ [ 0,2,4 ) ▁ ENDCOM typedef boost :: multi_array_types :: index_range range ; array :: array_view < 3 > :: type myview = myarray [ indices [ range ( 0 , 2 ) ] [ range ( 1 , 3 ) ] [ range ( 0 , 4 , 2 ) ] ] ; for ( array :: index i = 0 ; i != 2 ; ++ i ) for ( array :: index j = 0 ; j != 2 ; ++ j ) for ( array :: index k = 0 ; k != 2 ; ++ k ) assert ( myview [ i ] [ j ] [ k ] == myarray [ i ] [ j + 1 ] [ k * 2 ] ) ; return boost :: exit_success ; }
// AnimatCarlSim ENDCOM extern " C " __declspec ( dllexport ) IStdClassFactory * __cdecl GetStdClassFactory ( ) extern " C " IStdClassFactory * GetStdClassFactory ( ) { IStdClassFactory * lpFactory = new CsClassFactory ; return lpFactory ; }
int main ( ) { :: input_event buf [ 32 ] ; ( void ) buf ; return 0 ; }
extern __value_in_regs struct __initial_stackheap __user_setup_stackheap ( uint32_t R0 , uint32_t R1 , uint32_t R2 , uint32_t R3 ) { struct __initial_stackheap r ; r . heap_base = ( uint32_t ) Image$$ARM_LIB_HEAP$$Base ; r . heap_limit = ( uint32_t ) Image$$ARM_LIB_HEAP$$ZI$$Limit ; return r ; }
private : bool CanBuild ( Creature * creature ) { Battlefield * wintergrasp = sBattlefieldMgr -> GetBattlefieldByBattleId ( BATTLEFIELD_BATTLEID_WG ) ; if ( ! wintergrasp ) return false ; switch ( creature -> GetEntry ( ) ) { case NPC_GOBLIN_MECHANIC : return ( wintergrasp -> GetData ( BATTLEFIELD_WG_DATA_MAX_VEHICLE_H ) > wintergrasp -> GetData ( BATTLEFIELD_WG_DATA_VEHICLE_H ) ) ; case NPC_GNOMISH_ENGINEER : return ( wintergrasp -> GetData ( BATTLEFIELD_WG_DATA_MAX_VEHICLE_A ) > wintergrasp -> GetData ( BATTLEFIELD_WG_DATA_VEHICLE_A ) ) ; default : return false ; } }
void saveFile ( std :: string filename , std :: vector < std :: string > lines ) { std :: ofstream save ; save . open ( filename . c_str ( ) ) ; for ( int i = 0 ; i < lines . size ( ) ; i ++ ) { save << lines [ i ] << std :: endl ; } save . close ( ) ; }
// ▁ Copyright ▁ John ▁ Maddock ▁ 2006 . ENDCOM // ▁ Use , ▁ modification ▁ and ▁ distribution ▁ are ▁ subject ▁ to ▁ the ENDCOM // ▁ Boost ▁ Software ▁ License , ▁ Version ▁ 1.0 . ▁ ( See ▁ accompanying ▁ file ENDCOM // ▁ LICENSE _ 1_0 . txt ▁ or ▁ copy ▁ at ▁ http : // www . boost . org / LICENSE _ 1_0 . txt ) ENDCOM // ▁ Basic ▁ sanity ▁ check ▁ that ▁ header ▁ < boost / math / special _ functions / hypot . hpp > ENDCOM // ▁ # includes ▁ all ▁ the ▁ files ▁ that ▁ it ▁ needs ▁ to . ENDCOM // ▁ Note ▁ this ▁ header ▁ includes ▁ no ▁ other ▁ headers , ▁ this ▁ is ENDCOM // ▁ important ▁ if ▁ this ▁ test ▁ is ▁ to ▁ be ▁ meaningful : ENDCOM void compile_and_link_test ( ) { check_result < float > ( boost :: math :: hypot < float > ( f , f ) ) ; check_result < double > ( boost :: math :: hypot < double > ( d , d ) ) ; check_result < long double > ( boost :: math :: hypot < long double > ( l , l ) ) ; }
int System_GetPropertyInt ( SystemProperty prop ) { return - 1 ; }
// ▁ asin ▁ acos ▁ atan : ▁ https : // github . com / michaldrobot / ShaderFastLibs / blob / master / ShaderFastMathLib . h ENDCOM // ▁ TODO : ENDCOM // ▁ Fast ▁ approximate ▁ sincos ▁ for ▁ NEON ENDCOM // ▁ http : // blog . julien . cayzac . name / 2009/12 / fast - sinecosine - for - armv7neon . html ENDCOM // ▁ Fast ▁ sincos ENDCOM // ▁ http : // www . dspguru . com / dsp / tricks / parabolic - approximation - of - sin - and - cos ENDCOM // ▁ minimax ▁ ( surprisingly ▁ terrible ! ▁ something ▁ must ▁ be ▁ wrong ) ENDCOM // ▁ double ▁ asin _ plus _ sqrtthing ▁ = ▁ . 9998421793 ▁ + ▁ ( 1.012386649 ▁ + ▁ ( - . 6575341673 ▁ + ▁ . 8999841642 ▁ + ▁ ( -1.669668977 ▁ + ▁ ( 1.571945105 ▁ - ▁ . 5860008052 ▁ * ▁ x ) ▁ * ▁ x ) ▁ * ▁ x ) ▁ * ▁ x ) ▁ * ▁ x ; ENDCOM // ▁ VERY ▁ good . ▁ 6 ▁ MAD , ▁ one ▁ division . ENDCOM // ▁ double ▁ asin _ plus _ sqrtthing ▁ = ▁ ( 1.807607311 ▁ + ▁ ( .191900116 ▁ + ▁ ( -2.511278506 ▁ + ▁ ( 1.062519236 ▁ + ▁ ( - . 3572142480 ▁ + ▁ . 1087063463 ▁ * ▁ x ) ▁ * ▁ x ) ▁ * ▁ x ) ▁ * ▁ x ) ▁ * ▁ x ) ▁ / ▁ ( 1.807601897 ▁ - ▁ 1.615203794 ▁ * ▁ x ) ; ENDCOM // ▁ float ▁ asin _ plus _ sqrtthing _ correct _ ends ▁ = ENDCOM // ▁ TABSYMBOL ( 1.807607311f ▁ + ▁ ( .191900116f ▁ + ▁ ( -2.511278506f ▁ + ▁ ( 1.062519236f ▁ + ▁ ( - . 3572142480f ▁ + ▁ . 1087063463f ▁ * ▁ x ) ▁ * ▁ x ) ▁ * ▁ x ) ▁ * ▁ x ) ▁ * ▁ x ) ▁ / ▁ ( 1.807607311f ▁ - ▁ 1.615195094 ▁ * ▁ x ) ; ENDCOM // ▁ Unfortunately ▁ this ▁ is ▁ very ▁ serial . ENDCOM // ▁ At ▁ least ▁ there ▁ are ▁ only ▁ 8 ▁ constants ▁ needed ▁ - ▁ load ▁ them ▁ into ▁ two ▁ low ▁ quads ▁ and ▁ go ▁ to ▁ town . ENDCOM // ▁ For ▁ every ▁ step , ▁ VDUP ▁ the ▁ constant ▁ into ▁ a ▁ new ▁ register ▁ ( out ▁ of ▁ two ▁ alternating ) , ▁ then ▁ VMLA ▁ or ▁ VFMA ▁ into ▁ it . ENDCOM // ▁ http : // www . ecse . rpi . edu / ~ wrf / Research / Short _ Notes / arcsin / ENDCOM // ▁ minimax ▁ polynomial ▁ rational ▁ approx , ▁ pretty ▁ good , ▁ get ▁ four ▁ digits ▁ consistently . ENDCOM // ▁ unfortunately ▁ fastasin ( 1.0 ) ▁ / ▁ M _ PI _ 2 ▁ ! = ▁ 1.0f , ▁ but ▁ it ' s ▁ pretty ▁ close . ENDCOM float fastasin ( double x ) { float sign = x >= 0.0f ? 1.0f : - 1.0f ; x = fabs ( x ) ; float sqrtthing = sqrt ( 1.0f - x * x ) ; // ▁ note ▁ that ▁ the ▁ sqrt ▁ can ▁ run ▁ parallel ▁ while ▁ we ▁ do ▁ the ▁ rest ENDCOM // ▁ if ▁ the ▁ hardware ▁ supports ▁ it ENDCOM float y = - .3572142480f + .1087063463f * x ; y = y * x + 1.062519236f ; y = y * x + - 2.511278506f ; y = y * x + .191900116f ; y = y * x + 1.807607311f ; y /= ( 1.807607311f - 1.615195094 * x ) ; return sign * ( y - sqrtthing ) ; }
double atan_66s ( double x ) { const double c1 = 1.6867629106 ; const double c2 = 0.4378497304 ; const double c3 = 1.6867633134 ; double x2 ; // ▁ The ▁ input ▁ argument ▁ squared ENDCOM x2 = x * x ; return ( x * ( c1 + x2 * c2 ) / ( c3 + x2 ) ) ; }
// ▁ Terrible . ENDCOM double fastasin2 ( double x ) { return atan_66s ( x / sqrt ( 1 - x * x ) ) ; }
// ▁ Also ▁ terrible . ENDCOM float fastasin3 ( float x ) { return x + x * x * x * x * x * 0.4971 ; }
// ▁ Great ! ▁ This ▁ is ▁ the ▁ one ▁ we ' ll ▁ use . ▁ Can ▁ be ▁ easily ▁ rescaled ▁ to ▁ get ▁ the ▁ right ▁ range ▁ for ▁ free . ENDCOM // ▁ http : // mathforum . org / library / drmath / view / 54137 . html ENDCOM // ▁ http : // www . musicdsp . org / showone . php ? id = 115 ENDCOM float fastasin4 ( float x ) { float sign = x >= 0.0f ? 1.0f : - 1.0f ; x = fabs ( x ) ; x = M_PI / 2 - sqrtf ( 1.0f - x ) * ( 1.5707288 + - 0.2121144 * x + 0.0742610 * x * x + - 0.0187293 * x * x * x ) ; return sign * x ; }
// ▁ Or ▁ this : ENDCOM float fastasin5 ( float x ) { float sign = x >= 0.0f ? 1.0f : - 1.0f ; x = fabs ( x ) ; float fRoot = sqrtf ( 1.0f - x ) ; float fResult = 0.0742610f + - 0.0187293f * x ; fResult = - 0.2121144f + fResult * x ; fResult = 1.5707288f + fResult * x ; fResult = M_PI / 2 - fRoot * fResult ; return sign * fResult ; }
