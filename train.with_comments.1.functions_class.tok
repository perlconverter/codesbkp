CMaze :: CMaze ( int nWidth , int nHeight , int nCellWidth , int nCellHeight , bool bCopyScreen ) { m_nCounter = 0 ; m_nWidth = nWidth ; m_nHeight = nHeight ; m_nCellWidth = nCellWidth ; m_nCellHeight = nCellHeight ; m_nCols = m_nWidth / m_nCellWidth - 1 ; m_nRows = m_nHeight / m_nCellHeight - 1 ; m_nOffsetX = ( m_nWidth - m_nCols * m_nCellWidth ) / 2 ; m_nOffsetY = ( m_nHeight - m_nRows * m_nCellHeight ) / 2 ; m_bReDrawBeforeGenerate = FALSE ; m_bAllowNonSolution = FALSE ; m_bFlashPath = TRUE ; // ▁ m _ nOffsetX ▁ = ▁ 2 ; ENDCOM // ▁ m _ nOffsetY ▁ = ▁ 2 ; ENDCOM HDC hScreenDc = GetDC ( NULL ) ; m_hWorkDc = CreateCompatibleDC ( NULL ) ; m_hWorkBmp = CreateCompatibleBitmap ( hScreenDc , m_nWidth , m_nHeight ) ; m_hOldBmp = SelectObject ( m_hWorkDc , ( HGDIOBJ ) m_hWorkBmp ) ; m_hOldPen = SelectObject ( m_hWorkDc , m_mazeColor . GetPen ( clWall ) ) ; if ( bCopyScreen ) { BitBlt ( m_hWorkDc , 0 , 0 , m_nWidth , m_nHeight , hScreenDc , 0 , 0 , SRCCOPY ) ; } ReleaseDC ( NULL , hScreenDc ) ; RECT rect = { 0 , 0 , m_nWidth , m_nHeight } ; FillRect ( m_hWorkDc , & rect , m_mazeColor . GetBrush ( clBackGround ) ) ; if ( m_nCols > 0 && m_nRows > 0 ) { m_cells = new CMazeCell [ m_nCols * m_nRows ] ; InitializeCells ( ) ; ResetAndReDrawAllCells ( ) ; m_state = MS_INITIALIZED ; } else { m_state = MS_ERROR ; m_cells = NULL ; } }
CMaze :: ~ CMaze ( void ) { SelectObject ( m_hWorkDc , m_hOldPen ) ; SelectObject ( m_hWorkDc , m_hOldBmp ) ; DeleteDC ( m_hWorkDc ) ; DeleteObject ( m_hWorkBmp ) ; if ( m_cells != NULL ) { delete [ ] m_cells ; } }
CMazeCell * CMaze :: GetCell ( int i , int j ) { if ( i < 0 || j < 0 || i >= m_nCols || j >= m_nRows ) { return NULL ; } return & m_cells [ j * m_nCols + i ] ; }
void CMaze :: InitializeCells ( ) { for ( int i = 0 ; i < m_nCols ; ++ i ) { for ( int j = 0 ; j < m_nRows ; ++ j ) { CMazeCell * pCell = GetCell ( i , j ) ; pCell -> SetParent ( this , i , j ) ; } } }
void CMaze :: ReDrawSides ( ) { int nPicWidth = m_nCols * m_nCellWidth ; int nPicHeight = m_nRows * m_nCellHeight ; MoveToEx ( m_hWorkDc , m_nOffsetX , m_nOffsetY , NULL ) ; LineTo ( m_hWorkDc , m_nOffsetX + nPicWidth , m_nOffsetY ) ; LineTo ( m_hWorkDc , m_nOffsetX + nPicWidth , m_nOffsetY + nPicHeight ) ; LineTo ( m_hWorkDc , m_nOffsetX , m_nOffsetY + nPicHeight ) ; LineTo ( m_hWorkDc , m_nOffsetX , m_nOffsetY ) ; }
void CMaze :: ResetAllCells ( ) { for ( int i = 0 ; i < m_nCols ; ++ i ) { for ( int j = 0 ; j < m_nRows ; ++ j ) { CMazeCell * pCell = GetCell ( i , j ) ; pCell -> Reset ( ) ; } } }
void CMaze :: ResetAndReDrawAllCells ( ) { for ( int i = 0 ; i < m_nCols ; ++ i ) { for ( int j = 0 ; j < m_nRows ; ++ j ) { CMazeCell * pCell = GetCell ( i , j ) ; pCell -> Reset ( ) ; pCell -> ReDraw ( ) ; } } ReDrawSides ( ) ; }
void CMaze :: ReDrawAllCells ( ) { for ( int i = 0 ; i < m_nCols ; ++ i ) { for ( int j = 0 ; j < m_nRows ; ++ j ) { CMazeCell * pCell = GetCell ( i , j ) ; pCell -> ReDraw ( ) ; } } ReDrawSides ( ) ; }
void CMaze :: Next ( BOOL bDelay ) { DWORD dwDelayValue = 0 ; switch ( m_state ) { case MS_INITIALIZED : m_cellGenerating = GetRandomCell ( ) ; m_cellStack . Init ( ) ; m_cellStack . Push ( m_cellGenerating ) ; m_cellGenerating -> m_bGenerated = true ; ChangeState ( MS_GENERATING ) ; break ; case MS_GENERATING : if ( m_cellStack . IsEmpty ( ) ) { ChangeState ( MS_GENERATED ) ; } else { bool bGetNewCell = false ; CMazeCell * pTopCell = m_cellStack . Top ( ) ; pTopCell -> ReDraw ( ) ; pTopCell -> GoGenerate ( & bGetNewCell ) ; if ( bGetNewCell ) { // dwDelayValue ▁ = ▁ 1 ; ENDCOM } } break ; case MS_GENERATED : // ▁ Ëæ » ú ´ òÂÒÒ » Ð © Ç½Ãæ ENDCOM if ( m_bAllowNonSolution && m_nRows * m_nCols >= 10 && m_nCols > 1 && m_nRows > 1 ) { int nRightWallsCount = ( m_nCols - 1 ) * m_nRows ; int nBottomWallsCount = ( m_nRows - 1 ) * m_nCols ; int nWallsCount = nRightWallsCount + nBottomWallsCount ; int nChangedWallsCount = nWallsCount * 2 / 100 ; set < int > setChangedWalls ; vector < int > vectorChangedWalls ; if ( nChangedWallsCount > 100 ) { // ▁ µ ÷ ÕûµÄÇ½Ãæ² » ÒË¹ý ¶ à £ ¬ · ñÔò × ÜÊÇÎÞ½â ENDCOM nChangedWallsCount = 100 ; } while ( ( int ) setChangedWalls . size ( ) < nChangedWallsCount ) { setChangedWalls . insert ( BigRand ( ) % nWallsCount ) ; } vectorChangedWalls . assign ( setChangedWalls . begin ( ) , setChangedWalls . end ( ) ) ; random_shuffle ( vectorChangedWalls . begin ( ) , vectorChangedWalls . end ( ) ) ; for ( int i = 0 ; i < nChangedWallsCount ; ++ i ) { int nOffset = vectorChangedWalls . at ( i ) ; if ( nOffset < nRightWallsCount ) { int nRow = nOffset / ( m_nCols - 1 ) ; int nCol = nOffset % ( m_nCols - 1 ) ; CMazeCell * pCell = GetCell ( nCol , nRow ) ; pCell -> SetWall ( DIR_RIGHT , ! pCell -> GetWall ( DIR_RIGHT ) ) ; } else { nOffset -= nRightWallsCount ; int nRow = nOffset / m_nCols ; int nCol = nOffset % m_nCols ; CMazeCell * pCell = GetCell ( nCol , nRow ) ; pCell -> SetWall ( DIR_BOTTOM , ! pCell -> GetWall ( DIR_BOTTOM ) ) ; } } } ReDrawAllCells ( ) ; ChangeState ( MS_SETTING ) ; break ; case MS_SETTING : if ( true ) { int nCounter = GetCounter ( ) ; if ( nCounter == 0 ) { if ( rand ( ) % 5 == 0 ) { int bx [ ] = { 0 , 0 , 1 , 1 } ; int by [ ] = { 0 , 1 , 0 , 1 } ; int ex [ ] = { 1 , 1 , 0 , 0 } ; int ey [ ] = { 1 , 0 , 1 , 0 } ; int offset = rand ( ) % 4 ; m_cellBegin = GetCell ( ( GetCols ( ) - 1 ) * bx [ offset ] , ( GetRows ( ) - 1 ) * by [ offset ] ) ; m_cellEnd = GetCell ( ( GetCols ( ) - 1 ) * ex [ offset ] , ( GetRows ( ) - 1 ) * ey [ offset ] ) ; } else { m_cellBegin = GetRandomCell ( ) ; do { m_cellEnd = GetRandomCell ( ) ; } while ( m_cellEnd == m_cellBegin ) ; } m_cellBegin -> m_bIsBegin = true ; m_cellEnd -> m_bIsEnd = true ; } else if ( nCounter < 19 ) { m_cellBegin -> m_bIsBegin = ! m_cellBegin -> m_bIsBegin ; m_cellBegin -> ReDraw ( ) ; dwDelayValue = 55 ; } else if ( nCounter < 37 ) { m_cellEnd -> m_bIsEnd = ! m_cellEnd -> m_bIsEnd ; m_cellEnd -> ReDraw ( ) ; dwDelayValue = 55 ; } else { ChangeState ( MS_SET ) ; } } break ; case MS_SET : m_cellStack . Init ( ) ; m_cellStack . Push ( m_cellBegin ) ; m_cellBegin -> m_bVisited = true ; ChangeState ( MS_RESOLVING ) ; break ; case MS_RESOLVING : if ( m_cellStack . IsEmpty ( ) ) { ChangeState ( MS_RESOLVEFAILED ) ; } else { bool bGetNewCell = false ; CMazeCell * pTopCell = m_cellStack . Top ( ) ; pTopCell -> ReDraw ( ) ; if ( pTopCell == m_cellEnd ) { ChangeState ( MS_RESOLVED ) ; break ; } pTopCell -> GoResolve ( & bGetNewCell ) ; if ( bGetNewCell ) { // dwDelayValue ▁ = ▁ 1 ; ENDCOM } } dwDelayValue = 10 ; break ; case MS_RESOLVED : { int nCounter = GetCounter ( ) ; if ( nCounter > 5 ) { if ( m_bReDrawBeforeGenerate ) { ResetAndReDrawAllCells ( ) ; } else { ResetAllCells ( ) ; } ChangeState ( MS_INITIALIZED ) ; } else { if ( m_bFlashPath ) { COLORREF cl = m_mazeColor . GetColor ( clVisited ) ; m_mazeColor . SetColor ( clVisited , GetReverseColor ( cl ) ) ; ReDrawAllCells ( ) ; } dwDelayValue = 500 ; } } break ; case MS_RESOLVEFAILED : dwDelayValue = 3000 ; if ( m_bReDrawBeforeGenerate ) { ResetAndReDrawAllCells ( ) ; } else { ResetAllCells ( ) ; } ChangeState ( MS_INITIALIZED ) ; case MS_PAUSED : break ; case MS_ERROR : break ; default : break ; } if ( bDelay && dwDelayValue > 0 ) { Sleep ( dwDelayValue ) ; } }
CMazeColor & CMaze :: GetColorManager ( ) { return m_mazeColor ; }
CMazeCell * CMaze :: GetRandomCell ( ) { return GetCell ( rand ( ) % m_nCols , rand ( ) % m_nRows ) ; }
void CMaze :: MakeRandomBeginAndEndCell ( ) { m_cellBegin = GetRandomCell ( ) ; m_cellEnd = GetRandomCell ( ) ; while ( m_cellEnd == m_cellBegin ) { m_cellEnd = GetRandomCell ( ) ; } }
CMazeCellStack & CMaze :: GetCellStack ( ) { return m_cellStack ; }
void CMaze :: ChangeState ( MazeState state ) { if ( m_state != state ) { m_state = state ; m_nCounter = 0 ; } }
int CMaze :: GetCounter ( ) { return m_nCounter ++ ; }
int CMaze :: BigRand ( ) { return ( ( ( rand ( ) % 0x100 ) << 0 ) | ( ( rand ( ) % 0x100 ) << 8 ) | ( ( rand ( ) % 0x100 ) << 16 ) | ( ( rand ( ) % 0x100 ) << 24 ) ) & ( ( unsigned ) - 1 >> 1 ) ; }
COLORREF CMaze :: GetReverseColor ( COLORREF cl ) { return RGB ( ~ GetRValue ( cl ) , ~ GetGValue ( cl ) , ~ GetBValue ( cl ) ) ; }
void CMaze :: SetReDrawBeforeGenerate ( BOOL bReDrawBeforeGenerate ) { m_bReDrawBeforeGenerate = bReDrawBeforeGenerate ; }
void CMaze :: SetAllowNonSolution ( BOOL bAllowNonSolution ) { m_bAllowNonSolution = bAllowNonSolution ; }
void CMaze :: SetFlashPath ( BOOL bFlashPath ) { m_bFlashPath = bFlashPath ; }
void CMaze :: UpdateColors ( ) { SelectObject ( m_hWorkDc , m_mazeColor . GetPen ( clWall ) ) ; }
void CMaze :: Restart ( ) { if ( m_bReDrawBeforeGenerate ) { ResetAndReDrawAllCells ( ) ; } else { ResetAllCells ( ) ; } ChangeState ( MS_INITIALIZED ) ; }
GameLobbyStage :: GameLobbyStage ( ) { networkconnection = nullptr ; currentinfo = new GameInfo ( true ) ; selection = 0 ; selectionteamisblue = true ; }
GameLobbyStage :: GameLobbyStage ( Network * Connection ) { selection = 0 ; networkconnection = Connection ; currentinfo = new GameInfo ( Connection -> IsServer ( ) ) ; if ( ! Connection -> IsServer ( ) ) { // ▁ TODO : ▁ Request ▁ gameinfo ▁ from ▁ server ENDCOM } }
void GameLobbyStage :: Begin ( ) { optionfont = FontCache :: LoadFont ( " resources / armalite . ttf " , 32 ) ; helpfont = FontCache :: LoadFont ( " resources / armalite . ttf " , 16 ) ; // ▁ AUDIO - > PlayMusic ( ▁ " resources / Paul ▁ Hannay ▁ ( Feekzoid ) ▁ - ▁ Last _ Ninja _ 4 _ loader ▁ [ 1 ] . ogg " , ▁ true ▁ ) ; ENDCOM }
void GameLobbyStage :: Finish ( ) { AUDIO -> StopMusic ( ) ; if ( networkconnection != nullptr ) { delete networkconnection ; networkconnection = nullptr ; } }
void GameLobbyStage :: EventOccurred ( Event * e ) { InputItems :: ItemSet inputevent = InputItems :: NONE ; if ( e -> Type == EVENT_KEY_DOWN ) { if ( e -> Data . Keyboard . KeyCode == ALLEGRO_KEY_ESCAPE ) { delete FRAMEWORK -> ProgramStages -> Pop ( ) ; return ; } inputevent = Input :: GetItemFromEvent ( e ) ; } if ( e -> Type == EVENT_JOYSTICK_BUTTON_DOWN && inputevent == InputItems :: NONE ) { inputevent = Input :: GetItemFromEvent ( e ) ; } if ( inputevent != InputItems :: NONE ) { InputEvent ( inputevent ) ; } NetworkEvent ( e ) ; }
void GameLobbyStage :: InputEvent ( InputItems :: ItemSet inputevent ) { switch ( inputevent ) { case InputItems :: UP : if ( selection > 0 ) { selection -- ; } break ; case InputItems :: DOWN : if ( selection < 2 ) { selection ++ ; } break ; case InputItems :: LEFT : selectionteamisblue = true ; break ; case InputItems :: RIGHT : selectionteamisblue = false ; break ; case InputItems :: SELECT : delete FRAMEWORK -> ProgramStages -> Pop ( ) ; return ; break ; case InputItems :: X : if ( networkconnection == nullptr ) { PlayerInfo * p = nullptr ; if ( selectionteamisblue ) { if ( currentinfo -> BlueTeam [ selection ] == nullptr ) { currentinfo -> BlueTeam [ selection ] = new PlayerInfo ( " " , true , false ) ; } p = currentinfo -> BlueTeam [ selection ] ; } else { if ( currentinfo -> RedTeam [ selection ] == nullptr ) { currentinfo -> RedTeam [ selection ] = new PlayerInfo ( " " , true , false ) ; } p = currentinfo -> RedTeam [ selection ] ; } p -> BlueTeam = selectionteamisblue ; p -> TeamIndex = selection ; p -> GameData = currentinfo ; FRAMEWORK -> ProgramStages -> Push ( new GameLobbyAddLocalStage ( p ) ) ; } break ; case InputItems :: B : if ( networkconnection == nullptr ) { PlayerInfo * p = nullptr ; if ( selectionteamisblue ) { if ( currentinfo -> BlueTeam [ selection ] == nullptr ) { p = new PlayerInfo ( " CPU " , true , true ) ; currentinfo -> BlueTeam [ selection ] = p ; } } else { if ( currentinfo -> RedTeam [ selection ] == nullptr ) { p = new PlayerInfo ( " CPU " , true , true ) ; currentinfo -> RedTeam [ selection ] = p ; } } if ( p != nullptr ) { p -> BlueTeam = selectionteamisblue ; p -> TeamIndex = selection ; p -> GameData = currentinfo ; } } break ; case InputItems :: Y : if ( networkconnection == nullptr || networkconnection -> IsServer ( ) ) { PlayerInfo * p = nullptr ; if ( selectionteamisblue ) { p = currentinfo -> BlueTeam [ selection ] ; currentinfo -> BlueTeam [ selection ] = nullptr ; } else { p = currentinfo -> RedTeam [ selection ] ; currentinfo -> RedTeam [ selection ] = nullptr ; } if ( p != nullptr ) { if ( ! p -> Local ) { // ▁ TODO : ▁ Disconnect ENDCOM } delete p ; } } break ; case InputItems :: START : if ( networkconnection == nullptr || networkconnection -> IsServer ( ) ) { // ▁ TODO : ▁ Tell ▁ clients ▁ to ▁ start ▁ the ▁ game ENDCOM GameStage * g = new GameStage ( currentinfo ) ; delete FRAMEWORK -> ProgramStages -> Pop ( ) ; FRAMEWORK -> ProgramStages -> Push ( g ) ; } break ; } }
void GameLobbyStage :: NetworkEvent ( Event * e ) { if ( e -> Type == EVENT_NETWORK_CONNECTION_REQUEST ) { bool freeslot = false ; for ( int i = 0 ; i < 3 ; i ++ ) { freeslot = ( currentinfo -> BlueTeam [ i ] == nullptr ? true : freeslot ) ; freeslot = ( currentinfo -> RedTeam [ i ] == nullptr ? true : freeslot ) ; } if ( freeslot ) { // ▁ TODO : ▁ Accept ▁ player ▁ and ▁ balance ▁ teams ENDCOM } } if ( e -> Type == EVENT_NETWORK_CONNECTED ) { // ▁ TODO : ▁ Send ▁ current ▁ game ▁ info ENDCOM } if ( e -> Type == EVENT_NETWORK_DISCONNECTED ) { // ▁ TODO : ▁ Remove ▁ disconnected ▁ users ENDCOM } if ( e -> Type == EVENT_NETWORK_PACKET_RECEIVED ) { // ▁ TODO : ▁ Process ▁ packet ▁ info ENDCOM } }
void GameLobbyStage :: Render ( ) { al_clear_to_color ( al_map_rgb ( 255 , 220 , 128 ) ) ; optionfont -> DrawString ( ( DISPLAY -> GetWidth ( ) / 2 ) + 2 , 12 , " Lobby " , FontHAlign :: CENTRE , al_map_rgb ( 0 , 0 , 0 ) ) ; optionfont -> DrawString ( ( DISPLAY -> GetWidth ( ) / 2 ) , 10 , " Lobby " , FontHAlign :: CENTRE , al_map_rgb ( 255 , 255 , 0 ) ) ; GameResources :: DrawPanel ( GameResources :: BluePanel , 5 , 80 , 13 , 8 , 8 ) ; optionfont -> DrawString ( 15 , 85 , " Blue ▁ Team " , FontHAlign :: LEFT , al_map_rgb ( 255 , 255 , 255 ) ) ; RenderPlayerSlot ( true , 0 , 15 , 140 ) ; RenderPlayerSlot ( true , 1 , 15 , 192 ) ; RenderPlayerSlot ( true , 2 , 15 , 244 ) ; GameResources :: DrawPanel ( GameResources :: RedPanel , 405 , 80 , 13 , 8 , 8 ) ; optionfont -> DrawString ( 415 , 85 , " Red ▁ Team " , FontHAlign :: LEFT , al_map_rgb ( 255 , 255 , 255 ) ) ; RenderPlayerSlot ( false , 0 , 415 , 140 ) ; RenderPlayerSlot ( false , 1 , 415 , 192 ) ; RenderPlayerSlot ( false , 2 , 415 , 244 ) ; int textoff = ( 50 - helpfont -> GetFontHeight ( ) ) / 2 ; if ( networkconnection == nullptr ) { // ▁ Add ▁ Local ▁ Player ENDCOM al_draw_bitmap ( Input :: GetIcon ( InputItems :: X ) , 10 , 320 , 0 ) ; helpfont -> DrawString ( 64 , 320 + textoff , " Add ▁ Local ▁ Player " , FontHAlign :: LEFT , al_map_rgb ( 0 , 0 , 0 ) ) ; // ▁ Add ▁ AI ENDCOM al_draw_bitmap ( Input :: GetIcon ( InputItems :: B ) , 10 , 370 , 0 ) ; helpfont -> DrawString ( 64 , 370 + textoff , " Add ▁ CPU ▁ Player " , FontHAlign :: LEFT , al_map_rgb ( 0 , 0 , 0 ) ) ; } if ( networkconnection == nullptr || networkconnection -> IsServer ( ) ) { // ▁ Kick ▁ Player / AI ENDCOM al_draw_bitmap ( Input :: GetIcon ( InputItems :: Y ) , 10 , 420 , 0 ) ; helpfont -> DrawString ( 64 , 420 + textoff , " Kick ▁ Player " , FontHAlign :: LEFT , al_map_rgb ( 0 , 0 , 0 ) ) ; // ▁ Start ▁ game ENDCOM al_draw_bitmap ( Input :: GetIcon ( InputItems :: START ) , 500 , 370 , 0 ) ; helpfont -> DrawString ( 554 , 370 + textoff , " Start " , FontHAlign :: LEFT , al_map_rgb ( 0 , 0 , 0 ) ) ; } // ▁ Abort / Disconnect ENDCOM al_draw_bitmap ( Input :: GetIcon ( InputItems :: SELECT ) , 500 , 420 , 0 ) ; helpfont -> DrawString ( 554 , 420 + textoff , " Quit " , FontHAlign :: LEFT , al_map_rgb ( 0 , 0 , 0 ) ) ; }
bool GameLobbyStage :: IsTransition ( ) { return false ; }
void GameLobbyStage :: RenderPlayerSlot ( bool BlueTeam , int Index , int X , int Y ) { ButtonColours :: Colours colour = ButtonColours :: WHITE ; bool btnup = false ; PlayerInfo * p = ( BlueTeam ? currentinfo -> BlueTeam [ Index ] : currentinfo -> RedTeam [ Index ] ) ; if ( p != nullptr ) { colour = ( BlueTeam ? ButtonColours :: BLUE : ButtonColours :: RED ) ; } if ( networkconnection == nullptr || networkconnection -> IsServer ( ) ) { if ( selection == Index && selectionteamisblue == BlueTeam ) { colour = ButtonColours :: YELLOW ; btnup = true ; } } GameResources :: DrawButton ( colour , btnup , X , Y , 23 , 3 ) ; if ( p != nullptr ) { helpfont -> DrawString ( X + 184 , Y + 24 - ( helpfont -> GetFontHeight ( ) / 2 ) + ( ! btnup ? 4 : 0 ) , p -> Name , FontHAlign :: CENTRE , al_map_rgb ( 0 , 0 , 0 ) ) ; // ▁ helpfont - > DrawString ( ▁ X ▁ + ▁ 184 , ▁ Y ▁ + ▁ 24 ▁ - ▁ ( helpfont - > GetFontHeight ( ) ▁ / ▁ 2 ) ▁ + ▁ ( ! btnup ▁ ? ▁ 4 ▁ : ▁ 0 ) ▁ - ▁ 2 , ▁ p - > Name , ▁ FontHAlign : : CENTRE , ▁ al _ map _ rgb ( ▁ 255 , ▁ 255 , ▁ 255 ▁ ) ▁ ) ; ENDCOM } }
void ACE_Stream_Node :: apply ( ACE_Service_Gestalt * config , int & yyerrno ) { ACE_TRACE ( " ACE _ Stream _ Node : : apply " ) ; const ACE_Service_Type * sst = this -> node_ -> record ( config ) ; if ( sst == 0 ) const_cast < ACE_Static_Node * > ( this -> node_ ) -> apply ( config , yyerrno ) ; if ( yyerrno != 0 ) return ; sst = this -> node_ -> record ( config ) ; ACE_Stream_Type * st = dynamic_cast < ACE_Stream_Type * > ( const_cast < ACE_Service_Type_Impl * > ( sst -> type ( ) ) ) ; // ▁ The ▁ modules ▁ were ▁ linked ▁ as ▁ popped ▁ off ▁ the ▁ yacc ▁ stack , ▁ so ▁ they ' re ▁ in ENDCOM // ▁ reverse ▁ order ▁ from ▁ the ▁ way ▁ they ▁ should ▁ be ▁ pushed ▁ onto ▁ the ▁ stream . ENDCOM // ▁ So ▁ traverse ▁ mods _ ▁ and ▁ and ▁ reverse ▁ the ▁ list , ▁ then ▁ iterate ▁ over ▁ it ▁ to ▁ push ENDCOM // ▁ the ▁ modules ▁ in ▁ the ▁ stream ▁ in ▁ the ▁ correct ▁ order . ENDCOM std :: list < const ACE_Static_Node * > mod_list ; const ACE_Static_Node * module ; for ( module = dynamic_cast < const ACE_Static_Node * > ( this -> mods_ ) ; module != 0 ; module = dynamic_cast < ACE_Static_Node * > ( module -> link ( ) ) ) mod_list . push_front ( module ) ; std :: list < const ACE_Static_Node * > :: const_iterator iter ; for ( iter = mod_list . begin ( ) ; iter != mod_list . end ( ) ; ++ iter ) { module = * iter ; ACE_ARGV args ( module -> parameters ( ) ) ; const ACE_Service_Type * mst = module -> record ( config ) ; if ( mst == 0 ) const_cast < ACE_Static_Node * > ( module ) -> apply ( config , yyerrno ) ; if ( yyerrno != 0 ) { if ( ACE :: debug ( ) ) { ACE_ERROR ( ( LM_ERROR , ACE_TEXT ( " dynamic ▁ initialization ▁ failed ▁ for ▁ Module ▁ % s \n " ) , module -> name ( ) ) ) ; } ++ yyerrno ; continue ; // ▁ Don ' t ▁ try ▁ anything ▁ else ▁ with ▁ this ▁ one ENDCOM } ACE_Module_Type const * const mt1 = static_cast < ACE_Module_Type const * > ( module -> record ( config ) -> type ( ) ) ; ACE_Module_Type * mt = const_cast < ACE_Module_Type * > ( mt1 ) ; if ( st -> push ( mt ) == - 1 ) { if ( ACE :: debug ( ) ) { ACE_ERROR ( ( LM_ERROR , ACE_TEXT ( " dynamic ▁ initialization ▁ failed ▁ for ▁ Stream ▁ % s \n " ) , this -> node_ -> name ( ) ) ) ; } ++ yyerrno ; } } if ( ACE :: debug ( ) ) ACE_DEBUG ( ( LM_DEBUG , ACE_TEXT ( " ( % P | % t ) ▁ Did ▁ stream ▁ on ▁ % s , ▁ error ▁ = ▁ % d \n " ) , this -> node_ -> name ( ) , yyerrno ) ) ; /* ▁ ACE _ NLOGGING ▁ */ ENDCOM }
void ACE_Parse_Node :: link ( ACE_Parse_Node * n ) { ACE_TRACE ( " ACE _ Parse _ Node : : link " ) ; // ▁ Find ▁ the ▁ last ▁ list ▁ entry ▁ ( if ▁ any ) ▁ . . . ENDCOM ACE_Parse_Node * t = this ; while ( t -> next_ != 0 ) t = t -> next_ ; // ▁ . . . ▁ and ▁ insert ▁ n ▁ there . ENDCOM t -> next_ = n ; }
ACE_Stream_Node :: ACE_Stream_Node ( const ACE_Static_Node * str_ops , const ACE_Parse_Node * str_mods ) : ACE_Parse_Node ( ( str_ops == 0 ? ACE_TEXT ( " < unknown > " ) : str_ops -> name ( ) ) ) , node_ ( str_ops ) , mods_ ( str_mods ) { ACE_TRACE ( " ACE _ Stream _ Node : : ACE _ Stream _ Node " ) ; }
ACE_Stream_Node :: ~ ACE_Stream_Node ( void ) { ACE_TRACE ( " ACE _ Stream _ Node : : ~ ACE _ Stream _ Node " ) ; ACE_Static_Node * n = const_cast < ACE_Static_Node * > ( this -> node_ ) ; delete n ; ACE_Parse_Node * m = const_cast < ACE_Parse_Node * > ( this -> mods_ ) ; delete m ; }
ACE_Parse_Node :: ACE_Parse_Node ( void ) : name_ ( 0 ) , next_ ( 0 ) { ACE_TRACE ( " ACE _ Parse _ Node : : ACE _ Parse _ Node " ) ; }
ACE_Parse_Node :: ACE_Parse_Node ( const ACE_TCHAR * nm ) : name_ ( ACE :: strnew ( nm ) ) , next_ ( 0 ) { ACE_TRACE ( " ACE _ Parse _ Node : : ACE _ Parse _ Node " ) ; }
ACE_Parse_Node :: ~ ACE_Parse_Node ( void ) { ACE_TRACE ( " ACE _ Parse _ Node : : ~ ACE _ Parse _ Node " ) ; delete [ ] const_cast < ACE_TCHAR * > ( this -> name_ ) ; delete this -> next_ ; }
ACE_Suspend_Node :: ACE_Suspend_Node ( const ACE_TCHAR * name ) : ACE_Parse_Node ( name ) { ACE_TRACE ( " ACE _ Suspend _ Node : : ACE _ Suspend _ Node " ) ; }
ACE_Resume_Node :: ACE_Resume_Node ( const ACE_TCHAR * name ) : ACE_Parse_Node ( name ) { ACE_TRACE ( " ACE _ Resume _ Node : : ACE _ Resume _ Node " ) ; }
void ACE_Suspend_Node :: apply ( ACE_Service_Gestalt * config , int & yyerrno ) { ACE_TRACE ( " ACE _ Suspend _ Node : : apply " ) ; if ( config -> suspend ( this -> name ( ) ) == - 1 ) ++ yyerrno ; if ( ACE :: debug ( ) ) ACE_DEBUG ( ( LM_DEBUG , ACE_TEXT ( " did ▁ suspend ▁ on ▁ % s , ▁ error ▁ = ▁ % d \n " ) , this -> name ( ) , yyerrno ) ) ; /* ▁ ACE _ NLOGGING ▁ */ ENDCOM }
void ACE_Resume_Node :: apply ( ACE_Service_Gestalt * config , int & yyerrno ) { ACE_TRACE ( " ACE _ Resume _ Node : : apply " ) ; if ( config -> resume ( this -> name ( ) ) == - 1 ) ++ yyerrno ; if ( ACE :: debug ( ) ) ACE_DEBUG ( ( LM_DEBUG , ACE_TEXT ( " did ▁ resume ▁ on ▁ % s , ▁ error ▁ = ▁ % d \n " ) , this -> name ( ) , yyerrno ) ) ; /* ▁ ACE _ NLOGGING ▁ */ ENDCOM }
ACE_Remove_Node :: ACE_Remove_Node ( const ACE_TCHAR * name ) : ACE_Parse_Node ( name ) { ACE_TRACE ( " ACE _ Remove _ Node : : ACE _ Remove _ Node " ) ; }
void ACE_Remove_Node :: apply ( ACE_Service_Gestalt * config , int & yyerrno ) { ACE_TRACE ( " ACE _ Remove _ Node : : apply " ) ; if ( config -> remove ( this -> name ( ) ) == - 1 ) ++ yyerrno ; if ( ACE :: debug ( ) ) ACE_DEBUG ( ( LM_DEBUG , ACE_TEXT ( " ACE ▁ ( % P | % t ) ▁ Remove _ Node : : apply " ) ACE_TEXT ( " ▁ - ▁ did ▁ remove ▁ on ▁ % s , ▁ error ▁ = ▁ % d \n " ) , this -> name ( ) , yyerrno ) ) ; /* ▁ ACE _ NLOGGING ▁ */ ENDCOM }
ACE_Dynamic_Node :: ACE_Dynamic_Node ( ACE_Service_Type_Factory const * stf , ACE_TCHAR * parms ) : ACE_Static_Node ( stf -> name ( ) , parms ) , factory_ ( stf ) { ACE_TRACE ( " ACE _ Dynamic _ Node : : ACE _ Dynamic _ Node " ) ; }
void ACE_Dynamic_Node :: apply ( ACE_Service_Gestalt * config , int & yyerrno ) { ACE_TRACE ( " ACE _ Dynamic _ Node : : apply " ) ; if ( config -> initialize ( this -> factory_ . get ( ) , this -> parameters ( ) ) == - 1 ) ++ yyerrno ; if ( ACE :: debug ( ) ) ACE_DEBUG ( ( LM_DEBUG , ACE_TEXT ( " ACE ▁ ( % P | % t ) ▁ Dynamic _ Node : : apply " ) ACE_TEXT ( " ▁ - ▁ Did ▁ dynamic ▁ on ▁ % s ▁ ( yyerrno = % d ) \n " ) , this -> name ( ) , yyerrno ) ) ; /* ▁ ACE _ NLOGGING ▁ */ ENDCOM }
ACE_Dynamic_Node :: ~ ACE_Dynamic_Node ( void ) { ACE_TRACE ( " ACE _ Dynamic _ Node : : ~ ACE _ Dynamic _ Node " ) ; }
ACE_Static_Node :: ACE_Static_Node ( const ACE_TCHAR * nm , ACE_TCHAR * params ) : ACE_Parse_Node ( nm ) , parameters_ ( ACE :: strnew ( params ) ) { ACE_TRACE ( " ACE _ Static _ Node : : ACE _ Static _ Node " ) ; }
void ACE_Static_Node :: apply ( ACE_Service_Gestalt * config , int & yyerrno ) { ACE_TRACE ( " ACE _ Static _ Node : : apply " ) ; if ( config -> initialize ( this -> name ( ) , this -> parameters ( ) ) == - 1 ) ++ yyerrno ; if ( ACE :: debug ( ) ) ACE_DEBUG ( ( LM_DEBUG , ACE_TEXT ( " ACE ▁ ( % P | % t ) ▁ Static _ Node : : apply ▁ - " ) ACE_TEXT ( " ▁ Did ▁ static ▁ on ▁ % s ▁ ( yyerrno = % d ) \n " ) , this -> name ( ) , yyerrno ) ) ; /* ▁ ACE _ NLOGGING ▁ */ ENDCOM }
ACE_Static_Node :: ~ ACE_Static_Node ( void ) { ACE_TRACE ( " ACE _ Static _ Node : : ~ ACE _ Static _ Node " ) ; delete [ ] this -> parameters_ ; }
ACE_Location_Node :: ACE_Location_Node ( void ) : pathname_ ( 0 ) , dll_ ( ) , symbol_ ( 0 ) { ACE_TRACE ( " ACE _ Location _ Node : : ACE _ Location _ Node " ) ; }
ACE_Location_Node :: ~ ACE_Location_Node ( void ) { ACE_TRACE ( " ACE _ Location _ Node : : ~ ACE _ Location _ Node " ) ; }
const ACE_DLL & ACE_Location_Node :: dll ( void ) { return this -> dll_ ; }
void ACE_Location_Node :: pathname ( const ACE_TCHAR * p ) { ACE_TRACE ( " ACE _ Location _ Node : : pathname " ) ; this -> pathname_ = p ; }
int ACE_Location_Node :: open_dll ( int & yyerrno ) { ACE_TRACE ( " ACE _ Location _ Node : : open _ dll " ) ; if ( ACE :: debug ( ) ) ACE_DEBUG ( ( LM_DEBUG , ACE_TEXT ( " ACE ▁ ( % P | % t ) ▁ LN : : open _ dll ▁ - ▁ path = % s \n " ) , this -> pathname ( ) ) ) ; /* ▁ ACE _ NLOGGING ▁ */ ENDCOM if ( - 1 == this -> dll_ . open ( this -> pathname ( ) ) ) { ++ yyerrno ; if ( ACE :: debug ( ) ) { ACE_TCHAR * errmsg = this -> dll_ . error ( ) ; ACE_ERROR ( ( LM_ERROR , ACE_TEXT ( " ACE ▁ ( % P | % t ) ▁ LN : : open _ dll ▁ - ▁ Failed ▁ to ▁ open ▁ % s : ▁ % s \n " ) , this -> pathname ( ) , errmsg ? errmsg : ACE_TEXT ( " no ▁ error ▁ reported " ) ) ) ; } /* ▁ ACE _ NLOGGING ▁ */ ENDCOM return - 1 ; } return 0 ; }
void ACE_Location_Node :: set_symbol ( void * s ) { ACE_TRACE ( " ACE _ Location _ Node : : set _ symbol " ) ; this -> symbol_ = s ; }
ACE_Object_Node :: ACE_Object_Node ( const ACE_TCHAR * path , const ACE_TCHAR * obj_name ) : object_name_ ( ACE :: strnew ( obj_name ) ) { ACE_TRACE ( " ACE _ Object _ Node : : ACE _ Object _ Node " ) ; this -> pathname ( ACE :: strnew ( path ) ) ; this -> must_delete_ = 0 ; }
void * ACE_Object_Node :: symbol ( ACE_Service_Gestalt * , int & yyerrno , ACE_Service_Object_Exterminator * ) { ACE_TRACE ( " ACE _ Object _ Node : : symbol " ) ; if ( this -> open_dll ( yyerrno ) == 0 ) { ACE_TCHAR * object_name = const_cast < ACE_TCHAR * > ( this -> object_name_ ) ; this -> symbol_ = this -> dll_ . symbol ( object_name ) ; if ( this -> symbol_ == 0 ) { ++ yyerrno ; if ( ACE :: debug ( ) ) { ACE_TCHAR * errmsg = this -> dll_ . error ( ) ; ACE_ERROR ( ( LM_ERROR , ACE_TEXT ( " ACE ▁ ( % P | % t ) ▁ DLL : : symbol ▁ - " ) ACE_TEXT ( " ▁ Failed ▁ for ▁ object ▁ % s : ▁ % s \n " ) , object_name , errmsg ? errmsg : ACE_TEXT ( " no ▁ error ▁ reported " ) ) ) ; } /* ▁ ACE _ NLOGGING ▁ */ ENDCOM return 0 ; } return this -> symbol_ ; } return 0 ; }
ACE_Object_Node :: ~ ACE_Object_Node ( void ) { ACE_TRACE ( " ACE _ Object _ Node : : ~ ACE _ Object _ Node " ) ; delete [ ] const_cast < ACE_TCHAR * > ( this -> object_name_ ) ; }
ACE_Function_Node :: ACE_Function_Node ( const ACE_TCHAR * path , const ACE_TCHAR * func_name ) : function_name_ ( make_func_name ( func_name ) ) { ACE_TRACE ( " ACE _ Function _ Node : : ACE _ Function _ Node " ) ; this -> pathname ( ACE :: strnew ( path ) ) ; this -> must_delete_ = 1 ; }
ACE_TCHAR * ACE_Function_Node :: make_func_name ( ACE_TCHAR const * func_name ) { // ▁ Preprocessor ▁ symbols ▁ will ▁ not ▁ be ▁ expanded ▁ if ▁ they ▁ are ENDCOM // ▁ stringified . ▁ Force ▁ the ▁ preprocessor ▁ to ▁ expand ▁ them ▁ during ▁ the ENDCOM // ▁ argument ▁ prescan ▁ by ▁ calling ▁ a ▁ macro ▁ that ▁ itself ▁ calls ▁ another ENDCOM // ▁ that ▁ performs ▁ the ▁ actual ▁ stringification . ENDCOM && ACE_HAS_VERSIONED_NAMESPACE == 1 ; }
void AsmRoutineManager :: Generate ( MIPSState * mips , MIPSComp :: Jit * jit , MIPSComp :: JitOptions * jo ) { enterCode = AlignCode16 ( ) ; ABI_PushAllCalleeSavedRegsAndAdjustStack ( ) ; // ▁ Two ▁ statically ▁ allocated ▁ registers . ENDCOM MOV ( 64 , R ( MEMBASEREG ) , ImmPtr ( Memory :: base ) ) ; uintptr_t jitbase = ( uintptr_t ) jit -> GetBasePtr ( ) ; if ( jitbase > 0x7FFFFFFFULL ) { MOV ( 64 , R ( JITBASEREG ) , ImmPtr ( jit -> GetBasePtr ( ) ) ) ; jo -> reserveR15ForAsm = true ; } // ▁ From ▁ the ▁ start ▁ of ▁ the ▁ FP ▁ reg , ▁ a ▁ single ▁ byte ▁ offset ▁ can ▁ reach ▁ all ▁ GPR ▁ + ▁ all ▁ FPR ▁ ( but ▁ no ▁ VFPUR ) ENDCOM MOV ( PTRBITS , R ( CTXREG ) , ImmPtr ( & mips -> f [ 0 ] ) ) ; outerLoop = GetCodePtr ( ) ; jit -> RestoreRoundingMode ( true , this ) ; ABI_CallFunction ( reinterpret_cast < void * > ( & CoreTiming :: Advance ) ) ; jit -> ApplyRoundingMode ( true , this ) ; FixupBranch skipToRealDispatch = J ( ) ; // skip ▁ the ▁ sync ▁ and ▁ compare ▁ first ▁ time ENDCOM dispatcherCheckCoreState = GetCodePtr ( ) ; // ▁ The ▁ result ▁ of ▁ slice ▁ decrementation ▁ should ▁ be ▁ in ▁ flags ▁ if ▁ somebody ▁ jumped ▁ here ENDCOM // ▁ IMPORTANT ▁ - ▁ We ▁ jump ▁ on ▁ negative , ▁ not ▁ carry ! ! ! ENDCOM FixupBranch bailCoreState = J_CC ( CC_S , true ) ; CMP ( 32 , M ( & coreState ) , Imm32 ( 0 ) ) ; FixupBranch badCoreState = J_CC ( CC_NZ , true ) ; FixupBranch skipToRealDispatch2 = J ( ) ; // skip ▁ the ▁ sync ▁ and ▁ compare ▁ first ▁ time ENDCOM dispatcher = GetCodePtr ( ) ; // ▁ The ▁ result ▁ of ▁ slice ▁ decrementation ▁ should ▁ be ▁ in ▁ flags ▁ if ▁ somebody ▁ jumped ▁ here ENDCOM // ▁ IMPORTANT ▁ - ▁ We ▁ jump ▁ on ▁ negative , ▁ not ▁ carry ! ! ! ENDCOM FixupBranch bail = J_CC ( CC_S , true ) ; SetJumpTarget ( skipToRealDispatch ) ; SetJumpTarget ( skipToRealDispatch2 ) ; dispatcherNoCheck = GetCodePtr ( ) ; MOV ( 32 , R ( EAX ) , M ( & mips -> pc ) ) ; dispatcherInEAXNoCheck = GetCodePtr ( ) ; AND ( 32 , R ( EAX ) , Imm32 ( Memory :: MEMVIEW32_MASK ) ) ; _assert_msg_ ( CPU , Memory :: base != 0 , " Memory ▁ base ▁ bogus " ) ; MOV ( 32 , R ( EAX ) , MDisp ( EAX , ( u32 ) Memory :: base ) ) ; # elif _M_X64 MOV ( 32 , R ( EAX ) , MComplex ( MEMBASEREG , RAX , SCALE_1 , 0 ) ) ; MOV ( 32 , R ( EDX ) , R ( EAX ) ) ; _assert_msg_ ( JIT , MIPS_JITBLOCK_MASK == 0xFF000000 , " Hardcoded ▁ assumption ▁ of ▁ emuhack ▁ mask " ) ; SHR ( 32 , R ( EDX ) , Imm8 ( 24 ) ) ; CMP ( 32 , R ( EDX ) , Imm8 ( MIPS_EMUHACK_OPCODE >> 24 ) ) ; FixupBranch notfound = J_CC ( CC_NE ) ; if ( enableDebug ) { ADD ( 32 , M ( & mips -> debugCount ) , Imm8 ( 1 ) ) ; } // grab ▁ from ▁ list ▁ and ▁ jump ▁ to ▁ it ENDCOM AND ( 32 , R ( EAX ) , Imm32 ( MIPS_EMUHACK_VALUE_MASK ) ) ; ADD ( 32 , R ( EAX ) , ImmPtr ( jit -> GetBasePtr ( ) ) ) ; # elif _M_X64 if ( jo -> reserveR15ForAsm ) ADD ( 64 , R ( RAX ) , R ( JITBASEREG ) ) ; else ADD ( 64 , R ( EAX ) , Imm32 ( jitbase ) ) ; JMPptr ( R ( EAX ) ) ; SetJumpTarget ( notfound ) ; // Ok , ▁ no ▁ block , ▁ let ' s ▁ jit ENDCOM jit -> RestoreRoundingMode ( true , this ) ; ABI_CallFunction ( & MIPSComp :: JitAt ) ; jit -> ApplyRoundingMode ( true , this ) ; JMP ( dispatcherNoCheck , true ) ; // ▁ Let ' s ▁ just ▁ dispatch ▁ again , ▁ we ' ll ▁ enter ▁ the ▁ block ▁ since ▁ we ▁ know ▁ it ' s ▁ there . ENDCOM SetJumpTarget ( bail ) ; SetJumpTarget ( bailCoreState ) ; CMP ( 32 , M ( & coreState ) , Imm32 ( 0 ) ) ; J_CC ( CC_Z , outerLoop , true ) ; SetJumpTarget ( badCoreState ) ; jit -> RestoreRoundingMode ( true , this ) ; ABI_PopAllCalleeSavedRegsAndAdjustStack ( ) ; RET ( ) ; breakpointBailout = GetCodePtr ( ) ; jit -> RestoreRoundingMode ( true , this ) ; ABI_PopAllCalleeSavedRegsAndAdjustStack ( ) ; RET ( ) ; }
void FalagardCheckbox :: drawSelf ( float z ) { // ▁ this ▁ is ▁ hackish ▁ and ▁ relies ▁ on ▁ insider ▁ knowlegde ▁ of ▁ the ▁ way ▁ that ▁ both ▁ Checkbox ▁ ( actually ▁ ButtonBase ) ENDCOM // ▁ and ▁ Window ▁ implement ▁ things ; ▁ Soon ▁ I ' ll ▁ get ▁ to ▁ updating ▁ things ▁ so ▁ that ▁ this ▁ can ▁ be ▁ replaced ENDCOM // ▁ with ▁ clean ▁ code . ENDCOM // ▁ call ▁ Checkbox ▁ drawSelf ▁ method ▁ which ▁ will ▁ call ▁ one ▁ of ▁ the ▁ state ▁ drawing ▁ methods ▁ overridden ▁ in ▁ this ▁ class . ENDCOM Checkbox :: drawSelf ( z ) ; // ▁ call ▁ Window ▁ drawSelf ▁ to ▁ get ▁ it ▁ to ▁ send ▁ the ▁ cached ▁ imagery ▁ to ▁ the ▁ renderer . ENDCOM Window :: drawSelf ( z ) ; }
void FalagardCheckbox :: drawNormal ( float z ) { doButtonRender ( d_selected ? " SelectedNormal " : " Normal " ) ; }
void FalagardCheckbox :: drawHover ( float z ) { doButtonRender ( d_selected ? " SelectedHover " : " Hover " ) ; }
void FalagardCheckbox :: drawPushed ( float z ) { doButtonRender ( d_selected ? " SelectedPushed " : " Pushed " ) ; }
void FalagardCheckbox :: drawDisabled ( float z ) { doButtonRender ( d_selected ? " SelectedDisabled " : " Disabled " ) ; }
void FalagardCheckbox :: doButtonRender ( const String & state ) { // ▁ this ▁ is ▁ the ▁ second ▁ part ▁ of ▁ the ▁ hackish ▁ code . ▁ We ' re ▁ duplicating ▁ the ▁ first ▁ section ▁ of ▁ code ENDCOM // ▁ from ▁ the ▁ Window : : drawSelf ▁ method ▁ to ▁ decide ▁ whether ▁ to ▁ actually ▁ do ▁ anything . ▁ It ▁ is ▁ likely ENDCOM // ▁ this ▁ will ▁ be ▁ replaced ▁ with ▁ cleaner ▁ code ▁ in ▁ the ▁ near ▁ future . . . ENDCOM // ▁ do ▁ we ▁ need ▁ to ▁ update ▁ the ▁ cache ? ENDCOM if ( d_needsRedraw ) { const StateImagery * imagery ; // ▁ remove ▁ old ▁ cached ▁ imagery ENDCOM d_renderCache . clearCachedImagery ( ) ; // ▁ signal ▁ that ▁ we ' ll ▁ no ▁ loger ▁ need ▁ a ▁ redraw . ENDCOM d_needsRedraw = false ; try { // ▁ get ▁ WidgetLookFeel ▁ for ▁ the ▁ assigned ▁ look . ENDCOM const WidgetLookFeel & wlf = WidgetLookManager :: getSingleton ( ) . getWidgetLook ( d_lookName ) ; // ▁ try ▁ and ▁ get ▁ imagery ▁ for ▁ the ▁ state ▁ we ▁ were ▁ given , ▁ though ▁ default ▁ to ▁ Normal ▁ states ▁ if ▁ the ENDCOM // ▁ desired ▁ states ▁ do ▁ not ▁ exist ENDCOM imagery = wlf . isStateImageryPresent ( state ) ? & wlf . getStateImagery ( state ) : d_selected ? & wlf . getStateImagery ( " SelectedNormal " ) : & wlf . getStateImagery ( " Normal " ) ; } // ▁ catch ▁ exceptions , ▁ but ▁ do ▁ not ▁ exit . ENDCOM catch ( UnknownObjectException ) { // ▁ don ' t ▁ try ▁ and ▁ draw ▁ using ▁ missing ▁ imagery ! ENDCOM return ; } // ▁ peform ▁ the ▁ rendering ▁ operation . ENDCOM // ▁ NB : ▁ This ▁ is ▁ not ▁ in ▁ the ▁ above ▁ try ▁ block ▁ since ▁ we ▁ want ▁ UnknownObjectException ▁ exceptions ▁ to ▁ be ▁ emitted ▁ from ENDCOM // ▁ the ▁ rendering ▁ code ▁ for ▁ conditions ▁ such ▁ as ▁ missing ▁ Imagesets ▁ and / or ▁ Images . ENDCOM imagery -> render ( * this ) ; } }
/* * * * *  STRNEWLINE  STRNEWLINE ▁ Factory ▁ Methods STRNEWLINE  STRNEWLINE ▁ * * * * */ ENDCOM Window * FalagardCheckboxFactory :: createWindow ( const String & name ) { return new FalagardCheckbox ( d_type , name ) ; }
void FalagardCheckboxFactory :: destroyWindow ( Window * window ) { delete window ; }
bool CGUIDialogLibExportSettings :: Show ( CLibExportSettings & settings ) { CGUIDialogLibExportSettings * dialog = CServiceBroker :: GetGUI ( ) -> GetWindowManager ( ) . GetWindow < CGUIDialogLibExportSettings > ( WINDOW_DIALOG_LIBEXPORT_SETTINGS ) ; if ( ! dialog ) return false ; // ▁ Get ▁ current ▁ export ▁ settings ▁ from ▁ service ▁ broker ENDCOM dialog -> m_settings . SetExportType ( CServiceBroker :: GetSettings ( ) . GetInt ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_FILETYPE ) ) ; dialog -> m_settings . m_strPath = CServiceBroker :: GetSettings ( ) . GetString ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_FOLDER ) ; dialog -> m_settings . SetItemsToExport ( CServiceBroker :: GetSettings ( ) . GetInt ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_ITEMS ) ) ; dialog -> m_settings . m_unscraped = CServiceBroker :: GetSettings ( ) . GetBool ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_UNSCRAPED ) ; dialog -> m_settings . m_artwork = CServiceBroker :: GetSettings ( ) . GetBool ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_ARTWORK ) ; dialog -> m_settings . m_skipnfo = CServiceBroker :: GetSettings ( ) . GetBool ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_SKIPNFO ) ; dialog -> m_settings . m_overwrite = CServiceBroker :: GetSettings ( ) . GetBool ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_OVERWRITE ) ; dialog -> m_destinationChecked = false ; dialog -> Open ( ) ; bool confirmed = dialog -> IsConfirmed ( ) ; if ( confirmed ) { // ▁ Return ▁ the ▁ new ▁ settings ▁ ( saved ▁ by ▁ service ▁ broker ▁ but ▁ avoids ▁ re - reading ) ENDCOM settings = dialog -> m_settings ; } return confirmed ; }
void CGUIDialogLibExportSettings :: OnInitWindow ( ) { CGUIDialogSettingsManualBase :: OnInitWindow ( ) ; }
void CGUIDialogLibExportSettings :: OnSettingChanged ( std :: shared_ptr < const CSetting > setting ) { if ( ! setting ) return ; CGUIDialogSettingsManualBase :: OnSettingChanged ( setting ) ; const std :: string & settingId = setting -> GetId ( ) ; if ( settingId == CSettings :: SETTING_MUSICLIBRARY_EXPORT_FILETYPE ) { m_settings . SetExportType ( std :: static_pointer_cast < const CSettingInt > ( setting ) -> GetValue ( ) ) ; SetupView ( ) ; SetFocus ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_FILETYPE ) ; } else if ( settingId == CSettings :: SETTING_MUSICLIBRARY_EXPORT_FOLDER ) { m_settings . m_strPath = std :: static_pointer_cast < const CSettingString > ( setting ) -> GetValue ( ) ; UpdateButtons ( ) ; } else if ( settingId == CSettings :: SETTING_MUSICLIBRARY_EXPORT_OVERWRITE ) m_settings . m_overwrite = std :: static_pointer_cast < const CSettingBool > ( setting ) -> GetValue ( ) ; else if ( settingId == CSettings :: SETTING_MUSICLIBRARY_EXPORT_ITEMS ) m_settings . SetItemsToExport ( GetExportItemsFromSetting ( setting ) ) ; else if ( settingId == CSettings :: SETTING_MUSICLIBRARY_EXPORT_ARTWORK ) { m_settings . m_artwork = std :: static_pointer_cast < const CSettingBool > ( setting ) -> GetValue ( ) ; ToggleState ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_SKIPNFO , m_settings . m_artwork ) ; } else if ( settingId == CSettings :: SETTING_MUSICLIBRARY_EXPORT_UNSCRAPED ) m_settings . m_unscraped = std :: static_pointer_cast < const CSettingBool > ( setting ) -> GetValue ( ) ; else if ( settingId == CSettings :: SETTING_MUSICLIBRARY_EXPORT_SKIPNFO ) m_settings . m_skipnfo = std :: static_pointer_cast < const CSettingBool > ( setting ) -> GetValue ( ) ; }
void CGUIDialogLibExportSettings :: OnSettingAction ( std :: shared_ptr < const CSetting > setting ) { if ( setting == NULL ) return ; CGUIDialogSettingsManualBase :: OnSettingAction ( setting ) ; const std :: string & settingId = setting -> GetId ( ) ; if ( settingId == CSettings :: SETTING_MUSICLIBRARY_EXPORT_FOLDER ) { VECSOURCES shares ; g_mediaManager . GetLocalDrives ( shares ) ; g_mediaManager . GetNetworkLocations ( shares ) ; g_mediaManager . GetRemovableDrives ( shares ) ; std :: string strDirectory = m_settings . m_strPath ; if ( ! strDirectory . empty ( ) ) { URIUtils :: AddSlashAtEnd ( strDirectory ) ; bool bIsSource ; if ( CUtil :: GetMatchingSource ( strDirectory , shares , bIsSource ) < 0 ) // ▁ path ▁ is ▁ outside ▁ shares ▁ - ▁ add ▁ it ▁ as ▁ a ▁ separate ▁ one ENDCOM { CMediaSource share ; share . strName = g_localizeStrings . Get ( 13278 ) ; share . strPath = strDirectory ; shares . push_back ( share ) ; } } else strDirectory = " default ▁ location " ; if ( CGUIDialogFileBrowser :: ShowAndGetDirectory ( shares , g_localizeStrings . Get ( 661 ) , strDirectory , true ) ) { if ( ! strDirectory . empty ( ) ) { m_destinationChecked = true ; m_settings . m_strPath = strDirectory ; SetLabel2 ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_FOLDER , strDirectory ) ; SetFocus ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_FOLDER ) ; } } UpdateButtons ( ) ; } }
bool CGUIDialogLibExportSettings :: OnMessage ( CGUIMessage & message ) { switch ( message . GetMessage ( ) ) { case GUI_MSG_CLICKED : { int iControl = message . GetSenderId ( ) ; if ( iControl == CONTROL_SETTINGS_OKAY_BUTTON ) { OnOK ( ) ; return true ; } } break ; } return CGUIDialogSettingsManualBase :: OnMessage ( message ) ; }
void CGUIDialogLibExportSettings :: OnOK ( ) { // ▁ Validate ▁ destination ▁ folder ENDCOM if ( m_settings . IsToLibFolders ( ) ) { // ▁ Check ▁ artist ▁ info ▁ folder ▁ setting ENDCOM std :: string path = CServiceBroker :: GetSettings ( ) . GetString ( CSettings :: SETTING_MUSICLIBRARY_ARTISTSFOLDER ) ; if ( path . empty ( ) ) { // " Unable ▁ to ▁ export ▁ to ▁ library ▁ folders ▁ as ▁ the ▁ system ▁ artist ▁ information ▁ folder ▁ setting ▁ is ▁ empty " ENDCOM // Settings ▁ ( YES ) ▁ button ▁ takes ▁ user ▁ to ▁ enter ▁ the ▁ artist ▁ info ▁ folder ▁ setting ENDCOM if ( HELPERS :: ShowYesNoDialogText ( 20223 , 38317 , 186 , 10004 ) == DialogResponse :: YES ) { m_confirmed = false ; Close ( ) ; CServiceBroker :: GetGUI ( ) -> GetWindowManager ( ) . ActivateWindow ( WINDOW_SETTINGS_MEDIA , CSettings :: SETTING_MUSICLIBRARY_ARTISTSFOLDER ) ; } return ; } } else if ( ! m_destinationChecked ) { // ▁ ELIBEXPORT _ SINGLEFILE ▁ or ▁ LIBEXPORT _ SEPARATEFILES ENDCOM // ▁ Check ▁ that ▁ destination ▁ folder ▁ exists ENDCOM if ( ! XFILE :: CDirectory :: Exists ( m_settings . m_strPath ) ) { HELPERS :: ShowOKDialogText ( CVariant { 38300 } , CVariant { 38318 } ) ; return ; } } m_confirmed = true ; Save ( ) ; Close ( ) ; }
void CGUIDialogLibExportSettings :: Save ( ) { CLog :: Log ( LOGINFO , " CGUIDialogMusicExportSettings : ▁ Save ( ) ▁ called " ) ; CServiceBroker :: GetSettings ( ) . SetInt ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_FILETYPE , m_settings . GetExportType ( ) ) ; CServiceBroker :: GetSettings ( ) . SetString ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_FOLDER , m_settings . m_strPath ) ; CServiceBroker :: GetSettings ( ) . SetInt ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_ITEMS , m_settings . GetItemsToExport ( ) ) ; CServiceBroker :: GetSettings ( ) . SetBool ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_UNSCRAPED , m_settings . m_unscraped ) ; CServiceBroker :: GetSettings ( ) . SetBool ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_OVERWRITE , m_settings . m_overwrite ) ; CServiceBroker :: GetSettings ( ) . SetBool ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_ARTWORK , m_settings . m_artwork ) ; CServiceBroker :: GetSettings ( ) . SetBool ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_SKIPNFO , m_settings . m_skipnfo ) ; CServiceBroker :: GetSettings ( ) . Save ( ) ; }
void CGUIDialogLibExportSettings :: SetupView ( ) { CGUIDialogSettingsManualBase :: SetupView ( ) ; SetHeading ( 38300 ) ; SET_CONTROL_HIDDEN ( CONTROL_SETTINGS_CUSTOM_BUTTON ) ; SET_CONTROL_LABEL ( CONTROL_SETTINGS_OKAY_BUTTON , 38319 ) ; SET_CONTROL_LABEL ( CONTROL_SETTINGS_CANCEL_BUTTON , 222 ) ; SetLabel2 ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_FOLDER , m_settings . m_strPath ) ; if ( m_settings . IsSingleFile ( ) ) { ToggleState ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_FOLDER , true ) ; ToggleState ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_OVERWRITE , false ) ; ToggleState ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_ARTWORK , false ) ; ToggleState ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_SKIPNFO , false ) ; } else if ( m_settings . IsSeparateFiles ( ) ) { ToggleState ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_FOLDER , true ) ; ToggleState ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_OVERWRITE , true ) ; ToggleState ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_ARTWORK , true ) ; ToggleState ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_SKIPNFO , m_settings . m_artwork ) ; } else // ▁ To ▁ library ▁ folders ENDCOM { ToggleState ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_FOLDER , false ) ; ToggleState ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_OVERWRITE , true ) ; ToggleState ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_ARTWORK , true ) ; ToggleState ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_SKIPNFO , m_settings . m_artwork ) ; } UpdateButtons ( ) ; }
void CGUIDialogLibExportSettings :: UpdateButtons ( ) { // ▁ Enable ▁ Export ▁ button ▁ when ▁ destination ▁ folder ▁ has ▁ a ▁ path ▁ ( but ▁ may ▁ not ▁ exist ) ENDCOM bool enableExport ( true ) ; if ( m_settings . IsSingleFile ( ) || m_settings . IsSeparateFiles ( ) ) enableExport = ! m_settings . m_strPath . empty ( ) ; CONTROL_ENABLE_ON_CONDITION ( CONTROL_SETTINGS_OKAY_BUTTON , enableExport ) ; if ( ! enableExport ) SetFocus ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_FOLDER ) ; }
void CGUIDialogLibExportSettings :: InitializeSettings ( ) { CGUIDialogSettingsManualBase :: InitializeSettings ( ) ; std :: shared_ptr < CSettingCategory > category = AddCategory ( " exportsettings " , - 1 ) ; if ( ! category ) { CLog :: Log ( LOGERROR , " CGUIDialogLibExportSettings : ▁ unable ▁ to ▁ setup ▁ settings " ) ; return ; } std :: shared_ptr < CSettingGroup > groupDetails = AddGroup ( category ) ; if ( ! groupDetails ) { CLog :: Log ( LOGERROR , " CGUIDialogLibExportSettings : ▁ unable ▁ to ▁ setup ▁ settings " ) ; return ; } TranslatableIntegerSettingOptions entries ; entries . push_back ( std :: make_pair ( 38301 , ELIBEXPORT_SINGLEFILE ) ) ; entries . push_back ( std :: make_pair ( 38302 , ELIBEXPORT_SEPARATEFILES ) ) ; entries . push_back ( std :: make_pair ( 38303 , ELIBEXPORT_TOLIBRARYFOLDER ) ) ; AddList ( groupDetails , CSettings :: SETTING_MUSICLIBRARY_EXPORT_FILETYPE , 38304 , SettingLevel :: Basic , m_settings . GetExportType ( ) , entries , 38304 ) ; // ▁ " Choose ▁ kind ▁ of ▁ export ▁ output " ENDCOM AddButton ( groupDetails , CSettings :: SETTING_MUSICLIBRARY_EXPORT_FOLDER , 38305 , SettingLevel :: Basic ) ; entries . clear ( ) ; entries . push_back ( std :: make_pair ( 132 , ELIBEXPORT_ALBUMS ) ) ; // ablums ENDCOM entries . push_back ( std :: make_pair ( 38043 , ELIBEXPORT_ALBUMARTISTS ) ) ; // album ▁ artists ENDCOM entries . push_back ( std :: make_pair ( 38312 , ELIBEXPORT_SONGARTISTS ) ) ; // song ▁ artists ENDCOM entries . push_back ( std :: make_pair ( 38313 , ELIBEXPORT_OTHERARTISTS ) ) ; // other ▁ artists ENDCOM AddList ( groupDetails , CSettings :: SETTING_MUSICLIBRARY_EXPORT_ITEMS , 38306 , SettingLevel :: Basic , m_settings . GetExportItems ( ) , entries , 133 , 1 ) ; AddToggle ( groupDetails , CSettings :: SETTING_MUSICLIBRARY_EXPORT_UNSCRAPED , 38308 , SettingLevel :: Basic , m_settings . m_unscraped ) ; AddToggle ( groupDetails , CSettings :: SETTING_MUSICLIBRARY_EXPORT_ARTWORK , 38307 , SettingLevel :: Basic , m_settings . m_artwork ) ; AddToggle ( groupDetails , CSettings :: SETTING_MUSICLIBRARY_EXPORT_SKIPNFO , 38309 , SettingLevel :: Basic , m_settings . m_skipnfo ) ; AddToggle ( groupDetails , CSettings :: SETTING_MUSICLIBRARY_EXPORT_OVERWRITE , 38310 , SettingLevel :: Basic , m_settings . m_overwrite ) ; }
void CGUIDialogLibExportSettings :: SetLabel2 ( const std :: string & settingid , const std :: string & label ) { BaseSettingControlPtr settingControl = GetSettingControl ( settingid ) ; if ( settingControl != NULL && settingControl -> GetControl ( ) != NULL ) SET_CONTROL_LABEL2 ( settingControl -> GetID ( ) , label ) ; }
void CGUIDialogLibExportSettings :: ToggleState ( const std :: string & settingid , bool enabled ) { BaseSettingControlPtr settingControl = GetSettingControl ( settingid ) ; if ( settingControl != NULL && settingControl -> GetControl ( ) != NULL ) { if ( enabled ) CONTROL_ENABLE ( settingControl -> GetID ( ) ) ; else CONTROL_DISABLE ( settingControl -> GetID ( ) ) ; } }
void CGUIDialogLibExportSettings :: SetFocus ( const std :: string & settingid ) { BaseSettingControlPtr settingControl = GetSettingControl ( settingid ) ; if ( settingControl != NULL && settingControl -> GetControl ( ) != NULL ) SET_CONTROL_FOCUS ( settingControl -> GetID ( ) , 0 ) ; }
int CGUIDialogLibExportSettings :: GetExportItemsFromSetting ( SettingConstPtr setting ) { std :: shared_ptr < const CSettingList > settingList = std :: static_pointer_cast < const CSettingList > ( setting ) ; if ( settingList -> GetElementType ( ) != SettingType :: Integer ) { CLog :: Log ( LOGERROR , " CGUIDialogLibExportSettings : : % s ▁ - ▁ wrong ▁ items ▁ element ▁ type " , __FUNCTION__ ) ; return 0 ; } int exportitems = 0 ; std :: vector < CVariant > list = CSettingUtils :: GetList ( settingList ) ; for ( const auto & value : list ) { if ( ! value . isInteger ( ) ) { CLog :: Log ( LOGERROR , " CGUIDialogLibExportSettings : : % s ▁ - ▁ wrong ▁ items ▁ value ▁ type " , __FUNCTION__ ) ; return 0 ; } exportitems += value . asInteger ( ) ; } return exportitems ; }
/ ▁ moment ▁ of ▁ inertia ▁ prefactor ▁ for ▁ ellipsoid ComputeTempAsphere :: ComputeTempAsphere ( LAMMPS * lmp , int narg , char * * arg ) : Compute ( lmp , narg , arg ) { if ( narg < 3 ) error -> all ( FLERR , " Illegal ▁ compute ▁ temp / asphere ▁ command " ) ; scalar_flag = vector_flag = 1 ; size_vector = 6 ; extscalar = 0 ; extvector = 1 ; tempflag = 1 ; tempbias = 0 ; id_bias = NULL ; mode = ALL ; int iarg = 3 ; while ( iarg < narg ) { if ( strcmp ( arg [ iarg ] , " bias " ) == 0 ) { if ( iarg + 2 > narg ) error -> all ( FLERR , " Illegal ▁ compute ▁ temp / asphere ▁ command " ) ; tempbias = 1 ; int n = strlen ( arg [ iarg + 1 ] ) + 1 ; id_bias = new char [ n ] ; strcpy ( id_bias , arg [ iarg + 1 ] ) ; iarg += 2 ; } else if ( strcmp ( arg [ iarg ] , " dof " ) == 0 ) { if ( iarg + 2 > narg ) error -> all ( FLERR , " Illegal ▁ compute ▁ temp / asphere ▁ command " ) ; if ( strcmp ( arg [ iarg + 1 ] , " rotate " ) == 0 ) mode = ROTATE ; else if ( strcmp ( arg [ iarg + 1 ] , " all " ) == 0 ) mode = ALL ; else error -> all ( FLERR , " Illegal ▁ compute ▁ temp / asphere ▁ command " ) ; iarg += 2 ; } else error -> all ( FLERR , " Illegal ▁ compute ▁ temp / asphere ▁ command " ) ; } vector = new double [ 6 ] ; }
ComputeTempAsphere :: ~ ComputeTempAsphere ( ) { delete [ ] id_bias ; delete [ ] vector ; }
void ComputeTempAsphere :: init ( ) { // ▁ error ▁ check ENDCOM avec = ( AtomVecEllipsoid * ) atom -> style_match ( " ellipsoid " ) ; if ( ! avec ) error -> all ( FLERR , " Compute ▁ temp / asphere ▁ requires ▁ atom ▁ style ▁ ellipsoid " ) ; // ▁ check ▁ that ▁ all ▁ particles ▁ are ▁ finite - size , ▁ no ▁ point ▁ particles ▁ allowed ENDCOM int * ellipsoid = atom -> ellipsoid ; int * mask = atom -> mask ; int nlocal = atom -> nlocal ; for ( int i = 0 ; i < nlocal ; i ++ ) if ( mask [ i ] & groupbit ) if ( ellipsoid [ i ] < 0 ) error -> one ( FLERR , " Compute ▁ temp / asphere ▁ requires ▁ extended ▁ particles " ) ; if ( tempbias ) { int i = modify -> find_compute ( id_bias ) ; if ( i < 0 ) error -> all ( FLERR , " Could ▁ not ▁ find ▁ compute ▁ ID ▁ for ▁ temperature ▁ bias " ) ; tbias = modify -> compute [ i ] ; if ( tbias -> tempflag == 0 ) error -> all ( FLERR , " Bias ▁ compute ▁ does ▁ not ▁ calculate ▁ temperature " ) ; if ( tbias -> tempbias == 0 ) error -> all ( FLERR , " Bias ▁ compute ▁ does ▁ not ▁ calculate ▁ a ▁ velocity ▁ bias " ) ; if ( tbias -> igroup != igroup ) error -> all ( FLERR , " Bias ▁ compute ▁ group ▁ does ▁ not ▁ match ▁ compute ▁ group " ) ; tbias -> init ( ) ; tbias -> setup ( ) ; if ( strcmp ( tbias -> style , " temp / region " ) == 0 ) tempbias = 2 ; else tempbias = 1 ; } }
void ComputeTempAsphere :: setup ( ) { fix_dof = - 1 ; dof_compute ( ) ; }
void ComputeTempAsphere :: dof_compute ( ) { if ( fix_dof ) adjust_dof_fix ( ) ; // ▁ 6 ▁ dof ▁ for ▁ 3d , ▁ 3 ▁ dof ▁ for ▁ 2d ENDCOM // ▁ which ▁ dof ▁ are ▁ included ▁ also ▁ depends ▁ on ▁ mode ENDCOM // ▁ assume ▁ full ▁ rotation ▁ of ▁ extended ▁ particles ENDCOM // ▁ user ▁ should ▁ correct ▁ this ▁ via ▁ compute _ modify ▁ if ▁ needed ENDCOM double natoms = group -> count ( igroup ) ; int nper ; if ( domain -> dimension == 3 ) { if ( mode == ALL ) nper = 6 ; else nper = 3 ; } else { if ( mode == ALL ) nper = 3 ; else nper = 1 ; } dof = nper * natoms ; // ▁ additional ▁ adjustments ▁ to ▁ dof ENDCOM if ( tempbias == 1 ) { if ( mode == ALL ) dof -= tbias -> dof_remove ( - 1 ) * natoms ; } else if ( tempbias == 2 ) { int * mask = atom -> mask ; int nlocal = atom -> nlocal ; tbias -> dof_remove_pre ( ) ; int count = 0 ; for ( int i = 0 ; i < nlocal ; i ++ ) if ( mask [ i ] & groupbit ) if ( tbias -> dof_remove ( i ) ) count ++ ; int count_all ; MPI_Allreduce ( & count , & count_all , 1 , MPI_INT , MPI_SUM , world ) ; dof -= nper * count_all ; } dof -= extra_dof + fix_dof ; if ( dof > 0 ) tfactor = force -> mvv2e / ( dof * force -> boltz ) ; else tfactor = 0.0 ; }
double ComputeTempAsphere :: compute_scalar ( ) { invoked_scalar = update -> ntimestep ; if ( tempbias ) { if ( tbias -> invoked_scalar != update -> ntimestep ) tbias -> compute_scalar ( ) ; tbias -> remove_bias_all ( ) ; } AtomVecEllipsoid :: Bonus * bonus = avec -> bonus ; double * * v = atom -> v ; double * * angmom = atom -> angmom ; double * rmass = atom -> rmass ; int * ellipsoid = atom -> ellipsoid ; int * mask = atom -> mask ; int nlocal = atom -> nlocal ; double * shape , * quat ; double wbody [ 3 ] , inertia [ 3 ] ; double rot [ 3 ] [ 3 ] ; // ▁ sum ▁ translational ▁ and ▁ rotational ▁ energy ▁ for ▁ each ▁ particle ENDCOM // ▁ no ▁ point ▁ particles ▁ since ▁ divide ▁ by ▁ inertia ENDCOM double t = 0.0 ; if ( mode == ALL ) { for ( int i = 0 ; i < nlocal ; i ++ ) if ( mask [ i ] & groupbit ) { t += ( v [ i ] [ 0 ] * v [ i ] [ 0 ] + v [ i ] [ 1 ] * v [ i ] [ 1 ] + v [ i ] [ 2 ] * v [ i ] [ 2 ] ) * rmass [ i ] ; // ▁ principal ▁ moments ▁ of ▁ inertia ENDCOM shape = bonus [ ellipsoid [ i ] ] . shape ; quat = bonus [ ellipsoid [ i ] ] . quat ; inertia [ 0 ] = INERTIA * rmass [ i ] * ( shape [ 1 ] * shape [ 1 ] + shape [ 2 ] * shape [ 2 ] ) ; inertia [ 1 ] = INERTIA * rmass [ i ] * ( shape [ 0 ] * shape [ 0 ] + shape [ 2 ] * shape [ 2 ] ) ; inertia [ 2 ] = INERTIA * rmass [ i ] * ( shape [ 0 ] * shape [ 0 ] + shape [ 1 ] * shape [ 1 ] ) ; // ▁ wbody ▁ = ▁ angular ▁ velocity ▁ in ▁ body ▁ frame ENDCOM MathExtra :: quat_to_mat ( quat , rot ) ; MathExtra :: transpose_matvec ( rot , angmom [ i ] , wbody ) ; wbody [ 0 ] /= inertia [ 0 ] ; wbody [ 1 ] /= inertia [ 1 ] ; wbody [ 2 ] /= inertia [ 2 ] ; t += inertia [ 0 ] * wbody [ 0 ] * wbody [ 0 ] + inertia [ 1 ] * wbody [ 1 ] * wbody [ 1 ] + inertia [ 2 ] * wbody [ 2 ] * wbody [ 2 ] ; } } else { for ( int i = 0 ; i < nlocal ; i ++ ) if ( mask [ i ] & groupbit ) { // ▁ principal ▁ moments ▁ of ▁ inertia ENDCOM shape = bonus [ ellipsoid [ i ] ] . shape ; quat = bonus [ ellipsoid [ i ] ] . quat ; inertia [ 0 ] = INERTIA * rmass [ i ] * ( shape [ 1 ] * shape [ 1 ] + shape [ 2 ] * shape [ 2 ] ) ; inertia [ 1 ] = INERTIA * rmass [ i ] * ( shape [ 0 ] * shape [ 0 ] + shape [ 2 ] * shape [ 2 ] ) ; inertia [ 2 ] = INERTIA * rmass [ i ] * ( shape [ 0 ] * shape [ 0 ] + shape [ 1 ] * shape [ 1 ] ) ; // ▁ wbody ▁ = ▁ angular ▁ velocity ▁ in ▁ body ▁ frame ENDCOM MathExtra :: quat_to_mat ( quat , rot ) ; MathExtra :: transpose_matvec ( rot , angmom [ i ] , wbody ) ; wbody [ 0 ] /= inertia [ 0 ] ; wbody [ 1 ] /= inertia [ 1 ] ; wbody [ 2 ] /= inertia [ 2 ] ; t += inertia [ 0 ] * wbody [ 0 ] * wbody [ 0 ] + inertia [ 1 ] * wbody [ 1 ] * wbody [ 1 ] + inertia [ 2 ] * wbody [ 2 ] * wbody [ 2 ] ; } } if ( tempbias ) tbias -> restore_bias_all ( ) ; MPI_Allreduce ( & t , & scalar , 1 , MPI_DOUBLE , MPI_SUM , world ) ; if ( dynamic || tempbias == 2 ) dof_compute ( ) ; scalar *= tfactor ; return scalar ; }
void ComputeTempAsphere :: compute_vector ( ) { int i ; invoked_vector = update -> ntimestep ; if ( tempbias ) { if ( tbias -> invoked_vector != update -> ntimestep ) tbias -> compute_vector ( ) ; tbias -> remove_bias_all ( ) ; } AtomVecEllipsoid :: Bonus * bonus = avec -> bonus ; double * * v = atom -> v ; double * * angmom = atom -> angmom ; double * rmass = atom -> rmass ; int * ellipsoid = atom -> ellipsoid ; int * mask = atom -> mask ; int nlocal = atom -> nlocal ; double * shape , * quat ; double wbody [ 3 ] , inertia [ 3 ] , t [ 6 ] ; double rot [ 3 ] [ 3 ] ; double massone ; // ▁ sum ▁ translational ▁ and ▁ rotational ▁ energy ▁ for ▁ each ▁ particle ENDCOM // ▁ no ▁ point ▁ particles ▁ since ▁ divide ▁ by ▁ inertia ENDCOM for ( i = 0 ; i < 6 ; i ++ ) t [ i ] = 0.0 ; if ( mode == ALL ) { for ( i = 0 ; i < nlocal ; i ++ ) if ( mask [ i ] & groupbit ) { massone = rmass [ i ] ; t [ 0 ] += massone * v [ i ] [ 0 ] * v [ i ] [ 0 ] ; t [ 1 ] += massone * v [ i ] [ 1 ] * v [ i ] [ 1 ] ; t [ 2 ] += massone * v [ i ] [ 2 ] * v [ i ] [ 2 ] ; t [ 3 ] += massone * v [ i ] [ 0 ] * v [ i ] [ 1 ] ; t [ 4 ] += massone * v [ i ] [ 0 ] * v [ i ] [ 2 ] ; t [ 5 ] += massone * v [ i ] [ 1 ] * v [ i ] [ 2 ] ; // ▁ principal ▁ moments ▁ of ▁ inertia ENDCOM shape = bonus [ ellipsoid [ i ] ] . shape ; quat = bonus [ ellipsoid [ i ] ] . quat ; inertia [ 0 ] = INERTIA * massone * ( shape [ 1 ] * shape [ 1 ] + shape [ 2 ] * shape [ 2 ] ) ; inertia [ 1 ] = INERTIA * massone * ( shape [ 0 ] * shape [ 0 ] + shape [ 2 ] * shape [ 2 ] ) ; inertia [ 2 ] = INERTIA * massone * ( shape [ 0 ] * shape [ 0 ] + shape [ 1 ] * shape [ 1 ] ) ; // ▁ wbody ▁ = ▁ angular ▁ velocity ▁ in ▁ body ▁ frame ENDCOM MathExtra :: quat_to_mat ( quat , rot ) ; MathExtra :: transpose_matvec ( rot , angmom [ i ] , wbody ) ; wbody [ 0 ] /= inertia [ 0 ] ; wbody [ 1 ] /= inertia [ 1 ] ; wbody [ 2 ] /= inertia [ 2 ] ; // ▁ rotational ▁ kinetic ▁ energy ENDCOM t [ 0 ] += inertia [ 0 ] * wbody [ 0 ] * wbody [ 0 ] ; t [ 1 ] += inertia [ 1 ] * wbody [ 1 ] * wbody [ 1 ] ; t [ 2 ] += inertia [ 2 ] * wbody [ 2 ] * wbody [ 2 ] ; t [ 3 ] += inertia [ 0 ] * wbody [ 0 ] * wbody [ 1 ] ; t [ 4 ] += inertia [ 1 ] * wbody [ 0 ] * wbody [ 2 ] ; t [ 5 ] += inertia [ 2 ] * wbody [ 1 ] * wbody [ 2 ] ; } } else { for ( i = 0 ; i < nlocal ; i ++ ) if ( mask [ i ] & groupbit ) { // ▁ principal ▁ moments ▁ of ▁ inertia ENDCOM shape = bonus [ ellipsoid [ i ] ] . shape ; quat = bonus [ ellipsoid [ i ] ] . quat ; massone = rmass [ i ] ; inertia [ 0 ] = INERTIA * massone * ( shape [ 1 ] * shape [ 1 ] + shape [ 2 ] * shape [ 2 ] ) ; inertia [ 1 ] = INERTIA * massone * ( shape [ 0 ] * shape [ 0 ] + shape [ 2 ] * shape [ 2 ] ) ; inertia [ 2 ] = INERTIA * massone * ( shape [ 0 ] * shape [ 0 ] + shape [ 1 ] * shape [ 1 ] ) ; // ▁ wbody ▁ = ▁ angular ▁ velocity ▁ in ▁ body ▁ frame ENDCOM MathExtra :: quat_to_mat ( quat , rot ) ; MathExtra :: transpose_matvec ( rot , angmom [ i ] , wbody ) ; wbody [ 0 ] /= inertia [ 0 ] ; wbody [ 1 ] /= inertia [ 1 ] ; wbody [ 2 ] /= inertia [ 2 ] ; // ▁ rotational ▁ kinetic ▁ energy ENDCOM t [ 0 ] += inertia [ 0 ] * wbody [ 0 ] * wbody [ 0 ] ; t [ 1 ] += inertia [ 1 ] * wbody [ 1 ] * wbody [ 1 ] ; t [ 2 ] += inertia [ 2 ] * wbody [ 2 ] * wbody [ 2 ] ; t [ 3 ] += inertia [ 0 ] * wbody [ 0 ] * wbody [ 1 ] ; t [ 4 ] += inertia [ 1 ] * wbody [ 0 ] * wbody [ 2 ] ; t [ 5 ] += inertia [ 2 ] * wbody [ 1 ] * wbody [ 2 ] ; } } if ( tempbias ) tbias -> restore_bias_all ( ) ; MPI_Allreduce ( t , vector , 6 , MPI_DOUBLE , MPI_SUM , world ) ; for ( i = 0 ; i < 6 ; i ++ ) vector [ i ] *= force -> mvv2e ; }
/* ▁ - - - - - STRNEWLINE ▁ remove ▁ velocity ▁ bias ▁ from ▁ atom ▁ I ▁ to ▁ leave ▁ thermal ▁ velocity STRNEWLINE - - - - - ▁ */ ENDCOM void ComputeTempAsphere :: remove_bias ( int i , double * v ) { if ( tbias ) tbias -> remove_bias ( i , v ) ; }
/* ▁ - - - - - STRNEWLINE ▁ add ▁ back ▁ in ▁ velocity ▁ bias ▁ to ▁ atom ▁ I ▁ removed ▁ by ▁ remove _ bias ( ) STRNEWLINE ▁ assume ▁ remove _ bias ( ) ▁ was ▁ previously ▁ called STRNEWLINE - - - - - ▁ */ ENDCOM void ComputeTempAsphere :: restore_bias ( int i , double * v ) { if ( tbias ) tbias -> restore_bias ( i , v ) ; }
Node * CsClassFactory :: CreateNeuron ( std :: string strType , bool bThrowError ) { Node * lpNeuron = NULL ; try { strType = Std_ToUpper ( Std_Trim ( strType ) ) ; if ( strType == " NEURONGROUP " ) lpNeuron = new CsNeuronGroup ; else if ( strType == " SPIKEGENERATORGROUP " ) lpNeuron = new CsSpikeGeneratorGroup ; else { lpNeuron = NULL ; if ( bThrowError ) THROW_PARAM_ERROR ( Cs_Err_lInvalidNeuronType , Cs_Err_strInvalidNeuronType , " NeuronType " , strType ) ; } return lpNeuron ; } catch ( CStdErrorInfo oError ) { if ( lpNeuron ) delete lpNeuron ; RELAY_ERROR ( oError ) ; return NULL ; } catch ( ... ) { if ( lpNeuron ) delete lpNeuron ; THROW_ERROR ( Std_Err_lUnspecifiedError , Std_Err_strUnspecifiedError ) ; return NULL ; } }
// ▁ * * * * * ▁ Neuron ▁ Type ▁ Conversion ▁ functions ▁ * * * * * ENDCOM // ▁ * * * * * ▁ Synapse ▁ Type ▁ Conversion ▁ functions ▁ * * * * * ENDCOM AnimatSim :: Link * CsClassFactory :: CreateSynapse ( std :: string strType , bool bThrowError ) { AnimatSim :: Link * lpSynapse = NULL ; try { strType = Std_ToUpper ( Std_Trim ( strType ) ) ; if ( strType == " ONETOONESYNAPSE " ) lpSynapse = new CsSynapseOneToOne ; else if ( strType == " FULLSYNAPSE " ) lpSynapse = new CsSynapseFull ; else if ( strType == " RANDOMSYNAPSE " ) lpSynapse = new CsSynapseRandom ; else if ( strType == " INDIVIDUALSYNAPSE " ) lpSynapse = new CsSynapseIndividual ; else if ( strType == " SPIKINGCURRENTSYNAPSE " ) lpSynapse = new CsSpikingCurrentSynapse ; else { lpSynapse = NULL ; if ( bThrowError ) THROW_PARAM_ERROR ( Cs_Err_lInvalidSynapseType , Cs_Err_strInvalidSynapseType , " SynapseType " , strType ) ; } return lpSynapse ; } catch ( CStdErrorInfo oError ) { if ( lpSynapse ) delete lpSynapse ; RELAY_ERROR ( oError ) ; return NULL ; } catch ( ... ) { if ( lpSynapse ) delete lpSynapse ; THROW_ERROR ( Std_Err_lUnspecifiedError , Std_Err_strUnspecifiedError ) ; return NULL ; } }
// ▁ * * * * * ▁ Synapse ▁ Type ▁ Conversion ▁ functions ▁ * * * * * ENDCOM // ▁ * * * * * ▁ External ▁ Neural ▁ Module ▁ Conversion ▁ functions ▁ * * * * * ENDCOM NeuralModule * CsClassFactory :: CreateNeuralModule ( std :: string strType , bool bThrowError ) { NeuralModule * lpModule = NULL ; try { strType = Std_ToUpper ( Std_Trim ( strType ) ) ; if ( strType == " CARLSIMNEURALMODULE " ) lpModule = new CsNeuralModule ; else { lpModule = NULL ; if ( bThrowError ) THROW_PARAM_ERROR ( Al_Err_lInvalidNeuralModuleType , Al_Err_strInvalidNeuralModuleType , " NeuralModule " , strType ) ; } return lpModule ; } catch ( CStdErrorInfo oError ) { if ( lpModule ) delete lpModule ; RELAY_ERROR ( oError ) ; return NULL ; } catch ( ... ) { if ( lpModule ) delete lpModule ; THROW_ERROR ( Std_Err_lUnspecifiedError , Std_Err_strUnspecifiedError ) ; return NULL ; } }
// ▁ * * * * * ▁ Neural ▁ Module ▁ Type ▁ Conversion ▁ functions ▁ * * * * * ENDCOM // ▁ * * * * * ▁ External ▁ Stimulus ▁ Type ▁ Conversion ▁ functions ▁ * * * * * ENDCOM ExternalStimulus * CsClassFactory :: CreateExternalStimulus ( std :: string strType , bool bThrowError ) { ExternalStimulus * lpStimulus = NULL ; try { strType = Std_ToUpper ( Std_Trim ( strType ) ) ; if ( strType == " FIRINGRATE " ) lpStimulus = new CsFiringRateStimulus ; else { lpStimulus = NULL ; if ( bThrowError ) THROW_PARAM_ERROR ( Al_Err_lInvalidExternalStimulusType , Al_Err_strInvalidExternalStimulusType , " ExternalStimulusType " , strType ) ; } return lpStimulus ; } catch ( CStdErrorInfo oError ) { if ( lpStimulus ) delete lpStimulus ; RELAY_ERROR ( oError ) ; return NULL ; } catch ( ... ) { if ( lpStimulus ) delete lpStimulus ; THROW_ERROR ( Std_Err_lUnspecifiedError , Std_Err_strUnspecifiedError ) ; return NULL ; } }
// ▁ * * * * * ▁ External ▁ Stimulus ▁ Type ▁ Conversion ▁ functions ▁ * * * * * ENDCOM // ▁ * * * * * ▁ DataColumn ▁ Type ▁ Conversion ▁ functions ▁ * * * * * ENDCOM DataColumn * CsClassFactory :: CreateDataColumn ( std :: string strType , bool bThrowError ) { DataColumn * lpColumn = NULL ; try { strType = Std_ToUpper ( Std_Trim ( strType ) ) ; if ( strType == " NEURONDATACOLUMN " ) lpColumn = new CsNeuronDataColumn ; else { lpColumn = NULL ; if ( bThrowError ) THROW_PARAM_ERROR ( Al_Err_lInvalidDataColumnType , Al_Err_strInvalidDataColumnType , " DataColumnType " , strType ) ; } return lpColumn ; } catch ( CStdErrorInfo oError ) { if ( lpColumn ) delete lpColumn ; RELAY_ERROR ( oError ) ; return NULL ; } catch ( ... ) { if ( lpColumn ) delete lpColumn ; THROW_ERROR ( Std_Err_lUnspecifiedError , Std_Err_strUnspecifiedError ) ; return NULL ; } }
// ▁ * * * * * ▁ DataColumn ▁ Type ▁ Conversion ▁ functions ▁ * * * * * ENDCOM // ▁ * * * * * ▁ Adapter ▁ Type ▁ Conversion ▁ functions ▁ * * * * * ENDCOM Adapter * CsClassFactory :: CreateAdapter ( std :: string strType , bool bThrowError ) { Adapter * lpAdapter = NULL ; try { strType = Std_ToUpper ( Std_Trim ( strType ) ) ; if ( strType == " NODETONODE " ) lpAdapter = new CsAdapter ; else if ( strType == " PHYSICALTONODE " ) lpAdapter = new CsAdapter ; else { lpAdapter = NULL ; if ( bThrowError ) THROW_PARAM_ERROR ( Al_Err_lInvalidAdapterType , Al_Err_strInvalidAdapterType , " AdapterType " , strType ) ; } return lpAdapter ; } catch ( CStdErrorInfo oError ) { if ( lpAdapter ) delete lpAdapter ; RELAY_ERROR ( oError ) ; return NULL ; } catch ( ... ) { if ( lpAdapter ) delete lpAdapter ; THROW_ERROR ( Std_Err_lUnspecifiedError , Std_Err_strUnspecifiedError ) ; return NULL ; } }
// ▁ * * * * * ▁ Adpater ▁ Type ▁ Conversion ▁ functions ▁ * * * * * ENDCOM // ▁ * * * * * ▁ IStdCsClassFactory ▁ functions ▁ * * * * * ENDCOM CStdSerialize * CsClassFactory :: CreateObject ( std :: string strClassType , std :: string strObjectType , bool bThrowError ) { CStdSerialize * lpObject = NULL ; strClassType = Std_ToUpper ( Std_Trim ( strClassType ) ) ; if ( strClassType == " NEURON " ) lpObject = CreateNeuron ( strObjectType , bThrowError ) ; else if ( strClassType == " SYNAPSE " ) lpObject = CreateSynapse ( strObjectType , bThrowError ) ; else if ( strClassType == " NEURALMODULE " ) lpObject = CreateNeuralModule ( strObjectType , bThrowError ) ; else if ( strClassType == " EXTERNALSTIMULUS " ) lpObject = CreateExternalStimulus ( strObjectType , bThrowError ) ; else if ( strClassType == " DATACOLUMN " ) lpObject = CreateDataColumn ( strObjectType , bThrowError ) ; else if ( strClassType == " ADAPTER " ) lpObject = CreateAdapter ( strObjectType , bThrowError ) ; else { lpObject = NULL ; if ( bThrowError ) THROW_PARAM_ERROR ( Std_Err_lInvalidClassType , Std_Err_strInvalidClassType , " ClassType " , strClassType ) ; } return lpObject ; }
/* * * * * STRNEWLINE ▁ qgsfieldvalidator . cpp ▁ - ▁ description STRNEWLINE ▁ - - - - - STRNEWLINE ▁ begin ▁ : ▁ March ▁ 2011 STRNEWLINE ▁ copyright ▁ : ▁ ( C ) ▁ 2011 ▁ by ▁ SunilRajKiran - kCube STRNEWLINE ▁ email ▁ : ▁ sunilraj . kiran @ kcubeconsulting . com STRNEWLINE STRNEWLINE ▁ adapted ▁ version ▁ of ▁ QValidator ▁ for ▁ QgsField STRNEWLINE ▁ * * * * */ ENDCOM /* * * * * STRNEWLINE ▁ * ▁ * STRNEWLINE ▁ * ▁ This ▁ program ▁ is ▁ free ▁ software ; ▁ you ▁ can ▁ redistribute ▁ it ▁ and / or ▁ modify ▁ * STRNEWLINE ▁ * ▁ it ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ as ▁ published ▁ by ▁ * STRNEWLINE ▁ * ▁ the ▁ Free ▁ Software ▁ Foundation ; ▁ either ▁ version ▁ 2 ▁ of ▁ the ▁ License , ▁ or ▁ * STRNEWLINE ▁ * ▁ ( at ▁ your ▁ option ) ▁ any ▁ later ▁ version . ▁ * STRNEWLINE ▁ * ▁ * STRNEWLINE ▁ * * * * */ ENDCOM QgsFieldValidator :: QgsFieldValidator ( QObject * parent , const QgsField & field , QString dateFormat ) : QValidator ( parent ) , mField ( field ) , mDateFormat ( dateFormat ) { switch ( mField . type ( ) ) { case QVariant :: Int : { if ( mField . length ( ) > 0 ) { QString re = QString ( " - ? \\d { 0 , % 1 } " ) . arg ( mField . length ( ) ) ; mValidator = new QRegExpValidator ( QRegExp ( re ) , parent ) ; } else { mValidator = new QIntValidator ( parent ) ; } } break ; case QVariant :: Double : { if ( mField . length ( ) > 0 && mField . precision ( ) > 0 ) { QString re = QString ( " - ? \\d { 0 , % 1 } ( \\ . \\d { 0 , % 2 } ) ? " ) . arg ( mField . length ( ) - mField . precision ( ) ) . arg ( mField . precision ( ) ) ; mValidator = new QRegExpValidator ( QRegExp ( re ) , parent ) ; } else if ( mField . length ( ) > 0 && mField . precision ( ) == 0 ) { QString re = QString ( " - ? \\d { 0 , % 1 } " ) . arg ( mField . length ( ) ) ; mValidator = new QRegExpValidator ( QRegExp ( re ) , parent ) ; } else if ( mField . precision ( ) > 0 ) { QString re = QString ( " - ? \\d * ( \\ . \\d { 0 , % 1 } ) ? " ) . arg ( mField . precision ( ) ) ; mValidator = new QRegExpValidator ( QRegExp ( re ) , parent ) ; } else { mValidator = new QDoubleValidator ( parent ) ; } } break ; case QVariant :: LongLong : mValidator = new QgsLongLongValidator ( parent ) ; break ; default : mValidator = 0 ; } QSettings settings ; mNullValue = settings . value ( " qgis / nullValue " , " NULL " ) . toString ( ) ; }
QgsFieldValidator :: ~ QgsFieldValidator ( ) { delete mValidator ; }
/* = = = = = STRNEWLINE STRNEWLINE ▁ Library : ▁ CTK STRNEWLINE STRNEWLINE ▁ Copyright ▁ ( c ) ▁ German ▁ Cancer ▁ Research ▁ Center , STRNEWLINE ▁ Division ▁ of ▁ Medical ▁ and ▁ Biological ▁ Informatics STRNEWLINE STRNEWLINE ▁ Licensed ▁ under ▁ the ▁ Apache ▁ License , ▁ Version ▁ 2.0 ▁ ( the ▁ " License " ) ; STRNEWLINE ▁ you ▁ may ▁ not ▁ use ▁ this ▁ file ▁ except ▁ in ▁ compliance ▁ with ▁ the ▁ License . STRNEWLINE ▁ You ▁ may ▁ obtain ▁ a ▁ copy ▁ of ▁ the ▁ License ▁ at STRNEWLINE STRNEWLINE ▁ http : // www . apache . org / licenses / LICENSE - 2.0 STRNEWLINE STRNEWLINE ▁ Unless ▁ required ▁ by ▁ applicable ▁ law ▁ or ▁ agreed ▁ to ▁ in ▁ writing , ▁ software STRNEWLINE ▁ distributed ▁ under ▁ the ▁ License ▁ is ▁ distributed ▁ on ▁ an ▁ " AS ▁ IS " ▁ BASIS , STRNEWLINE ▁ WITHOUT ▁ WARRANTIES ▁ OR ▁ CONDITIONS ▁ OF ▁ ANY ▁ KIND , ▁ either ▁ express ▁ or ▁ implied . STRNEWLINE ▁ See ▁ the ▁ License ▁ for ▁ the ▁ specific ▁ language ▁ governing ▁ permissions ▁ and STRNEWLINE ▁ limitations ▁ under ▁ the ▁ License . STRNEWLINE STRNEWLINE = = = = = */ ENDCOM void ctkPluginGeneratorUiPlugin :: start ( ctkPluginContext * context ) { mainExtension = new ctkPluginGeneratorMainExtension ( ) ; ctkDictionary props ; props . insert ( ctkPluginConstants :: SERVICE_RANKING , 0 ) ; context -> registerService ( QStringList ( " ctkPluginGeneratorAbstractUiExtension " ) , mainExtension , props ) ; qDebug ( ) << " Registered ▁ Main ▁ Extension " ; }
void ctkPluginGeneratorUiPlugin :: stop ( ctkPluginContext * context ) { Q_UNUSED ( context ) delete mainExtension ; }
std :: vector < std :: string > readFile ( std :: string filename ) { std :: vector < std :: string > lines ; std :: ifstream read ; std :: string line ; read . open ( filename . c_str ( ) ) ; if ( ! read . good ( ) ) { read . close ( ) ; std :: ofstream create ; create . open ( filename . c_str ( ) ) ; return lines ; } while ( ! read . eof ( ) ) { getline ( read , line ) ; if ( line != " " ) { // std : : cout < < " Wczytano ▁ " < < line < < std : : endl ; ENDCOM lines . push_back ( line ) ; } } read . close ( ) ; return lines ; }
resultset :: resultset ( const std :: shared_ptr < sqlite :: session > & sess , const shared_ptr < sqlite3_stmt > & stmt ) : stmt_ ( stmt ) , sess_ ( sess ) , status_ ( - 1 ) { if ( sess_ == nullptr ) { throw database_exception ( " No ▁ database ▁ provided ▁ to ▁ sqlite3 ▁ resultset " ) ; } if ( stmt_ == nullptr ) { throw database_exception ( " no ▁ statement ▁ provided ▁ to ▁ sqlite3 ▁ resultset " ) ; } }
resultset :: resultset ( resultset && other ) : stmt_ ( std :: move ( other . stmt_ ) ) , sess_ ( std :: move ( other . sess_ ) ) , status_ ( other . status_ ) { other . sess_ = nullptr ; other . stmt_ = nullptr ; }
bool resultset :: next ( ) { if ( ! is_valid ( ) ) { return false ; } if ( status_ == SQLITE_DONE ) { return false ; } status_ = sqlite3_step ( stmt_ . get ( ) ) ; return status_ == SQLITE_ROW ; }
void resultset :: reset ( ) { if ( ! is_valid ( ) ) { // resultset : : reset ▁ database ▁ not ▁ open ENDCOM return ; } if ( sqlite3_reset ( stmt_ . get ( ) ) != SQLITE_OK ) { throw database_exception ( sess_ -> last_error ( ) ) ; } status_ = - 1 ; }
resultset :: row_type resultset :: current_row ( ) { return row_type ( make_shared < row > ( sess_ , stmt_ ) ) ; }
CGLContextEGL :: ~ CGLContextEGL ( ) { Destroy ( ) ; }
bool CGLContextEGL :: CreateDisplay ( EGLDisplay display , EGLint renderable_type , EGLint rendering_api ) { EGLint neglconfigs = 0 ; int major , minor ; EGLint surface_type = EGL_WINDOW_BIT ; // ▁ for ▁ the ▁ non - trivial ▁ dirty ▁ region ▁ modes , ▁ we ▁ need ▁ the ▁ EGL ▁ buffer ▁ to ▁ be ▁ preserved ▁ across ▁ updates ENDCOM if ( g_advancedSettings . m_guiAlgorithmDirtyRegions == DIRTYREGION_SOLVER_COST_REDUCTION || g_advancedSettings . m_guiAlgorithmDirtyRegions == DIRTYREGION_SOLVER_UNION ) surface_type |= EGL_SWAP_BEHAVIOR_PRESERVED_BIT ; EGLint attribs [ ] = { EGL_RED_SIZE , 8 , EGL_GREEN_SIZE , 8 , EGL_BLUE_SIZE , 8 , EGL_ALPHA_SIZE , 8 , EGL_DEPTH_SIZE , 16 , EGL_STENCIL_SIZE , 0 , EGL_SAMPLE_BUFFERS , 0 , EGL_SAMPLES , 0 , EGL_SURFACE_TYPE , surface_type , EGL_RENDERABLE_TYPE , renderable_type , EGL_NONE } ; if ( m_eglDisplay == EGL_NO_DISPLAY ) { m_eglDisplay = eglGetDisplay ( ( EGLNativeDisplayType ) display ) ; } if ( m_eglDisplay == EGL_NO_DISPLAY ) { CLog :: Log ( LOGERROR , " failed ▁ to ▁ get ▁ EGL ▁ display " ) ; return false ; } if ( ! eglInitialize ( m_eglDisplay , & major , & minor ) ) { CLog :: Log ( LOGERROR , " failed ▁ to ▁ initialize ▁ EGL ▁ display " ) ; return false ; } eglBindAPI ( rendering_api ) ; if ( ! eglChooseConfig ( m_eglDisplay , attribs , & m_eglConfig , 1 , & neglconfigs ) ) { CLog :: Log ( LOGERROR , " Failed ▁ to ▁ query ▁ number ▁ of ▁ EGL ▁ configs " ) ; return false ; } if ( neglconfigs <= 0 ) { CLog :: Log ( LOGERROR , " No ▁ suitable ▁ EGL ▁ configs ▁ found " ) ; return false ; } return true ; }
bool CGLContextEGL :: CreateContext ( ) { int client_version = 2 ; const EGLint context_attribs [ ] = { EGL_CONTEXT_CLIENT_VERSION , client_version , EGL_NONE } ; if ( m_eglContext == EGL_NO_CONTEXT ) { m_eglContext = eglCreateContext ( m_eglDisplay , m_eglConfig , EGL_NO_CONTEXT , context_attribs ) ; } if ( m_eglContext == EGL_NO_CONTEXT ) { CLog :: Log ( LOGERROR , " failed ▁ to ▁ create ▁ EGL ▁ context " ) ; return false ; } return true ; }
bool CGLContextEGL :: BindContext ( ) { if ( ! eglMakeCurrent ( m_eglDisplay , m_eglSurface , m_eglSurface , m_eglContext ) ) { CLog :: Log ( LOGERROR , " Failed ▁ to ▁ make ▁ context ▁ current ▁ % p ▁ % p ▁ % p " , m_eglDisplay , m_eglSurface , m_eglContext ) ; return false ; } return true ; }
bool CGLContextEGL :: SurfaceAttrib ( ) { // ▁ for ▁ the ▁ non - trivial ▁ dirty ▁ region ▁ modes , ▁ we ▁ need ▁ the ▁ EGL ▁ buffer ▁ to ▁ be ▁ preserved ▁ across ▁ updates ENDCOM if ( g_advancedSettings . m_guiAlgorithmDirtyRegions == DIRTYREGION_SOLVER_COST_REDUCTION || g_advancedSettings . m_guiAlgorithmDirtyRegions == DIRTYREGION_SOLVER_UNION ) { if ( ( m_eglDisplay == EGL_NO_DISPLAY ) || ( m_eglSurface == EGL_NO_SURFACE ) ) { return false ; } if ( ! eglSurfaceAttrib ( m_eglDisplay , m_eglSurface , EGL_SWAP_BEHAVIOR , EGL_BUFFER_PRESERVED ) ) { CLog :: Log ( LOGDEBUG , " % s : ▁ Could ▁ not ▁ set ▁ EGL _ SWAP _ BEHAVIOR " , __FUNCTION__ ) ; } } return true ; }
bool CGLContextEGL :: CreateSurface ( EGLNativeWindowType surface ) { m_eglSurface = eglCreateWindowSurface ( m_eglDisplay , m_eglConfig , surface , nullptr ) ; if ( m_eglSurface == EGL_NO_SURFACE ) { CLog :: Log ( LOGERROR , " failed ▁ to ▁ create ▁ EGL ▁ window ▁ surface ▁ % d " , eglGetError ( ) ) ; return false ; } return true ; }
void CGLContextEGL :: Destroy ( ) { if ( m_eglContext != EGL_NO_CONTEXT ) { eglDestroyContext ( m_eglDisplay , m_eglContext ) ; eglMakeCurrent ( m_eglDisplay , EGL_NO_SURFACE , EGL_NO_SURFACE , EGL_NO_CONTEXT ) ; m_eglContext = EGL_NO_CONTEXT ; } if ( m_eglSurface != EGL_NO_SURFACE ) { eglDestroySurface ( m_eglDisplay , m_eglSurface ) ; m_eglSurface = EGL_NO_SURFACE ; } if ( m_eglDisplay != EGL_NO_DISPLAY ) { eglTerminate ( m_eglDisplay ) ; m_eglDisplay = EGL_NO_DISPLAY ; } }
void CGLContextEGL :: Detach ( ) { if ( m_eglContext != EGL_NO_CONTEXT ) { eglMakeCurrent ( m_eglDisplay , EGL_NO_SURFACE , EGL_NO_SURFACE , EGL_NO_CONTEXT ) ; } if ( m_eglSurface != EGL_NO_SURFACE ) { eglDestroySurface ( m_eglDisplay , m_eglSurface ) ; m_eglSurface = EGL_NO_SURFACE ; } }
bool CGLContextEGL :: SetVSync ( bool enable ) { if ( ! eglSwapInterval ( m_eglDisplay , enable ) ) { return false ; } return true ; }
void CGLContextEGL :: SwapBuffers ( ) { if ( m_eglDisplay == EGL_NO_DISPLAY || m_eglSurface == EGL_NO_SURFACE ) { return ; } eglSwapBuffers ( m_eglDisplay , m_eglSurface ) ; }
/* STRNEWLINE ▁ mkvmerge ▁ - - ▁ utility ▁ for ▁ splicing ▁ together ▁ matroska ▁ files STRNEWLINE ▁ from ▁ component ▁ media ▁ subtypes STRNEWLINE STRNEWLINE ▁ Distributed ▁ under ▁ the ▁ GPL ▁ v2 STRNEWLINE ▁ see ▁ the ▁ file ▁ COPYING ▁ for ▁ details STRNEWLINE ▁ or ▁ visit ▁ http : // www . gnu . org / copyleft / gpl . html STRNEWLINE STRNEWLINE ▁ MPEG4 ▁ part ▁ 2 ▁ video ▁ output ▁ module STRNEWLINE STRNEWLINE ▁ Written ▁ by ▁ Moritz ▁ Bunkus ▁ < moritz @ bunkus . org > . STRNEWLINE */ ENDCOM mpeg4_p2_video_packetizer_c :: mpeg4_p2_video_packetizer_c ( generic_reader_c * p_reader , track_info_c & p_ti , double fps , int width , int height , bool input_is_native ) : video_for_windows_packetizer_c ( p_reader , p_ti , fps , width , height ) , m_timecodes_generated ( 0 ) , m_previous_timecode ( 0 ) , m_aspect_ratio_extracted ( false ) , m_input_is_native ( input_is_native ) , m_output_is_native ( hack_engaged ( ENGAGE_NATIVE_MPEG4 ) || input_is_native ) , m_size_extracted ( false ) { if ( ! m_output_is_native ) m_timestamp_factory_application_mode = TFA_SHORT_QUEUEING ; else { set_codec_id ( MKV_V_MPEG4_ASP ) ; if ( ! m_input_is_native ) m_ti . m_private_data . reset ( ) ; // ▁ If ▁ no ▁ external ▁ timecode ▁ file ▁ has ▁ been ▁ specified ▁ then ▁ mkvmerge ENDCOM // ▁ might ▁ have ▁ created ▁ a ▁ factory ▁ due ▁ to ▁ the ▁ - - default - duration ENDCOM // ▁ command ▁ line ▁ argument . ▁ This ▁ factory ▁ must ▁ be ▁ disabled ▁ for ▁ this ENDCOM // ▁ packetizer ▁ because ▁ it ▁ takes ▁ care ▁ of ▁ handling ▁ the ▁ default ENDCOM // ▁ duration / FPS ▁ itself . ENDCOM if ( m_ti . m_ext_timecodes . empty ( ) ) m_timestamp_factory . reset ( ) ; if ( m_default_duration_forced ) m_fps = 1000000000.0 / m_htrack_default_duration ; else if ( 0.0 != m_fps ) m_htrack_default_duration = static_cast < int64_t > ( 1000000000ll / m_fps ) ; m_timestamp_factory_application_mode = TFA_FULL_QUEUEING ; } }
mpeg4_p2_video_packetizer_c :: ~ mpeg4_p2_video_packetizer_c ( ) { if ( ! debugging_c :: requested ( " mpeg4 _ p2 _ statistics " ) ) return ; mxinfo ( boost :: format ( " mpeg4 _ p2 _ video _ packetizer _ c ▁ statistics : \n " " ▁ ▁ # ▁ I ▁ frames : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ % 1 % \n " " ▁ ▁ # ▁ P ▁ frames : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ % 2 % \n " " ▁ ▁ # ▁ B ▁ frames : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ % 3 % \n " " ▁ ▁ # ▁ NVOPs : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ % 4 % \n " " ▁ ▁ # ▁ generated ▁ timecodes : ▁ % 5 % \n " " ▁ ▁ # ▁ dropped ▁ timecodes : ▁ ▁ ▁ % 6 % \n " ) % m_statistics . m_num_i_frames % m_statistics . m_num_p_frames % m_statistics . m_num_b_frames % m_statistics . m_num_n_vops % m_statistics . m_num_generated_timecodes % m_statistics . m_num_dropped_timecodes ) ; }
int mpeg4_p2_video_packetizer_c :: process ( packet_cptr packet ) { extract_size ( packet -> data -> get_buffer ( ) , packet -> data -> get_size ( ) ) ; extract_aspect_ratio ( packet -> data -> get_buffer ( ) , packet -> data -> get_size ( ) ) ; int result = m_input_is_native == m_output_is_native ? video_for_windows_packetizer_c :: process ( packet ) : m_input_is_native ? process_native ( packet ) : process_non_native ( packet ) ; ++ m_frames_output ; return result ; }
int mpeg4_p2_video_packetizer_c :: process_non_native ( packet_cptr packet ) { extract_config_data ( packet ) ; // ▁ Add ▁ a ▁ timecode ▁ and ▁ a ▁ duration ▁ if ▁ they ' ve ▁ been ▁ given . ENDCOM if ( - 1 != packet -> timecode ) { if ( ! m_default_duration_forced ) m_available_timecodes . push_back ( timecode_duration_t ( packet -> timecode , packet -> duration ) ) ; else { m_available_timecodes . push_back ( timecode_duration_t ( m_timecodes_generated * m_htrack_default_duration , m_htrack_default_duration ) ) ; ++ m_timecodes_generated ; } } else if ( 0.0 == m_fps ) mxerror_tid ( m_ti . m_fname , m_ti . m_id , Y ( " Cannot ▁ convert ▁ non - native ▁ MPEG4 ▁ video ▁ frames ▁ into ▁ native ▁ ones ▁ if ▁ the ▁ source ▁ container ▁ " " provides ▁ neither ▁ timecodes ▁ nor ▁ a ▁ number ▁ of ▁ frames ▁ per ▁ second . \n " ) ) ; std :: vector < video_frame_t > frames ; mpeg4 :: p2 :: find_frame_types ( packet -> data -> get_buffer ( ) , packet -> data -> get_size ( ) , frames , m_config_data ) ; for ( auto & frame : frames ) { if ( ! frame . is_coded ) { ++ m_statistics . m_num_n_vops ; int num_surplus_timecodes = static_cast < int > ( m_available_timecodes . size ( ) ) - static_cast < int > ( m_ref_frames . size ( ) + m_b_frames . size ( ) ) ; if ( 0 < num_surplus_timecodes ) { std :: deque < timecode_duration_t > :: iterator start = m_available_timecodes . begin ( ) + m_ref_frames . size ( ) + m_b_frames . size ( ) ; std :: deque < timecode_duration_t > :: iterator end = start + num_surplus_timecodes ; if ( 0 != ( m_ref_frames . size ( ) + m_b_frames . size ( ) ) ) { std :: deque < timecode_duration_t > :: iterator last = m_available_timecodes . begin ( ) + m_ref_frames . size ( ) + m_b_frames . size ( ) - 1 ; std :: deque < timecode_duration_t > :: iterator cur = start ; while ( cur != end ) { last -> m_duration = std :: max ( last -> m_duration , static_cast < int64_t > ( 0 ) ) + std :: max ( cur -> m_duration , static_cast < int64_t > ( 0 ) ) ; ++ cur ; } } m_available_timecodes . erase ( start , end ) ; m_statistics . m_num_dropped_timecodes += num_surplus_timecodes ; } continue ; } if ( FRAME_TYPE_I == frame . type ) ++ m_statistics . m_num_i_frames ; else if ( FRAME_TYPE_P == frame . type ) ++ m_statistics . m_num_p_frames ; else ++ m_statistics . m_num_b_frames ; // ▁ Maybe ▁ we ▁ can ▁ flush ▁ queued ▁ frames ▁ now . ▁ But ▁ only ▁ if ▁ we ▁ don ' t ▁ have ENDCOM // ▁ a ▁ B ▁ frame . ENDCOM if ( FRAME_TYPE_B != frame . type ) flush_frames ( false ) ; frame . data = ( unsigned char * ) safememdup ( packet -> data -> get_buffer ( ) + frame . pos , frame . size ) ; frame . timecode = - 1 ; if ( FRAME_TYPE_B == frame . type ) m_b_frames . push_back ( frame ) ; else m_ref_frames . push_back ( frame ) ; } m_previous_timecode = m_available_timecodes . back ( ) . m_timecode ; return FILE_STATUS_MOREDATA ; }
void mpeg4_p2_video_packetizer_c :: extract_config_data ( packet_cptr & packet ) { if ( m_ti . m_private_data ) return ; m_ti . m_private_data = memory_cptr { mpeg4 :: p2 :: parse_config_data ( packet -> data -> get_buffer ( ) , packet -> data -> get_size ( ) , m_config_data ) } ; if ( ! m_ti . m_private_data ) mxerror_tid ( m_ti . m_fname , m_ti . m_id , Y ( " Could ▁ not ▁ find ▁ the ▁ codec ▁ configuration ▁ data ▁ in ▁ the ▁ first ▁ MPEG - 4 ▁ part ▁ 2 ▁ video ▁ frame . ▁ This ▁ track ▁ cannot ▁ be ▁ stored ▁ in ▁ native ▁ mode . \n " ) ) ; fix_codec_string ( ) ; set_codec_private ( m_ti . m_private_data ) ; rerender_track_headers ( ) ; }
void mpeg4_p2_video_packetizer_c :: fix_codec_string ( ) { static const unsigned char start_code [ 4 ] = { 0x00 , 0x00 , 0x01 , 0xb2 } ; if ( ! m_ti . m_private_data || ( 0 == m_ti . m_private_data -> get_size ( ) ) ) return ; auto private_data = m_ti . m_private_data -> get_buffer ( ) ; int size = m_ti . m_private_data -> get_size ( ) ; int i ; for ( i = 0 ; 9 < size ; ) { if ( memcmp ( & private_data [ i ] , start_code , 4 ) != 0 ) { ++ i ; -- size ; continue ; } i += 8 ; size -= 8 ; if ( strncasecmp ( ( const char * ) & private_data [ i - 4 ] , " divx " , 4 ) != 0 ) continue ; unsigned char * end_pos = ( unsigned char * ) memchr ( & private_data [ i ] , 0 , size ) ; if ( ! end_pos ) end_pos = & private_data [ i + size ] ; -- end_pos ; if ( ' p ' == * end_pos ) * end_pos = ' n ' ; return ; } }
int mpeg4_p2_video_packetizer_c :: process_native ( packet_cptr ) { // ▁ Not ▁ implemented ▁ yet . ENDCOM return FILE_STATUS_MOREDATA ; }
/* * ▁ \brief ▁ Handle ▁ frame ▁ sequences ▁ in ▁ which ▁ too ▁ few ▁ timecodes ▁ are ▁ available STRNEWLINE STRNEWLINE ▁ This ▁ function ▁ gets ▁ called ▁ if ▁ mkvmerge ▁ wants ▁ to ▁ flush ▁ its ▁ frame ▁ queue STRNEWLINE ▁ but ▁ it ▁ doesn ' t ▁ have ▁ enough ▁ timecodes ▁ and / or ▁ durations ▁ available ▁ for STRNEWLINE ▁ each ▁ queued ▁ frame . ▁ This ▁ can ▁ happen ▁ in ▁ two ▁ cases : STRNEWLINE STRNEWLINE ▁ 1 . ▁ A ▁ picture ▁ sequence ▁ is ▁ found ▁ that ▁ mkvmerge ▁ does ▁ not ▁ support . ▁ An STRNEWLINE ▁ example : ▁ Two ▁ frames ▁ have ▁ been ▁ read . ▁ The ▁ first ▁ contained ▁ a STRNEWLINE ▁ P ▁ and ▁ a ▁ B ▁ frame ▁ ( that ' s ▁ OK ▁ so ▁ far ) , ▁ but ▁ the ▁ second ▁ one ▁ contained STRNEWLINE ▁ another ▁ P ▁ or ▁ I ▁ frame ▁ without ▁ an ▁ intermediate ▁ dummy ▁ frame . STRNEWLINE STRNEWLINE ▁ 2 . ▁ The ▁ end ▁ of ▁ the ▁ file ▁ has ▁ been ▁ reached ▁ but ▁ the ▁ frame ▁ queue ▁ contains STRNEWLINE ▁ more ▁ frames ▁ than ▁ the ▁ timecode ▁ queue . ▁ For ▁ example : ▁ The ▁ last ▁ frame STRNEWLINE ▁ contained ▁ two ▁ frames , ▁ a ▁ P ▁ and ▁ a ▁ B ▁ frame . ▁ Right ▁ afterwards ▁ the STRNEWLINE ▁ end ▁ of ▁ the ▁ file ▁ is ▁ reached . ▁ In ▁ this ▁ case ▁ a ▁ dummy ▁ frame ▁ is ▁ missing . STRNEWLINE STRNEWLINE ▁ Both ▁ cases ▁ can ▁ be ▁ solved ▁ if ▁ the ▁ source ▁ file ▁ provides ▁ a ▁ FPS ▁ for ▁ this STRNEWLINE ▁ track . ▁ The ▁ other ▁ case ▁ is ▁ not ▁ supported . STRNEWLINE */ ENDCOM void mpeg4_p2_video_packetizer_c :: generate_timecode_and_duration ( ) { if ( 0.0 >= m_fps ) { // ▁ TODO : ▁ error ENDCOM mxexit ( 1 ) ; } if ( m_available_timecodes . empty ( ) ) { m_previous_timecode = ( int64_t ) ( m_previous_timecode + 1000000000.0 / m_fps ) ; m_available_timecodes . push_back ( timecode_duration_t ( m_previous_timecode , ( int64_t ) ( 1000000000.0 / m_fps ) ) ) ; mxverb ( 3 , boost :: format ( " mpeg4 _ p2 : : flush _ frames ( ) : ▁ Needed ▁ new ▁ timecode ▁ % 1 % \n " ) % m_previous_timecode ) ; ++ m_statistics . m_num_generated_timecodes ; } }
void mpeg4_p2_video_packetizer_c :: get_next_timecode_and_duration ( int64_t & timecode , int64_t & duration ) { if ( m_available_timecodes . empty ( ) ) generate_timecode_and_duration ( ) ; timecode = m_available_timecodes . front ( ) . m_timecode ; duration = m_available_timecodes . front ( ) . m_duration ; m_available_timecodes . pop_front ( ) ; }
void mpeg4_p2_video_packetizer_c :: flush_frames ( bool end_of_file ) { if ( m_ref_frames . empty ( ) ) return ; if ( m_ref_frames . size ( ) == 1 ) { video_frame_t & frame = m_ref_frames . front ( ) ; // ▁ The ▁ first ▁ frame ▁ in ▁ the ▁ file . ▁ Only ▁ apply ▁ the ▁ timecode , ▁ nothing ▁ else . ENDCOM if ( - 1 == frame . timecode ) { get_next_timecode_and_duration ( frame . timecode , frame . duration ) ; add_packet ( new packet_t ( new memory_c ( frame . data , frame . size , true ) , frame . timecode , frame . duration ) ) ; } return ; } video_frame_t & bref_frame = m_ref_frames . front ( ) ; video_frame_t & fref_frame = m_ref_frames . back ( ) ; for ( auto & frame : m_b_frames ) get_next_timecode_and_duration ( frame . timecode , frame . duration ) ; get_next_timecode_and_duration ( fref_frame . timecode , fref_frame . duration ) ; add_packet ( new packet_t ( new memory_c ( fref_frame . data , fref_frame . size , true ) , fref_frame . timecode , fref_frame . duration , FRAME_TYPE_P == fref_frame . type ? bref_frame . timecode : VFT_IFRAME ) ) ; for ( auto & frame : m_b_frames ) add_packet ( new packet_t ( new memory_c ( frame . data , frame . size , true ) , frame . timecode , frame . duration , bref_frame . timecode , fref_frame . timecode ) ) ; m_ref_frames . pop_front ( ) ; m_b_frames . clear ( ) ; if ( end_of_file ) m_ref_frames . clear ( ) ; }
void mpeg4_p2_video_packetizer_c :: flush_impl ( ) { flush_frames ( true ) ; }
void mpeg4_p2_video_packetizer_c :: extract_aspect_ratio ( const unsigned char * buffer , int size ) { if ( m_aspect_ratio_extracted ) return ; if ( ( 0 != m_connected_to ) || display_dimensions_or_aspect_ratio_set ( ) ) { m_aspect_ratio_extracted = true ; return ; } uint32_t num , den ; if ( mpeg4 :: p2 :: extract_par ( buffer , size , num , den ) ) { m_aspect_ratio_extracted = true ; set_video_aspect_ratio ( ( double ) m_hvideo_pixel_width / ( double ) m_hvideo_pixel_height * ( double ) num / ( double ) den , false , OPTION_SOURCE_BITSTREAM ) ; generic_packetizer_c :: set_headers ( ) ; rerender_track_headers ( ) ; mxinfo_tid ( m_ti . m_fname , m_ti . m_id , boost :: format ( Y ( " Extracted ▁ the ▁ aspect ▁ ratio ▁ information ▁ from ▁ the ▁ MPEG4 ▁ layer ▁ 2 ▁ video ▁ data ▁ and ▁ set ▁ the ▁ display ▁ dimensions ▁ to ▁ % 1 % / %2 % . \n " ) ) % m_hvideo_display_width % m_hvideo_display_height ) ; } else if ( 50 <= m_frames_output ) m_aspect_ratio_extracted = true ; }
void mpeg4_p2_video_packetizer_c :: extract_size ( const unsigned char * buffer , int size ) { if ( m_size_extracted ) return ; if ( 0 != m_connected_to ) { m_size_extracted = true ; return ; } uint32_t xtr_width , xtr_height ; if ( mpeg4 :: p2 :: extract_size ( buffer , size , xtr_width , xtr_height ) ) { m_size_extracted = true ; if ( ! m_reader -> m_appending && ( ( xtr_width != static_cast < uint32_t > ( m_hvideo_pixel_width ) ) || ( xtr_height != static_cast < uint32_t > ( m_hvideo_pixel_height ) ) ) ) { set_video_pixel_width ( xtr_width ) ; set_video_pixel_height ( xtr_height ) ; if ( ! m_output_is_native && m_ti . m_private_data && ( sizeof ( alBITMAPINFOHEADER ) <= m_ti . m_private_data -> get_size ( ) ) ) { auto bih = reinterpret_cast < alBITMAPINFOHEADER * > ( m_ti . m_private_data -> get_buffer ( ) ) ; put_uint32_le ( & bih -> bi_width , xtr_width ) ; put_uint32_le ( & bih -> bi_height , xtr_height ) ; set_codec_private ( m_ti . m_private_data ) ; } m_hvideo_display_width = - 1 ; m_hvideo_display_height = - 1 ; generic_packetizer_c :: set_headers ( ) ; rerender_track_headers ( ) ; mxinfo_tid ( m_ti . m_fname , m_ti . m_id , boost :: format ( Y ( " The ▁ extracted ▁ values ▁ for ▁ video ▁ width ▁ and ▁ height ▁ from ▁ the ▁ MPEG4 ▁ layer ▁ 2 ▁ video ▁ data ▁ bitstream ▁ differ ▁ from ▁ what ▁ the ▁ values ▁ " " in ▁ the ▁ source ▁ container . ▁ The ▁ ones ▁ from ▁ the ▁ video ▁ data ▁ bitstream ▁ ( %1 % x % 2 % ) ▁ will ▁ be ▁ used . \n " ) ) % xtr_width % xtr_height ) ; } } else if ( 50 <= m_frames_output ) m_aspect_ratio_extracted = true ; }
// ▁ Copyright ▁ ( c ) ▁ 2012 - ▁ PPSSPP ▁ Project . ENDCOM // ▁ This ▁ program ▁ is ▁ free ▁ software : ▁ you ▁ can ▁ redistribute ▁ it ▁ and / or ▁ modify ENDCOM // ▁ it ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ as ▁ published ▁ by ENDCOM // ▁ the ▁ Free ▁ Software ▁ Foundation , ▁ version ▁ 2.0 ▁ or ▁ later ▁ versions . ENDCOM // ▁ This ▁ program ▁ is ▁ distributed ▁ in ▁ the ▁ hope ▁ that ▁ it ▁ will ▁ be ▁ useful , ENDCOM // ▁ but ▁ WITHOUT ▁ ANY ▁ WARRANTY ; ▁ without ▁ even ▁ the ▁ implied ▁ warranty ▁ of ENDCOM // ▁ MERCHANTABILITY ▁ or ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE . ▁ See ▁ the ENDCOM // ▁ GNU ▁ General ▁ Public ▁ License ▁ 2.0 ▁ for ▁ more ▁ details . ENDCOM // ▁ A ▁ copy ▁ of ▁ the ▁ GPL ▁ 2.0 ▁ should ▁ have ▁ been ▁ included ▁ with ▁ the ▁ program . ENDCOM // ▁ If ▁ not , ▁ see ▁ http : // www . gnu . org / licenses / ENDCOM // ▁ Official ▁ git ▁ repository ▁ and ▁ contact ▁ information ▁ can ▁ be ▁ found ▁ at ENDCOM // ▁ https : // github . com / hrydgard / ppsspp ▁ and ▁ http : // www . ppsspp . org / . ENDCOM // ▁ UnitTests ENDCOM // ▁ This ▁ is ▁ a ▁ program ▁ to ▁ directly ▁ test ▁ various ▁ functions , ▁ without ▁ going ENDCOM // ▁ through ▁ a ▁ PSP . ▁ Especially ▁ useful ▁ for ▁ things ▁ like ▁ opcode ▁ emitters , ENDCOM // ▁ hashes , ▁ and ▁ various ▁ data ▁ conversion ▁ utility ▁ function . ENDCOM // ▁ TODO : ▁ Make ▁ a ▁ test ▁ of ▁ nice ▁ unittest ▁ asserts ▁ and ▁ count ▁ successes ▁ etc . ENDCOM // ▁ Or ▁ just ▁ integrate ▁ with ▁ an ▁ existing ▁ testing ▁ framework . ENDCOM std :: string System_GetProperty ( SystemProperty prop ) { return " " ; }
